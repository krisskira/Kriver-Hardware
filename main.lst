CCS PCM C Compiler, Version 5.015, 5967               29-nov.-17 22:45

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   4836 words (59%)
                           Largest free fragment is 2048
               RAM used:   80 (22%) at main() level
                           132 (36%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   391
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   309
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  4F
0056:  RETLW  4B
0057:  RETLW  0D
0058:  RETLW  0A
0059:  RETLW  43
005A:  RETLW  6C
005B:  RETLW  69
005C:  RETLW  65
005D:  RETLW  6E
005E:  RETLW  74
005F:  RETLW  65
0060:  RETLW  20
0061:  RETLW  20
0062:  RETLW  20
0063:  RETLW  20
0064:  RETLW  20
0065:  RETLW  00
0066:  RETLW  41
0067:  RETLW  63
0068:  RETLW  63
0069:  RETLW  65
006A:  RETLW  73
006B:  RETLW  73
006C:  RETLW  20
006D:  RETLW  50
006E:  RETLW  6F
006F:  RETLW  69
0070:  RETLW  6E
0071:  RETLW  74
0072:  RETLW  00
0073:  RETLW  43
0074:  RETLW  6C
0075:  RETLW  69
0076:  RETLW  65
0077:  RETLW  6E
0078:  RETLW  74
0079:  RETLW  65
007A:  RETLW  20
007B:  RETLW  2B
007C:  RETLW  20
007D:  RETLW  41
007E:  RETLW  50
007F:  RETLW  00
0080:  RETLW  53
0081:  RETLW  41
0082:  RETLW  4C
0083:  RETLW  49
0084:  RETLW  52
0085:  RETLW  20
0086:  RETLW  20
0087:  RETLW  20
0088:  RETLW  20
0089:  RETLW  20
008A:  RETLW  20
008B:  RETLW  20
008C:  RETLW  00
008D:  RETLW  00
008E:  RETLW  00
008F:  RETLW  00
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  00
0094:  RETLW  00
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  00
0098:  RETLW  00
0099:  RETLW  00
009A:  DATA D3,20
009B:  DATA CC,24
009C:  DATA 52,00
009D:  DATA DB,29
009E:  DATA C9,23
009F:  DATA 5D,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA A0,2D
00A3:  DATA 45,27
00A4:  DATA D4,2E
00A5:  DATA 00,00
00A6:  DATA 41,2A
00A7:  DATA AB,21
00A8:  DATA D7,26
00A9:  DATA 4F,22
00AA:  DATA C5,2F
00AB:  DATA C4,22
00AC:  DATA C6,1E
00AD:  DATA B1,12
00AE:  DATA E3,12
00AF:  DATA 63,00
00B0:  DATA 8C,21
00B1:  DATA 6F,37
00B2:  DATA E6,34
00B3:  DATA 67,10
00B4:  DATA 43,36
00B5:  DATA E9,32
00B6:  DATA 6E,3A
00B7:  DATA 65,00
00B8:  DATA 41,2A
00B9:  DATA AB,21
00BA:  DATA D7,26
00BB:  DATA 4F,22
00BC:  DATA C5,2F
00BD:  DATA C4,22
00BE:  DATA C6,1E
00BF:  DATA B2,12
00C0:  DATA E3,12
00C1:  DATA 63,00
00C2:  DATA 8C,21
00C3:  DATA 6F,37
00C4:  DATA E6,34
00C5:  DATA 67,10
00C6:  DATA 41,28
00C7:  DATA 00,01
00C8:  DATA 41,2A
00C9:  DATA AB,21
00CA:  DATA D7,26
00CB:  DATA 4F,22
00CC:  DATA C5,2F
00CD:  DATA C4,22
00CE:  DATA C6,1E
00CF:  DATA B3,12
00D0:  DATA E3,12
00D1:  DATA 63,00
00D2:  DATA 8C,21
00D3:  DATA 6F,37
00D4:  DATA E6,34
00D5:  DATA 67,10
00D6:  DATA 43,36
00D7:  DATA E9,32
00D8:  DATA 6E,3A
00D9:  DATA E5,20
00DA:  DATA 50,00
00DB:  DATA B1,1C
00DC:  DATA 32,17
00DD:  DATA 31,1B
00DE:  DATA 38,17
00DF:  DATA 30,17
00E0:  DATA 31,00
00E1:  DATA 8C,18
00E2:  DATA 39,19
00E3:  DATA AE,18
00E4:  DATA 36,1C
00E5:  DATA 2E,18
00E6:  DATA AE,18
00E7:  DATA 00,01
00E8:  DATA 43,18
00E9:  DATA C7,19
00EA:  DATA DF,2A
00EB:  DATA CE,22
00EC:  DATA 00,01
00ED:  DATA 8C,21
00EE:  DATA B0,23
00EF:  DATA B3,2F
00F0:  DATA 55,27
00F1:  DATA 45,00
00F2:  DATA 31,19
00F3:  DATA 33,1A
00F4:  DATA 41,3D
00F5:  DATA 21,00
00F6:  DATA 8C,18
00F7:  DATA B2,19
00F8:  DATA B4,20
00F9:  DATA FA,10
00FA:  DATA 00,01
00FB:  DATA 0C,21
00FC:  DATA E1,31
00FD:  DATA 6B,36
00FE:  DATA E9,33
00FF:  DATA 68,3A
0100:  DATA A0,27
0101:  DATA 6E,00
0102:  DATA 0C,21
0103:  DATA E1,31
0104:  DATA 6B,36
0105:  DATA E9,33
0106:  DATA 68,3A
0107:  DATA A0,27
0108:  DATA 66,33
0109:  DATA 00,01
010A:  RETLW  45
010B:  RETLW  6E
010C:  RETLW  63
010D:  RETLW  65
010E:  RETLW  6E
010F:  RETLW  64
0110:  RETLW  65
0111:  RETLW  72
0112:  RETLW  20
0113:  RETLW  4D
0114:  RETLW  61
0115:  RETLW  6E
0116:  RETLW  75
0117:  RETLW  61
0118:  RETLW  6C
0119:  RETLW  00
011A:  RETLW  41
011B:  RETLW  70
011C:  RETLW  61
011D:  RETLW  67
011E:  RETLW  61
011F:  RETLW  64
0120:  RETLW  6F
0121:  RETLW  20
0122:  RETLW  4D
0123:  RETLW  61
0124:  RETLW  6E
0125:  RETLW  75
0126:  RETLW  61
0127:  RETLW  6C
0128:  RETLW  20
0129:  RETLW  00
012A:  RETLW  43
012B:  RETLW  6F
012C:  RETLW  6E
012D:  RETLW  66
012E:  RETLW  69
012F:  RETLW  67
0130:  RETLW  75
0131:  RETLW  72
0132:  RETLW  61
0133:  RETLW  63
0134:  RETLW  69
0135:  RETLW  6F
0136:  RETLW  6E
0137:  RETLW  20
0138:  RETLW  20
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  00
013C:  RETLW  00
013D:  RETLW  00
013E:  RETLW  00
013F:  RETLW  00
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  00
0143:  RETLW  00
0144:  RETLW  00
0145:  RETLW  00
0146:  RETLW  00
0147:  RETLW  00
0148:  RETLW  00
0149:  RETLW  00
014A:  RETLW  4F
014B:  RETLW  6E
014C:  RETLW  20
014D:  RETLW  2D
014E:  RETLW  3E
014F:  RETLW  20
0150:  RETLW  53
0151:  RETLW  61
0152:  RETLW  6C
0153:  RETLW  69
0154:  RETLW  64
0155:  RETLW  61
0156:  RETLW  20
0157:  RETLW  31
0158:  RETLW  00
0159:  RETLW  4F
015A:  RETLW  6E
015B:  RETLW  20
015C:  RETLW  2D
015D:  RETLW  3E
015E:  RETLW  20
015F:  RETLW  53
0160:  RETLW  61
0161:  RETLW  6C
0162:  RETLW  69
0163:  RETLW  64
0164:  RETLW  61
0165:  RETLW  20
0166:  RETLW  32
0167:  RETLW  00
0168:  RETLW  4F
0169:  RETLW  6E
016A:  RETLW  20
016B:  RETLW  2D
016C:  RETLW  3E
016D:  RETLW  20
016E:  RETLW  53
016F:  RETLW  61
0170:  RETLW  6C
0171:  RETLW  69
0172:  RETLW  64
0173:  RETLW  61
0174:  RETLW  20
0175:  RETLW  33
0176:  RETLW  00
0177:  RETLW  4F
0178:  RETLW  6E
0179:  RETLW  20
017A:  RETLW  2D
017B:  RETLW  3E
017C:  RETLW  20
017D:  RETLW  53
017E:  RETLW  61
017F:  RETLW  6C
0180:  RETLW  69
0181:  RETLW  64
0182:  RETLW  61
0183:  RETLW  20
0184:  RETLW  34
0185:  RETLW  00
0186:  RETLW  4F
0187:  RETLW  6E
0188:  RETLW  20
0189:  RETLW  2D
018A:  RETLW  3E
018B:  RETLW  20
018C:  RETLW  53
018D:  RETLW  61
018E:  RETLW  6C
018F:  RETLW  69
0190:  RETLW  64
0191:  RETLW  61
0192:  RETLW  20
0193:  RETLW  35
0194:  RETLW  00
0195:  RETLW  4F
0196:  RETLW  6E
0197:  RETLW  20
0198:  RETLW  2D
0199:  RETLW  3E
019A:  RETLW  20
019B:  RETLW  53
019C:  RETLW  61
019D:  RETLW  6C
019E:  RETLW  69
019F:  RETLW  64
01A0:  RETLW  61
01A1:  RETLW  20
01A2:  RETLW  36
01A3:  RETLW  00
01A4:  RETLW  4F
01A5:  RETLW  6E
01A6:  RETLW  20
01A7:  RETLW  2D
01A8:  RETLW  3E
01A9:  RETLW  20
01AA:  RETLW  53
01AB:  RETLW  61
01AC:  RETLW  6C
01AD:  RETLW  69
01AE:  RETLW  64
01AF:  RETLW  61
01B0:  RETLW  20
01B1:  RETLW  37
01B2:  RETLW  00
01B3:  RETLW  4F
01B4:  RETLW  6E
01B5:  RETLW  20
01B6:  RETLW  2D
01B7:  RETLW  3E
01B8:  RETLW  20
01B9:  RETLW  53
01BA:  RETLW  61
01BB:  RETLW  6C
01BC:  RETLW  69
01BD:  RETLW  64
01BE:  RETLW  61
01BF:  RETLW  20
01C0:  RETLW  38
01C1:  RETLW  00
01C2:  RETLW  53
01C3:  RETLW  41
01C4:  RETLW  4C
01C5:  RETLW  49
01C6:  RETLW  52
01C7:  RETLW  20
01C8:  RETLW  20
01C9:  RETLW  20
01CA:  RETLW  20
01CB:  RETLW  20
01CC:  RETLW  20
01CD:  RETLW  20
01CE:  RETLW  20
01CF:  RETLW  20
01D0:  RETLW  00
01D1:  RETLW  00
01D2:  RETLW  00
01D3:  RETLW  00
01D4:  RETLW  00
01D5:  RETLW  00
01D6:  RETLW  00
01D7:  RETLW  00
01D8:  RETLW  00
01D9:  RETLW  00
01DA:  RETLW  00
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  00
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  4F
01E1:  RETLW  66
01E2:  RETLW  66
01E3:  RETLW  20
01E4:  RETLW  2D
01E5:  RETLW  3E
01E6:  RETLW  20
01E7:  RETLW  53
01E8:  RETLW  61
01E9:  RETLW  6C
01EA:  RETLW  69
01EB:  RETLW  64
01EC:  RETLW  61
01ED:  RETLW  20
01EE:  RETLW  31
01EF:  RETLW  00
01F0:  RETLW  4F
01F1:  RETLW  66
01F2:  RETLW  66
01F3:  RETLW  20
01F4:  RETLW  2D
01F5:  RETLW  3E
01F6:  RETLW  20
01F7:  RETLW  53
01F8:  RETLW  61
01F9:  RETLW  6C
01FA:  RETLW  69
01FB:  RETLW  64
01FC:  RETLW  61
01FD:  RETLW  20
01FE:  RETLW  32
01FF:  RETLW  00
0200:  RETLW  4F
0201:  RETLW  66
0202:  RETLW  66
0203:  RETLW  20
0204:  RETLW  2D
0205:  RETLW  3E
0206:  RETLW  20
0207:  RETLW  53
0208:  RETLW  61
0209:  RETLW  6C
020A:  RETLW  69
020B:  RETLW  64
020C:  RETLW  61
020D:  RETLW  20
020E:  RETLW  33
020F:  RETLW  00
0210:  RETLW  4F
0211:  RETLW  66
0212:  RETLW  66
0213:  RETLW  20
0214:  RETLW  2D
0215:  RETLW  3E
0216:  RETLW  20
0217:  RETLW  53
0218:  RETLW  61
0219:  RETLW  6C
021A:  RETLW  69
021B:  RETLW  64
021C:  RETLW  61
021D:  RETLW  20
021E:  RETLW  34
021F:  RETLW  00
0220:  RETLW  4F
0221:  RETLW  66
0222:  RETLW  66
0223:  RETLW  20
0224:  RETLW  2D
0225:  RETLW  3E
0226:  RETLW  20
0227:  RETLW  53
0228:  RETLW  61
0229:  RETLW  6C
022A:  RETLW  69
022B:  RETLW  64
022C:  RETLW  61
022D:  RETLW  20
022E:  RETLW  35
022F:  RETLW  00
0230:  RETLW  4F
0231:  RETLW  66
0232:  RETLW  66
0233:  RETLW  20
0234:  RETLW  2D
0235:  RETLW  3E
0236:  RETLW  20
0237:  RETLW  53
0238:  RETLW  61
0239:  RETLW  6C
023A:  RETLW  69
023B:  RETLW  64
023C:  RETLW  61
023D:  RETLW  20
023E:  RETLW  36
023F:  RETLW  00
0240:  RETLW  4F
0241:  RETLW  66
0242:  RETLW  66
0243:  RETLW  20
0244:  RETLW  2D
0245:  RETLW  3E
0246:  RETLW  20
0247:  RETLW  53
0248:  RETLW  61
0249:  RETLW  6C
024A:  RETLW  69
024B:  RETLW  64
024C:  RETLW  61
024D:  RETLW  20
024E:  RETLW  37
024F:  RETLW  00
0250:  RETLW  4F
0251:  RETLW  66
0252:  RETLW  66
0253:  RETLW  20
0254:  RETLW  2D
0255:  RETLW  3E
0256:  RETLW  20
0257:  RETLW  53
0258:  RETLW  61
0259:  RETLW  6C
025A:  RETLW  69
025B:  RETLW  64
025C:  RETLW  61
025D:  RETLW  20
025E:  RETLW  38
025F:  RETLW  00
0260:  RETLW  53
0261:  RETLW  41
0262:  RETLW  4C
0263:  RETLW  49
0264:  RETLW  52
0265:  RETLW  20
0266:  RETLW  20
0267:  RETLW  20
0268:  RETLW  20
0269:  RETLW  20
026A:  RETLW  20
026B:  RETLW  20
026C:  RETLW  20
026D:  RETLW  20
026E:  RETLW  20
026F:  RETLW  00
0270:  RETLW  00
0271:  RETLW  00
0272:  RETLW  00
0273:  RETLW  00
0274:  RETLW  00
0275:  RETLW  00
0276:  RETLW  00
0277:  RETLW  00
0278:  RETLW  00
0279:  RETLW  00
027A:  RETLW  00
027B:  RETLW  00
027C:  RETLW  00
027D:  RETLW  00
027E:  RETLW  00
027F:  RETLW  00
0280:  RETLW  56
0281:  RETLW  45
0282:  RETLW  52
0283:  RETLW  20
0284:  RETLW  49
0285:  RETLW  50
0286:  RETLW  20
0287:  RETLW  20
0288:  RETLW  20
0289:  RETLW  20
028A:  RETLW  20
028B:  RETLW  20
028C:  RETLW  20
028D:  RETLW  20
028E:  RETLW  20
028F:  RETLW  20
0290:  RETLW  00
0291:  RETLW  56
0292:  RETLW  45
0293:  RETLW  52
0294:  RETLW  20
0295:  RETLW  53
0296:  RETLW  53
0297:  RETLW  49
0298:  RETLW  44
0299:  RETLW  20
029A:  RETLW  20
029B:  RETLW  20
029C:  RETLW  20
029D:  RETLW  20
029E:  RETLW  20
029F:  RETLW  20
02A0:  RETLW  20
02A1:  RETLW  00
02A2:  RETLW  56
02A3:  RETLW  45
02A4:  RETLW  52
02A5:  RETLW  20
02A6:  RETLW  4B
02A7:  RETLW  45
02A8:  RETLW  59
02A9:  RETLW  20
02AA:  RETLW  20
02AB:  RETLW  20
02AC:  RETLW  20
02AD:  RETLW  20
02AE:  RETLW  20
02AF:  RETLW  20
02B0:  RETLW  20
02B1:  RETLW  20
02B2:  RETLW  00
02B3:  RETLW  43
02B4:  RETLW  6F
02B5:  RETLW  6E
02B6:  RETLW  66
02B7:  RETLW  20
02B8:  RETLW  41
02B9:  RETLW  63
02BA:  RETLW  63
02BB:  RETLW  65
02BC:  RETLW  73
02BD:  RETLW  73
02BE:  RETLW  6F
02BF:  RETLW  20
02C0:  RETLW  52
02C1:  RETLW  65
02C2:  RETLW  64
02C3:  RETLW  00
02C4:  RETLW  4F
02C5:  RETLW  6E
02C6:  RETLW  2F
02C7:  RETLW  4F
02C8:  RETLW  66
02C9:  RETLW  66
02CA:  RETLW  20
02CB:  RETLW  42
02CC:  RETLW  61
02CD:  RETLW  63
02CE:  RETLW  6B
02CF:  RETLW  6C
02D0:  RETLW  69
02D1:  RETLW  67
02D2:  RETLW  68
02D3:  RETLW  74
02D4:  RETLW  00
02D5:  RETLW  53
02D6:  RETLW  41
02D7:  RETLW  4C
02D8:  RETLW  49
02D9:  RETLW  52
02DA:  RETLW  20
02DB:  RETLW  20
02DC:  RETLW  20
02DD:  RETLW  20
02DE:  RETLW  20
02DF:  RETLW  20
02E0:  RETLW  20
02E1:  RETLW  20
02E2:  RETLW  20
02E3:  RETLW  20
02E4:  RETLW  20
02E5:  RETLW  00
02E6:  RETLW  00
02E7:  RETLW  00
02E8:  RETLW  00
02E9:  RETLW  00
02EA:  RETLW  00
02EB:  RETLW  00
02EC:  RETLW  00
02ED:  RETLW  00
02EE:  RETLW  00
02EF:  RETLW  00
02F0:  RETLW  00
02F1:  RETLW  00
02F2:  RETLW  00
02F3:  RETLW  00
02F4:  RETLW  00
02F5:  RETLW  00
02F6:  RETLW  00
02F7:  DATA 8C,24
02F8:  DATA EE,34
02F9:  DATA E3,34
02FA:  DATA 61,36
02FB:  DATA 69,3D
02FC:  DATA 61,37
02FD:  DATA E4,37
02FE:  DATA 2E,17
02FF:  DATA 2E,00
0300:  DATA 8C,26
0301:  DATA 6F,32
0302:  DATA 6F,10
0303:  DATA E3,37
0304:  DATA 6E,33
0305:  DATA E9,33
0306:  DATA 75,39
0307:  DATA 61,32
0308:  DATA 6F,00
*
04F9:  MOVF   0B,W
04FA:  MOVWF  7B
04FB:  BCF    0B.7
04FC:  BSF    03.5
04FD:  BSF    03.6
04FE:  BSF    0C.7
04FF:  BSF    0C.0
0500:  NOP
0501:  NOP
0502:  BTFSS  7B.7
0503:  GOTO   509
0504:  BCF    03.5
0505:  BCF    03.6
0506:  BSF    0B.7
0507:  BSF    03.5
0508:  BSF    03.6
0509:  BCF    03.5
050A:  MOVF   0C,W
050B:  ANDLW  7F
050C:  BTFSC  03.2
050D:  GOTO   547
050E:  MOVWF  7B
050F:  MOVF   0D,W
0510:  MOVWF  7C
0511:  MOVF   0F,W
0512:  MOVWF  7D
0513:  MOVF   7B,W
0514:  MOVWF  7E
0515:  BCF    03.6
0516:  CALL   4A1
0517:  MOVF   7C,W
0518:  BSF    03.6
0519:  MOVWF  0D
051A:  MOVF   7D,W
051B:  MOVWF  0F
051C:  BCF    03.6
051D:  MOVF   0B,W
051E:  MOVWF  7E
051F:  BCF    0B.7
0520:  BSF    03.5
0521:  BSF    03.6
0522:  BSF    0C.7
0523:  BSF    0C.0
0524:  NOP
0525:  NOP
0526:  BTFSS  7E.7
0527:  GOTO   52D
0528:  BCF    03.5
0529:  BCF    03.6
052A:  BSF    0B.7
052B:  BSF    03.5
052C:  BSF    03.6
052D:  BCF    03.5
052E:  RLF    0C,W
052F:  RLF    0E,W
0530:  ANDLW  7F
0531:  BTFSC  03.2
0532:  GOTO   547
0533:  MOVWF  7B
0534:  MOVF   0D,W
0535:  MOVWF  7C
0536:  MOVF   0F,W
0537:  MOVWF  7D
0538:  MOVF   7B,W
0539:  MOVWF  7E
053A:  BCF    03.6
053B:  CALL   4A1
053C:  MOVF   7C,W
053D:  BSF    03.6
053E:  MOVWF  0D
053F:  MOVF   7D,W
0540:  MOVWF  0F
0541:  INCF   0D,F
0542:  BTFSC  03.2
0543:  INCF   0F,F
0544:  BCF    03.6
0545:  GOTO   4F9
0546:  BSF    03.6
0547:  BCF    03.6
0548:  RETURN
*
062E:  MOVF   0B,W
062F:  MOVWF  70
0630:  BCF    0B.7
0631:  BSF    03.5
0632:  BSF    03.6
0633:  BSF    0C.7
0634:  BSF    0C.0
0635:  NOP
0636:  NOP
0637:  BTFSS  70.7
0638:  GOTO   63E
0639:  BCF    03.5
063A:  BCF    03.6
063B:  BSF    0B.7
063C:  BSF    03.5
063D:  BSF    03.6
063E:  BCF    03.5
063F:  MOVF   0C,F
0640:  BTFSC  03.2
0641:  GOTO   655
0642:  MOVF   0D,W
0643:  MOVWF  70
0644:  MOVF   0F,W
0645:  MOVWF  71
0646:  MOVF   0C,W
0647:  MOVWF  7E
0648:  BCF    03.6
0649:  CALL   4A1
064A:  MOVF   70,W
064B:  BSF    03.6
064C:  MOVWF  0D
064D:  MOVF   71,W
064E:  MOVWF  0F
064F:  INCF   0D,F
0650:  BTFSC  03.2
0651:  INCF   0F,F
0652:  BCF    03.6
0653:  GOTO   62E
0654:  BSF    03.6
0655:  BCF    03.6
0656:  RETURN
*
0685:  BTFSC  03.1
0686:  GOTO   68A
0687:  MOVLW  AC
0688:  MOVWF  04
0689:  BCF    03.7
068A:  CLRF   77
068B:  CLRF   78
068C:  CLRF   79
068D:  CLRF   7A
068E:  CLRF   2C
068F:  CLRF   2D
0690:  CLRF   2E
0691:  CLRF   2F
0692:  MOVF   2B,W
0693:  IORWF  2A,W
0694:  IORWF  29,W
0695:  IORWF  28,W
0696:  BTFSC  03.2
0697:  GOTO   6C8
0698:  MOVLW  20
0699:  MOVWF  30
069A:  BCF    03.0
069B:  RLF    24,F
069C:  RLF    25,F
069D:  RLF    26,F
069E:  RLF    27,F
069F:  RLF    2C,F
06A0:  RLF    2D,F
06A1:  RLF    2E,F
06A2:  RLF    2F,F
06A3:  MOVF   2B,W
06A4:  SUBWF  2F,W
06A5:  BTFSS  03.2
06A6:  GOTO   6B1
06A7:  MOVF   2A,W
06A8:  SUBWF  2E,W
06A9:  BTFSS  03.2
06AA:  GOTO   6B1
06AB:  MOVF   29,W
06AC:  SUBWF  2D,W
06AD:  BTFSS  03.2
06AE:  GOTO   6B1
06AF:  MOVF   28,W
06B0:  SUBWF  2C,W
06B1:  BTFSS  03.0
06B2:  GOTO   6C2
06B3:  MOVF   28,W
06B4:  SUBWF  2C,F
06B5:  MOVF   29,W
06B6:  BTFSS  03.0
06B7:  INCFSZ 29,W
06B8:  SUBWF  2D,F
06B9:  MOVF   2A,W
06BA:  BTFSS  03.0
06BB:  INCFSZ 2A,W
06BC:  SUBWF  2E,F
06BD:  MOVF   2B,W
06BE:  BTFSS  03.0
06BF:  INCFSZ 2B,W
06C0:  SUBWF  2F,F
06C1:  BSF    03.0
06C2:  RLF    77,F
06C3:  RLF    78,F
06C4:  RLF    79,F
06C5:  RLF    7A,F
06C6:  DECFSZ 30,F
06C7:  GOTO   69A
06C8:  MOVF   2C,W
06C9:  MOVWF  00
06CA:  INCF   04,F
06CB:  MOVF   2D,W
06CC:  MOVWF  00
06CD:  INCF   04,F
06CE:  MOVF   2E,W
06CF:  MOVWF  00
06D0:  INCF   04,F
06D1:  MOVF   2F,W
06D2:  MOVWF  00
*
06E8:  MOVLW  20
06E9:  MOVWF  30
06EA:  CLRF   2C
06EB:  CLRF   2D
06EC:  CLRF   2E
06ED:  CLRF   2F
06EE:  MOVF   27,W
06EF:  MOVWF  7A
06F0:  MOVF   26,W
06F1:  MOVWF  79
06F2:  MOVF   25,W
06F3:  MOVWF  78
06F4:  MOVF   24,W
06F5:  MOVWF  77
06F6:  BCF    03.0
06F7:  BTFSS  77.0
06F8:  GOTO   707
06F9:  MOVF   28,W
06FA:  ADDWF  2C,F
06FB:  MOVF   29,W
06FC:  BTFSC  03.0
06FD:  INCFSZ 29,W
06FE:  ADDWF  2D,F
06FF:  MOVF   2A,W
0700:  BTFSC  03.0
0701:  INCFSZ 2A,W
0702:  ADDWF  2E,F
0703:  MOVF   2B,W
0704:  BTFSC  03.0
0705:  INCFSZ 2B,W
0706:  ADDWF  2F,F
0707:  RRF    2F,F
0708:  RRF    2E,F
0709:  RRF    2D,F
070A:  RRF    2C,F
070B:  RRF    7A,F
070C:  RRF    79,F
070D:  RRF    78,F
070E:  RRF    77,F
070F:  DECFSZ 30,F
0710:  GOTO   6F6
*
07AC:  CLRF   77
07AD:  CLRF   78
07AE:  MOVF   6F,W
07AF:  BCF    03.0
07B0:  BTFSC  70.0
07B1:  ADDWF  77,F
07B2:  RRF    77,F
07B3:  RRF    78,F
07B4:  BTFSC  70.1
07B5:  ADDWF  77,F
07B6:  RRF    77,F
07B7:  RRF    78,F
07B8:  BTFSC  70.2
07B9:  ADDWF  77,F
07BA:  RRF    77,F
07BB:  RRF    78,F
07BC:  BTFSC  70.3
07BD:  ADDWF  77,F
07BE:  RRF    77,F
07BF:  RRF    78,F
07C0:  BTFSC  70.4
07C1:  ADDWF  77,F
07C2:  RRF    77,F
07C3:  RRF    78,F
07C4:  BTFSC  70.5
07C5:  ADDWF  77,F
07C6:  RRF    77,F
07C7:  RRF    78,F
07C8:  BTFSC  70.6
07C9:  ADDWF  77,F
07CA:  RRF    77,F
07CB:  RRF    78,F
07CC:  BTFSC  70.7
07CD:  ADDWF  77,F
07CE:  RRF    77,F
07CF:  RRF    78,F
07D0:  RETURN
07D1:  MOVF   6E,W
07D2:  ANDLW  07
07D3:  MOVWF  77
07D4:  RRF    6E,W
07D5:  MOVWF  78
07D6:  RRF    78,F
07D7:  RRF    78,F
07D8:  MOVLW  1F
07D9:  ANDWF  78,F
07DA:  MOVF   78,W
07DB:  ADDWF  70,W
07DC:  MOVWF  04
07DD:  BCF    03.7
07DE:  BTFSC  71.0
07DF:  BSF    03.7
07E0:  CLRF   78
07E1:  INCF   78,F
07E2:  INCF   77,F
07E3:  GOTO   7E5
07E4:  RLF    78,F
07E5:  DECFSZ 77,F
07E6:  GOTO   7E4
07E7:  MOVF   6F,F
07E8:  BTFSC  03.2
07E9:  GOTO   7ED
07EA:  MOVF   78,W
07EB:  IORWF  00,F
07EC:  GOTO   7F0
07ED:  COMF   78,F
07EE:  MOVF   78,W
07EF:  ANDWF  00,F
07F0:  RETURN
*
0C49:  BCF    0A.0
0C4A:  BCF    0A.1
0C4B:  BSF    0A.2
0C4C:  ADDWF  02,F
0C4D:  GOTO   438
0C4E:  GOTO   43C
0C4F:  GOTO   440
0C50:  GOTO   444
*
100B:  BCF    03.6
100C:  MOVF   0B,W
100D:  MOVWF  6D
100E:  BCF    0B.7
100F:  BSF    03.5
1010:  BSF    03.6
1011:  BSF    0C.7
1012:  BSF    0C.0
1013:  NOP
1014:  NOP
1015:  BCF    03.5
1016:  BCF    03.6
1017:  BTFSC  6D.7
1018:  BSF    0B.7
1019:  BSF    03.6
101A:  MOVF   0C,W
101B:  ANDLW  7F
101C:  BTFSC  03.2
101D:  GOTO   0A1
101E:  BCF    03.6
101F:  MOVWF  6D
1020:  BSF    03.6
1021:  MOVF   0D,W
1022:  BCF    03.6
1023:  MOVWF  6E
1024:  BSF    03.6
1025:  MOVF   0F,W
1026:  BCF    03.6
1027:  MOVWF  6F
1028:  MOVF   6D,W
1029:  MOVWF  71
*
104B:  MOVF   6E,W
104C:  BSF    03.6
104D:  MOVWF  0D
104E:  BCF    03.6
104F:  MOVF   6F,W
1050:  BSF    03.6
1051:  MOVWF  0F
1052:  BCF    03.6
1053:  MOVF   0B,W
1054:  MOVWF  70
1055:  BCF    0B.7
1056:  BSF    03.5
1057:  BSF    03.6
1058:  BSF    0C.7
1059:  BSF    0C.0
105A:  NOP
105B:  NOP
105C:  BTFSS  70.7
105D:  GOTO   063
105E:  BCF    03.5
105F:  BCF    03.6
1060:  BSF    0B.7
1061:  BSF    03.5
1062:  BSF    03.6
1063:  BCF    03.5
1064:  RLF    0C,W
1065:  RLF    0E,W
1066:  ANDLW  7F
1067:  BTFSC  03.2
1068:  GOTO   0A1
1069:  BCF    03.6
106A:  MOVWF  6D
106B:  BSF    03.6
106C:  MOVF   0D,W
106D:  BCF    03.6
106E:  MOVWF  6E
106F:  BSF    03.6
1070:  MOVF   0F,W
1071:  BCF    03.6
1072:  MOVWF  6F
1073:  MOVF   6D,W
1074:  MOVWF  71
*
1096:  MOVF   6E,W
1097:  BSF    03.6
1098:  MOVWF  0D
1099:  BCF    03.6
109A:  MOVF   6F,W
109B:  BSF    03.6
109C:  MOVWF  0F
109D:  INCF   0D,F
109E:  BTFSC  03.2
109F:  INCF   0F,F
10A0:  GOTO   00B
*
10E0:  MOVF   00,F
10E1:  BTFSC  03.2
10E2:  GOTO   115
10E3:  CLRF   70
10E4:  MOVF   04,W
10E5:  MOVWF  6F
10E6:  BCF    70.0
10E7:  BTFSC  03.7
10E8:  BSF    70.0
10E9:  MOVF   00,W
10EA:  MOVWF  71
*
110C:  MOVF   6F,W
110D:  MOVWF  04
110E:  BCF    03.7
110F:  BTFSC  70.0
1110:  BSF    03.7
1111:  INCF   04,F
1112:  BTFSC  03.2
1113:  INCF   05,F
1114:  GOTO   0E0
*
111B:  BCF    03.6
111C:  MOVF   0B,W
111D:  MOVWF  6D
111E:  BCF    0B.7
111F:  BSF    03.5
1120:  BSF    03.6
1121:  BSF    0C.7
1122:  BSF    0C.0
1123:  NOP
1124:  NOP
1125:  BCF    03.5
1126:  BCF    03.6
1127:  BTFSC  6D.7
1128:  BSF    0B.7
1129:  BSF    03.6
112A:  MOVF   0C,W
112B:  ANDLW  7F
112C:  BTFSC  03.2
112D:  GOTO   1B1
112E:  BCF    03.6
112F:  MOVWF  6D
1130:  BSF    03.6
1131:  MOVF   0D,W
1132:  BCF    03.6
1133:  MOVWF  6E
1134:  BSF    03.6
1135:  MOVF   0F,W
1136:  BCF    03.6
1137:  MOVWF  6F
1138:  MOVF   6D,W
1139:  MOVWF  71
*
115B:  MOVF   6E,W
115C:  BSF    03.6
115D:  MOVWF  0D
115E:  BCF    03.6
115F:  MOVF   6F,W
1160:  BSF    03.6
1161:  MOVWF  0F
1162:  BCF    03.6
1163:  MOVF   0B,W
1164:  MOVWF  70
1165:  BCF    0B.7
1166:  BSF    03.5
1167:  BSF    03.6
1168:  BSF    0C.7
1169:  BSF    0C.0
116A:  NOP
116B:  NOP
116C:  BTFSS  70.7
116D:  GOTO   173
116E:  BCF    03.5
116F:  BCF    03.6
1170:  BSF    0B.7
1171:  BSF    03.5
1172:  BSF    03.6
1173:  BCF    03.5
1174:  RLF    0C,W
1175:  RLF    0E,W
1176:  ANDLW  7F
1177:  BTFSC  03.2
1178:  GOTO   1B1
1179:  BCF    03.6
117A:  MOVWF  6D
117B:  BSF    03.6
117C:  MOVF   0D,W
117D:  BCF    03.6
117E:  MOVWF  6E
117F:  BSF    03.6
1180:  MOVF   0F,W
1181:  BCF    03.6
1182:  MOVWF  6F
1183:  MOVF   6D,W
1184:  MOVWF  71
*
11A6:  MOVF   6E,W
11A7:  BSF    03.6
11A8:  MOVWF  0D
11A9:  BCF    03.6
11AA:  MOVF   6F,W
11AB:  BSF    03.6
11AC:  MOVWF  0F
11AD:  INCF   0D,F
11AE:  BTFSC  03.2
11AF:  INCF   0F,F
11B0:  GOTO   11B
*
11F0:  MOVF   00,F
11F1:  BTFSC  03.2
11F2:  GOTO   225
11F3:  CLRF   70
11F4:  MOVF   04,W
11F5:  MOVWF  6F
11F6:  BCF    70.0
11F7:  BTFSC  03.7
11F8:  BSF    70.0
11F9:  MOVF   00,W
11FA:  MOVWF  71
*
121C:  MOVF   6F,W
121D:  MOVWF  04
121E:  BCF    03.7
121F:  BTFSC  70.0
1220:  BSF    03.7
1221:  INCF   04,F
1222:  BTFSC  03.2
1223:  INCF   05,F
1224:  GOTO   1F0
*
122B:  BCF    03.6
122C:  MOVF   0B,W
122D:  MOVWF  6D
122E:  BCF    0B.7
122F:  BSF    03.5
1230:  BSF    03.6
1231:  BSF    0C.7
1232:  BSF    0C.0
1233:  NOP
1234:  NOP
1235:  BCF    03.5
1236:  BCF    03.6
1237:  BTFSC  6D.7
1238:  BSF    0B.7
1239:  BSF    03.6
123A:  MOVF   0C,W
123B:  ANDLW  7F
123C:  BTFSC  03.2
123D:  GOTO   2C1
123E:  BCF    03.6
123F:  MOVWF  6D
1240:  BSF    03.6
1241:  MOVF   0D,W
1242:  BCF    03.6
1243:  MOVWF  6E
1244:  BSF    03.6
1245:  MOVF   0F,W
1246:  BCF    03.6
1247:  MOVWF  6F
1248:  MOVF   6D,W
1249:  MOVWF  71
*
126B:  MOVF   6E,W
126C:  BSF    03.6
126D:  MOVWF  0D
126E:  BCF    03.6
126F:  MOVF   6F,W
1270:  BSF    03.6
1271:  MOVWF  0F
1272:  BCF    03.6
1273:  MOVF   0B,W
1274:  MOVWF  70
1275:  BCF    0B.7
1276:  BSF    03.5
1277:  BSF    03.6
1278:  BSF    0C.7
1279:  BSF    0C.0
127A:  NOP
127B:  NOP
127C:  BTFSS  70.7
127D:  GOTO   283
127E:  BCF    03.5
127F:  BCF    03.6
1280:  BSF    0B.7
1281:  BSF    03.5
1282:  BSF    03.6
1283:  BCF    03.5
1284:  RLF    0C,W
1285:  RLF    0E,W
1286:  ANDLW  7F
1287:  BTFSC  03.2
1288:  GOTO   2C1
1289:  BCF    03.6
128A:  MOVWF  6D
128B:  BSF    03.6
128C:  MOVF   0D,W
128D:  BCF    03.6
128E:  MOVWF  6E
128F:  BSF    03.6
1290:  MOVF   0F,W
1291:  BCF    03.6
1292:  MOVWF  6F
1293:  MOVF   6D,W
1294:  MOVWF  71
*
12B6:  MOVF   6E,W
12B7:  BSF    03.6
12B8:  MOVWF  0D
12B9:  BCF    03.6
12BA:  MOVF   6F,W
12BB:  BSF    03.6
12BC:  MOVWF  0F
12BD:  INCF   0D,F
12BE:  BTFSC  03.2
12BF:  INCF   0F,F
12C0:  GOTO   22B
*
1300:  MOVF   00,F
1301:  BTFSC  03.2
1302:  GOTO   335
1303:  CLRF   70
1304:  MOVF   04,W
1305:  MOVWF  6F
1306:  BCF    70.0
1307:  BTFSC  03.7
1308:  BSF    70.0
1309:  MOVF   00,W
130A:  MOVWF  71
*
132C:  MOVF   6F,W
132D:  MOVWF  04
132E:  BCF    03.7
132F:  BTFSC  70.0
1330:  BSF    03.7
1331:  INCF   04,F
1332:  BTFSC  03.2
1333:  INCF   05,F
1334:  GOTO   300
*
140C:  MOVF   0B,W
140D:  MOVWF  70
140E:  BCF    0B.7
140F:  BSF    03.5
1410:  BSF    03.6
1411:  BSF    0C.7
1412:  BSF    0C.0
1413:  NOP
1414:  NOP
1415:  BTFSS  70.7
1416:  GOTO   41C
1417:  BCF    03.5
1418:  BCF    03.6
1419:  BSF    0B.7
141A:  BSF    03.5
141B:  BSF    03.6
141C:  BTFSC  03.0
141D:  GOTO   44C
141E:  BCF    03.5
141F:  MOVF   0C,W
1420:  ANDLW  7F
1421:  MOVWF  70
1422:  MOVF   0D,W
1423:  MOVWF  71
1424:  MOVF   0F,W
1425:  MOVWF  72
1426:  MOVF   70,W
1427:  BCF    03.6
1428:  BTFSS  0C.4
1429:  GOTO   428
142A:  MOVWF  19
142B:  MOVF   71,W
142C:  BSF    03.6
142D:  MOVWF  0D
142E:  MOVF   72,W
142F:  MOVWF  0F
1430:  BCF    03.6
1431:  MOVF   0B,W
1432:  MOVWF  73
1433:  BCF    0B.7
1434:  BSF    03.5
1435:  BSF    03.6
1436:  BSF    0C.7
1437:  BSF    0C.0
1438:  NOP
1439:  NOP
143A:  BTFSS  73.7
143B:  GOTO   441
143C:  BCF    03.5
143D:  BCF    03.6
143E:  BSF    0B.7
143F:  BSF    03.5
1440:  BSF    03.6
1441:  BCF    03.5
1442:  BCF    03.6
1443:  DECFSZ 6F,F
1444:  GOTO   446
1445:  GOTO   449
1446:  BSF    03.5
1447:  BSF    03.6
1448:  GOTO   44C
1449:  GOTO   466
144A:  BSF    03.5
144B:  BSF    03.6
144C:  BCF    03.5
144D:  RLF    0C,W
144E:  RLF    0E,W
144F:  ANDLW  7F
1450:  MOVWF  70
1451:  MOVF   0D,W
1452:  MOVWF  71
1453:  MOVF   0F,W
1454:  MOVWF  72
1455:  MOVF   70,W
1456:  BCF    03.6
1457:  BTFSS  0C.4
1458:  GOTO   457
1459:  MOVWF  19
145A:  MOVF   71,W
145B:  BSF    03.6
145C:  MOVWF  0D
145D:  MOVF   72,W
145E:  MOVWF  0F
145F:  INCF   0D,F
1460:  BTFSC  03.2
1461:  INCF   0F,F
1462:  BCF    03.0
1463:  BCF    03.6
1464:  DECFSZ 6F,F
1465:  GOTO   40C
*
1481:  MOVF   0B,W
1482:  MOVWF  70
1483:  BCF    0B.7
1484:  BSF    03.5
1485:  BSF    03.6
1486:  BSF    0C.7
1487:  BSF    0C.0
1488:  NOP
1489:  NOP
148A:  BTFSS  70.7
148B:  GOTO   491
148C:  BCF    03.5
148D:  BCF    03.6
148E:  BSF    0B.7
148F:  BSF    03.5
1490:  BSF    03.6
1491:  BTFSC  03.0
1492:  GOTO   4C1
1493:  BCF    03.5
1494:  MOVF   0C,W
1495:  ANDLW  7F
1496:  MOVWF  70
1497:  MOVF   0D,W
1498:  MOVWF  71
1499:  MOVF   0F,W
149A:  MOVWF  72
149B:  MOVF   70,W
149C:  BCF    03.6
149D:  BTFSS  0C.4
149E:  GOTO   49D
149F:  MOVWF  19
14A0:  MOVF   71,W
14A1:  BSF    03.6
14A2:  MOVWF  0D
14A3:  MOVF   72,W
14A4:  MOVWF  0F
14A5:  BCF    03.6
14A6:  MOVF   0B,W
14A7:  MOVWF  73
14A8:  BCF    0B.7
14A9:  BSF    03.5
14AA:  BSF    03.6
14AB:  BSF    0C.7
14AC:  BSF    0C.0
14AD:  NOP
14AE:  NOP
14AF:  BTFSS  73.7
14B0:  GOTO   4B6
14B1:  BCF    03.5
14B2:  BCF    03.6
14B3:  BSF    0B.7
14B4:  BSF    03.5
14B5:  BSF    03.6
14B6:  BCF    03.5
14B7:  BCF    03.6
14B8:  DECFSZ 6F,F
14B9:  GOTO   4BB
14BA:  GOTO   4BE
14BB:  BSF    03.5
14BC:  BSF    03.6
14BD:  GOTO   4C1
14BE:  GOTO   4DB
14BF:  BSF    03.5
14C0:  BSF    03.6
14C1:  BCF    03.5
14C2:  RLF    0C,W
14C3:  RLF    0E,W
14C4:  ANDLW  7F
14C5:  MOVWF  70
14C6:  MOVF   0D,W
14C7:  MOVWF  71
14C8:  MOVF   0F,W
14C9:  MOVWF  72
14CA:  MOVF   70,W
14CB:  BCF    03.6
14CC:  BTFSS  0C.4
14CD:  GOTO   4CC
14CE:  MOVWF  19
14CF:  MOVF   71,W
14D0:  BSF    03.6
14D1:  MOVWF  0D
14D2:  MOVF   72,W
14D3:  MOVWF  0F
14D4:  INCF   0D,F
14D5:  BTFSC  03.2
14D6:  INCF   0F,F
14D7:  BCF    03.0
14D8:  BCF    03.6
14D9:  DECFSZ 6F,F
14DA:  GOTO   481
*
14F6:  MOVF   0B,W
14F7:  MOVWF  70
14F8:  BCF    0B.7
14F9:  BSF    03.5
14FA:  BSF    03.6
14FB:  BSF    0C.7
14FC:  BSF    0C.0
14FD:  NOP
14FE:  NOP
14FF:  BTFSS  70.7
1500:  GOTO   506
1501:  BCF    03.5
1502:  BCF    03.6
1503:  BSF    0B.7
1504:  BSF    03.5
1505:  BSF    03.6
1506:  BTFSC  03.0
1507:  GOTO   536
1508:  BCF    03.5
1509:  MOVF   0C,W
150A:  ANDLW  7F
150B:  MOVWF  70
150C:  MOVF   0D,W
150D:  MOVWF  71
150E:  MOVF   0F,W
150F:  MOVWF  72
1510:  MOVF   70,W
1511:  BCF    03.6
1512:  BTFSS  0C.4
1513:  GOTO   512
1514:  MOVWF  19
1515:  MOVF   71,W
1516:  BSF    03.6
1517:  MOVWF  0D
1518:  MOVF   72,W
1519:  MOVWF  0F
151A:  BCF    03.6
151B:  MOVF   0B,W
151C:  MOVWF  73
151D:  BCF    0B.7
151E:  BSF    03.5
151F:  BSF    03.6
1520:  BSF    0C.7
1521:  BSF    0C.0
1522:  NOP
1523:  NOP
1524:  BTFSS  73.7
1525:  GOTO   52B
1526:  BCF    03.5
1527:  BCF    03.6
1528:  BSF    0B.7
1529:  BSF    03.5
152A:  BSF    03.6
152B:  BCF    03.5
152C:  BCF    03.6
152D:  DECFSZ 6F,F
152E:  GOTO   530
152F:  GOTO   533
1530:  BSF    03.5
1531:  BSF    03.6
1532:  GOTO   536
1533:  GOTO   550
1534:  BSF    03.5
1535:  BSF    03.6
1536:  BCF    03.5
1537:  RLF    0C,W
1538:  RLF    0E,W
1539:  ANDLW  7F
153A:  MOVWF  70
153B:  MOVF   0D,W
153C:  MOVWF  71
153D:  MOVF   0F,W
153E:  MOVWF  72
153F:  MOVF   70,W
1540:  BCF    03.6
1541:  BTFSS  0C.4
1542:  GOTO   541
1543:  MOVWF  19
1544:  MOVF   71,W
1545:  BSF    03.6
1546:  MOVWF  0D
1547:  MOVF   72,W
1548:  MOVWF  0F
1549:  INCF   0D,F
154A:  BTFSC  03.2
154B:  INCF   0F,F
154C:  BCF    03.0
154D:  BCF    03.6
154E:  DECFSZ 6F,F
154F:  GOTO   4F6
*
1598:  MOVF   00,F
1599:  BTFSC  03.2
159A:  GOTO   5CD
159B:  CLRF   70
159C:  MOVF   04,W
159D:  MOVWF  6F
159E:  BCF    70.0
159F:  BTFSC  03.7
15A0:  BSF    70.0
15A1:  MOVF   00,W
15A2:  MOVWF  71
*
15C4:  MOVF   6F,W
15C5:  MOVWF  04
15C6:  BCF    03.7
15C7:  BTFSC  70.0
15C8:  BSF    03.7
15C9:  INCF   04,F
15CA:  BTFSC  03.2
15CB:  INCF   05,F
15CC:  GOTO   598
*
165F:  MOVF   00,F
1660:  BTFSC  03.2
1661:  GOTO   694
1662:  CLRF   70
1663:  MOVF   04,W
1664:  MOVWF  6F
1665:  BCF    70.0
1666:  BTFSC  03.7
1667:  BSF    70.0
1668:  MOVF   00,W
1669:  MOVWF  71
*
168B:  MOVF   6F,W
168C:  MOVWF  04
168D:  BCF    03.7
168E:  BTFSC  70.0
168F:  BSF    03.7
1690:  INCF   04,F
1691:  BTFSC  03.2
1692:  INCF   05,F
1693:  GOTO   65F
*
1698:  BCF    0A.0
1699:  BSF    0A.1
169A:  BSF    0A.2
169B:  ADDWF  02,F
169C:  GOTO   006
169D:  GOTO   116
169E:  GOTO   226
169F:  GOTO   336
16A0:  GOTO   60E
16A1:  GOTO   695
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20000000) 
*
0343:  MOVLW  A0
0344:  MOVWF  04
0345:  BCF    03.7
0346:  MOVF   00,W
0347:  BTFSC  03.2
0348:  GOTO   356
0349:  MOVLW  06
034A:  MOVWF  78
034B:  CLRF   77
034C:  DECFSZ 77,F
034D:  GOTO   34C
034E:  DECFSZ 78,F
034F:  GOTO   34B
0350:  MOVLW  7B
0351:  MOVWF  77
0352:  DECFSZ 77,F
0353:  GOTO   352
0354:  DECFSZ 00,F
0355:  GOTO   349
0356:  RETURN
*
0729:  MOVLW  03
072A:  SUBWF  25,F
072B:  BTFSS  03.0
072C:  GOTO   737
072D:  MOVLW  A5
072E:  MOVWF  04
072F:  BCF    03.7
0730:  MOVF   00,W
0731:  BTFSC  03.2
0732:  GOTO   737
0733:  GOTO   735
0734:  GOTO   735
0735:  DECFSZ 00,F
0736:  GOTO   734
*
073C:  MOVLW  03
073D:  SUBWF  25,F
073E:  BTFSS  03.0
073F:  GOTO   74A
0740:  MOVLW  A5
0741:  MOVWF  04
0742:  BCF    03.7
0743:  MOVF   00,W
0744:  BTFSC  03.2
0745:  GOTO   74A
0746:  GOTO   748
0747:  GOTO   748
0748:  DECFSZ 00,F
0749:  GOTO   747
*
075C:  MOVLW  03
075D:  SUBWF  25,F
075E:  BTFSS  03.0
075F:  GOTO   76A
0760:  MOVLW  A5
0761:  MOVWF  04
0762:  BCF    03.7
0763:  MOVF   00,W
0764:  BTFSC  03.2
0765:  GOTO   76A
0766:  GOTO   768
0767:  GOTO   768
0768:  DECFSZ 00,F
0769:  GOTO   767
*
076F:  MOVLW  03
0770:  SUBWF  25,F
0771:  BTFSS  03.0
0772:  GOTO   77D
0773:  MOVLW  A5
0774:  MOVWF  04
0775:  BCF    03.7
0776:  MOVF   00,W
0777:  BTFSC  03.2
0778:  GOTO   77D
0779:  GOTO   77B
077A:  GOTO   77B
077B:  DECFSZ 00,F
077C:  GOTO   77A
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
*
102A:  BSF    03.5
102B:  BCF    06.0
102C:  BCF    03.5
102D:  BCF    06.0
102E:  MOVLW  08
102F:  MOVWF  78
1030:  GOTO   031
1031:  NOP
1032:  BSF    78.7
1033:  GOTO   042
1034:  BCF    78.7
1035:  RRF    71,F
1036:  BTFSC  03.0
1037:  BSF    06.0
1038:  BTFSS  03.0
1039:  BCF    06.0
103A:  BSF    78.6
103B:  GOTO   042
103C:  BCF    78.6
103D:  DECFSZ 78,F
103E:  GOTO   035
103F:  GOTO   040
1040:  NOP
1041:  BSF    06.0
1042:  MOVLW  A7
1043:  MOVWF  04
1044:  DECFSZ 04,F
1045:  GOTO   044
1046:  GOTO   047
1047:  BTFSC  78.7
1048:  GOTO   034
1049:  BTFSC  78.6
104A:  GOTO   03C
*
1075:  BSF    03.5
1076:  BCF    06.0
1077:  BCF    03.5
1078:  BCF    06.0
1079:  MOVLW  08
107A:  MOVWF  78
107B:  GOTO   07C
107C:  NOP
107D:  BSF    78.7
107E:  GOTO   08D
107F:  BCF    78.7
1080:  RRF    71,F
1081:  BTFSC  03.0
1082:  BSF    06.0
1083:  BTFSS  03.0
1084:  BCF    06.0
1085:  BSF    78.6
1086:  GOTO   08D
1087:  BCF    78.6
1088:  DECFSZ 78,F
1089:  GOTO   080
108A:  GOTO   08B
108B:  NOP
108C:  BSF    06.0
108D:  MOVLW  A7
108E:  MOVWF  04
108F:  DECFSZ 04,F
1090:  GOTO   08F
1091:  GOTO   092
1092:  BTFSC  78.7
1093:  GOTO   07F
1094:  BTFSC  78.6
1095:  GOTO   087
*
10EB:  BSF    03.5
10EC:  BCF    06.0
10ED:  BCF    03.5
10EE:  BCF    06.0
10EF:  MOVLW  08
10F0:  MOVWF  78
10F1:  GOTO   0F2
10F2:  NOP
10F3:  BSF    78.7
10F4:  GOTO   103
10F5:  BCF    78.7
10F6:  RRF    71,F
10F7:  BTFSC  03.0
10F8:  BSF    06.0
10F9:  BTFSS  03.0
10FA:  BCF    06.0
10FB:  BSF    78.6
10FC:  GOTO   103
10FD:  BCF    78.6
10FE:  DECFSZ 78,F
10FF:  GOTO   0F6
1100:  GOTO   101
1101:  NOP
1102:  BSF    06.0
1103:  MOVLW  A7
1104:  MOVWF  04
1105:  DECFSZ 04,F
1106:  GOTO   105
1107:  GOTO   108
1108:  BTFSC  78.7
1109:  GOTO   0F5
110A:  BTFSC  78.6
110B:  GOTO   0FD
*
113A:  BSF    03.5
113B:  BCF    06.0
113C:  BCF    03.5
113D:  BCF    06.0
113E:  MOVLW  08
113F:  MOVWF  78
1140:  GOTO   141
1141:  NOP
1142:  BSF    78.7
1143:  GOTO   152
1144:  BCF    78.7
1145:  RRF    71,F
1146:  BTFSC  03.0
1147:  BSF    06.0
1148:  BTFSS  03.0
1149:  BCF    06.0
114A:  BSF    78.6
114B:  GOTO   152
114C:  BCF    78.6
114D:  DECFSZ 78,F
114E:  GOTO   145
114F:  GOTO   150
1150:  NOP
1151:  BSF    06.0
1152:  MOVLW  A7
1153:  MOVWF  04
1154:  DECFSZ 04,F
1155:  GOTO   154
1156:  GOTO   157
1157:  BTFSC  78.7
1158:  GOTO   144
1159:  BTFSC  78.6
115A:  GOTO   14C
*
1185:  BSF    03.5
1186:  BCF    06.0
1187:  BCF    03.5
1188:  BCF    06.0
1189:  MOVLW  08
118A:  MOVWF  78
118B:  GOTO   18C
118C:  NOP
118D:  BSF    78.7
118E:  GOTO   19D
118F:  BCF    78.7
1190:  RRF    71,F
1191:  BTFSC  03.0
1192:  BSF    06.0
1193:  BTFSS  03.0
1194:  BCF    06.0
1195:  BSF    78.6
1196:  GOTO   19D
1197:  BCF    78.6
1198:  DECFSZ 78,F
1199:  GOTO   190
119A:  GOTO   19B
119B:  NOP
119C:  BSF    06.0
119D:  MOVLW  A7
119E:  MOVWF  04
119F:  DECFSZ 04,F
11A0:  GOTO   19F
11A1:  GOTO   1A2
11A2:  BTFSC  78.7
11A3:  GOTO   18F
11A4:  BTFSC  78.6
11A5:  GOTO   197
*
11FB:  BSF    03.5
11FC:  BCF    06.0
11FD:  BCF    03.5
11FE:  BCF    06.0
11FF:  MOVLW  08
1200:  MOVWF  78
1201:  GOTO   202
1202:  NOP
1203:  BSF    78.7
1204:  GOTO   213
1205:  BCF    78.7
1206:  RRF    71,F
1207:  BTFSC  03.0
1208:  BSF    06.0
1209:  BTFSS  03.0
120A:  BCF    06.0
120B:  BSF    78.6
120C:  GOTO   213
120D:  BCF    78.6
120E:  DECFSZ 78,F
120F:  GOTO   206
1210:  GOTO   211
1211:  NOP
1212:  BSF    06.0
1213:  MOVLW  A7
1214:  MOVWF  04
1215:  DECFSZ 04,F
1216:  GOTO   215
1217:  GOTO   218
1218:  BTFSC  78.7
1219:  GOTO   205
121A:  BTFSC  78.6
121B:  GOTO   20D
*
124A:  BSF    03.5
124B:  BCF    06.0
124C:  BCF    03.5
124D:  BCF    06.0
124E:  MOVLW  08
124F:  MOVWF  78
1250:  GOTO   251
1251:  NOP
1252:  BSF    78.7
1253:  GOTO   262
1254:  BCF    78.7
1255:  RRF    71,F
1256:  BTFSC  03.0
1257:  BSF    06.0
1258:  BTFSS  03.0
1259:  BCF    06.0
125A:  BSF    78.6
125B:  GOTO   262
125C:  BCF    78.6
125D:  DECFSZ 78,F
125E:  GOTO   255
125F:  GOTO   260
1260:  NOP
1261:  BSF    06.0
1262:  MOVLW  A7
1263:  MOVWF  04
1264:  DECFSZ 04,F
1265:  GOTO   264
1266:  GOTO   267
1267:  BTFSC  78.7
1268:  GOTO   254
1269:  BTFSC  78.6
126A:  GOTO   25C
*
1295:  BSF    03.5
1296:  BCF    06.0
1297:  BCF    03.5
1298:  BCF    06.0
1299:  MOVLW  08
129A:  MOVWF  78
129B:  GOTO   29C
129C:  NOP
129D:  BSF    78.7
129E:  GOTO   2AD
129F:  BCF    78.7
12A0:  RRF    71,F
12A1:  BTFSC  03.0
12A2:  BSF    06.0
12A3:  BTFSS  03.0
12A4:  BCF    06.0
12A5:  BSF    78.6
12A6:  GOTO   2AD
12A7:  BCF    78.6
12A8:  DECFSZ 78,F
12A9:  GOTO   2A0
12AA:  GOTO   2AB
12AB:  NOP
12AC:  BSF    06.0
12AD:  MOVLW  A7
12AE:  MOVWF  04
12AF:  DECFSZ 04,F
12B0:  GOTO   2AF
12B1:  GOTO   2B2
12B2:  BTFSC  78.7
12B3:  GOTO   29F
12B4:  BTFSC  78.6
12B5:  GOTO   2A7
*
130B:  BSF    03.5
130C:  BCF    06.0
130D:  BCF    03.5
130E:  BCF    06.0
130F:  MOVLW  08
1310:  MOVWF  78
1311:  GOTO   312
1312:  NOP
1313:  BSF    78.7
1314:  GOTO   323
1315:  BCF    78.7
1316:  RRF    71,F
1317:  BTFSC  03.0
1318:  BSF    06.0
1319:  BTFSS  03.0
131A:  BCF    06.0
131B:  BSF    78.6
131C:  GOTO   323
131D:  BCF    78.6
131E:  DECFSZ 78,F
131F:  GOTO   316
1320:  GOTO   321
1321:  NOP
1322:  BSF    06.0
1323:  MOVLW  A7
1324:  MOVWF  04
1325:  DECFSZ 04,F
1326:  GOTO   325
1327:  GOTO   328
1328:  BTFSC  78.7
1329:  GOTO   315
132A:  BTFSC  78.6
132B:  GOTO   31D
*
15A3:  BSF    03.5
15A4:  BCF    06.0
15A5:  BCF    03.5
15A6:  BCF    06.0
15A7:  MOVLW  08
15A8:  MOVWF  78
15A9:  GOTO   5AA
15AA:  NOP
15AB:  BSF    78.7
15AC:  GOTO   5BB
15AD:  BCF    78.7
15AE:  RRF    71,F
15AF:  BTFSC  03.0
15B0:  BSF    06.0
15B1:  BTFSS  03.0
15B2:  BCF    06.0
15B3:  BSF    78.6
15B4:  GOTO   5BB
15B5:  BCF    78.6
15B6:  DECFSZ 78,F
15B7:  GOTO   5AE
15B8:  GOTO   5B9
15B9:  NOP
15BA:  BSF    06.0
15BB:  MOVLW  A7
15BC:  MOVWF  04
15BD:  DECFSZ 04,F
15BE:  GOTO   5BD
15BF:  GOTO   5C0
15C0:  BTFSC  78.7
15C1:  GOTO   5AD
15C2:  BTFSC  78.6
15C3:  GOTO   5B5
*
166A:  BSF    03.5
166B:  BCF    06.0
166C:  BCF    03.5
166D:  BCF    06.0
166E:  MOVLW  08
166F:  MOVWF  78
1670:  GOTO   671
1671:  NOP
1672:  BSF    78.7
1673:  GOTO   682
1674:  BCF    78.7
1675:  RRF    71,F
1676:  BTFSC  03.0
1677:  BSF    06.0
1678:  BTFSS  03.0
1679:  BCF    06.0
167A:  BSF    78.6
167B:  GOTO   682
167C:  BCF    78.6
167D:  DECFSZ 78,F
167E:  GOTO   675
167F:  GOTO   680
1680:  NOP
1681:  BSF    06.0
1682:  MOVLW  A7
1683:  MOVWF  04
1684:  DECFSZ 04,F
1685:  GOTO   684
1686:  GOTO   687
1687:  BTFSC  78.7
1688:  GOTO   674
1689:  BTFSC  78.6
168A:  GOTO   67C
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... char NL        = 0x0A; 
.................... char CR        = 0x0D; 
....................  
.................... /*const char OUT_END_CMD[2] = { 
....................                               0x0D, // CR 
....................                               0x0A,  // NL 
....................                               0x00   // End String 
....................                             }; 
....................  
.................... const char INP_END_CMD[4] = { 
....................                               0x4F, // O 
....................                               0x4B, // K 
....................                               0x0D, // CR 
....................                               0x0A,  // NL 
....................                               0x00   // End String 
....................                             };*/ 
.................... char buffer[] = 0x0; 
*
0BC7:  BCF    03.6
0BC8:  CLRF   2D
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
0BC9:  MOVLW  4A
0BCA:  MOVWF  2E
0BCB:  CLRF   2F
0BCC:  MOVLW  49
0BCD:  MOVWF  30
0BCE:  CLRF   31
0BCF:  MOVLW  48
0BD0:  MOVWF  32
0BD1:  CLRF   33
0BD2:  MOVLW  2C
0BD3:  MOVWF  34
0BD4:  CLRF   35
0BD5:  MOVLW  28
0BD6:  MOVWF  36
0BD7:  CLRF   37
0BD8:  MOVLW  29
0BD9:  MOVWF  38
0BDA:  CLRF   39
0BDB:  MOVLW  2A
0BDC:  MOVWF  3A
0BDD:  CLRF   3B
0BDE:  MOVLW  2B
0BDF:  MOVWF  3C
0BE0:  CLRF   3D
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05BD:  MOVF   2E,W
05BE:  MOVWF  32
05BF:  MOVF   2D,W
05C0:  MOVWF  31
05C1:  MOVF   32,W
05C2:  MOVWF  7A
05C3:  MOVF   31,W
05C4:  MOVWF  04
05C5:  BCF    03.7
05C6:  BTFSC  7A.0
05C7:  BSF    03.7
05C8:  MOVF   00,F
05C9:  BTFSC  03.2
05CA:  GOTO   5CF
05CB:  INCF   31,F
05CC:  BTFSC  03.2
05CD:  INCF   32,F
05CE:  GOTO   5C1
....................    while(*s2 != '\0') 
05CF:  MOVF   30,W
05D0:  MOVWF  7A
05D1:  MOVF   2F,W
05D2:  MOVWF  04
05D3:  BCF    03.7
05D4:  BTFSC  7A.0
05D5:  BSF    03.7
05D6:  MOVF   00,F
05D7:  BTFSC  03.2
05D8:  GOTO   5EE
....................    { 
....................       *s = *s2; 
05D9:  MOVF   2F,W
05DA:  MOVWF  04
05DB:  BCF    03.7
05DC:  BTFSC  30.0
05DD:  BSF    03.7
05DE:  MOVF   00,W
05DF:  MOVWF  35
05E0:  MOVF   31,W
05E1:  MOVWF  04
05E2:  BCF    03.7
05E3:  BTFSC  32.0
05E4:  BSF    03.7
05E5:  MOVF   35,W
05E6:  MOVWF  00
....................       ++s; 
05E7:  INCF   31,F
05E8:  BTFSC  03.2
05E9:  INCF   32,F
....................       ++s2; 
05EA:  INCF   2F,F
05EB:  BTFSC  03.2
05EC:  INCF   30,F
05ED:  GOTO   5CF
....................    } 
....................  
....................    *s = '\0'; 
05EE:  MOVF   31,W
05EF:  MOVWF  04
05F0:  BCF    03.7
05F1:  BTFSC  32.0
05F2:  BSF    03.7
05F3:  CLRF   00
....................    return(s1); 
05F4:  MOVF   2D,W
05F5:  MOVWF  78
05F6:  MOVF   2E,W
05F7:  MOVWF  79
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0BE1:  CLRF   3E
0BE2:  CLRF   3F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0399:  BSF    08.4
....................    output_float(LCD_DATA5); 
039A:  BSF    08.5
....................    output_float(LCD_DATA6); 
039B:  BSF    08.6
....................    output_float(LCD_DATA7); 
039C:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
039D:  BCF    03.5
039E:  BSF    08.1
039F:  BSF    03.5
03A0:  BCF    08.1
....................    delay_cycles(1); 
03A1:  NOP
....................    lcd_output_enable(1); 
03A2:  BCF    03.5
03A3:  BSF    08.0
03A4:  BSF    03.5
03A5:  BCF    08.0
....................    delay_cycles(1); 
03A6:  NOP
....................    high = lcd_read_nibble(); 
*
03D7:  MOVF   78,W
03D8:  MOVWF  27
....................        
....................    lcd_output_enable(0); 
03D9:  BCF    03.5
03DA:  BCF    08.0
03DB:  BSF    03.5
03DC:  BCF    08.0
....................    delay_cycles(1); 
03DD:  NOP
....................    lcd_output_enable(1); 
03DE:  BCF    03.5
03DF:  BSF    08.0
03E0:  BSF    03.5
03E1:  BCF    08.0
....................    delay_us(1); 
03E2:  GOTO   3E3
03E3:  GOTO   3E4
03E4:  NOP
....................    low = lcd_read_nibble(); 
*
0415:  MOVF   78,W
0416:  MOVWF  26
....................        
....................    lcd_output_enable(0); 
0417:  BCF    03.5
0418:  BCF    08.0
0419:  BSF    03.5
041A:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
041B:  BCF    08.4
....................    output_drive(LCD_DATA5); 
041C:  BCF    08.5
....................    output_drive(LCD_DATA6); 
041D:  BCF    08.6
....................    output_drive(LCD_DATA7); 
041E:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
041F:  SWAPF  27,W
0420:  MOVWF  77
0421:  MOVLW  F0
0422:  ANDWF  77,F
0423:  MOVF   77,W
0424:  IORWF  26,W
0425:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
03A7:  CLRF   28
*
03E5:  CLRF   28
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
03A8:  BSF    08.4
03A9:  MOVLW  00
03AA:  BCF    03.5
03AB:  BTFSC  08.4
03AC:  MOVLW  01
03AD:  BSF    03.5
03AE:  IORWF  28,F
*
03E6:  BSF    08.4
03E7:  MOVLW  00
03E8:  BCF    03.5
03E9:  BTFSC  08.4
03EA:  MOVLW  01
03EB:  BSF    03.5
03EC:  IORWF  28,F
....................    n |= input(LCD_DATA5) << 1; 
*
03AF:  BSF    08.5
03B0:  MOVLW  00
03B1:  BCF    03.5
03B2:  BTFSC  08.5
03B3:  MOVLW  01
03B4:  MOVWF  77
03B5:  BCF    03.0
03B6:  RLF    77,F
03B7:  MOVF   77,W
03B8:  BSF    03.5
03B9:  IORWF  28,F
*
03ED:  BSF    08.5
03EE:  MOVLW  00
03EF:  BCF    03.5
03F0:  BTFSC  08.5
03F1:  MOVLW  01
03F2:  MOVWF  77
03F3:  BCF    03.0
03F4:  RLF    77,F
03F5:  MOVF   77,W
03F6:  BSF    03.5
03F7:  IORWF  28,F
....................    n |= input(LCD_DATA6) << 2; 
*
03BA:  BSF    08.6
03BB:  MOVLW  00
03BC:  BCF    03.5
03BD:  BTFSC  08.6
03BE:  MOVLW  01
03BF:  MOVWF  77
03C0:  RLF    77,F
03C1:  RLF    77,F
03C2:  MOVLW  FC
03C3:  ANDWF  77,F
03C4:  MOVF   77,W
03C5:  BSF    03.5
03C6:  IORWF  28,F
*
03F8:  BSF    08.6
03F9:  MOVLW  00
03FA:  BCF    03.5
03FB:  BTFSC  08.6
03FC:  MOVLW  01
03FD:  MOVWF  77
03FE:  RLF    77,F
03FF:  RLF    77,F
0400:  MOVLW  FC
0401:  ANDWF  77,F
0402:  MOVF   77,W
0403:  BSF    03.5
0404:  IORWF  28,F
....................    n |= input(LCD_DATA7) << 3; 
*
03C7:  BSF    08.7
03C8:  MOVLW  00
03C9:  BCF    03.5
03CA:  BTFSC  08.7
03CB:  MOVLW  01
03CC:  MOVWF  77
03CD:  RLF    77,F
03CE:  RLF    77,F
03CF:  RLF    77,F
03D0:  MOVLW  F8
03D1:  ANDWF  77,F
03D2:  MOVF   77,W
03D3:  BSF    03.5
03D4:  IORWF  28,F
*
0405:  BSF    08.7
0406:  MOVLW  00
0407:  BCF    03.5
0408:  BTFSC  08.7
0409:  MOVLW  01
040A:  MOVWF  77
040B:  RLF    77,F
040C:  RLF    77,F
040D:  RLF    77,F
040E:  MOVLW  F8
040F:  ANDWF  77,F
0410:  MOVF   77,W
0411:  BSF    03.5
0412:  IORWF  28,F
....................     
....................    return(n); 
*
03D5:  MOVF   28,W
03D6:  MOVWF  78
*
0413:  MOVF   28,W
0414:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0357:  BSF    03.5
0358:  BTFSC  27.0
0359:  GOTO   35E
035A:  BCF    03.5
035B:  BCF    08.4
035C:  GOTO   360
035D:  BSF    03.5
035E:  BCF    03.5
035F:  BSF    08.4
0360:  BSF    03.5
0361:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0362:  BTFSC  27.1
0363:  GOTO   368
0364:  BCF    03.5
0365:  BCF    08.5
0366:  GOTO   36A
0367:  BSF    03.5
0368:  BCF    03.5
0369:  BSF    08.5
036A:  BSF    03.5
036B:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
036C:  BTFSC  27.2
036D:  GOTO   372
036E:  BCF    03.5
036F:  BCF    08.6
0370:  GOTO   374
0371:  BSF    03.5
0372:  BCF    03.5
0373:  BSF    08.6
0374:  BSF    03.5
0375:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0376:  BTFSC  27.3
0377:  GOTO   37C
0378:  BCF    03.5
0379:  BCF    08.7
037A:  GOTO   37E
037B:  BSF    03.5
037C:  BCF    03.5
037D:  BSF    08.7
037E:  BSF    03.5
037F:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0380:  NOP
....................    lcd_output_enable(1); 
0381:  BCF    03.5
0382:  BSF    08.0
0383:  BSF    03.5
0384:  BCF    08.0
....................    delay_us(2); 
0385:  MOVLW  02
0386:  MOVWF  77
0387:  DECFSZ 77,F
0388:  GOTO   387
0389:  GOTO   38A
038A:  NOP
....................    lcd_output_enable(0); 
038B:  BCF    03.5
038C:  BCF    08.0
038D:  BSF    03.5
038E:  BCF    08.0
038F:  BCF    03.5
0390:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
0391:  BSF    03.5
0392:  BCF    08.0
....................    lcd_rs_tris(); 
0393:  BCF    08.2
....................    lcd_rw_tris(); 
0394:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0395:  BCF    03.5
0396:  BCF    08.2
0397:  BSF    03.5
0398:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0426:  MOVF   78,W
0427:  MOVWF  26
0428:  BTFSC  26.7
0429:  GOTO   399
....................    lcd_output_rs(address); 
042A:  MOVF   24,F
042B:  BTFSS  03.2
042C:  GOTO   431
042D:  BCF    03.5
042E:  BCF    08.2
042F:  GOTO   433
0430:  BSF    03.5
0431:  BCF    03.5
0432:  BSF    08.2
0433:  BSF    03.5
0434:  BCF    08.2
....................    delay_cycles(1); 
0435:  NOP
....................    lcd_output_rw(0); 
0436:  BCF    03.5
0437:  BCF    08.1
0438:  BSF    03.5
0439:  BCF    08.1
....................    delay_cycles(1); 
043A:  NOP
....................    lcd_output_enable(0); 
043B:  BCF    03.5
043C:  BCF    08.0
043D:  BSF    03.5
043E:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
043F:  SWAPF  25,W
0440:  MOVWF  26
0441:  MOVLW  0F
0442:  ANDWF  26,F
0443:  MOVF   26,W
0444:  MOVWF  27
0445:  BCF    03.5
0446:  CALL   357
....................    lcd_send_nibble(n & 0xf); 
0447:  BSF    03.5
0448:  MOVF   25,W
0449:  ANDLW  0F
044A:  MOVWF  26
044B:  MOVWF  27
044C:  BCF    03.5
044D:  CALL   357
044E:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
044F:  MOVLW  28
0450:  MOVWF  6B
0451:  MOVLW  0C
0452:  MOVWF  6C
0453:  MOVLW  01
0454:  MOVWF  6D
0455:  MOVLW  06
0456:  MOVWF  6E
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0457:  BCF    08.0
0458:  BSF    03.5
0459:  BCF    08.0
....................    lcd_output_rs(0); 
045A:  BCF    03.5
045B:  BCF    08.2
045C:  BSF    03.5
045D:  BCF    08.2
....................    lcd_output_rw(0); 
045E:  BCF    03.5
045F:  BCF    08.1
0460:  BSF    03.5
0461:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0462:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0463:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0464:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0465:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0466:  BCF    08.0
....................    lcd_rs_tris(); 
0467:  BCF    08.2
....................    lcd_rw_tris(); 
0468:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
0469:  MOVLW  0F
046A:  MOVWF  20
046B:  BCF    03.5
046C:  CALL   343
....................    for(i=1;i<=3;++i) 
046D:  MOVLW  01
046E:  MOVWF  6A
046F:  MOVF   6A,W
0470:  SUBLW  03
0471:  BTFSS  03.0
0472:  GOTO   47F
....................    { 
....................        lcd_send_nibble(3); 
0473:  MOVLW  03
0474:  BSF    03.5
0475:  MOVWF  27
0476:  BCF    03.5
0477:  CALL   357
....................        delay_ms(5); 
0478:  MOVLW  05
0479:  BSF    03.5
047A:  MOVWF  20
047B:  BCF    03.5
047C:  CALL   343
047D:  INCF   6A,F
047E:  GOTO   46F
....................    } 
....................     
....................    lcd_send_nibble(2); 
047F:  MOVLW  02
0480:  BSF    03.5
0481:  MOVWF  27
0482:  BCF    03.5
0483:  CALL   357
....................    delay_ms(5); 
0484:  MOVLW  05
0485:  BSF    03.5
0486:  MOVWF  20
0487:  BCF    03.5
0488:  CALL   343
....................    for(i=0;i<=3;++i) 
0489:  CLRF   6A
048A:  MOVF   6A,W
048B:  SUBLW  03
048C:  BTFSS  03.0
048D:  GOTO   49E
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
048E:  MOVLW  6B
048F:  ADDWF  6A,W
0490:  MOVWF  04
0491:  BCF    03.7
0492:  MOVF   00,W
0493:  MOVWF  6F
0494:  BSF    03.5
0495:  CLRF   24
0496:  BCF    03.5
0497:  MOVF   6F,W
0498:  BSF    03.5
0499:  MOVWF  25
049A:  BCF    03.5
049B:  CALL   391
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
049C:  INCF   6A,F
049D:  GOTO   48A
049E:  BSF    0A.3
049F:  BCF    0A.4
04A0:  GOTO   41F (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
04B3:  DECFSZ 21,W
04B4:  GOTO   4B6
04B5:  GOTO   4B9
*
04D7:  DECFSZ 21,W
04D8:  GOTO   4DA
04D9:  GOTO   4DD
*
0821:  DECFSZ 21,W
0822:  GOTO   024
0823:  GOTO   027
*
087F:  DECFSZ 21,W
0880:  GOTO   082
0881:  GOTO   085
*
08E3:  DECFSZ 21,W
08E4:  GOTO   0E6
08E5:  GOTO   0E9
*
0944:  DECFSZ 21,W
0945:  GOTO   147
0946:  GOTO   14A
*
09C5:  DECFSZ 21,W
09C6:  GOTO   1C8
09C7:  GOTO   1CB
*
0A23:  DECFSZ 21,W
0A24:  GOTO   226
0A25:  GOTO   229
*
0AA6:  DECFSZ 21,W
0AA7:  GOTO   2A9
0AA8:  GOTO   2AC
*
0B07:  DECFSZ 21,W
0B08:  GOTO   30A
0B09:  GOTO   30D
*
0B6E:  DECFSZ 21,W
0B6F:  GOTO   371
0B70:  GOTO   374
*
10AE:  DECFSZ 21,W
10AF:  GOTO   0B1
10B0:  GOTO   0B4
*
11BE:  DECFSZ 21,W
11BF:  GOTO   1C1
11C0:  GOTO   1C4
*
12CE:  DECFSZ 21,W
12CF:  GOTO   2D1
12D0:  GOTO   2D4
*
135A:  DECFSZ 21,W
135B:  GOTO   35D
135C:  GOTO   360
*
13BB:  DECFSZ 21,W
13BC:  GOTO   3BE
13BD:  GOTO   3C1
*
1566:  DECFSZ 21,W
1567:  GOTO   569
1568:  GOTO   56C
*
15EF:  DECFSZ 21,W
15F0:  GOTO   5F2
15F1:  GOTO   5F5
*
162D:  DECFSZ 21,W
162E:  GOTO   630
162F:  GOTO   633
....................       address=LCD_LINE_TWO; 
*
04B6:  MOVLW  40
04B7:  MOVWF  22
04B8:  GOTO   4BA
*
04DA:  MOVLW  40
04DB:  MOVWF  22
04DC:  GOTO   4DE
*
0824:  MOVLW  40
0825:  MOVWF  22
0826:  GOTO   028
*
0882:  MOVLW  40
0883:  MOVWF  22
0884:  GOTO   086
*
08E6:  MOVLW  40
08E7:  MOVWF  22
08E8:  GOTO   0EA
*
0947:  MOVLW  40
0948:  MOVWF  22
0949:  GOTO   14B
*
09C8:  MOVLW  40
09C9:  MOVWF  22
09CA:  GOTO   1CC
*
0A26:  MOVLW  40
0A27:  MOVWF  22
0A28:  GOTO   22A
*
0AA9:  MOVLW  40
0AAA:  MOVWF  22
0AAB:  GOTO   2AD
*
0B0A:  MOVLW  40
0B0B:  MOVWF  22
0B0C:  GOTO   30E
*
0B71:  MOVLW  40
0B72:  MOVWF  22
0B73:  GOTO   375
*
10B1:  MOVLW  40
10B2:  MOVWF  22
10B3:  GOTO   0B5
*
11C1:  MOVLW  40
11C2:  MOVWF  22
11C3:  GOTO   1C5
*
12D1:  MOVLW  40
12D2:  MOVWF  22
12D3:  GOTO   2D5
*
135D:  MOVLW  40
135E:  MOVWF  22
135F:  GOTO   361
*
13BE:  MOVLW  40
13BF:  MOVWF  22
13C0:  GOTO   3C2
*
1569:  MOVLW  40
156A:  MOVWF  22
156B:  GOTO   56D
*
15F2:  MOVLW  40
15F3:  MOVWF  22
15F4:  GOTO   5F6
*
1630:  MOVLW  40
1631:  MOVWF  22
1632:  GOTO   634
....................    else 
....................       address=0; 
*
04B9:  CLRF   22
*
04DD:  CLRF   22
*
0827:  CLRF   22
*
0885:  CLRF   22
*
08E9:  CLRF   22
*
094A:  CLRF   22
*
09CB:  CLRF   22
*
0A29:  CLRF   22
*
0AAC:  CLRF   22
*
0B0D:  CLRF   22
*
0B74:  CLRF   22
*
10B4:  CLRF   22
*
11C4:  CLRF   22
*
12D4:  CLRF   22
*
1360:  CLRF   22
*
13C1:  CLRF   22
*
156C:  CLRF   22
*
15F5:  CLRF   22
*
1633:  CLRF   22
....................       
....................    address+=x-1; 
*
04BA:  MOVLW  01
04BB:  SUBWF  20,W
04BC:  ADDWF  22,F
*
04DE:  MOVLW  01
04DF:  SUBWF  20,W
04E0:  ADDWF  22,F
*
0828:  MOVLW  01
0829:  SUBWF  20,W
082A:  ADDWF  22,F
*
0886:  MOVLW  01
0887:  SUBWF  20,W
0888:  ADDWF  22,F
*
08EA:  MOVLW  01
08EB:  SUBWF  20,W
08EC:  ADDWF  22,F
*
094B:  MOVLW  01
094C:  SUBWF  20,W
094D:  ADDWF  22,F
*
09CC:  MOVLW  01
09CD:  SUBWF  20,W
09CE:  ADDWF  22,F
*
0A2A:  MOVLW  01
0A2B:  SUBWF  20,W
0A2C:  ADDWF  22,F
*
0AAD:  MOVLW  01
0AAE:  SUBWF  20,W
0AAF:  ADDWF  22,F
*
0B0E:  MOVLW  01
0B0F:  SUBWF  20,W
0B10:  ADDWF  22,F
*
0B75:  MOVLW  01
0B76:  SUBWF  20,W
0B77:  ADDWF  22,F
*
10B5:  MOVLW  01
10B6:  SUBWF  20,W
10B7:  ADDWF  22,F
*
11C5:  MOVLW  01
11C6:  SUBWF  20,W
11C7:  ADDWF  22,F
*
12D5:  MOVLW  01
12D6:  SUBWF  20,W
12D7:  ADDWF  22,F
*
1361:  MOVLW  01
1362:  SUBWF  20,W
1363:  ADDWF  22,F
*
13C2:  MOVLW  01
13C3:  SUBWF  20,W
13C4:  ADDWF  22,F
*
156D:  MOVLW  01
156E:  SUBWF  20,W
156F:  ADDWF  22,F
*
15F6:  MOVLW  01
15F7:  SUBWF  20,W
15F8:  ADDWF  22,F
*
1634:  MOVLW  01
1635:  SUBWF  20,W
1636:  ADDWF  22,F
....................    lcd_send_byte(0,0x80|address); 
*
04BD:  MOVF   22,W
04BE:  IORLW  80
04BF:  MOVWF  23
04C0:  CLRF   24
04C1:  MOVF   23,W
04C2:  MOVWF  25
04C3:  BCF    03.5
04C4:  CALL   391
*
04E1:  MOVF   22,W
04E2:  IORLW  80
04E3:  MOVWF  23
04E4:  CLRF   24
04E5:  MOVF   23,W
04E6:  MOVWF  25
04E7:  BCF    03.5
04E8:  CALL   391
*
082B:  MOVF   22,W
082C:  IORLW  80
082D:  MOVWF  23
082E:  CLRF   24
082F:  MOVF   23,W
0830:  MOVWF  25
0831:  BCF    0A.3
0832:  BCF    03.5
0833:  CALL   391
0834:  BSF    0A.3
*
0889:  MOVF   22,W
088A:  IORLW  80
088B:  MOVWF  23
088C:  CLRF   24
088D:  MOVF   23,W
088E:  MOVWF  25
088F:  BCF    0A.3
0890:  BCF    03.5
0891:  CALL   391
0892:  BSF    0A.3
*
08ED:  MOVF   22,W
08EE:  IORLW  80
08EF:  MOVWF  23
08F0:  CLRF   24
08F1:  MOVF   23,W
08F2:  MOVWF  25
08F3:  BCF    0A.3
08F4:  BCF    03.5
08F5:  CALL   391
08F6:  BSF    0A.3
*
094E:  MOVF   22,W
094F:  IORLW  80
0950:  MOVWF  23
0951:  CLRF   24
0952:  MOVF   23,W
0953:  MOVWF  25
0954:  BCF    0A.3
0955:  BCF    03.5
0956:  CALL   391
0957:  BSF    0A.3
*
09CF:  MOVF   22,W
09D0:  IORLW  80
09D1:  MOVWF  23
09D2:  CLRF   24
09D3:  MOVF   23,W
09D4:  MOVWF  25
09D5:  BCF    0A.3
09D6:  BCF    03.5
09D7:  CALL   391
09D8:  BSF    0A.3
*
0A2D:  MOVF   22,W
0A2E:  IORLW  80
0A2F:  MOVWF  23
0A30:  CLRF   24
0A31:  MOVF   23,W
0A32:  MOVWF  25
0A33:  BCF    0A.3
0A34:  BCF    03.5
0A35:  CALL   391
0A36:  BSF    0A.3
*
0AB0:  MOVF   22,W
0AB1:  IORLW  80
0AB2:  MOVWF  23
0AB3:  CLRF   24
0AB4:  MOVF   23,W
0AB5:  MOVWF  25
0AB6:  BCF    0A.3
0AB7:  BCF    03.5
0AB8:  CALL   391
0AB9:  BSF    0A.3
*
0B11:  MOVF   22,W
0B12:  IORLW  80
0B13:  MOVWF  23
0B14:  CLRF   24
0B15:  MOVF   23,W
0B16:  MOVWF  25
0B17:  BCF    0A.3
0B18:  BCF    03.5
0B19:  CALL   391
0B1A:  BSF    0A.3
*
0B78:  MOVF   22,W
0B79:  IORLW  80
0B7A:  MOVWF  23
0B7B:  CLRF   24
0B7C:  MOVF   23,W
0B7D:  MOVWF  25
0B7E:  BCF    0A.3
0B7F:  BCF    03.5
0B80:  CALL   391
0B81:  BSF    0A.3
*
10B8:  MOVF   22,W
10B9:  IORLW  80
10BA:  MOVWF  23
10BB:  CLRF   24
10BC:  MOVF   23,W
10BD:  MOVWF  25
10BE:  BCF    0A.4
10BF:  BCF    03.5
10C0:  CALL   391
10C1:  BSF    0A.4
*
11C8:  MOVF   22,W
11C9:  IORLW  80
11CA:  MOVWF  23
11CB:  CLRF   24
11CC:  MOVF   23,W
11CD:  MOVWF  25
11CE:  BCF    0A.4
11CF:  BCF    03.5
11D0:  CALL   391
11D1:  BSF    0A.4
*
12D8:  MOVF   22,W
12D9:  IORLW  80
12DA:  MOVWF  23
12DB:  CLRF   24
12DC:  MOVF   23,W
12DD:  MOVWF  25
12DE:  BCF    0A.4
12DF:  BCF    03.5
12E0:  CALL   391
12E1:  BSF    0A.4
*
1364:  MOVF   22,W
1365:  IORLW  80
1366:  MOVWF  23
1367:  CLRF   24
1368:  MOVF   23,W
1369:  MOVWF  25
136A:  BCF    0A.4
136B:  BCF    03.5
136C:  CALL   391
136D:  BSF    0A.4
*
13C5:  MOVF   22,W
13C6:  IORLW  80
13C7:  MOVWF  23
13C8:  CLRF   24
13C9:  MOVF   23,W
13CA:  MOVWF  25
13CB:  BCF    0A.4
13CC:  BCF    03.5
13CD:  CALL   391
13CE:  BSF    0A.4
*
1570:  MOVF   22,W
1571:  IORLW  80
1572:  MOVWF  23
1573:  CLRF   24
1574:  MOVF   23,W
1575:  MOVWF  25
1576:  BCF    0A.4
1577:  BCF    03.5
1578:  CALL   391
1579:  BSF    0A.4
*
15F9:  MOVF   22,W
15FA:  IORLW  80
15FB:  MOVWF  23
15FC:  CLRF   24
15FD:  MOVF   23,W
15FE:  MOVWF  25
15FF:  BCF    0A.4
1600:  BCF    03.5
1601:  CALL   391
1602:  BSF    0A.4
*
1637:  MOVF   22,W
1638:  IORLW  80
1639:  MOVWF  23
163A:  CLRF   24
163B:  MOVF   23,W
163C:  MOVWF  25
163D:  BCF    0A.4
163E:  BCF    03.5
163F:  CALL   391
1640:  BSF    0A.4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
04A1:  MOVF   7E,W
04A2:  XORLW  07
04A3:  BTFSC  03.2
04A4:  GOTO   4AF
04A5:  XORLW  0B
04A6:  BTFSC  03.2
04A7:  GOTO   4C6
04A8:  XORLW  06
04A9:  BTFSC  03.2
04AA:  GOTO   4D2
04AB:  XORLW  02
04AC:  BTFSC  03.2
04AD:  GOTO   4EA
04AE:  GOTO   4F1
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
04AF:  MOVLW  01
04B0:  BSF    03.5
04B1:  MOVWF  20
04B2:  MOVWF  21
*
04C5:  GOTO   4F8
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
04C6:  BSF    03.5
04C7:  CLRF   24
04C8:  MOVLW  01
04C9:  MOVWF  25
04CA:  BCF    03.5
04CB:  CALL   391
....................                      delay_ms(2); 
04CC:  MOVLW  02
04CD:  BSF    03.5
04CE:  MOVWF  20
04CF:  BCF    03.5
04D0:  CALL   343
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
04D1:  GOTO   4F8
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
04D2:  MOVLW  01
04D3:  BSF    03.5
04D4:  MOVWF  20
04D5:  MOVLW  02
04D6:  MOVWF  21
*
04E9:  GOTO   4F8
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
04EA:  BSF    03.5
04EB:  CLRF   24
04EC:  MOVLW  10
04ED:  MOVWF  25
04EE:  BCF    03.5
04EF:  CALL   391
04F0:  GOTO   4F8
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
04F1:  MOVLW  01
04F2:  BSF    03.5
04F3:  MOVWF  24
04F4:  MOVF   7E,W
04F5:  MOVWF  25
04F6:  BCF    03.5
04F7:  CALL   391
....................      #endif 
....................    } 
04F8:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
....................  
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
*
0BE3:  MOVLW  B9
0BE4:  MOVWF  44
0BE5:  MOVLW  3B
0BE6:  MOVWF  45
0BE7:  MOVLW  5E
0BE8:  MOVWF  46
0BE9:  MOVLW  38
0BEA:  MOVWF  47
0BEB:  MOVLW  34
0BEC:  MOVWF  48
0BED:  MOVLW  35
0BEE:  MOVWF  49
0BEF:  MOVLW  38
0BF0:  MOVWF  4A
0BF1:  MOVLW  32
0BF2:  MOVWF  4B
0BF3:  MOVLW  66
0BF4:  MOVWF  4C
0BF5:  MOVLW  2F
0BF6:  MOVWF  4D
0BF7:  MOVLW  BD
0BF8:  MOVWF  4E
0BF9:  MOVLW  2C
0BFA:  MOVWF  4F
0BFB:  MOVLW  3A
0BFC:  MOVWF  50
0BFD:  MOVLW  2A
0BFE:  MOVWF  51
0BFF:  MOVLW  DC
0C00:  MOVWF  52
0C01:  MOVLW  27
0C02:  MOVWF  53
0C03:  MOVLW  9F
0C04:  MOVWF  54
0C05:  MOVLW  25
0C06:  MOVWF  55
0C07:  MOVLW  82
0C08:  MOVWF  56
0C09:  MOVLW  23
0C0A:  MOVWF  57
0C0B:  MOVLW  84
0C0C:  MOVWF  58
0C0D:  MOVLW  21
0C0E:  MOVWF  59
0C0F:  MOVLW  A3
0C10:  MOVWF  5A
0C11:  MOVLW  1F
0C12:  MOVWF  5B
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
....................  
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
0657:  CLRF   74
0658:  CLRF   73
0659:  CLRF   76
065A:  CLRF   75
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
065B:  MOVF   70,F
065C:  BTFSS  03.2
065D:  GOTO   662
065E:  MOVF   6F,W
065F:  SUBLW  13
0660:  BTFSC  03.0
0661:  GOTO   7AB
0662:  MOVF   70,W
0663:  SUBLW  4E
0664:  BTFSS  03.0
0665:  GOTO   7AB
0666:  BTFSS  03.2
0667:  GOTO   66C
0668:  MOVF   6F,W
0669:  SUBLW  20
066A:  BTFSS  03.0
066B:  GOTO   7AB
....................       tmp=100000; 
066C:  BSF    03.5
066D:  CLRF   23
066E:  MOVLW  01
066F:  MOVWF  22
0670:  MOVLW  86
0671:  MOVWF  21
0672:  MOVLW  A0
0673:  MOVWF  20
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
0674:  BCF    03.1
0675:  MOVF   23,W
0676:  MOVWF  27
0677:  MOVF   22,W
0678:  MOVWF  26
0679:  MOVF   21,W
067A:  MOVWF  25
067B:  MOVF   20,W
067C:  MOVWF  24
067D:  CLRF   2B
067E:  CLRF   2A
067F:  MOVF   70,W
0680:  MOVWF  29
0681:  BCF    03.5
0682:  MOVF   6F,W
0683:  BSF    03.5
0684:  MOVWF  28
*
06D3:  MOVF   7A,W
06D4:  MOVWF  23
06D5:  MOVF   79,W
06D6:  MOVWF  22
06D7:  MOVF   78,W
06D8:  MOVWF  21
06D9:  MOVF   77,W
06DA:  MOVWF  20
....................       tmp*=5;    
06DB:  MOVF   23,W
06DC:  MOVWF  27
06DD:  MOVF   22,W
06DE:  MOVWF  26
06DF:  MOVF   21,W
06E0:  MOVWF  25
06E1:  MOVF   20,W
06E2:  MOVWF  24
06E3:  CLRF   2B
06E4:  CLRF   2A
06E5:  CLRF   29
06E6:  MOVLW  05
06E7:  MOVWF  28
*
0711:  MOVF   7A,W
0712:  MOVWF  23
0713:  MOVF   79,W
0714:  MOVWF  22
0715:  MOVF   78,W
0716:  MOVWF  21
0717:  MOVF   77,W
0718:  MOVWF  20
....................       uS=tmp; 
0719:  MOVF   21,W
071A:  MOVWF  7C
071B:  MOVF   20,W
071C:  MOVWF  7B
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
071D:  BCF    06.2
071E:  BCF    03.5
071F:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0720:  MOVF   7C,W
0721:  MOVWF  7D
0722:  INCF   7D,F
0723:  DECF   7D,F
0724:  BTFSC  03.2
0725:  GOTO   739
0726:  MOVLW  FF
0727:  BSF    03.5
0728:  MOVWF  25
*
0737:  BCF    03.5
0738:  GOTO   723
0739:  MOVF   7B,W
073A:  BSF    03.5
073B:  MOVWF  25
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
074A:  MOVF   7B,W
074B:  ADDWF  75,F
074C:  MOVF   7C,W
074D:  BTFSC  03.0
074E:  INCFSZ 7C,W
074F:  ADDWF  76,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0750:  BCF    06.2
0751:  BCF    03.5
0752:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
0753:  MOVF   7C,W
0754:  MOVWF  7D
0755:  INCF   7D,F
0756:  DECF   7D,F
0757:  BTFSC  03.2
0758:  GOTO   76C
0759:  MOVLW  FF
075A:  BSF    03.5
075B:  MOVWF  25
*
076A:  BCF    03.5
076B:  GOTO   756
076C:  MOVF   7B,W
076D:  BSF    03.5
076E:  MOVWF  25
....................          CiclosL+=(uS);          //  
*
077D:  MOVF   7B,W
077E:  ADDWF  75,F
077F:  MOVF   7C,W
0780:  BTFSC  03.0
0781:  INCFSZ 7C,W
0782:  ADDWF  76,F
....................          CiclosL+=25;            // Compensador. 
0783:  MOVLW  19
0784:  ADDWF  75,F
0785:  BTFSC  03.0
0786:  INCF   76,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
0787:  MOVF   76,W
0788:  SUBLW  02
0789:  BTFSC  03.0
078A:  GOTO   7A0
078B:  XORLW  FF
078C:  BTFSS  03.2
078D:  GOTO   792
078E:  MOVF   75,W
078F:  SUBLW  E7
0790:  BTFSC  03.0
0791:  GOTO   7A0
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0792:  MOVLW  E8
0793:  SUBWF  75,F
0794:  MOVLW  03
0795:  BTFSS  03.0
0796:  MOVLW  04
0797:  SUBWF  76,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0798:  INCF   73,F
0799:  BTFSC  03.2
079A:  INCF   74,F
....................             CiclosL+=25;         // Compensador. 
079B:  MOVLW  19
079C:  ADDWF  75,F
079D:  BTFSC  03.0
079E:  INCF   76,F
079F:  GOTO   787
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
07A0:  MOVF   74,W
07A1:  SUBWF  72,W
07A2:  BTFSS  03.0
07A3:  GOTO   7AA
07A4:  BTFSS  03.2
07A5:  GOTO   71D
07A6:  MOVF   71,W
07A7:  SUBWF  73,W
07A8:  BTFSS  03.0
07A9:  GOTO   71D
07AA:  BCF    03.5
....................                                          // tiempo indicado. 
....................    } 
07AB:  RETURN
.................... } 
....................  
.................... #include "header/func_menu_setup.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
.................... /** DIRECTIVAS **/ 
.................... #define OPT_SHOW_IP     0 
.................... #define OPT_SHOW_SSID   1 
.................... #define OPT_SHOW_KEY    2 
.................... #define OPT_MODE_AP     3 
.................... #define OPT_BACKLIGH    4 
.................... #define OPT_EXIT        5 
....................  
.................... //Flag, Modo Cliente(1), Access Point(2), Cliente + AP (3) 
.................... #define MODE_CLIENT     0 
.................... #define MODE_AP         1 
.................... #define MODE_CLIENT_AP  2 
....................  
.................... int8 countOptMenuModo = 3; 
....................  
.................... //Contiene las opciones del menu optMenuModo[pos][lenString] 
.................... const char  optMenuModo[5][13]    =  { {"Cliente     "}, 
....................                                        {"Access Point"}, 
....................                                        {"Cliente + AP"}, 
....................                                        {"SALIR       "} 
....................                                      }; 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................    lcd_gotoxy(12,2); 
*
10A9:  MOVLW  0C
10AA:  BSF    03.5
10AB:  MOVWF  20
10AC:  MOVLW  02
10AD:  MOVWF  21
*
11B9:  MOVLW  0C
11BA:  BSF    03.5
11BB:  MOVWF  20
11BC:  MOVLW  02
11BD:  MOVWF  21
*
12C9:  MOVLW  0C
12CA:  BSF    03.5
12CB:  MOVWF  20
12CC:  MOVLW  02
12CD:  MOVWF  21
*
1561:  MOVLW  0C
1562:  BSF    03.5
1563:  MOVWF  20
1564:  MOVLW  02
1565:  MOVWF  21
*
1628:  MOVLW  0C
1629:  BSF    03.5
162A:  MOVWF  20
162B:  MOVLW  02
162C:  MOVWF  21
....................    printf(lcd_putc, "SALIR"); 
*
10C2:  MOVLW  9A
10C3:  BSF    03.6
10C4:  MOVWF  0D
10C5:  MOVLW  00
10C6:  MOVWF  0F
10C7:  BCF    0A.4
10C8:  BCF    03.6
10C9:  CALL   4F9
10CA:  BSF    0A.4
*
11D2:  MOVLW  9A
11D3:  BSF    03.6
11D4:  MOVWF  0D
11D5:  MOVLW  00
11D6:  MOVWF  0F
11D7:  BCF    0A.4
11D8:  BCF    03.6
11D9:  CALL   4F9
11DA:  BSF    0A.4
*
12E2:  MOVLW  9A
12E3:  BSF    03.6
12E4:  MOVWF  0D
12E5:  MOVLW  00
12E6:  MOVWF  0F
12E7:  BCF    0A.4
12E8:  BCF    03.6
12E9:  CALL   4F9
12EA:  BSF    0A.4
*
157A:  MOVLW  9A
157B:  BSF    03.6
157C:  MOVWF  0D
157D:  MOVLW  00
157E:  MOVWF  0F
157F:  BCF    0A.4
1580:  BCF    03.6
1581:  CALL   4F9
1582:  BSF    0A.4
*
1641:  MOVLW  9A
1642:  BSF    03.6
1643:  MOVWF  0D
1644:  MOVLW  00
1645:  MOVWF  0F
1646:  BCF    0A.4
1647:  BCF    03.6
1648:  CALL   4F9
1649:  BSF    0A.4
....................    while(1){ 
....................           
....................       if(input(KEY_OK)==0){ 
*
10CB:  BSF    03.5
10CC:  BSF    06.5
10CD:  BCF    03.5
10CE:  BTFSC  06.5
10CF:  GOTO   0DC
*
11DB:  BSF    03.5
11DC:  BSF    06.5
11DD:  BCF    03.5
11DE:  BTFSC  06.5
11DF:  GOTO   1EC
*
12EB:  BSF    03.5
12EC:  BSF    06.5
12ED:  BCF    03.5
12EE:  BTFSC  06.5
12EF:  GOTO   2FC
*
1583:  BSF    03.5
1584:  BSF    06.5
1585:  BCF    03.5
1586:  BTFSC  06.5
1587:  GOTO   594
*
164A:  BSF    03.5
164B:  BSF    06.5
164C:  BCF    03.5
164D:  BTFSC  06.5
164E:  GOTO   65B
....................             // Elimina el rebote 
....................             delay_ms(500); 
*
10D0:  MOVLW  02
10D1:  MOVWF  6F
10D2:  MOVLW  FA
10D3:  BSF    03.5
10D4:  MOVWF  20
10D5:  BCF    0A.4
10D6:  BCF    03.5
10D7:  CALL   343
10D8:  BSF    0A.4
10D9:  DECFSZ 6F,F
10DA:  GOTO   0D2
*
11E0:  MOVLW  02
11E1:  MOVWF  6F
11E2:  MOVLW  FA
11E3:  BSF    03.5
11E4:  MOVWF  20
11E5:  BCF    0A.4
11E6:  BCF    03.5
11E7:  CALL   343
11E8:  BSF    0A.4
11E9:  DECFSZ 6F,F
11EA:  GOTO   1E2
*
12F0:  MOVLW  02
12F1:  MOVWF  6F
12F2:  MOVLW  FA
12F3:  BSF    03.5
12F4:  MOVWF  20
12F5:  BCF    0A.4
12F6:  BCF    03.5
12F7:  CALL   343
12F8:  BSF    0A.4
12F9:  DECFSZ 6F,F
12FA:  GOTO   2F2
*
1588:  MOVLW  02
1589:  MOVWF  6F
158A:  MOVLW  FA
158B:  BSF    03.5
158C:  MOVWF  20
158D:  BCF    0A.4
158E:  BCF    03.5
158F:  CALL   343
1590:  BSF    0A.4
1591:  DECFSZ 6F,F
1592:  GOTO   58A
*
164F:  MOVLW  02
1650:  MOVWF  6F
1651:  MOVLW  FA
1652:  BSF    03.5
1653:  MOVWF  20
1654:  BCF    0A.4
1655:  BCF    03.5
1656:  CALL   343
1657:  BSF    0A.4
1658:  DECFSZ 6F,F
1659:  GOTO   651
....................             break; 
*
10DB:  GOTO   0DD
*
11EB:  GOTO   1ED
*
12FB:  GOTO   2FD
*
1593:  GOTO   595
*
165A:  GOTO   65C
....................       } 
*
10DC:  GOTO   0CB
*
11EC:  GOTO   1DB
*
12FC:  GOTO   2EB
*
1594:  GOTO   583
*
165B:  GOTO   64A
....................    } 
....................    fprintf(console,"%s",buffer); 
*
10DD:  MOVLW  2D
10DE:  MOVWF  04
10DF:  BCF    03.7
*
11ED:  MOVLW  2D
11EE:  MOVWF  04
11EF:  BCF    03.7
*
12FD:  MOVLW  2D
12FE:  MOVWF  04
12FF:  BCF    03.7
*
1595:  MOVLW  2D
1596:  MOVWF  04
1597:  BCF    03.7
*
165C:  MOVLW  2D
165D:  MOVWF  04
165E:  BCF    03.7
.................... } 
....................  
.................... void showBottonMenu(void){ 
....................    lcd_gotoxy(1,2); 
*
081C:  MOVLW  01
081D:  BSF    03.5
081E:  MOVWF  20
081F:  MOVLW  02
0820:  MOVWF  21
*
087A:  MOVLW  01
087B:  BSF    03.5
087C:  MOVWF  20
087D:  MOVLW  02
087E:  MOVWF  21
*
08DE:  MOVLW  01
08DF:  BSF    03.5
08E0:  MOVWF  20
08E1:  MOVLW  02
08E2:  MOVWF  21
*
093F:  MOVLW  01
0940:  BSF    03.5
0941:  MOVWF  20
0942:  MOVLW  02
0943:  MOVWF  21
*
09C0:  MOVLW  01
09C1:  BSF    03.5
09C2:  MOVWF  20
09C3:  MOVLW  02
09C4:  MOVWF  21
*
0A1E:  MOVLW  01
0A1F:  BSF    03.5
0A20:  MOVWF  20
0A21:  MOVLW  02
0A22:  MOVWF  21
*
0AA1:  MOVLW  01
0AA2:  BSF    03.5
0AA3:  MOVWF  20
0AA4:  MOVLW  02
0AA5:  MOVWF  21
*
0B02:  MOVLW  01
0B03:  BSF    03.5
0B04:  MOVWF  20
0B05:  MOVLW  02
0B06:  MOVWF  21
*
0B69:  MOVLW  01
0B6A:  BSF    03.5
0B6B:  MOVWF  20
0B6C:  MOVLW  02
0B6D:  MOVWF  21
*
1355:  MOVLW  01
1356:  BSF    03.5
1357:  MOVWF  20
1358:  MOVLW  02
1359:  MOVWF  21
*
13B6:  MOVLW  01
13B7:  BSF    03.5
13B8:  MOVWF  20
13B9:  MOVLW  02
13BA:  MOVWF  21
*
15EA:  MOVLW  01
15EB:  BSF    03.5
15EC:  MOVWF  20
15ED:  MOVLW  02
15EE:  MOVWF  21
....................    printf(lcd_putc, "[SIG]      [ENT]"); 
*
0835:  MOVLW  9D
0836:  BSF    03.6
0837:  MOVWF  0D
0838:  MOVLW  00
0839:  MOVWF  0F
083A:  BCF    0A.3
083B:  BCF    03.6
083C:  CALL   4F9
083D:  BSF    0A.3
*
0893:  MOVLW  9D
0894:  BSF    03.6
0895:  MOVWF  0D
0896:  MOVLW  00
0897:  MOVWF  0F
0898:  BCF    0A.3
0899:  BCF    03.6
089A:  CALL   4F9
089B:  BSF    0A.3
*
08F7:  MOVLW  9D
08F8:  BSF    03.6
08F9:  MOVWF  0D
08FA:  MOVLW  00
08FB:  MOVWF  0F
08FC:  BCF    0A.3
08FD:  BCF    03.6
08FE:  CALL   4F9
08FF:  BSF    0A.3
*
0958:  MOVLW  9D
0959:  BSF    03.6
095A:  MOVWF  0D
095B:  MOVLW  00
095C:  MOVWF  0F
095D:  BCF    0A.3
095E:  BCF    03.6
095F:  CALL   4F9
0960:  BSF    0A.3
*
09D9:  MOVLW  9D
09DA:  BSF    03.6
09DB:  MOVWF  0D
09DC:  MOVLW  00
09DD:  MOVWF  0F
09DE:  BCF    0A.3
09DF:  BCF    03.6
09E0:  CALL   4F9
09E1:  BSF    0A.3
*
0A37:  MOVLW  9D
0A38:  BSF    03.6
0A39:  MOVWF  0D
0A3A:  MOVLW  00
0A3B:  MOVWF  0F
0A3C:  BCF    0A.3
0A3D:  BCF    03.6
0A3E:  CALL   4F9
0A3F:  BSF    0A.3
*
0ABA:  MOVLW  9D
0ABB:  BSF    03.6
0ABC:  MOVWF  0D
0ABD:  MOVLW  00
0ABE:  MOVWF  0F
0ABF:  BCF    0A.3
0AC0:  BCF    03.6
0AC1:  CALL   4F9
0AC2:  BSF    0A.3
*
0B1B:  MOVLW  9D
0B1C:  BSF    03.6
0B1D:  MOVWF  0D
0B1E:  MOVLW  00
0B1F:  MOVWF  0F
0B20:  BCF    0A.3
0B21:  BCF    03.6
0B22:  CALL   4F9
0B23:  BSF    0A.3
*
0B82:  MOVLW  9D
0B83:  BSF    03.6
0B84:  MOVWF  0D
0B85:  MOVLW  00
0B86:  MOVWF  0F
0B87:  BCF    0A.3
0B88:  BCF    03.6
0B89:  CALL   4F9
0B8A:  BSF    0A.3
*
136E:  MOVLW  9D
136F:  BSF    03.6
1370:  MOVWF  0D
1371:  MOVLW  00
1372:  MOVWF  0F
1373:  BCF    0A.4
1374:  BCF    03.6
1375:  CALL   4F9
1376:  BSF    0A.4
*
13CF:  MOVLW  9D
13D0:  BSF    03.6
13D1:  MOVWF  0D
13D2:  MOVLW  00
13D3:  MOVWF  0F
13D4:  BCF    0A.4
13D5:  BCF    03.6
13D6:  CALL   4F9
13D7:  BSF    0A.4
*
1603:  MOVLW  9D
1604:  BSF    03.6
1605:  MOVWF  0D
1606:  MOVLW  00
1607:  MOVWF  0F
1608:  BCF    0A.4
1609:  BCF    03.6
160A:  CALL   4F9
160B:  BSF    0A.4
.................... } 
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
.................... void setMenuModo(void){ 
*
1336:  CLRF   6D
1337:  CLRF   6E
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
1338:  MOVF   6D,W
1339:  MOVWF  6F
133A:  MOVLW  0D
133B:  MOVWF  70
133C:  BCF    0A.4
133D:  CALL   7AC
133E:  BSF    0A.4
133F:  MOVF   78,W
1340:  MOVWF  6F
1341:  MOVLW  0C
1342:  MOVWF  7E
1343:  BCF    0A.4
1344:  CALL   4A1
1345:  BSF    0A.4
1346:  MOVLW  59
1347:  BSF    03.6
1348:  MOVWF  0D
1349:  MOVLW  00
134A:  MOVWF  0F
134B:  BCF    03.6
134C:  MOVF   6F,W
134D:  BSF    03.6
134E:  ADDWF  0D,F
134F:  BTFSC  03.0
1350:  INCF   0F,F
1351:  BCF    0A.4
1352:  BCF    03.6
1353:  CALL   62E
1354:  BSF    0A.4
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1377:  MOVF   6E,F
1378:  BTFSS  03.2
1379:  GOTO   60D
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
137A:  BSF    03.5
137B:  BSF    06.4
137C:  BCF    03.5
137D:  BTFSC  06.4
137E:  GOTO   3D8
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
137F:  MOVLW  02
1380:  MOVWF  6F
1381:  MOVLW  FA
1382:  BSF    03.5
1383:  MOVWF  20
1384:  BCF    0A.4
1385:  BCF    03.5
1386:  CALL   343
1387:  BSF    0A.4
1388:  DECFSZ 6F,F
1389:  GOTO   381
....................          BEEP; 
138A:  MOVLW  04
138B:  MOVWF  70
138C:  MOVLW  B9
138D:  MOVWF  6F
138E:  CLRF   72
138F:  MOVLW  14
1390:  MOVWF  71
1391:  BCF    0A.4
1392:  CALL   657
1393:  BSF    0A.4
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
1394:  INCF   6D,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuModo){ 
1395:  MOVF   6D,W
1396:  SUBWF  5C,W
1397:  BTFSS  03.0
....................             optSelected = 0; 
1398:  CLRF   6D
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
1399:  MOVF   6D,W
139A:  MOVWF  6F
139B:  MOVLW  0D
139C:  MOVWF  70
139D:  BCF    0A.4
139E:  CALL   7AC
139F:  BSF    0A.4
13A0:  MOVF   78,W
13A1:  MOVWF  6F
13A2:  MOVLW  0C
13A3:  MOVWF  7E
13A4:  BCF    0A.4
13A5:  CALL   4A1
13A6:  BSF    0A.4
13A7:  MOVLW  59
13A8:  BSF    03.6
13A9:  MOVWF  0D
13AA:  MOVLW  00
13AB:  MOVWF  0F
13AC:  BCF    03.6
13AD:  MOVF   6F,W
13AE:  BSF    03.6
13AF:  ADDWF  0D,F
13B0:  BTFSC  03.0
13B1:  INCF   0F,F
13B2:  BCF    0A.4
13B3:  BCF    03.6
13B4:  CALL   62E
13B5:  BSF    0A.4
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
13D8:  BSF    03.5
13D9:  BSF    06.5
13DA:  BCF    03.5
13DB:  BTFSC  06.5
13DC:  GOTO   60C
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
13DD:  MOVLW  02
13DE:  MOVWF  6F
13DF:  MOVLW  FA
13E0:  BSF    03.5
13E1:  MOVWF  20
13E2:  BCF    0A.4
13E3:  BCF    03.5
13E4:  CALL   343
13E5:  BSF    0A.4
13E6:  DECFSZ 6F,F
13E7:  GOTO   3DF
....................          BEEP; 
13E8:  MOVLW  04
13E9:  MOVWF  70
13EA:  MOVLW  B9
13EB:  MOVWF  6F
13EC:  CLRF   72
13ED:  MOVLW  14
13EE:  MOVWF  71
13EF:  BCF    0A.4
13F0:  CALL   657
13F1:  BSF    0A.4
....................           
....................          // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuModo){ 
13F2:  MOVF   5C,W
13F3:  SUBWF  6D,W
13F4:  BTFSS  03.2
13F5:  GOTO   3F9
....................             exit = 1; 
13F6:  MOVLW  01
13F7:  MOVWF  6E
....................          }else{ 
13F8:  GOTO   60C
....................             switch(optSelected){ 
13F9:  MOVF   6D,W
13FA:  BTFSC  03.2
13FB:  GOTO   403
13FC:  XORLW  01
13FD:  BTFSC  03.2
13FE:  GOTO   478
13FF:  XORLW  03
1400:  BTFSC  03.2
1401:  GOTO   4ED
1402:  GOTO   561
....................                case MODE_CLIENT: 
....................                   fprintf(ESP8266,"AT+CWMODE_DEF=1%c%c",NL,CR); 
1403:  MOVLW  A6
1404:  BSF    03.6
1405:  MOVWF  0D
1406:  MOVLW  00
1407:  MOVWF  0F
1408:  BCF    03.0
1409:  MOVLW  0F
140A:  BCF    03.6
140B:  MOVWF  6F
*
1466:  MOVF   2B,W
1467:  BTFSS  0C.4
1468:  GOTO   467
1469:  MOVWF  19
146A:  MOVF   2C,W
146B:  BTFSS  0C.4
146C:  GOTO   46B
146D:  MOVWF  19
....................                   printf(lcd_putc, "\fConfig Cliente"); 
146E:  MOVLW  B0
146F:  BSF    03.6
1470:  MOVWF  0D
1471:  MOVLW  00
1472:  MOVWF  0F
1473:  BCF    0A.4
1474:  BCF    03.6
1475:  CALL   4F9
1476:  BSF    0A.4
....................                   break; 
1477:  GOTO   561
....................                case MODE_AP: 
....................                   fprintf(ESP8266,"AT+CWMODE_DEF=2%c%c",NL,CR); 
1478:  MOVLW  B8
1479:  BSF    03.6
147A:  MOVWF  0D
147B:  MOVLW  00
147C:  MOVWF  0F
147D:  BCF    03.0
147E:  MOVLW  0F
147F:  BCF    03.6
1480:  MOVWF  6F
*
14DB:  MOVF   2B,W
14DC:  BTFSS  0C.4
14DD:  GOTO   4DC
14DE:  MOVWF  19
14DF:  MOVF   2C,W
14E0:  BTFSS  0C.4
14E1:  GOTO   4E0
14E2:  MOVWF  19
....................                   printf(lcd_putc, "\fConfig AP"); 
14E3:  MOVLW  C2
14E4:  BSF    03.6
14E5:  MOVWF  0D
14E6:  MOVLW  00
14E7:  MOVWF  0F
14E8:  BCF    0A.4
14E9:  BCF    03.6
14EA:  CALL   4F9
14EB:  BSF    0A.4
....................                   break; 
14EC:  GOTO   561
....................                case MODE_CLIENT_AP: 
....................                   fprintf(ESP8266,"AT+CWMODE_DEF=3%c%c",NL,CR); 
14ED:  MOVLW  C8
14EE:  BSF    03.6
14EF:  MOVWF  0D
14F0:  MOVLW  00
14F1:  MOVWF  0F
14F2:  BCF    03.0
14F3:  MOVLW  0F
14F4:  BCF    03.6
14F5:  MOVWF  6F
*
1550:  MOVF   2B,W
1551:  BTFSS  0C.4
1552:  GOTO   551
1553:  MOVWF  19
1554:  MOVF   2C,W
1555:  BTFSS  0C.4
1556:  GOTO   555
1557:  MOVWF  19
....................                   printf(lcd_putc, "\fConfig ClienteAP"); 
1558:  MOVLW  D2
1559:  BSF    03.6
155A:  MOVWF  0D
155B:  MOVLW  00
155C:  MOVWF  0F
155D:  BCF    0A.4
155E:  BCF    03.6
155F:  CALL   4F9
1560:  BSF    0A.4
....................                   break; 
....................             } 
....................             pressExit(); 
....................             // Muestra la ultima opcion del menu seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
*
15CD:  MOVF   6D,W
15CE:  MOVWF  6F
15CF:  MOVLW  0D
15D0:  MOVWF  70
15D1:  BCF    0A.4
15D2:  CALL   7AC
15D3:  BSF    0A.4
15D4:  MOVF   78,W
15D5:  MOVWF  6F
15D6:  MOVLW  0C
15D7:  MOVWF  7E
15D8:  BCF    0A.4
15D9:  CALL   4A1
15DA:  BSF    0A.4
15DB:  MOVLW  59
15DC:  BSF    03.6
15DD:  MOVWF  0D
15DE:  MOVLW  00
15DF:  MOVWF  0F
15E0:  BCF    03.6
15E1:  MOVF   6F,W
15E2:  BSF    03.6
15E3:  ADDWF  0D,F
15E4:  BTFSC  03.0
15E5:  INCF   0F,F
15E6:  BCF    0A.4
15E7:  BCF    03.6
15E8:  CALL   62E
15E9:  BSF    0A.4
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
160C:  GOTO   377
....................    } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................    switch(optSelect){ 
*
1000:  MOVF   6C,W
1001:  ADDLW  FA
1002:  BTFSC  03.0
1003:  GOTO   695
1004:  ADDLW  06
1005:  GOTO   698
....................        
....................       case OPT_SHOW_IP: 
....................          fprintf(console,"192.168.0.1"); 
1006:  MOVLW  DB
1007:  BSF    03.6
1008:  MOVWF  0D
1009:  MOVLW  00
100A:  MOVWF  0F
....................          printf(lcd_putc, "\f192.168.0.1"); 
*
10A1:  MOVLW  E1
10A2:  MOVWF  0D
10A3:  MOVLW  00
10A4:  MOVWF  0F
10A5:  BCF    0A.4
10A6:  BCF    03.6
10A7:  CALL   4F9
10A8:  BSF    0A.4
....................          pressExit(); 
....................          break; 
*
1115:  GOTO   695
....................       case OPT_SHOW_SSID: 
....................          fprintf(console,"C0G3_UNE"); 
1116:  MOVLW  E8
1117:  BSF    03.6
1118:  MOVWF  0D
1119:  MOVLW  00
111A:  MOVWF  0F
....................          printf(lcd_putc, "\fC0G3_UNE"); 
*
11B1:  MOVLW  ED
11B2:  MOVWF  0D
11B3:  MOVLW  00
11B4:  MOVWF  0F
11B5:  BCF    0A.4
11B6:  BCF    03.6
11B7:  CALL   4F9
11B8:  BSF    0A.4
....................          pressExit();          
....................          break; 
*
1225:  GOTO   695
....................       case OPT_SHOW_KEY: 
....................          fprintf(console,"1234Az!"); 
1226:  MOVLW  F2
1227:  BSF    03.6
1228:  MOVWF  0D
1229:  MOVLW  00
122A:  MOVWF  0F
....................          printf(lcd_putc, "\f1234Az!"); 
*
12C1:  MOVLW  F6
12C2:  MOVWF  0D
12C3:  MOVLW  00
12C4:  MOVWF  0F
12C5:  BCF    0A.4
12C6:  BCF    03.6
12C7:  CALL   4F9
12C8:  BSF    0A.4
....................          pressExit(); 
....................          break; 
*
1335:  GOTO   695
....................       case OPT_MODE_AP: 
....................          setMenuModo(); 
....................          break; 
*
160D:  GOTO   695
....................       case OPT_BACKLIGH: 
....................          output_toggle(LCD_LIGHT_PIN); 
160E:  BSF    03.5
160F:  BCF    08.3
1610:  MOVLW  08
1611:  BCF    03.5
1612:  XORWF  08,F
....................          if(input_state(LCD_LIGHT_PIN)==1){ 
1613:  BTFSS  08.3
1614:  GOTO   61F
....................             printf(lcd_putc, "\fBacklight On"); 
1615:  MOVLW  FB
1616:  BSF    03.6
1617:  MOVWF  0D
1618:  MOVLW  00
1619:  MOVWF  0F
161A:  BCF    0A.4
161B:  BCF    03.6
161C:  CALL   4F9
161D:  BSF    0A.4
....................          }else{ 
161E:  GOTO   628
....................             printf(lcd_putc, "\fBacklight Off"); 
161F:  MOVLW  02
1620:  BSF    03.6
1621:  MOVWF  0D
1622:  MOVLW  01
1623:  MOVWF  0F
1624:  BCF    0A.4
1625:  BCF    03.6
1626:  CALL   4F9
1627:  BSF    0A.4
....................          } 
....................          pressExit(); 
....................          break; 
*
1694:  GOTO   695
....................       case OPT_EXIT: 
....................          break; 
....................           
....................    } 
1695:  BSF    0A.3
1696:  BCF    0A.4
1697:  GOTO   34A (RETURN)
....................  
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuSetup  = 5; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[7][17]    =  { {"VER IP          "}, 
....................                                         {"VER SSID        "}, 
....................                                         {"VER KEY         "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................                                        
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
0800:  CLRF   6A
0801:  CLRF   6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0802:  SWAPF  6A,W
0803:  MOVWF  77
0804:  MOVLW  F0
0805:  ANDWF  77,F
0806:  MOVF   77,W
0807:  MOVWF  6C
0808:  MOVLW  0C
0809:  MOVWF  7E
080A:  BCF    0A.3
080B:  CALL   4A1
080C:  BSF    0A.3
080D:  MOVLW  0A
080E:  BSF    03.6
080F:  MOVWF  0D
0810:  MOVLW  01
0811:  MOVWF  0F
0812:  BCF    03.6
0813:  MOVF   6C,W
0814:  BSF    03.6
0815:  ADDWF  0D,F
0816:  BTFSC  03.0
0817:  INCF   0F,F
0818:  BCF    0A.3
0819:  BCF    03.6
081A:  CALL   62E
081B:  BSF    0A.3
....................    showBottonMenu(); 
....................    while(!exit){ 
*
083E:  MOVF   6B,F
083F:  BTFSS  03.2
0840:  GOTO   0B9
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0841:  BSF    03.5
0842:  BSF    06.4
0843:  BCF    03.5
0844:  BTFSC  06.4
0845:  GOTO   09C
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0846:  MOVLW  02
0847:  MOVWF  6C
0848:  MOVLW  FA
0849:  BSF    03.5
084A:  MOVWF  20
084B:  BCF    0A.3
084C:  BCF    03.5
084D:  CALL   343
084E:  BSF    0A.3
084F:  DECFSZ 6C,F
0850:  GOTO   048
....................          BEEP; 
0851:  MOVLW  04
0852:  MOVWF  70
0853:  MOVLW  B9
0854:  MOVWF  6F
0855:  CLRF   72
0856:  MOVLW  14
0857:  MOVWF  71
0858:  BCF    0A.3
0859:  CALL   657
085A:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
085B:  INCF   6A,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
085C:  MOVF   6A,W
085D:  SUBWF  5D,W
085E:  BTFSS  03.0
....................             optSelected = 0; 
085F:  CLRF   6A
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0860:  SWAPF  6A,W
0861:  MOVWF  77
0862:  MOVLW  F0
0863:  ANDWF  77,F
0864:  MOVF   77,W
0865:  MOVWF  6C
0866:  MOVLW  0C
0867:  MOVWF  7E
0868:  BCF    0A.3
0869:  CALL   4A1
086A:  BSF    0A.3
086B:  MOVLW  0A
086C:  BSF    03.6
086D:  MOVWF  0D
086E:  MOVLW  01
086F:  MOVWF  0F
0870:  BCF    03.6
0871:  MOVF   6C,W
0872:  BSF    03.6
0873:  ADDWF  0D,F
0874:  BTFSC  03.0
0875:  INCF   0F,F
0876:  BCF    0A.3
0877:  BCF    03.6
0878:  CALL   62E
0879:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
089C:  BSF    03.5
089D:  BSF    06.5
089E:  BCF    03.5
089F:  BTFSC  06.5
08A0:  GOTO   0B8
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
08A1:  MOVLW  02
08A2:  MOVWF  6C
08A3:  MOVLW  FA
08A4:  BSF    03.5
08A5:  MOVWF  20
08A6:  BCF    0A.3
08A7:  BCF    03.5
08A8:  CALL   343
08A9:  BSF    0A.3
08AA:  DECFSZ 6C,F
08AB:  GOTO   0A3
....................          BEEP; 
08AC:  MOVLW  04
08AD:  MOVWF  70
08AE:  MOVLW  B9
08AF:  MOVWF  6F
08B0:  CLRF   72
08B1:  MOVLW  14
08B2:  MOVWF  71
08B3:  BCF    0A.3
08B4:  CALL   657
08B5:  BSF    0A.3
....................          // Rompe el Loop 
....................          exit = 1; 
08B6:  MOVLW  01
08B7:  MOVWF  6B
....................       } // Fin KEY_OK 
08B8:  GOTO   03E
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
08B9:  MOVLW  01
08BA:  ADDWF  6A,W
08BB:  MOVWF  78
08BC:  BSF    0A.3
08BD:  BCF    0A.4
08BE:  GOTO   439 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
08BF:  CLRF   6A
08C0:  CLRF   6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
08C1:  MOVF   6A,W
08C2:  MOVWF  6F
08C3:  MOVLW  0F
08C4:  MOVWF  70
08C5:  BCF    0A.3
08C6:  CALL   7AC
08C7:  BSF    0A.3
08C8:  MOVF   78,W
08C9:  MOVWF  6C
08CA:  MOVLW  0C
08CB:  MOVWF  7E
08CC:  BCF    0A.3
08CD:  CALL   4A1
08CE:  BSF    0A.3
08CF:  MOVLW  4A
08D0:  BSF    03.6
08D1:  MOVWF  0D
08D2:  MOVLW  01
08D3:  MOVWF  0F
08D4:  BCF    03.6
08D5:  MOVF   6C,W
08D6:  BSF    03.6
08D7:  ADDWF  0D,F
08D8:  BTFSC  03.0
08D9:  INCF   0F,F
08DA:  BCF    0A.3
08DB:  BCF    03.6
08DC:  CALL   62E
08DD:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0900:  MOVF   6B,F
0901:  BTFSS  03.2
0902:  GOTO   19F
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0903:  BSF    03.5
0904:  BSF    06.4
0905:  BCF    03.5
0906:  BTFSC  06.4
0907:  GOTO   161
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0908:  MOVLW  02
0909:  MOVWF  6C
090A:  MOVLW  FA
090B:  BSF    03.5
090C:  MOVWF  20
090D:  BCF    0A.3
090E:  BCF    03.5
090F:  CALL   343
0910:  BSF    0A.3
0911:  DECFSZ 6C,F
0912:  GOTO   10A
....................          BEEP; 
0913:  MOVLW  04
0914:  MOVWF  70
0915:  MOVLW  B9
0916:  MOVWF  6F
0917:  CLRF   72
0918:  MOVLW  14
0919:  MOVWF  71
091A:  BCF    0A.3
091B:  CALL   657
091C:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
091D:  INCF   6A,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
091E:  MOVF   6A,W
091F:  SUBWF  5F,W
0920:  BTFSS  03.0
....................             optSelected = 0; 
0921:  CLRF   6A
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0922:  MOVF   6A,W
0923:  MOVWF  6F
0924:  MOVLW  0F
0925:  MOVWF  70
0926:  BCF    0A.3
0927:  CALL   7AC
0928:  BSF    0A.3
0929:  MOVF   78,W
092A:  MOVWF  6C
092B:  MOVLW  0C
092C:  MOVWF  7E
092D:  BCF    0A.3
092E:  CALL   4A1
092F:  BSF    0A.3
0930:  MOVLW  4A
0931:  BSF    03.6
0932:  MOVWF  0D
0933:  MOVLW  01
0934:  MOVWF  0F
0935:  BCF    03.6
0936:  MOVF   6C,W
0937:  BSF    03.6
0938:  ADDWF  0D,F
0939:  BTFSC  03.0
093A:  INCF   0F,F
093B:  BCF    0A.3
093C:  BCF    03.6
093D:  CALL   62E
093E:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0961:  BSF    03.5
0962:  BSF    06.5
0963:  BCF    03.5
0964:  BTFSC  06.5
0965:  GOTO   19E
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0966:  MOVLW  02
0967:  MOVWF  6C
0968:  MOVLW  FA
0969:  BSF    03.5
096A:  MOVWF  20
096B:  BCF    0A.3
096C:  BCF    03.5
096D:  CALL   343
096E:  BSF    0A.3
096F:  DECFSZ 6C,F
0970:  GOTO   168
....................          BEEP; 
0971:  MOVLW  04
0972:  MOVWF  70
0973:  MOVLW  B9
0974:  MOVWF  6F
0975:  CLRF   72
0976:  MOVLW  14
0977:  MOVWF  71
0978:  BCF    0A.3
0979:  CALL   657
097A:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
097B:  MOVF   5F,W
097C:  SUBWF  6A,W
097D:  BTFSS  03.2
097E:  GOTO   182
....................             exit = 1; 
097F:  MOVLW  01
0980:  MOVWF  6B
....................          }else{ 
0981:  GOTO   19E
....................             output_high(PIN_OUT[optSelected]); 
0982:  BCF    03.0
0983:  RLF    6A,W
0984:  ADDLW  2E
0985:  MOVWF  04
0986:  BCF    03.7
0987:  INCF   04,F
0988:  MOVF   00,W
0989:  MOVWF  6D
098A:  DECF   04,F
098B:  MOVF   00,W
098C:  MOVWF  6C
098D:  MOVWF  6E
098E:  MOVLW  01
098F:  MOVWF  6F
0990:  CLRF   71
0991:  CLRF   70
0992:  BCF    0A.3
0993:  CALL   7D1
0994:  BSF    0A.3
0995:  MOVF   6C,W
0996:  MOVWF  6E
0997:  CLRF   6F
0998:  CLRF   71
0999:  MOVLW  80
099A:  MOVWF  70
099B:  BCF    0A.3
099C:  CALL   7D1
099D:  BSF    0A.3
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
099E:  GOTO   100
....................    } // FIN While Infinito 
....................  
....................    return 0; 
099F:  MOVLW  00
09A0:  MOVWF  78
09A1:  BSF    0A.3
09A2:  BCF    0A.4
09A3:  GOTO   43D (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
09A4:  CLRF   6A
09A5:  CLRF   6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
09A6:  SWAPF  6A,W
09A7:  MOVWF  77
09A8:  MOVLW  F0
09A9:  ANDWF  77,F
09AA:  MOVF   77,W
09AB:  MOVWF  6C
09AC:  MOVLW  0C
09AD:  MOVWF  7E
09AE:  BCF    0A.3
09AF:  CALL   4A1
09B0:  BSF    0A.3
09B1:  MOVLW  E0
09B2:  BSF    03.6
09B3:  MOVWF  0D
09B4:  MOVLW  01
09B5:  MOVWF  0F
09B6:  BCF    03.6
09B7:  MOVF   6C,W
09B8:  BSF    03.6
09B9:  ADDWF  0D,F
09BA:  BTFSC  03.0
09BB:  INCF   0F,F
09BC:  BCF    0A.3
09BD:  BCF    03.6
09BE:  CALL   62E
09BF:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
09E2:  MOVF   6B,F
09E3:  BTFSS  03.2
09E4:  GOTO   27D
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
09E5:  BSF    03.5
09E6:  BSF    06.4
09E7:  BCF    03.5
09E8:  BTFSC  06.4
09E9:  GOTO   240
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
09EA:  MOVLW  02
09EB:  MOVWF  6C
09EC:  MOVLW  FA
09ED:  BSF    03.5
09EE:  MOVWF  20
09EF:  BCF    0A.3
09F0:  BCF    03.5
09F1:  CALL   343
09F2:  BSF    0A.3
09F3:  DECFSZ 6C,F
09F4:  GOTO   1EC
....................          BEEP; 
09F5:  MOVLW  04
09F6:  MOVWF  70
09F7:  MOVLW  B9
09F8:  MOVWF  6F
09F9:  CLRF   72
09FA:  MOVLW  14
09FB:  MOVWF  71
09FC:  BCF    0A.3
09FD:  CALL   657
09FE:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
09FF:  INCF   6A,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
0A00:  MOVF   6A,W
0A01:  SUBWF  60,W
0A02:  BTFSS  03.0
....................             optSelected = 0; 
0A03:  CLRF   6A
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0A04:  SWAPF  6A,W
0A05:  MOVWF  77
0A06:  MOVLW  F0
0A07:  ANDWF  77,F
0A08:  MOVF   77,W
0A09:  MOVWF  6C
0A0A:  MOVLW  0C
0A0B:  MOVWF  7E
0A0C:  BCF    0A.3
0A0D:  CALL   4A1
0A0E:  BSF    0A.3
0A0F:  MOVLW  E0
0A10:  BSF    03.6
0A11:  MOVWF  0D
0A12:  MOVLW  01
0A13:  MOVWF  0F
0A14:  BCF    03.6
0A15:  MOVF   6C,W
0A16:  BSF    03.6
0A17:  ADDWF  0D,F
0A18:  BTFSC  03.0
0A19:  INCF   0F,F
0A1A:  BCF    0A.3
0A1B:  BCF    03.6
0A1C:  CALL   62E
0A1D:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0A40:  BSF    03.5
0A41:  BSF    06.5
0A42:  BCF    03.5
0A43:  BTFSC  06.5
0A44:  GOTO   27C
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0A45:  MOVLW  02
0A46:  MOVWF  6C
0A47:  MOVLW  FA
0A48:  BSF    03.5
0A49:  MOVWF  20
0A4A:  BCF    0A.3
0A4B:  BCF    03.5
0A4C:  CALL   343
0A4D:  BSF    0A.3
0A4E:  DECFSZ 6C,F
0A4F:  GOTO   247
....................          BEEP; 
0A50:  MOVLW  04
0A51:  MOVWF  70
0A52:  MOVLW  B9
0A53:  MOVWF  6F
0A54:  CLRF   72
0A55:  MOVLW  14
0A56:  MOVWF  71
0A57:  BCF    0A.3
0A58:  CALL   657
0A59:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
0A5A:  MOVF   60,W
0A5B:  SUBWF  6A,W
0A5C:  BTFSS  03.2
0A5D:  GOTO   261
....................             exit = 1; 
0A5E:  MOVLW  01
0A5F:  MOVWF  6B
....................          }else{ 
0A60:  GOTO   27C
....................             output_low(PIN_OUT[optSelected]); 
0A61:  BCF    03.0
0A62:  RLF    6A,W
0A63:  ADDLW  2E
0A64:  MOVWF  04
0A65:  BCF    03.7
0A66:  INCF   04,F
0A67:  MOVF   00,W
0A68:  MOVWF  6D
0A69:  DECF   04,F
0A6A:  MOVF   00,W
0A6B:  MOVWF  6C
0A6C:  MOVWF  6E
0A6D:  CLRF   6F
0A6E:  CLRF   71
0A6F:  CLRF   70
0A70:  BCF    0A.3
0A71:  CALL   7D1
0A72:  BSF    0A.3
0A73:  MOVF   6C,W
0A74:  MOVWF  6E
0A75:  CLRF   6F
0A76:  CLRF   71
0A77:  MOVLW  80
0A78:  MOVWF  70
0A79:  BCF    0A.3
0A7A:  CALL   7D1
0A7B:  BSF    0A.3
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0A7C:  GOTO   1E2
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0A7D:  MOVLW  00
0A7E:  MOVWF  78
0A7F:  BSF    0A.3
0A80:  BCF    0A.4
0A81:  GOTO   441 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
.................... int getMenuSetup(void){ 
0A82:  CLRF   6A
0A83:  CLRF   6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0A84:  MOVF   6A,W
0A85:  MOVWF  6F
0A86:  MOVLW  11
0A87:  MOVWF  70
0A88:  BCF    0A.3
0A89:  CALL   7AC
0A8A:  BSF    0A.3
0A8B:  MOVF   78,W
0A8C:  MOVWF  6C
0A8D:  MOVLW  0C
0A8E:  MOVWF  7E
0A8F:  BCF    0A.3
0A90:  CALL   4A1
0A91:  BSF    0A.3
0A92:  MOVLW  80
0A93:  BSF    03.6
0A94:  MOVWF  0D
0A95:  MOVLW  02
0A96:  MOVWF  0F
0A97:  BCF    03.6
0A98:  MOVF   6C,W
0A99:  BSF    03.6
0A9A:  ADDWF  0D,F
0A9B:  BTFSC  03.0
0A9C:  INCF   0F,F
0A9D:  BCF    0A.3
0A9E:  BCF    03.6
0A9F:  CALL   62E
0AA0:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0AC3:  MOVF   6B,F
0AC4:  BTFSS  03.2
0AC5:  GOTO   38C
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0AC6:  BSF    03.5
0AC7:  BSF    06.4
0AC8:  BCF    03.5
0AC9:  BTFSC  06.4
0ACA:  GOTO   324
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0ACB:  MOVLW  02
0ACC:  MOVWF  6C
0ACD:  MOVLW  FA
0ACE:  BSF    03.5
0ACF:  MOVWF  20
0AD0:  BCF    0A.3
0AD1:  BCF    03.5
0AD2:  CALL   343
0AD3:  BSF    0A.3
0AD4:  DECFSZ 6C,F
0AD5:  GOTO   2CD
....................          BEEP; 
0AD6:  MOVLW  04
0AD7:  MOVWF  70
0AD8:  MOVLW  B9
0AD9:  MOVWF  6F
0ADA:  CLRF   72
0ADB:  MOVLW  14
0ADC:  MOVWF  71
0ADD:  BCF    0A.3
0ADE:  CALL   657
0ADF:  BSF    0A.3
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0AE0:  INCF   6A,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
0AE1:  MOVF   6A,W
0AE2:  SUBWF  5E,W
0AE3:  BTFSS  03.0
....................             optSelected = 0; 
0AE4:  CLRF   6A
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0AE5:  MOVF   6A,W
0AE6:  MOVWF  6F
0AE7:  MOVLW  11
0AE8:  MOVWF  70
0AE9:  BCF    0A.3
0AEA:  CALL   7AC
0AEB:  BSF    0A.3
0AEC:  MOVF   78,W
0AED:  MOVWF  6C
0AEE:  MOVLW  0C
0AEF:  MOVWF  7E
0AF0:  BCF    0A.3
0AF1:  CALL   4A1
0AF2:  BSF    0A.3
0AF3:  MOVLW  80
0AF4:  BSF    03.6
0AF5:  MOVWF  0D
0AF6:  MOVLW  02
0AF7:  MOVWF  0F
0AF8:  BCF    03.6
0AF9:  MOVF   6C,W
0AFA:  BSF    03.6
0AFB:  ADDWF  0D,F
0AFC:  BTFSC  03.0
0AFD:  INCF   0F,F
0AFE:  BCF    0A.3
0AFF:  BCF    03.6
0B00:  CALL   62E
0B01:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0B24:  BSF    03.5
0B25:  BSF    06.5
0B26:  BCF    03.5
0B27:  BTFSC  06.5
0B28:  GOTO   38B
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0B29:  MOVLW  02
0B2A:  MOVWF  6C
0B2B:  MOVLW  FA
0B2C:  BSF    03.5
0B2D:  MOVWF  20
0B2E:  BCF    0A.3
0B2F:  BCF    03.5
0B30:  CALL   343
0B31:  BSF    0A.3
0B32:  DECFSZ 6C,F
0B33:  GOTO   32B
....................          BEEP; 
0B34:  MOVLW  04
0B35:  MOVWF  70
0B36:  MOVLW  B9
0B37:  MOVWF  6F
0B38:  CLRF   72
0B39:  MOVLW  14
0B3A:  MOVWF  71
0B3B:  BCF    0A.3
0B3C:  CALL   657
0B3D:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
0B3E:  MOVF   5E,W
0B3F:  SUBWF  6A,W
0B40:  BTFSS  03.2
0B41:  GOTO   345
....................             exit = 1; 
0B42:  MOVLW  01
0B43:  MOVWF  6B
....................          }else{ 
0B44:  GOTO   38B
....................             executeSetup(optSelected); 
0B45:  MOVF   6A,W
0B46:  MOVWF  6C
0B47:  BSF    0A.4
0B48:  BCF    0A.3
0B49:  GOTO   000
0B4A:  BCF    0A.4
0B4B:  BSF    0A.3
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0B4C:  MOVF   6A,W
0B4D:  MOVWF  6F
0B4E:  MOVLW  11
0B4F:  MOVWF  70
0B50:  BCF    0A.3
0B51:  CALL   7AC
0B52:  BSF    0A.3
0B53:  MOVF   78,W
0B54:  MOVWF  6C
0B55:  MOVLW  0C
0B56:  MOVWF  7E
0B57:  BCF    0A.3
0B58:  CALL   4A1
0B59:  BSF    0A.3
0B5A:  MOVLW  80
0B5B:  BSF    03.6
0B5C:  MOVWF  0D
0B5D:  MOVLW  02
0B5E:  MOVWF  0F
0B5F:  BCF    03.6
0B60:  MOVF   6C,W
0B61:  BSF    03.6
0B62:  ADDWF  0D,F
0B63:  BTFSC  03.0
0B64:  INCF   0F,F
0B65:  BCF    0A.3
0B66:  BCF    03.6
0B67:  CALL   62E
0B68:  BSF    0A.3
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
0B8B:  GOTO   2C3
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0B8C:  MOVLW  00
0B8D:  MOVWF  78
0B8E:  BSF    0A.3
0B8F:  BCF    0A.4
0B90:  GOTO   445 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... #include "header/esp8266.h" 
.................... #define  CMD_MODE 1 
....................  
.................... /* Constantes de respuestas */ 
.................... const char ESP8266_RESP_OK[4]={'O','K',0x0D,0x0A}; 
.................... int   CMD_RUN = 0x00; 
....................  
.................... /* Buffer de response ESP8266 */ 
.................... char bufferRespOK[4]; 
....................  
.................... /* Declaracion de Funciones */ 
.................... int   setupMode(char modeVal[]); 
.................... void  waitRespOK(void); 
.................... void  waitResp(void); 
.................... void  reset(void); 
....................  
.................... /* Variables Globales */ 
.................... int flag_Resp_Valid  = 0; 
.................... int flag_Pos_Resp    = 0; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    printf(lcd_putc, "\fInicializando..."); 
*
0549:  MOVLW  F7
054A:  BSF    03.6
054B:  MOVWF  0D
054C:  MOVLW  02
054D:  MOVWF  0F
054E:  BCF    03.6
054F:  CALL   4F9
....................     
....................    /*@TODO: Variables que se setean con la data de la EEPROM*/ 
....................    char modoVal[] = "1"; 
0550:  MOVLW  31
0551:  MOVWF  6A
0552:  CLRF   6B
....................    char ssid[]    = "UNE_C06E"; 
0553:  MOVLW  55
0554:  MOVWF  6C
0555:  MOVLW  4E
0556:  MOVWF  6D
0557:  MOVLW  45
0558:  MOVWF  6E
0559:  MOVLW  5F
055A:  MOVWF  6F
055B:  MOVLW  43
055C:  MOVWF  70
055D:  MOVLW  30
055E:  MOVWF  71
055F:  MOVLW  36
0560:  MOVWF  72
0561:  MOVLW  45
0562:  MOVWF  73
0563:  CLRF   74
....................    char key[]     = "1"; 
0564:  MOVLW  31
0565:  MOVWF  75
0566:  CLRF   76
....................     
....................    reset(); 
....................    delay_ms(2000); 
*
0592:  MOVLW  08
0593:  MOVWF  7B
0594:  MOVLW  FA
0595:  BSF    03.5
0596:  MOVWF  20
0597:  BCF    03.5
0598:  CALL   343
0599:  DECFSZ 7B,F
059A:  GOTO   594
....................     
....................    CMD_RUN =  setupMode(modoVal); 
059B:  CLRF   7C
059C:  MOVLW  6A
059D:  MOVWF  7B
*
0615:  MOVF   78,W
0616:  MOVWF  61
....................    waitResp(); 
....................     
....................    printf(lcd_putc, "\fModo configurado"); 
*
061B:  MOVLW  00
061C:  BSF    03.6
061D:  MOVWF  0D
061E:  MOVLW  03
061F:  MOVWF  0F
0620:  BCF    03.6
0621:  CALL   4F9
....................    delay_ms(5000); 
0622:  MOVLW  14
0623:  MOVWF  7B
0624:  MOVLW  FA
0625:  BSF    03.5
0626:  MOVWF  20
0627:  BCF    03.5
0628:  CALL   343
0629:  DECFSZ 7B,F
062A:  GOTO   624
062B:  BSF    0A.3
062C:  BCF    0A.4
062D:  GOTO   431 (RETURN)
.................... } 
.................... /* reinicia el modulo para tener sincronia */ 
.................... void reset(void) 
*
0575:  MOVLW  06
0576:  MOVWF  7B
.................... { 
....................    char  mode[]   = "AT+RST";   // Comando AT 
*
0567:  MOVLW  41
0568:  BSF    03.5
0569:  MOVWF  20
056A:  MOVLW  54
056B:  MOVWF  21
056C:  MOVLW  2B
056D:  MOVWF  22
056E:  MOVLW  52
056F:  MOVWF  23
0570:  MOVLW  53
0571:  MOVWF  24
0572:  MOVLW  54
0573:  MOVWF  25
0574:  CLRF   26
....................    int   lenCMD   = 6;          // Tamao del string del comando 
....................     
....................    // Lanza el comando AT 
....................    for(int idx=0;idx<lenCMD;idx++){ 
*
0577:  CLRF   7C
0578:  MOVF   7B,W
0579:  SUBWF  7C,W
057A:  BTFSC  03.0
057B:  GOTO   589
....................       fputc(mode[idx], ESP8266); 
057C:  MOVLW  A0
057D:  ADDWF  7C,W
057E:  MOVWF  04
057F:  BCF    03.7
0580:  MOVF   00,W
0581:  MOVWF  7D
0582:  BCF    03.5
0583:  BTFSS  0C.4
0584:  GOTO   583
0585:  MOVWF  19
0586:  INCF   7C,F
0587:  BSF    03.5
0588:  GOTO   578
....................    } 
....................     
....................    // Finaliza el comando con \r\n 
....................    fputc(0x0D, ESP8266); 
0589:  MOVLW  0D
058A:  BCF    03.5
058B:  BTFSS  0C.4
058C:  GOTO   58B
058D:  MOVWF  19
....................    fputc(0x0A, ESP8266); 
058E:  MOVLW  0A
058F:  BTFSS  0C.4
0590:  GOTO   58F
0591:  MOVWF  19
.................... } // fin de la funcion reset() 
....................  
.................... /* Configura el modo de funcionamiento 1-Cliente, 2-AccessPoint, 3-AP+STA */ 
.................... int setupMode(char modeVal[]) 
*
05B4:  MOVLW  0B
05B5:  MOVWF  7D
.................... { 
....................    char  mode[]   = "AT+CWMODE=";   // Comando AT 
*
059E:  MOVLW  41
059F:  BSF    03.5
05A0:  MOVWF  20
05A1:  MOVLW  54
05A2:  MOVWF  21
05A3:  MOVLW  2B
05A4:  MOVWF  22
05A5:  MOVLW  43
05A6:  MOVWF  23
05A7:  MOVLW  57
05A8:  MOVWF  24
05A9:  MOVLW  4D
05AA:  MOVWF  25
05AB:  MOVLW  4F
05AC:  MOVWF  26
05AD:  MOVLW  44
05AE:  MOVWF  27
05AF:  MOVLW  45
05B0:  MOVWF  28
05B1:  MOVLW  3D
05B2:  MOVWF  29
05B3:  CLRF   2A
....................    int   lenCMD   = 11;             // Tamao del string del comando 
....................     
....................    // Concatena el comando junto con el valor a setear 
....................    strcat(mode,modeVal); 
*
05B6:  CLRF   2E
05B7:  MOVLW  A0
05B8:  MOVWF  2D
05B9:  MOVF   7C,W
05BA:  MOVWF  30
05BB:  MOVF   7B,W
05BC:  MOVWF  2F
....................     
....................    // Lanza el comando AT 
....................    for(int idx=0;idx<lenCMD;idx++){ 
*
05F8:  CLRF   7E
05F9:  MOVF   7D,W
05FA:  SUBWF  7E,W
05FB:  BTFSC  03.0
05FC:  GOTO   60A
....................       fputc(mode[idx], ESP8266); 
05FD:  MOVLW  A0
05FE:  ADDWF  7E,W
05FF:  MOVWF  04
0600:  BCF    03.7
0601:  MOVF   00,W
0602:  MOVWF  2B
0603:  BCF    03.5
0604:  BTFSS  0C.4
0605:  GOTO   604
0606:  MOVWF  19
0607:  INCF   7E,F
0608:  BSF    03.5
0609:  GOTO   5F9
....................    } 
....................     
....................    // Finaliza el comando con \r\n 
....................    fputc(0x0D, ESP8266); 
060A:  MOVLW  0D
060B:  BCF    03.5
060C:  BTFSS  0C.4
060D:  GOTO   60C
060E:  MOVWF  19
....................    fputc(0x0A, ESP8266); 
060F:  MOVLW  0A
0610:  BTFSS  0C.4
0611:  GOTO   610
0612:  MOVWF  19
....................     
....................    // Retorna Una constante que hace referencia al comando ejecutado 
....................    return CMD_MODE; 
0613:  MOVLW  01
0614:  MOVWF  78
.................... } // fin de la funcion setupMode() 
....................  
.................... /* @TODO: Esta funcion debe ser es bloqueante 
....................    Espera hasta que la respuesta sea completada, si la respuesta es completada 
....................    retorna 1 de lo contrario siempre retornara 0  
.................... */ 
.................... void waitRespOK(int buffer) 
*
0316:  MOVLW  04
0317:  MOVWF  41
.................... { 
....................    int lenResp = 4;  // Tamao del buffer de respuesta esperado 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_OK[flag_Pos_Resp] ) 
0318:  BCF    03.5
0319:  MOVF   67,W
031A:  CALL   051
031B:  MOVWF  78
031C:  BSF    03.5
031D:  SUBWF  40,W
031E:  BTFSS  03.2
031F:  GOTO   336
....................    { 
....................       // Almacena el caracter en el buffer de respuesta 
....................       bufferRespOK[flag_Pos_Resp] = buffer; 
0320:  MOVLW  62
0321:  BCF    03.5
0322:  ADDWF  67,W
0323:  MOVWF  04
0324:  BCF    03.7
0325:  BSF    03.5
0326:  MOVF   40,W
0327:  MOVWF  00
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp++; 
0328:  BCF    03.5
0329:  INCF   67,F
....................        
....................       if(flag_Pos_Resp==lenResp){ 
032A:  BSF    03.5
032B:  MOVF   41,W
032C:  BCF    03.5
032D:  SUBWF  67,W
032E:  BTFSS  03.2
032F:  GOTO   333
....................          // Respuesta es valida 
....................          flag_Resp_Valid   = 1; 
0330:  MOVLW  01
0331:  MOVWF  66
....................       }else{ 
0332:  GOTO   334
....................          // Reinicia la bandera para asegurar la integridad de la respesta 
....................          flag_Resp_Valid   = 0; 
0333:  CLRF   66
....................       } 
....................  
....................    }else{ 
0334:  GOTO   33D
0335:  BSF    03.5
....................       // Reinicia la bandera para asegurar la integridad de la respesta y 
....................       // asegura que la respuesta optenida no es valida, basea el buffer de 
....................       // respuesta 
....................       flag_Pos_Resp     = 0; 
0336:  BCF    03.5
0337:  CLRF   67
....................       flag_Resp_Valid   = 0; 
0338:  CLRF   66
....................       bufferRespOK[0]   = 0x00; 
0339:  CLRF   62
....................       bufferRespOK[1]   = 0x00; 
033A:  CLRF   63
....................       bufferRespOK[2]   = 0x00; 
033B:  CLRF   64
....................       bufferRespOK[3]   = 0x00; 
033C:  CLRF   65
....................    } 
.................... } // Fin de la funcion waitRespOK() 
....................  
.................... /* Bloque el programa hasta que la bandera flag_Resp_Valid=1 utilizada para 
....................    esperar por una respuesta valida */ 
.................... void waitResp(void){ 
....................    while(!flag_Resp_Valid); 
*
0617:  MOVF   66,F
0618:  BTFSC  03.2
0619:  GOTO   617
....................    flag_Resp_Valid = 0; 
061A:  CLRF   66
.................... } 
....................  
....................  
.................... /** VARIABLES GLOBALS **/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
.................... // Flag usada para almacenar las respuestas de las opciones de menu 
.................... int optSelect  = 0; 
....................  
.................... /** INTERRUPCIONES **/ 
....................  
.................... //@hint: se dispara cuando se detectan datos de llegada al puerto serie portWF 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
0309:  BTFSS  0C.5
030A:  GOTO   309
030B:  MOVF   1A,W
030C:  BSF    03.5
030D:  MOVWF  3F
.................... { 
....................    int buffer = getc(); 
....................     
....................    // Seleciona la funcion de confirmacion de la respuesta 
....................    switch(CMD_RUN){ 
030E:  BCF    03.5
030F:  MOVF   61,W
0310:  XORLW  01
0311:  BTFSS  03.2
0312:  GOTO   33E
....................     
....................       case CMD_MODE: 
....................          waitRespOK(buffer); 
0313:  BSF    03.5
0314:  MOVF   3F,W
0315:  MOVWF  40
....................          break; 
*
033D:  GOTO   33F
....................           
....................       default: 
....................          CMD_RUN = 0x00; 
033E:  CLRF   61
....................          break; 
....................    } 
....................     
033F:  BCF    0C.5
0340:  BCF    0A.3
0341:  BCF    0A.4
0342:  GOTO   02D
.................... } 
....................  
.................... /** INIT **/ 
....................  
....................    void main() 
*
0B91:  MOVF   03,W
0B92:  ANDLW  1F
0B93:  MOVWF  03
0B94:  BSF    03.5
0B95:  BSF    03.6
0B96:  BSF    07.3
0B97:  MOVLW  08
0B98:  BCF    03.6
0B99:  MOVWF  19
0B9A:  MOVLW  02
0B9B:  MOVWF  1A
0B9C:  MOVLW  A6
0B9D:  MOVWF  18
0B9E:  MOVLW  90
0B9F:  BCF    03.5
0BA0:  MOVWF  18
0BA1:  BSF    03.5
0BA2:  BCF    06.0
0BA3:  BCF    03.5
0BA4:  BSF    06.0
0BA5:  MOVLW  0A
0BA6:  MOVWF  2B
0BA7:  MOVLW  0D
0BA8:  MOVWF  2C
0BA9:  MOVLW  03
0BAA:  MOVWF  5C
0BAB:  MOVLW  02
0BAC:  MOVWF  5D
0BAD:  MOVLW  05
0BAE:  MOVWF  5E
0BAF:  MOVLW  08
0BB0:  MOVWF  5F
0BB1:  MOVWF  60
0BB2:  CLRF   61
0BB3:  CLRF   66
0BB4:  CLRF   67
0BB5:  CLRF   68
0BB6:  CLRF   69
0BB7:  BSF    03.5
0BB8:  BSF    03.6
0BB9:  MOVF   09,W
0BBA:  ANDLW  C0
0BBB:  MOVWF  09
0BBC:  BCF    03.6
0BBD:  BCF    1F.4
0BBE:  BCF    1F.5
0BBF:  MOVLW  00
0BC0:  BSF    03.6
0BC1:  MOVWF  08
0BC2:  BCF    03.5
0BC3:  CLRF   07
0BC4:  CLRF   08
0BC5:  CLRF   09
0BC6:  BCF    03.7
....................    { 
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
*
0C13:  MOVLW  30
0C14:  BSF    03.5
0C15:  MOVWF  15
0C16:  BCF    01.7
....................       set_tris_b(0b00110010); 
0C17:  MOVLW  32
0C18:  MOVWF  06
....................        
....................       enable_interrupts(INT_RDA);  
0C19:  BSF    0C.5
....................       enable_interrupts(GLOBAL);  
0C1A:  MOVLW  C0
0C1B:  BCF    03.5
0C1C:  IORWF  0B,F
....................  
....................       // Inicializa la lcd 
....................       lcd_init(); 
0C1D:  BCF    0A.3
0C1E:  GOTO   44F
0C1F:  BSF    0A.3
....................       output_high(LCD_LIGHT_PIN); 
0C20:  BSF    03.5
0C21:  BCF    08.3
0C22:  BCF    03.5
0C23:  BSF    08.3
....................  
....................       //Estabiliza el inicio del programa 
....................       delay_ms(500); 
0C24:  MOVLW  02
0C25:  MOVWF  6A
0C26:  MOVLW  FA
0C27:  BSF    03.5
0C28:  MOVWF  20
0C29:  BCF    0A.3
0C2A:  BCF    03.5
0C2B:  CALL   343
0C2C:  BSF    0A.3
0C2D:  DECFSZ 6A,F
0C2E:  GOTO   426
....................        
....................       esp8266_init(); 
0C2F:  BCF    0A.3
0C30:  GOTO   549
0C31:  BSF    0A.3
....................        
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
0C32:  MOVF   68,W
0C33:  ADDLW  FC
0C34:  BTFSC  03.0
0C35:  GOTO   447
0C36:  ADDLW  04
0C37:  GOTO   449
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
0C38:  GOTO   000
0C39:  MOVF   78,W
0C3A:  MOVWF  68
....................                break; 
0C3B:  GOTO   447
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
0C3C:  GOTO   0BF
0C3D:  MOVF   78,W
0C3E:  MOVWF  68
....................                break; 
0C3F:  GOTO   447
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
0C40:  GOTO   1A4
0C41:  MOVF   78,W
0C42:  MOVWF  68
....................                break; 
0C43:  GOTO   447
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
0C44:  GOTO   282
0C45:  MOVF   78,W
0C46:  MOVWF  68
....................                break; 
....................          } // Fin del Switch(menuActive) 
0C47:  GOTO   432
....................           
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
0C48:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
