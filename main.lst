CCS PCM C Compiler, Version 5.015, 5967               13-dic.-17 00:44

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   4805 words (59%)
                           Largest free fragment is 2048
               RAM used:   176 (48%) at main() level
                           224 (61%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   4DE
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  2B
0056:  RETLW  49
0057:  RETLW  50
0058:  RETLW  44
0059:  RETLW  2C
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  43
005F:  RETLW  4D
0060:  RETLW  44
0061:  RETLW  3A
0062:  BCF    0A.0
0063:  BCF    0A.1
0064:  BCF    0A.2
0065:  ADDWF  02,F
0066:  RETLW  4F
0067:  RETLW  4B
0068:  RETLW  0D
0069:  RETLW  0A
006A:  RETLW  00
006B:  BCF    0A.0
006C:  BCF    0A.1
006D:  BCF    0A.2
006E:  ADDWF  02,F
006F:  RETLW  4E
0070:  RETLW  6F
0071:  RETLW  20
0072:  RETLW  41
0073:  RETLW  70
0074:  RETLW  00
0075:  BCF    0A.0
0076:  BCF    0A.1
0077:  BCF    0A.2
0078:  ADDWF  02,F
0079:  RETLW  2B
007A:  RETLW  43
007B:  RETLW  57
007C:  RETLW  4A
007D:  RETLW  41
007E:  RETLW  50
007F:  RETLW  3A
0080:  RETLW  00
0081:  BCF    0A.0
0082:  BCF    0A.1
0083:  BCF    0A.2
0084:  ADDWF  02,F
0085:  RETLW  43
0086:  RETLW  4F
0087:  RETLW  4E
0088:  RETLW  4E
0089:  RETLW  45
008A:  RETLW  43
008B:  RETLW  54
008C:  RETLW  45
008D:  RETLW  44
008E:  RETLW  00
008F:  BCF    0A.0
0090:  BCF    0A.1
0091:  BCF    0A.2
0092:  ADDWF  02,F
0093:  RETLW  46
0094:  RETLW  41
0095:  RETLW  49
0096:  RETLW  4C
0097:  RETLW  00
0098:  DATA 41,2A
0099:  DATA AB,21
009A:  DATA 49,28
009B:  DATA D3,22
009C:  DATA 4E,22
009D:  DATA BD,12
009E:  DATA 63,16
009F:  DATA 31,19
00A0:  DATA 0D,05
00A1:  DATA 00,00
00A2:  DATA 41,2A
00A3:  DATA AB,21
00A4:  DATA 49,28
00A5:  DATA 43,26
00A6:  DATA CF,29
00A7:  DATA C5,1E
00A8:  DATA A5,31
00A9:  DATA 0D,05
00AA:  DATA 00,01
00AB:  DATA 41,2A
00AC:  DATA AB,21
00AD:  DATA D7,28
00AE:  DATA 41,28
00AF:  DATA 8A,06
00B0:  DATA 00,00
00B1:  DATA 41,2A
00B2:  DATA AB,21
00B3:  DATA 49,28
00B4:  DATA D3,22
00B5:  DATA 4E,22
00B6:  DATA BD,12
00B7:  DATA 63,16
00B8:  DATA 31,19
00B9:  DATA 0D,05
00BA:  DATA 00,01
00BB:  DATA 41,2A
00BC:  DATA AB,21
00BD:  DATA 49,28
00BE:  DATA 43,26
00BF:  DATA CF,29
00C0:  DATA C5,1E
00C1:  DATA A5,31
00C2:  DATA 0D,05
00C3:  DATA 00,01
00C4:  DATA 41,2A
00C5:  DATA AB,21
00C6:  DATA 49,28
00C7:  DATA D3,22
00C8:  DATA 4E,22
00C9:  DATA BD,12
00CA:  DATA 63,16
00CB:  DATA 31,19
00CC:  DATA 0D,05
00CD:  DATA 00,01
00CE:  DATA 41,2A
00CF:  DATA AB,21
00D0:  DATA 49,28
00D1:  DATA 43,26
00D2:  DATA CF,29
00D3:  DATA C5,1E
00D4:  DATA A5,31
00D5:  DATA 0D,05
00D6:  DATA 00,00
00D7:  DATA 41,2A
00D8:  DATA AB,21
00D9:  DATA D7,26
00DA:  DATA 4F,22
00DB:  DATA C5,1E
00DC:  DATA A5,31
00DD:  DATA 0D,05
00DE:  DATA 00,01
00DF:  DATA 41,2A
00E0:  DATA AB,21
00E1:  DATA 57,25
00E2:  DATA 41,28
00E3:  DATA BF,06
00E4:  DATA 0A,00
00E5:  DATA 41,2A
00E6:  DATA AB,21
00E7:  DATA 57,25
00E8:  DATA 41,28
00E9:  DATA BD,12
00EA:  DATA 73,00
00EB:  DATA 41,2A
00EC:  DATA AB,21
00ED:  DATA D7,26
00EE:  DATA 4F,22
00EF:  DATA C5,1E
00F0:  DATA A5,31
00F1:  DATA 0D,05
00F2:  DATA 00,01
00F3:  DATA 41,2A
00F4:  DATA AB,21
00F5:  DATA 49,28
00F6:  DATA CD,2A
00F7:  DATA D8,1E
00F8:  DATA B1,06
00F9:  DATA 0A,00
00FA:  DATA 41,2A
00FB:  DATA AB,21
00FC:  DATA 49,28
00FD:  DATA D3,22
00FE:  DATA 52,2B
00FF:  DATA 45,29
0100:  DATA BD,18
0101:  DATA 2C,1C
0102:  DATA B0,06
0103:  DATA 0A,00
0104:  RETLW  45
0105:  RETLW  6E
0106:  RETLW  63
0107:  RETLW  65
0108:  RETLW  6E
0109:  RETLW  64
010A:  RETLW  65
010B:  RETLW  72
010C:  RETLW  20
010D:  RETLW  4D
010E:  RETLW  61
010F:  RETLW  6E
0110:  RETLW  75
0111:  RETLW  61
0112:  RETLW  6C
0113:  RETLW  00
0114:  RETLW  41
0115:  RETLW  70
0116:  RETLW  61
0117:  RETLW  67
0118:  RETLW  61
0119:  RETLW  64
011A:  RETLW  6F
011B:  RETLW  20
011C:  RETLW  4D
011D:  RETLW  61
011E:  RETLW  6E
011F:  RETLW  75
0120:  RETLW  61
0121:  RETLW  6C
0122:  RETLW  20
0123:  RETLW  00
0124:  RETLW  43
0125:  RETLW  6F
0126:  RETLW  6E
0127:  RETLW  66
0128:  RETLW  69
0129:  RETLW  67
012A:  RETLW  75
012B:  RETLW  72
012C:  RETLW  61
012D:  RETLW  63
012E:  RETLW  69
012F:  RETLW  6F
0130:  RETLW  6E
0131:  RETLW  20
0132:  RETLW  20
0133:  RETLW  00
0134:  RETLW  00
0135:  RETLW  00
0136:  RETLW  00
0137:  RETLW  00
0138:  RETLW  00
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  00
013C:  RETLW  00
013D:  RETLW  00
013E:  RETLW  00
013F:  RETLW  00
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  00
0143:  RETLW  00
0144:  RETLW  4F
0145:  RETLW  6E
0146:  RETLW  20
0147:  RETLW  2D
0148:  RETLW  3E
0149:  RETLW  20
014A:  RETLW  53
014B:  RETLW  61
014C:  RETLW  6C
014D:  RETLW  69
014E:  RETLW  64
014F:  RETLW  61
0150:  RETLW  20
0151:  RETLW  31
0152:  RETLW  00
0153:  RETLW  4F
0154:  RETLW  6E
0155:  RETLW  20
0156:  RETLW  2D
0157:  RETLW  3E
0158:  RETLW  20
0159:  RETLW  53
015A:  RETLW  61
015B:  RETLW  6C
015C:  RETLW  69
015D:  RETLW  64
015E:  RETLW  61
015F:  RETLW  20
0160:  RETLW  32
0161:  RETLW  00
0162:  RETLW  4F
0163:  RETLW  6E
0164:  RETLW  20
0165:  RETLW  2D
0166:  RETLW  3E
0167:  RETLW  20
0168:  RETLW  53
0169:  RETLW  61
016A:  RETLW  6C
016B:  RETLW  69
016C:  RETLW  64
016D:  RETLW  61
016E:  RETLW  20
016F:  RETLW  33
0170:  RETLW  00
0171:  RETLW  4F
0172:  RETLW  6E
0173:  RETLW  20
0174:  RETLW  2D
0175:  RETLW  3E
0176:  RETLW  20
0177:  RETLW  53
0178:  RETLW  61
0179:  RETLW  6C
017A:  RETLW  69
017B:  RETLW  64
017C:  RETLW  61
017D:  RETLW  20
017E:  RETLW  34
017F:  RETLW  00
0180:  RETLW  4F
0181:  RETLW  6E
0182:  RETLW  20
0183:  RETLW  2D
0184:  RETLW  3E
0185:  RETLW  20
0186:  RETLW  53
0187:  RETLW  61
0188:  RETLW  6C
0189:  RETLW  69
018A:  RETLW  64
018B:  RETLW  61
018C:  RETLW  20
018D:  RETLW  35
018E:  RETLW  00
018F:  RETLW  4F
0190:  RETLW  6E
0191:  RETLW  20
0192:  RETLW  2D
0193:  RETLW  3E
0194:  RETLW  20
0195:  RETLW  53
0196:  RETLW  61
0197:  RETLW  6C
0198:  RETLW  69
0199:  RETLW  64
019A:  RETLW  61
019B:  RETLW  20
019C:  RETLW  36
019D:  RETLW  00
019E:  RETLW  4F
019F:  RETLW  6E
01A0:  RETLW  20
01A1:  RETLW  2D
01A2:  RETLW  3E
01A3:  RETLW  20
01A4:  RETLW  53
01A5:  RETLW  61
01A6:  RETLW  6C
01A7:  RETLW  69
01A8:  RETLW  64
01A9:  RETLW  61
01AA:  RETLW  20
01AB:  RETLW  37
01AC:  RETLW  00
01AD:  RETLW  4F
01AE:  RETLW  6E
01AF:  RETLW  20
01B0:  RETLW  2D
01B1:  RETLW  3E
01B2:  RETLW  20
01B3:  RETLW  53
01B4:  RETLW  61
01B5:  RETLW  6C
01B6:  RETLW  69
01B7:  RETLW  64
01B8:  RETLW  61
01B9:  RETLW  20
01BA:  RETLW  38
01BB:  RETLW  00
01BC:  RETLW  53
01BD:  RETLW  41
01BE:  RETLW  4C
01BF:  RETLW  49
01C0:  RETLW  52
01C1:  RETLW  20
01C2:  RETLW  20
01C3:  RETLW  20
01C4:  RETLW  20
01C5:  RETLW  20
01C6:  RETLW  20
01C7:  RETLW  20
01C8:  RETLW  20
01C9:  RETLW  20
01CA:  RETLW  00
01CB:  RETLW  00
01CC:  RETLW  00
01CD:  RETLW  00
01CE:  RETLW  00
01CF:  RETLW  00
01D0:  RETLW  00
01D1:  RETLW  00
01D2:  RETLW  00
01D3:  RETLW  00
01D4:  RETLW  00
01D5:  RETLW  00
01D6:  RETLW  00
01D7:  RETLW  00
01D8:  RETLW  00
01D9:  RETLW  00
01DA:  RETLW  4F
01DB:  RETLW  66
01DC:  RETLW  66
01DD:  RETLW  20
01DE:  RETLW  2D
01DF:  RETLW  3E
01E0:  RETLW  20
01E1:  RETLW  53
01E2:  RETLW  61
01E3:  RETLW  6C
01E4:  RETLW  69
01E5:  RETLW  64
01E6:  RETLW  61
01E7:  RETLW  20
01E8:  RETLW  31
01E9:  RETLW  00
01EA:  RETLW  4F
01EB:  RETLW  66
01EC:  RETLW  66
01ED:  RETLW  20
01EE:  RETLW  2D
01EF:  RETLW  3E
01F0:  RETLW  20
01F1:  RETLW  53
01F2:  RETLW  61
01F3:  RETLW  6C
01F4:  RETLW  69
01F5:  RETLW  64
01F6:  RETLW  61
01F7:  RETLW  20
01F8:  RETLW  32
01F9:  RETLW  00
01FA:  RETLW  4F
01FB:  RETLW  66
01FC:  RETLW  66
01FD:  RETLW  20
01FE:  RETLW  2D
01FF:  RETLW  3E
0200:  RETLW  20
0201:  RETLW  53
0202:  RETLW  61
0203:  RETLW  6C
0204:  RETLW  69
0205:  RETLW  64
0206:  RETLW  61
0207:  RETLW  20
0208:  RETLW  33
0209:  RETLW  00
020A:  RETLW  4F
020B:  RETLW  66
020C:  RETLW  66
020D:  RETLW  20
020E:  RETLW  2D
020F:  RETLW  3E
0210:  RETLW  20
0211:  RETLW  53
0212:  RETLW  61
0213:  RETLW  6C
0214:  RETLW  69
0215:  RETLW  64
0216:  RETLW  61
0217:  RETLW  20
0218:  RETLW  34
0219:  RETLW  00
021A:  RETLW  4F
021B:  RETLW  66
021C:  RETLW  66
021D:  RETLW  20
021E:  RETLW  2D
021F:  RETLW  3E
0220:  RETLW  20
0221:  RETLW  53
0222:  RETLW  61
0223:  RETLW  6C
0224:  RETLW  69
0225:  RETLW  64
0226:  RETLW  61
0227:  RETLW  20
0228:  RETLW  35
0229:  RETLW  00
022A:  RETLW  4F
022B:  RETLW  66
022C:  RETLW  66
022D:  RETLW  20
022E:  RETLW  2D
022F:  RETLW  3E
0230:  RETLW  20
0231:  RETLW  53
0232:  RETLW  61
0233:  RETLW  6C
0234:  RETLW  69
0235:  RETLW  64
0236:  RETLW  61
0237:  RETLW  20
0238:  RETLW  36
0239:  RETLW  00
023A:  RETLW  4F
023B:  RETLW  66
023C:  RETLW  66
023D:  RETLW  20
023E:  RETLW  2D
023F:  RETLW  3E
0240:  RETLW  20
0241:  RETLW  53
0242:  RETLW  61
0243:  RETLW  6C
0244:  RETLW  69
0245:  RETLW  64
0246:  RETLW  61
0247:  RETLW  20
0248:  RETLW  37
0249:  RETLW  00
024A:  RETLW  4F
024B:  RETLW  66
024C:  RETLW  66
024D:  RETLW  20
024E:  RETLW  2D
024F:  RETLW  3E
0250:  RETLW  20
0251:  RETLW  53
0252:  RETLW  61
0253:  RETLW  6C
0254:  RETLW  69
0255:  RETLW  64
0256:  RETLW  61
0257:  RETLW  20
0258:  RETLW  38
0259:  RETLW  00
025A:  RETLW  53
025B:  RETLW  41
025C:  RETLW  4C
025D:  RETLW  49
025E:  RETLW  52
025F:  RETLW  20
0260:  RETLW  20
0261:  RETLW  20
0262:  RETLW  20
0263:  RETLW  20
0264:  RETLW  20
0265:  RETLW  20
0266:  RETLW  20
0267:  RETLW  20
0268:  RETLW  20
0269:  RETLW  00
026A:  RETLW  00
026B:  RETLW  00
026C:  RETLW  00
026D:  RETLW  00
026E:  RETLW  00
026F:  RETLW  00
0270:  RETLW  00
0271:  RETLW  00
0272:  RETLW  00
0273:  RETLW  00
0274:  RETLW  00
0275:  RETLW  00
0276:  RETLW  00
0277:  RETLW  00
0278:  RETLW  00
0279:  RETLW  00
027A:  RETLW  45
027B:  RETLW  53
027C:  RETLW  54
027D:  RETLW  41
027E:  RETLW  43
027F:  RETLW  49
0280:  RETLW  4F
0281:  RETLW  4E
0282:  RETLW  20
0283:  RETLW  49
0284:  RETLW  50
0285:  RETLW  20
0286:  RETLW  20
0287:  RETLW  20
0288:  RETLW  20
0289:  RETLW  20
028A:  RETLW  00
028B:  RETLW  45
028C:  RETLW  53
028D:  RETLW  54
028E:  RETLW  41
028F:  RETLW  43
0290:  RETLW  49
0291:  RETLW  4F
0292:  RETLW  4E
0293:  RETLW  20
0294:  RETLW  53
0295:  RETLW  53
0296:  RETLW  49
0297:  RETLW  44
0298:  RETLW  20
0299:  RETLW  20
029A:  RETLW  20
029B:  RETLW  00
029C:  RETLW  41
029D:  RETLW  50
029E:  RETLW  20
029F:  RETLW  53
02A0:  RETLW  53
02A1:  RETLW  49
02A2:  RETLW  44
02A3:  RETLW  20
02A4:  RETLW  20
02A5:  RETLW  20
02A6:  RETLW  20
02A7:  RETLW  20
02A8:  RETLW  20
02A9:  RETLW  20
02AA:  RETLW  20
02AB:  RETLW  20
02AC:  RETLW  00
02AD:  RETLW  41
02AE:  RETLW  50
02AF:  RETLW  20
02B0:  RETLW  4B
02B1:  RETLW  45
02B2:  RETLW  59
02B3:  RETLW  20
02B4:  RETLW  20
02B5:  RETLW  20
02B6:  RETLW  20
02B7:  RETLW  20
02B8:  RETLW  20
02B9:  RETLW  20
02BA:  RETLW  20
02BB:  RETLW  20
02BC:  RETLW  20
02BD:  RETLW  00
02BE:  RETLW  41
02BF:  RETLW  50
02C0:  RETLW  20
02C1:  RETLW  49
02C2:  RETLW  50
02C3:  RETLW  20
02C4:  RETLW  20
02C5:  RETLW  20
02C6:  RETLW  20
02C7:  RETLW  20
02C8:  RETLW  20
02C9:  RETLW  20
02CA:  RETLW  20
02CB:  RETLW  20
02CC:  RETLW  20
02CD:  RETLW  20
02CE:  RETLW  00
02CF:  RETLW  43
02D0:  RETLW  6F
02D1:  RETLW  6E
02D2:  RETLW  66
02D3:  RETLW  20
02D4:  RETLW  41
02D5:  RETLW  63
02D6:  RETLW  63
02D7:  RETLW  65
02D8:  RETLW  73
02D9:  RETLW  73
02DA:  RETLW  6F
02DB:  RETLW  20
02DC:  RETLW  52
02DD:  RETLW  65
02DE:  RETLW  64
02DF:  RETLW  00
02E0:  RETLW  4F
02E1:  RETLW  6E
02E2:  RETLW  2F
02E3:  RETLW  4F
02E4:  RETLW  66
02E5:  RETLW  66
02E6:  RETLW  20
02E7:  RETLW  42
02E8:  RETLW  61
02E9:  RETLW  63
02EA:  RETLW  6B
02EB:  RETLW  6C
02EC:  RETLW  69
02ED:  RETLW  67
02EE:  RETLW  68
02EF:  RETLW  74
02F0:  RETLW  00
02F1:  RETLW  53
02F2:  RETLW  41
02F3:  RETLW  4C
02F4:  RETLW  49
02F5:  RETLW  52
02F6:  RETLW  20
02F7:  RETLW  20
02F8:  RETLW  20
02F9:  RETLW  20
02FA:  RETLW  20
02FB:  RETLW  20
02FC:  RETLW  20
02FD:  RETLW  20
02FE:  RETLW  20
02FF:  RETLW  20
0300:  RETLW  20
0301:  RETLW  00
0302:  RETLW  00
0303:  RETLW  00
0304:  RETLW  00
0305:  RETLW  00
0306:  RETLW  00
0307:  RETLW  00
0308:  RETLW  00
0309:  RETLW  00
030A:  RETLW  00
030B:  RETLW  00
030C:  RETLW  00
030D:  RETLW  00
030E:  RETLW  00
030F:  RETLW  00
0310:  RETLW  00
0311:  RETLW  00
0312:  RETLW  00
0313:  RETLW  45
0314:  RETLW  73
0315:  RETLW  74
0316:  RETLW  61
0317:  RETLW  63
0318:  RETLW  69
0319:  RETLW  F3
031A:  RETLW  6E
031B:  RETLW  20
031C:  RETLW  20
031D:  RETLW  20
031E:  RETLW  20
031F:  RETLW  20
0320:  RETLW  00
0321:  RETLW  41
0322:  RETLW  63
0323:  RETLW  63
0324:  RETLW  65
0325:  RETLW  73
0326:  RETLW  73
0327:  RETLW  20
0328:  RETLW  50
0329:  RETLW  6F
032A:  RETLW  69
032B:  RETLW  6E
032C:  RETLW  74
032D:  RETLW  20
032E:  RETLW  00
032F:  RETLW  45
0330:  RETLW  73
0331:  RETLW  74
0332:  RETLW  61
0333:  RETLW  63
0334:  RETLW  69
0335:  RETLW  6F
0336:  RETLW  6E
0337:  RETLW  20
0338:  RETLW  2B
0339:  RETLW  20
033A:  RETLW  41
033B:  RETLW  50
033C:  RETLW  00
033D:  RETLW  53
033E:  RETLW  41
033F:  RETLW  4C
0340:  RETLW  49
0341:  RETLW  52
0342:  RETLW  20
0343:  RETLW  20
0344:  RETLW  20
0345:  RETLW  20
0346:  RETLW  20
0347:  RETLW  20
0348:  RETLW  20
0349:  RETLW  20
034A:  RETLW  00
034B:  RETLW  00
034C:  RETLW  00
034D:  RETLW  00
034E:  RETLW  00
034F:  RETLW  00
0350:  RETLW  00
0351:  RETLW  00
0352:  RETLW  00
0353:  RETLW  00
0354:  RETLW  00
0355:  RETLW  00
0356:  RETLW  00
0357:  RETLW  00
0358:  RETLW  00
0359:  DATA D3,20
035A:  DATA CC,24
035B:  DATA 52,00
035C:  DATA DB,29
035D:  DATA C9,23
035E:  DATA 5D,10
035F:  DATA 20,10
0360:  DATA 20,10
0361:  DATA A0,2D
0362:  DATA 45,27
0363:  DATA D4,2E
0364:  DATA 00,00
0365:  DATA 41,2A
0366:  DATA AB,21
0367:  DATA D7,26
0368:  DATA 4F,22
0369:  DATA C5,2F
036A:  DATA C4,22
036B:  DATA C6,1E
036C:  DATA B1,06
036D:  DATA 0A,00
036E:  DATA 8C,21
036F:  DATA 6F,37
0370:  DATA E6,34
0371:  DATA 67,10
0372:  DATA 43,36
0373:  DATA E9,32
0374:  DATA 6E,3A
0375:  DATA 65,00
0376:  DATA 41,2A
0377:  DATA AB,21
0378:  DATA D7,26
0379:  DATA 4F,22
037A:  DATA C5,2F
037B:  DATA C4,22
037C:  DATA C6,1E
037D:  DATA B2,06
037E:  DATA 0A,00
037F:  DATA 8C,21
0380:  DATA 6F,37
0381:  DATA E6,34
0382:  DATA 67,10
0383:  DATA 41,28
0384:  DATA 00,01
0385:  DATA 41,2A
0386:  DATA AB,21
0387:  DATA D7,26
0388:  DATA 4F,22
0389:  DATA C5,2F
038A:  DATA C4,22
038B:  DATA C6,1E
038C:  DATA B3,06
038D:  DATA 0A,00
038E:  DATA 8C,21
038F:  DATA 6F,37
0390:  DATA E6,34
0391:  DATA 67,10
0392:  DATA 43,36
0393:  DATA E9,32
0394:  DATA 6E,3A
0395:  DATA E5,20
0396:  DATA 50,00
0397:  CLRF   77
0398:  CLRF   78
0399:  BSF    03.5
039A:  BSF    03.6
039B:  MOVF   11,W
039C:  BCF    03.0
039D:  BTFSC  12.0
039E:  ADDWF  77,F
039F:  RRF    77,F
03A0:  RRF    78,F
03A1:  BTFSC  12.1
03A2:  ADDWF  77,F
03A3:  RRF    77,F
03A4:  RRF    78,F
03A5:  BTFSC  12.2
03A6:  ADDWF  77,F
03A7:  RRF    77,F
03A8:  RRF    78,F
03A9:  BTFSC  12.3
03AA:  ADDWF  77,F
03AB:  RRF    77,F
03AC:  RRF    78,F
03AD:  BTFSC  12.4
03AE:  ADDWF  77,F
03AF:  RRF    77,F
03B0:  RRF    78,F
03B1:  BTFSC  12.5
03B2:  ADDWF  77,F
03B3:  RRF    77,F
03B4:  RRF    78,F
03B5:  BTFSC  12.6
03B6:  ADDWF  77,F
03B7:  RRF    77,F
03B8:  RRF    78,F
03B9:  BTFSC  12.7
03BA:  ADDWF  77,F
03BB:  RRF    77,F
03BC:  RRF    78,F
03BD:  BCF    03.5
03BE:  BCF    03.6
03BF:  RETURN
*
04D5:  BCF    0A.0
04D6:  BCF    0A.1
04D7:  BSF    0A.2
04D8:  ADDWF  02,F
04D9:  GOTO   3CA
04DA:  GOTO   404
04DB:  GOTO   3E8
04DC:  GOTO   420
04DD:  GOTO   43C
*
05D5:  DATA 8C,21
05D6:  DATA 6F,37
05D7:  DATA E6,34
05D8:  DATA E7,3A
05D9:  DATA F2,30
05DA:  DATA 6E,32
05DB:  DATA 6F,17
05DC:  DATA 2E,17
05DD:  DATA 00,01
*
07BB:  MOVF   0B,W
07BC:  BSF    03.6
07BD:  MOVWF  45
07BE:  BCF    03.6
07BF:  BCF    0B.7
07C0:  BSF    03.5
07C1:  BSF    03.6
07C2:  BSF    0C.7
07C3:  BSF    0C.0
07C4:  NOP
07C5:  NOP
07C6:  BCF    03.5
07C7:  BTFSS  45.7
07C8:  GOTO   7CC
07C9:  BCF    03.6
07CA:  BSF    0B.7
07CB:  BSF    03.6
07CC:  MOVF   0C,F
07CD:  BTFSC  03.2
07CE:  GOTO   7E2
07CF:  MOVF   0D,W
07D0:  MOVWF  45
07D1:  MOVF   0F,W
07D2:  MOVWF  46
07D3:  MOVF   0C,W
07D4:  MOVWF  47
07D5:  BCF    03.6
07D6:  CALL   761
07D7:  BSF    03.6
07D8:  MOVF   45,W
07D9:  MOVWF  0D
07DA:  MOVF   46,W
07DB:  MOVWF  0F
07DC:  INCF   0D,F
07DD:  BTFSC  03.2
07DE:  INCF   0F,F
07DF:  BCF    03.6
07E0:  GOTO   7BB
07E1:  BSF    03.6
07E2:  BCF    03.6
07E3:  RETURN
*
0800:  MOVF   0B,W
0801:  BSF    03.6
0802:  MOVWF  44
0803:  BCF    03.6
0804:  BCF    0B.7
0805:  BSF    03.5
0806:  BSF    03.6
0807:  BSF    0C.7
0808:  BSF    0C.0
0809:  NOP
080A:  NOP
080B:  BCF    03.5
080C:  BTFSS  44.7
080D:  GOTO   011
080E:  BCF    03.6
080F:  BSF    0B.7
0810:  BSF    03.6
0811:  MOVF   0C,W
0812:  ANDLW  7F
0813:  BTFSC  03.2
0814:  GOTO   052
0815:  MOVWF  44
0816:  MOVF   0D,W
0817:  MOVWF  45
0818:  MOVF   0F,W
0819:  MOVWF  46
081A:  MOVF   44,W
081B:  MOVWF  47
081C:  BCF    0A.3
081D:  BCF    03.6
081E:  CALL   761
081F:  BSF    0A.3
0820:  BSF    03.6
0821:  MOVF   45,W
0822:  MOVWF  0D
0823:  MOVF   46,W
0824:  MOVWF  0F
0825:  BCF    03.6
0826:  MOVF   0B,W
0827:  BSF    03.6
0828:  MOVWF  47
0829:  BCF    03.6
082A:  BCF    0B.7
082B:  BSF    03.5
082C:  BSF    03.6
082D:  BSF    0C.7
082E:  BSF    0C.0
082F:  NOP
0830:  NOP
0831:  BCF    03.5
0832:  BTFSS  47.7
0833:  GOTO   037
0834:  BCF    03.6
0835:  BSF    0B.7
0836:  BSF    03.6
0837:  RLF    0C,W
0838:  RLF    0E,W
0839:  ANDLW  7F
083A:  BTFSC  03.2
083B:  GOTO   052
083C:  MOVWF  44
083D:  MOVF   0D,W
083E:  MOVWF  45
083F:  MOVF   0F,W
0840:  MOVWF  46
0841:  MOVF   44,W
0842:  MOVWF  47
0843:  BCF    0A.3
0844:  BCF    03.6
0845:  CALL   761
0846:  BSF    0A.3
0847:  BSF    03.6
0848:  MOVF   45,W
0849:  MOVWF  0D
084A:  MOVF   46,W
084B:  MOVWF  0F
084C:  INCF   0D,F
084D:  BTFSC  03.2
084E:  INCF   0F,F
084F:  BCF    03.6
0850:  GOTO   000
0851:  BSF    03.6
0852:  BCF    03.6
0853:  RETURN
0854:  MOVF   0B,W
0855:  BSF    03.6
0856:  MOVWF  56
0857:  BCF    03.6
0858:  BCF    0B.7
0859:  BSF    03.5
085A:  BSF    03.6
085B:  BSF    0C.7
085C:  BSF    0C.0
085D:  NOP
085E:  NOP
085F:  BCF    03.5
0860:  BTFSS  56.7
0861:  GOTO   065
0862:  BCF    03.6
0863:  BSF    0B.7
0864:  BSF    03.6
0865:  BTFSC  03.0
0866:  GOTO   08D
0867:  MOVF   0C,W
0868:  ANDLW  7F
0869:  MOVWF  56
086A:  MOVF   0D,W
086B:  MOVWF  57
086C:  MOVF   0F,W
086D:  MOVWF  58
086E:  MOVF   56,W
086F:  BCF    03.6
0870:  BTFSS  0C.4
0871:  GOTO   070
0872:  MOVWF  19
0873:  BSF    03.6
0874:  MOVF   57,W
0875:  MOVWF  0D
0876:  MOVF   58,W
0877:  MOVWF  0F
0878:  BCF    03.6
0879:  MOVF   0B,W
087A:  BSF    03.6
087B:  MOVWF  59
087C:  BCF    03.6
087D:  BCF    0B.7
087E:  BSF    03.5
087F:  BSF    03.6
0880:  BSF    0C.7
0881:  BSF    0C.0
0882:  NOP
0883:  NOP
0884:  BCF    03.5
0885:  BTFSS  59.7
0886:  GOTO   08A
0887:  BCF    03.6
0888:  BSF    0B.7
0889:  BSF    03.6
088A:  DECFSZ 55,F
088B:  GOTO   08D
088C:  GOTO   0A8
088D:  RLF    0C,W
088E:  RLF    0E,W
088F:  ANDLW  7F
0890:  MOVWF  56
0891:  MOVF   0D,W
0892:  MOVWF  57
0893:  MOVF   0F,W
0894:  MOVWF  58
0895:  MOVF   56,W
0896:  BCF    03.6
0897:  BTFSS  0C.4
0898:  GOTO   097
0899:  MOVWF  19
089A:  BSF    03.6
089B:  MOVF   57,W
089C:  MOVWF  0D
089D:  MOVF   58,W
089E:  MOVWF  0F
089F:  INCF   0D,F
08A0:  BTFSC  03.2
08A1:  INCF   0F,F
08A2:  BCF    03.0
08A3:  DECFSZ 55,F
08A4:  GOTO   0A6
08A5:  GOTO   0A8
08A6:  BCF    03.6
08A7:  GOTO   054
08A8:  BCF    03.6
08A9:  RETURN
08AA:  MOVF   0B,W
08AB:  BSF    03.6
08AC:  MOVWF  55
08AD:  BCF    03.6
08AE:  BCF    0B.7
08AF:  BSF    03.5
08B0:  BSF    03.6
08B1:  BSF    0C.7
08B2:  BSF    0C.0
08B3:  NOP
08B4:  NOP
08B5:  BCF    03.5
08B6:  BTFSS  55.7
08B7:  GOTO   0BB
08B8:  BCF    03.6
08B9:  BSF    0B.7
08BA:  BSF    03.6
08BB:  MOVF   0C,W
08BC:  ANDLW  7F
08BD:  BTFSC  03.2
08BE:  GOTO   0FA
08BF:  MOVWF  55
08C0:  MOVF   0D,W
08C1:  MOVWF  56
08C2:  MOVF   0F,W
08C3:  MOVWF  57
08C4:  MOVF   55,W
08C5:  BCF    03.6
08C6:  BTFSS  0C.4
08C7:  GOTO   0C6
08C8:  MOVWF  19
08C9:  BSF    03.6
08CA:  MOVF   56,W
08CB:  MOVWF  0D
08CC:  MOVF   57,W
08CD:  MOVWF  0F
08CE:  BCF    03.6
08CF:  MOVF   0B,W
08D0:  BSF    03.6
08D1:  MOVWF  58
08D2:  BCF    03.6
08D3:  BCF    0B.7
08D4:  BSF    03.5
08D5:  BSF    03.6
08D6:  BSF    0C.7
08D7:  BSF    0C.0
08D8:  NOP
08D9:  NOP
08DA:  BCF    03.5
08DB:  BTFSS  58.7
08DC:  GOTO   0E0
08DD:  BCF    03.6
08DE:  BSF    0B.7
08DF:  BSF    03.6
08E0:  RLF    0C,W
08E1:  RLF    0E,W
08E2:  ANDLW  7F
08E3:  BTFSC  03.2
08E4:  GOTO   0FA
08E5:  MOVWF  55
08E6:  MOVF   0D,W
08E7:  MOVWF  56
08E8:  MOVF   0F,W
08E9:  MOVWF  57
08EA:  MOVF   55,W
08EB:  BCF    03.6
08EC:  BTFSS  0C.4
08ED:  GOTO   0EC
08EE:  MOVWF  19
08EF:  BSF    03.6
08F0:  MOVF   56,W
08F1:  MOVWF  0D
08F2:  MOVF   57,W
08F3:  MOVWF  0F
08F4:  INCF   0D,F
08F5:  BTFSC  03.2
08F6:  INCF   0F,F
08F7:  BCF    03.6
08F8:  GOTO   0AA
08F9:  BSF    03.6
08FA:  BCF    03.6
08FB:  RETURN
*
0A60:  MOVF   00,F
0A61:  BTFSC  03.2
0A62:  GOTO   27D
0A63:  BSF    03.6
0A64:  CLRF   56
0A65:  MOVF   04,W
0A66:  MOVWF  55
0A67:  BCF    56.0
0A68:  BTFSC  03.7
0A69:  BSF    56.0
0A6A:  MOVF   00,W
0A6B:  BCF    03.6
0A6C:  BTFSS  0C.4
0A6D:  GOTO   26C
0A6E:  MOVWF  19
0A6F:  BSF    03.6
0A70:  MOVF   55,W
0A71:  MOVWF  04
0A72:  BCF    03.7
0A73:  BTFSC  56.0
0A74:  BSF    03.7
0A75:  INCF   04,F
0A76:  BTFSS  03.2
0A77:  GOTO   27B
0A78:  BCF    03.6
0A79:  INCF   05,F
0A7A:  BSF    03.6
0A7B:  BCF    03.6
0A7C:  GOTO   260
*
0AEE:  BSF    03.6
0AEF:  MOVF   57,W
0AF0:  ANDLW  07
0AF1:  MOVWF  77
0AF2:  RRF    57,W
0AF3:  MOVWF  78
0AF4:  RRF    78,F
0AF5:  RRF    78,F
0AF6:  MOVLW  1F
0AF7:  ANDWF  78,F
0AF8:  MOVF   78,W
0AF9:  ADDWF  59,W
0AFA:  MOVWF  04
0AFB:  BCF    03.7
0AFC:  BTFSC  5A.0
0AFD:  BSF    03.7
0AFE:  CLRF   78
0AFF:  INCF   78,F
0B00:  INCF   77,F
0B01:  GOTO   303
0B02:  RLF    78,F
0B03:  DECFSZ 77,F
0B04:  GOTO   302
0B05:  MOVF   58,F
0B06:  BTFSC  03.2
0B07:  GOTO   30B
0B08:  MOVF   78,W
0B09:  IORWF  00,F
0B0A:  GOTO   30E
0B0B:  COMF   78,F
0B0C:  MOVF   78,W
0B0D:  ANDWF  00,F
0B0E:  BCF    03.6
0B0F:  RETURN
*
0C2D:  MOVF   00,F
0C2E:  BTFSC  03.2
0C2F:  GOTO   44A
0C30:  BSF    03.6
0C31:  CLRF   56
0C32:  MOVF   04,W
0C33:  MOVWF  55
0C34:  BCF    56.0
0C35:  BTFSC  03.7
0C36:  BSF    56.0
0C37:  MOVF   00,W
0C38:  BCF    03.6
0C39:  BTFSS  0C.4
0C3A:  GOTO   439
0C3B:  MOVWF  19
0C3C:  BSF    03.6
0C3D:  MOVF   55,W
0C3E:  MOVWF  04
0C3F:  BCF    03.7
0C40:  BTFSC  56.0
0C41:  BSF    03.7
0C42:  INCF   04,F
0C43:  BTFSS  03.2
0C44:  GOTO   448
0C45:  BCF    03.6
0C46:  INCF   05,F
0C47:  BSF    03.6
0C48:  BCF    03.6
0C49:  GOTO   42D
*
0CD3:  MOVF   00,F
0CD4:  BTFSC  03.2
0CD5:  GOTO   4F0
0CD6:  BSF    03.6
0CD7:  CLRF   56
0CD8:  MOVF   04,W
0CD9:  MOVWF  55
0CDA:  BCF    56.0
0CDB:  BTFSC  03.7
0CDC:  BSF    56.0
0CDD:  MOVF   00,W
0CDE:  BCF    03.6
0CDF:  BTFSS  0C.4
0CE0:  GOTO   4DF
0CE1:  MOVWF  19
0CE2:  BSF    03.6
0CE3:  MOVF   55,W
0CE4:  MOVWF  04
0CE5:  BCF    03.7
0CE6:  BTFSC  56.0
0CE7:  BSF    03.7
0CE8:  INCF   04,F
0CE9:  BTFSS  03.2
0CEA:  GOTO   4EE
0CEB:  BCF    03.6
0CEC:  INCF   05,F
0CED:  BSF    03.6
0CEE:  BCF    03.6
0CEF:  GOTO   4D3
*
0D3C:  MOVF   00,F
0D3D:  BTFSC  03.2
0D3E:  GOTO   559
0D3F:  BSF    03.6
0D40:  CLRF   56
0D41:  MOVF   04,W
0D42:  MOVWF  55
0D43:  BCF    56.0
0D44:  BTFSC  03.7
0D45:  BSF    56.0
0D46:  MOVF   00,W
0D47:  BCF    03.6
0D48:  BTFSS  0C.4
0D49:  GOTO   548
0D4A:  MOVWF  19
0D4B:  BSF    03.6
0D4C:  MOVF   55,W
0D4D:  MOVWF  04
0D4E:  BCF    03.7
0D4F:  BTFSC  56.0
0D50:  BSF    03.7
0D51:  INCF   04,F
0D52:  BTFSS  03.2
0D53:  GOTO   557
0D54:  BCF    03.6
0D55:  INCF   05,F
0D56:  BSF    03.6
0D57:  BCF    03.6
0D58:  GOTO   53C
*
0DC2:  BTFSC  03.1
0DC3:  GOTO   5C7
0DC4:  MOVLW  5A
0DC5:  MOVWF  04
0DC6:  BSF    03.7
0DC7:  CLRF   77
0DC8:  CLRF   78
0DC9:  CLRF   79
0DCA:  CLRF   7A
0DCB:  CLRF   5A
0DCC:  CLRF   5B
0DCD:  CLRF   5C
0DCE:  CLRF   5D
0DCF:  MOVF   59,W
0DD0:  IORWF  58,W
0DD1:  IORWF  57,W
0DD2:  IORWF  56,W
0DD3:  BTFSC  03.2
0DD4:  GOTO   605
0DD5:  MOVLW  20
0DD6:  MOVWF  5E
0DD7:  BCF    03.0
0DD8:  RLF    52,F
0DD9:  RLF    53,F
0DDA:  RLF    54,F
0DDB:  RLF    55,F
0DDC:  RLF    5A,F
0DDD:  RLF    5B,F
0DDE:  RLF    5C,F
0DDF:  RLF    5D,F
0DE0:  MOVF   59,W
0DE1:  SUBWF  5D,W
0DE2:  BTFSS  03.2
0DE3:  GOTO   5EE
0DE4:  MOVF   58,W
0DE5:  SUBWF  5C,W
0DE6:  BTFSS  03.2
0DE7:  GOTO   5EE
0DE8:  MOVF   57,W
0DE9:  SUBWF  5B,W
0DEA:  BTFSS  03.2
0DEB:  GOTO   5EE
0DEC:  MOVF   56,W
0DED:  SUBWF  5A,W
0DEE:  BTFSS  03.0
0DEF:  GOTO   5FF
0DF0:  MOVF   56,W
0DF1:  SUBWF  5A,F
0DF2:  MOVF   57,W
0DF3:  BTFSS  03.0
0DF4:  INCFSZ 57,W
0DF5:  SUBWF  5B,F
0DF6:  MOVF   58,W
0DF7:  BTFSS  03.0
0DF8:  INCFSZ 58,W
0DF9:  SUBWF  5C,F
0DFA:  MOVF   59,W
0DFB:  BTFSS  03.0
0DFC:  INCFSZ 59,W
0DFD:  SUBWF  5D,F
0DFE:  BSF    03.0
0DFF:  RLF    77,F
0E00:  RLF    78,F
0E01:  RLF    79,F
0E02:  RLF    7A,F
0E03:  DECFSZ 5E,F
0E04:  GOTO   5D7
0E05:  MOVF   5A,W
0E06:  MOVWF  00
0E07:  INCF   04,F
0E08:  MOVF   5B,W
0E09:  MOVWF  00
0E0A:  INCF   04,F
0E0B:  MOVF   5C,W
0E0C:  MOVWF  00
0E0D:  INCF   04,F
0E0E:  MOVF   5D,W
0E0F:  MOVWF  00
*
0E25:  MOVLW  20
0E26:  MOVWF  5E
0E27:  CLRF   5A
0E28:  CLRF   5B
0E29:  CLRF   5C
0E2A:  CLRF   5D
0E2B:  MOVF   55,W
0E2C:  MOVWF  7A
0E2D:  MOVF   54,W
0E2E:  MOVWF  79
0E2F:  MOVF   53,W
0E30:  MOVWF  78
0E31:  MOVF   52,W
0E32:  MOVWF  77
0E33:  BCF    03.0
0E34:  BTFSS  77.0
0E35:  GOTO   644
0E36:  MOVF   56,W
0E37:  ADDWF  5A,F
0E38:  MOVF   57,W
0E39:  BTFSC  03.0
0E3A:  INCFSZ 57,W
0E3B:  ADDWF  5B,F
0E3C:  MOVF   58,W
0E3D:  BTFSC  03.0
0E3E:  INCFSZ 58,W
0E3F:  ADDWF  5C,F
0E40:  MOVF   59,W
0E41:  BTFSC  03.0
0E42:  INCFSZ 59,W
0E43:  ADDWF  5D,F
0E44:  RRF    5D,F
0E45:  RRF    5C,F
0E46:  RRF    5B,F
0E47:  RRF    5A,F
0E48:  RRF    7A,F
0E49:  RRF    79,F
0E4A:  RRF    78,F
0E4B:  RRF    77,F
0E4C:  DECFSZ 5E,F
0E4D:  GOTO   633
*
13F0:  BSF    0A.0
13F1:  BSF    0A.1
13F2:  BCF    0A.2
13F3:  ADDWF  02,F
13F4:  GOTO   0C6
13F5:  GOTO   163
13F6:  GOTO   242
13F7:  GOTO   304
....................  
.................... #list 
....................  
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20M) 
*
05DE:  MOVLW  56
05DF:  MOVWF  04
05E0:  BSF    03.7
05E1:  MOVF   00,W
05E2:  BTFSC  03.2
05E3:  GOTO   5F1
05E4:  MOVLW  06
05E5:  MOVWF  78
05E6:  CLRF   77
05E7:  DECFSZ 77,F
05E8:  GOTO   5E7
05E9:  DECFSZ 78,F
05EA:  GOTO   5E6
05EB:  MOVLW  7B
05EC:  MOVWF  77
05ED:  DECFSZ 77,F
05EE:  GOTO   5ED
05EF:  DECFSZ 00,F
05F0:  GOTO   5E4
05F1:  RETURN
*
0E68:  MOVLW  03
0E69:  SUBWF  53,F
0E6A:  BTFSS  03.0
0E6B:  GOTO   676
0E6C:  MOVLW  53
0E6D:  MOVWF  04
0E6E:  BSF    03.7
0E6F:  MOVF   00,W
0E70:  BTFSC  03.2
0E71:  GOTO   676
0E72:  GOTO   674
0E73:  GOTO   674
0E74:  DECFSZ 00,F
0E75:  GOTO   673
*
0E79:  MOVLW  03
0E7A:  SUBWF  53,F
0E7B:  BTFSS  03.0
0E7C:  GOTO   687
0E7D:  MOVLW  53
0E7E:  MOVWF  04
0E7F:  BSF    03.7
0E80:  MOVF   00,W
0E81:  BTFSC  03.2
0E82:  GOTO   687
0E83:  GOTO   685
0E84:  GOTO   685
0E85:  DECFSZ 00,F
0E86:  GOTO   684
*
0E9B:  MOVLW  03
0E9C:  SUBWF  53,F
0E9D:  BTFSS  03.0
0E9E:  GOTO   6A9
0E9F:  MOVLW  53
0EA0:  MOVWF  04
0EA1:  BSF    03.7
0EA2:  MOVF   00,W
0EA3:  BTFSC  03.2
0EA4:  GOTO   6A9
0EA5:  GOTO   6A7
0EA6:  GOTO   6A7
0EA7:  DECFSZ 00,F
0EA8:  GOTO   6A6
*
0EAC:  MOVLW  03
0EAD:  SUBWF  53,F
0EAE:  BTFSS  03.0
0EAF:  GOTO   6BA
0EB0:  MOVLW  53
0EB1:  MOVWF  04
0EB2:  BSF    03.7
0EB3:  MOVF   00,W
0EB4:  BTFSC  03.2
0EB5:  GOTO   6BA
0EB6:  GOTO   6B8
0EB7:  GOTO   6B8
0EB8:  DECFSZ 00,F
0EB9:  GOTO   6B7
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
*
106B:  MOVLW  4A
106C:  BCF    03.6
106D:  MOVWF  2C
106E:  CLRF   2D
106F:  MOVLW  49
1070:  MOVWF  2E
1071:  CLRF   2F
1072:  MOVLW  48
1073:  MOVWF  30
1074:  CLRF   31
1075:  MOVLW  2C
1076:  MOVWF  32
1077:  CLRF   33
1078:  MOVLW  28
1079:  MOVWF  34
107A:  CLRF   35
107B:  MOVLW  29
107C:  MOVWF  36
107D:  CLRF   37
107E:  MOVLW  2A
107F:  MOVWF  38
1080:  CLRF   39
1081:  MOVLW  2B
1082:  MOVWF  3A
1083:  CLRF   3B
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
1084:  CLRF   3C
1085:  CLRF   3D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
063A:  BSF    08.4
....................    output_float(LCD_DATA5); 
063B:  BSF    08.5
....................    output_float(LCD_DATA6); 
063C:  BSF    08.6
....................    output_float(LCD_DATA7); 
063D:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
063E:  BCF    03.5
063F:  BSF    08.1
0640:  BSF    03.5
0641:  BCF    08.1
....................    delay_cycles(1); 
0642:  NOP
....................    lcd_output_enable(1); 
0643:  BCF    03.5
0644:  BSF    08.0
0645:  BSF    03.5
0646:  BCF    08.0
....................    delay_cycles(1); 
0647:  NOP
....................    high = lcd_read_nibble(); 
*
0682:  MOVF   78,W
0683:  MOVWF  4F
....................        
....................    lcd_output_enable(0); 
0684:  BCF    03.6
0685:  BCF    08.0
0686:  BSF    03.5
0687:  BCF    08.0
....................    delay_cycles(1); 
0688:  NOP
....................    lcd_output_enable(1); 
0689:  BCF    03.5
068A:  BSF    08.0
068B:  BSF    03.5
068C:  BCF    08.0
....................    delay_us(1); 
068D:  GOTO   68E
068E:  GOTO   68F
068F:  NOP
....................    low = lcd_read_nibble(); 
*
06CA:  MOVF   78,W
06CB:  MOVWF  4E
....................        
....................    lcd_output_enable(0); 
06CC:  BCF    03.6
06CD:  BCF    08.0
06CE:  BSF    03.5
06CF:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
06D0:  BCF    08.4
....................    output_drive(LCD_DATA5); 
06D1:  BCF    08.5
....................    output_drive(LCD_DATA6); 
06D2:  BCF    08.6
....................    output_drive(LCD_DATA7); 
06D3:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
06D4:  BCF    03.5
06D5:  BSF    03.6
06D6:  SWAPF  4F,W
06D7:  MOVWF  77
06D8:  MOVLW  F0
06D9:  ANDWF  77,F
06DA:  MOVF   77,W
06DB:  IORWF  4E,W
06DC:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0648:  BCF    03.5
0649:  BSF    03.6
064A:  CLRF   50
*
0690:  BCF    03.5
0691:  BSF    03.6
0692:  CLRF   50
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
064B:  BSF    03.5
064C:  BCF    03.6
064D:  BSF    08.4
064E:  MOVLW  00
064F:  BCF    03.5
0650:  BTFSC  08.4
0651:  MOVLW  01
0652:  BSF    03.6
0653:  IORWF  50,F
*
0693:  BSF    03.5
0694:  BCF    03.6
0695:  BSF    08.4
0696:  MOVLW  00
0697:  BCF    03.5
0698:  BTFSC  08.4
0699:  MOVLW  01
069A:  BSF    03.6
069B:  IORWF  50,F
....................    n |= input(LCD_DATA5) << 1; 
*
0654:  BSF    03.5
0655:  BCF    03.6
0656:  BSF    08.5
0657:  MOVLW  00
0658:  BCF    03.5
0659:  BTFSC  08.5
065A:  MOVLW  01
065B:  MOVWF  77
065C:  BCF    03.0
065D:  RLF    77,F
065E:  MOVF   77,W
065F:  BSF    03.6
0660:  IORWF  50,F
*
069C:  BSF    03.5
069D:  BCF    03.6
069E:  BSF    08.5
069F:  MOVLW  00
06A0:  BCF    03.5
06A1:  BTFSC  08.5
06A2:  MOVLW  01
06A3:  MOVWF  77
06A4:  BCF    03.0
06A5:  RLF    77,F
06A6:  MOVF   77,W
06A7:  BSF    03.6
06A8:  IORWF  50,F
....................    n |= input(LCD_DATA6) << 2; 
*
0661:  BSF    03.5
0662:  BCF    03.6
0663:  BSF    08.6
0664:  MOVLW  00
0665:  BCF    03.5
0666:  BTFSC  08.6
0667:  MOVLW  01
0668:  MOVWF  77
0669:  RLF    77,F
066A:  RLF    77,F
066B:  MOVLW  FC
066C:  ANDWF  77,F
066D:  MOVF   77,W
066E:  BSF    03.6
066F:  IORWF  50,F
*
06A9:  BSF    03.5
06AA:  BCF    03.6
06AB:  BSF    08.6
06AC:  MOVLW  00
06AD:  BCF    03.5
06AE:  BTFSC  08.6
06AF:  MOVLW  01
06B0:  MOVWF  77
06B1:  RLF    77,F
06B2:  RLF    77,F
06B3:  MOVLW  FC
06B4:  ANDWF  77,F
06B5:  MOVF   77,W
06B6:  BSF    03.6
06B7:  IORWF  50,F
....................    n |= input(LCD_DATA7) << 3; 
*
0670:  BSF    03.5
0671:  BCF    03.6
0672:  BSF    08.7
0673:  MOVLW  00
0674:  BCF    03.5
0675:  BTFSC  08.7
0676:  MOVLW  01
0677:  MOVWF  77
0678:  RLF    77,F
0679:  RLF    77,F
067A:  RLF    77,F
067B:  MOVLW  F8
067C:  ANDWF  77,F
067D:  MOVF   77,W
067E:  BSF    03.6
067F:  IORWF  50,F
*
06B8:  BSF    03.5
06B9:  BCF    03.6
06BA:  BSF    08.7
06BB:  MOVLW  00
06BC:  BCF    03.5
06BD:  BTFSC  08.7
06BE:  MOVLW  01
06BF:  MOVWF  77
06C0:  RLF    77,F
06C1:  RLF    77,F
06C2:  RLF    77,F
06C3:  MOVLW  F8
06C4:  ANDWF  77,F
06C5:  MOVF   77,W
06C6:  BSF    03.6
06C7:  IORWF  50,F
....................     
....................    return(n); 
*
0680:  MOVF   50,W
0681:  MOVWF  78
*
06C8:  MOVF   50,W
06C9:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
05F2:  BSF    03.6
05F3:  BTFSC  4F.0
05F4:  GOTO   5F9
05F5:  BCF    03.6
05F6:  BCF    08.4
05F7:  GOTO   5FB
05F8:  BSF    03.6
05F9:  BCF    03.6
05FA:  BSF    08.4
05FB:  BSF    03.5
05FC:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
05FD:  BCF    03.5
05FE:  BSF    03.6
05FF:  BTFSC  4F.1
0600:  GOTO   605
0601:  BCF    03.6
0602:  BCF    08.5
0603:  GOTO   607
0604:  BSF    03.6
0605:  BCF    03.6
0606:  BSF    08.5
0607:  BSF    03.5
0608:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0609:  BCF    03.5
060A:  BSF    03.6
060B:  BTFSC  4F.2
060C:  GOTO   611
060D:  BCF    03.6
060E:  BCF    08.6
060F:  GOTO   613
0610:  BSF    03.6
0611:  BCF    03.6
0612:  BSF    08.6
0613:  BSF    03.5
0614:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0615:  BCF    03.5
0616:  BSF    03.6
0617:  BTFSC  4F.3
0618:  GOTO   61D
0619:  BCF    03.6
061A:  BCF    08.7
061B:  GOTO   61F
061C:  BSF    03.6
061D:  BCF    03.6
061E:  BSF    08.7
061F:  BSF    03.5
0620:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0621:  NOP
....................    lcd_output_enable(1); 
0622:  BCF    03.5
0623:  BSF    08.0
0624:  BSF    03.5
0625:  BCF    08.0
....................    delay_us(2); 
0626:  MOVLW  02
0627:  MOVWF  77
0628:  DECFSZ 77,F
0629:  GOTO   628
062A:  GOTO   62B
062B:  NOP
....................    lcd_output_enable(0); 
062C:  BCF    03.5
062D:  BCF    08.0
062E:  BSF    03.5
062F:  BCF    08.0
0630:  BCF    03.5
0631:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
0632:  BSF    03.5
0633:  BCF    08.0
....................    lcd_rs_tris(); 
0634:  BCF    08.2
....................    lcd_rw_tris(); 
0635:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0636:  BCF    03.5
0637:  BCF    08.2
0638:  BSF    03.5
0639:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
06DD:  MOVF   78,W
06DE:  MOVWF  4E
06DF:  BTFSS  4E.7
06E0:  GOTO   6E4
06E1:  BSF    03.5
06E2:  BCF    03.6
06E3:  GOTO   63A
....................    lcd_output_rs(address); 
06E4:  MOVF   4C,F
06E5:  BTFSS  03.2
06E6:  GOTO   6EB
06E7:  BCF    03.6
06E8:  BCF    08.2
06E9:  GOTO   6ED
06EA:  BSF    03.6
06EB:  BCF    03.6
06EC:  BSF    08.2
06ED:  BSF    03.5
06EE:  BCF    08.2
....................    delay_cycles(1); 
06EF:  NOP
....................    lcd_output_rw(0); 
06F0:  BCF    03.5
06F1:  BCF    08.1
06F2:  BSF    03.5
06F3:  BCF    08.1
....................    delay_cycles(1); 
06F4:  NOP
....................    lcd_output_enable(0); 
06F5:  BCF    03.5
06F6:  BCF    08.0
06F7:  BSF    03.5
06F8:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
06F9:  BCF    03.5
06FA:  BSF    03.6
06FB:  SWAPF  4D,W
06FC:  MOVWF  4E
06FD:  MOVLW  0F
06FE:  ANDWF  4E,F
06FF:  MOVF   4E,W
0700:  MOVWF  4F
0701:  BCF    03.6
0702:  CALL   5F2
....................    lcd_send_nibble(n & 0xf); 
0703:  BSF    03.6
0704:  MOVF   4D,W
0705:  ANDLW  0F
0706:  MOVWF  4E
0707:  MOVWF  4F
0708:  BCF    03.6
0709:  CALL   5F2
070A:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
070B:  MOVLW  28
070C:  BSF    03.6
070D:  MOVWF  43
070E:  MOVLW  0C
070F:  MOVWF  44
0710:  MOVLW  01
0711:  MOVWF  45
0712:  MOVLW  06
0713:  MOVWF  46
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0714:  BCF    03.6
0715:  BCF    08.0
0716:  BSF    03.5
0717:  BCF    08.0
....................    lcd_output_rs(0); 
0718:  BCF    03.5
0719:  BCF    08.2
071A:  BSF    03.5
071B:  BCF    08.2
....................    lcd_output_rw(0); 
071C:  BCF    03.5
071D:  BCF    08.1
071E:  BSF    03.5
071F:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0720:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0721:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0722:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0723:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0724:  BCF    08.0
....................    lcd_rs_tris(); 
0725:  BCF    08.2
....................    lcd_rw_tris(); 
0726:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
0727:  MOVLW  0F
0728:  BCF    03.5
0729:  BSF    03.6
072A:  MOVWF  56
072B:  BCF    03.6
072C:  CALL   5DE
....................    for(i=1;i<=3;++i) 
072D:  MOVLW  01
072E:  BSF    03.6
072F:  MOVWF  42
0730:  MOVF   42,W
0731:  SUBLW  03
0732:  BTFSS  03.0
0733:  GOTO   740
....................    { 
....................        lcd_send_nibble(3); 
0734:  MOVLW  03
0735:  MOVWF  4F
0736:  BCF    03.6
0737:  CALL   5F2
....................        delay_ms(5); 
0738:  MOVLW  05
0739:  BSF    03.6
073A:  MOVWF  56
073B:  BCF    03.6
073C:  CALL   5DE
073D:  BSF    03.6
073E:  INCF   42,F
073F:  GOTO   730
....................    } 
....................     
....................    lcd_send_nibble(2); 
0740:  MOVLW  02
0741:  MOVWF  4F
0742:  BCF    03.6
0743:  CALL   5F2
....................    delay_ms(5); 
0744:  MOVLW  05
0745:  BSF    03.6
0746:  MOVWF  56
0747:  BCF    03.6
0748:  CALL   5DE
....................    for(i=0;i<=3;++i) 
0749:  BSF    03.6
074A:  CLRF   42
074B:  MOVF   42,W
074C:  SUBLW  03
074D:  BTFSS  03.0
074E:  GOTO   75D
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
074F:  MOVLW  43
0750:  ADDWF  42,W
0751:  MOVWF  04
0752:  BSF    03.7
0753:  MOVF   00,W
0754:  MOVWF  47
0755:  CLRF   4C
0756:  MOVF   47,W
0757:  MOVWF  4D
0758:  BCF    03.6
0759:  CALL   632
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
075A:  BSF    03.6
075B:  INCF   42,F
075C:  GOTO   74B
075D:  BCF    03.6
075E:  BCF    0A.3
075F:  BSF    0A.4
0760:  GOTO   0AB (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0775:  DECFSZ 49,W
0776:  GOTO   778
0777:  GOTO   77B
*
0799:  DECFSZ 49,W
079A:  GOTO   79C
079B:  GOTO   79F
*
0AD2:  DECFSZ 49,W
0AD3:  GOTO   2D5
0AD4:  GOTO   2D8
....................       address=LCD_LINE_TWO; 
*
0778:  MOVLW  40
0779:  MOVWF  4A
077A:  GOTO   77C
*
079C:  MOVLW  40
079D:  MOVWF  4A
079E:  GOTO   7A0
*
0AD5:  MOVLW  40
0AD6:  MOVWF  4A
0AD7:  GOTO   2D9
....................    else 
....................       address=0; 
*
077B:  CLRF   4A
*
079F:  CLRF   4A
*
0AD8:  CLRF   4A
....................       
....................    address+=x-1; 
*
077C:  MOVLW  01
077D:  SUBWF  48,W
077E:  ADDWF  4A,F
*
07A0:  MOVLW  01
07A1:  SUBWF  48,W
07A2:  ADDWF  4A,F
*
0AD9:  MOVLW  01
0ADA:  SUBWF  48,W
0ADB:  ADDWF  4A,F
....................    lcd_send_byte(0,0x80|address); 
*
077F:  MOVF   4A,W
0780:  IORLW  80
0781:  MOVWF  4B
0782:  CLRF   4C
0783:  MOVF   4B,W
0784:  MOVWF  4D
0785:  BCF    03.6
0786:  CALL   632
*
07A3:  MOVF   4A,W
07A4:  IORLW  80
07A5:  MOVWF  4B
07A6:  CLRF   4C
07A7:  MOVF   4B,W
07A8:  MOVWF  4D
07A9:  BCF    03.6
07AA:  CALL   632
*
0ADC:  MOVF   4A,W
0ADD:  IORLW  80
0ADE:  MOVWF  4B
0ADF:  CLRF   4C
0AE0:  MOVF   4B,W
0AE1:  MOVWF  4D
0AE2:  BCF    0A.3
0AE3:  BCF    03.6
0AE4:  CALL   632
0AE5:  BSF    0A.3
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
0761:  BSF    03.6
0762:  MOVF   47,W
0763:  XORLW  07
0764:  BCF    03.6
0765:  BTFSC  03.2
0766:  GOTO   771
0767:  XORLW  0B
0768:  BTFSC  03.2
0769:  GOTO   788
076A:  XORLW  06
076B:  BTFSC  03.2
076C:  GOTO   794
076D:  XORLW  02
076E:  BTFSC  03.2
076F:  GOTO   7AC
0770:  GOTO   7B3
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0771:  MOVLW  01
0772:  BSF    03.6
0773:  MOVWF  48
0774:  MOVWF  49
*
0787:  GOTO   7BA
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0788:  BSF    03.6
0789:  CLRF   4C
078A:  MOVLW  01
078B:  MOVWF  4D
078C:  BCF    03.6
078D:  CALL   632
....................                      delay_ms(2); 
078E:  MOVLW  02
078F:  BSF    03.6
0790:  MOVWF  56
0791:  BCF    03.6
0792:  CALL   5DE
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0793:  GOTO   7BA
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0794:  MOVLW  01
0795:  BSF    03.6
0796:  MOVWF  48
0797:  MOVLW  02
0798:  MOVWF  49
*
07AB:  GOTO   7BA
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
07AC:  BSF    03.6
07AD:  CLRF   4C
07AE:  MOVLW  10
07AF:  MOVWF  4D
07B0:  BCF    03.6
07B1:  CALL   632
07B2:  GOTO   7BA
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
07B3:  MOVLW  01
07B4:  BSF    03.6
07B5:  MOVWF  4C
07B6:  MOVF   47,W
07B7:  MOVWF  4D
07B8:  BCF    03.6
07B9:  CALL   632
....................      #endif 
....................    } 
07BA:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
0D96:  BSF    03.6
0D97:  CLRF   49
0D98:  CLRF   48
0D99:  CLRF   4B
0D9A:  CLRF   4A
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
0D9B:  MOVF   45,F
0D9C:  BTFSS  03.2
0D9D:  GOTO   5A2
0D9E:  MOVF   44,W
0D9F:  SUBLW  13
0DA0:  BTFSC  03.0
0DA1:  GOTO   6E7
0DA2:  MOVF   45,W
0DA3:  SUBLW  4E
0DA4:  BTFSS  03.0
0DA5:  GOTO   6E7
0DA6:  BTFSS  03.2
0DA7:  GOTO   5AC
0DA8:  MOVF   44,W
0DA9:  SUBLW  20
0DAA:  BTFSS  03.0
0DAB:  GOTO   6E7
....................       tmp=100000; 
0DAC:  CLRF   51
0DAD:  MOVLW  01
0DAE:  MOVWF  50
0DAF:  MOVLW  86
0DB0:  MOVWF  4F
0DB1:  MOVLW  A0
0DB2:  MOVWF  4E
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
0DB3:  BCF    03.1
0DB4:  MOVF   51,W
0DB5:  MOVWF  55
0DB6:  MOVF   50,W
0DB7:  MOVWF  54
0DB8:  MOVF   4F,W
0DB9:  MOVWF  53
0DBA:  MOVF   4E,W
0DBB:  MOVWF  52
0DBC:  CLRF   59
0DBD:  CLRF   58
0DBE:  MOVF   45,W
0DBF:  MOVWF  57
0DC0:  MOVF   44,W
0DC1:  MOVWF  56
*
0E10:  MOVF   7A,W
0E11:  MOVWF  51
0E12:  MOVF   79,W
0E13:  MOVWF  50
0E14:  MOVF   78,W
0E15:  MOVWF  4F
0E16:  MOVF   77,W
0E17:  MOVWF  4E
....................       tmp*=5;    
0E18:  MOVF   51,W
0E19:  MOVWF  55
0E1A:  MOVF   50,W
0E1B:  MOVWF  54
0E1C:  MOVF   4F,W
0E1D:  MOVWF  53
0E1E:  MOVF   4E,W
0E1F:  MOVWF  52
0E20:  CLRF   59
0E21:  CLRF   58
0E22:  CLRF   57
0E23:  MOVLW  05
0E24:  MOVWF  56
*
0E4E:  MOVF   7A,W
0E4F:  MOVWF  51
0E50:  MOVF   79,W
0E51:  MOVWF  50
0E52:  MOVF   78,W
0E53:  MOVWF  4F
0E54:  MOVF   77,W
0E55:  MOVWF  4E
....................       uS=tmp; 
0E56:  MOVF   4F,W
0E57:  MOVWF  4D
0E58:  MOVF   4E,W
0E59:  MOVWF  4C
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
0E5A:  BSF    03.5
0E5B:  BCF    03.6
0E5C:  BCF    06.2
0E5D:  BCF    03.5
0E5E:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0E5F:  BSF    03.6
0E60:  MOVF   4D,W
0E61:  MOVWF  52
0E62:  INCF   52,F
0E63:  DECF   52,F
0E64:  BTFSC  03.2
0E65:  GOTO   677
0E66:  MOVLW  FF
0E67:  MOVWF  53
*
0E76:  GOTO   663
0E77:  MOVF   4C,W
0E78:  MOVWF  53
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
0E87:  MOVF   4C,W
0E88:  ADDWF  4A,F
0E89:  MOVF   4D,W
0E8A:  BTFSC  03.0
0E8B:  INCFSZ 4D,W
0E8C:  ADDWF  4B,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0E8D:  BSF    03.5
0E8E:  BCF    03.6
0E8F:  BCF    06.2
0E90:  BCF    03.5
0E91:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
0E92:  BSF    03.6
0E93:  MOVF   4D,W
0E94:  MOVWF  52
0E95:  INCF   52,F
0E96:  DECF   52,F
0E97:  BTFSC  03.2
0E98:  GOTO   6AA
0E99:  MOVLW  FF
0E9A:  MOVWF  53
*
0EA9:  GOTO   696
0EAA:  MOVF   4C,W
0EAB:  MOVWF  53
....................          CiclosL+=(uS);          //  
*
0EBA:  MOVF   4C,W
0EBB:  ADDWF  4A,F
0EBC:  MOVF   4D,W
0EBD:  BTFSC  03.0
0EBE:  INCFSZ 4D,W
0EBF:  ADDWF  4B,F
....................          CiclosL+=25;            // Compensador. 
0EC0:  MOVLW  19
0EC1:  ADDWF  4A,F
0EC2:  BTFSC  03.0
0EC3:  INCF   4B,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
0EC4:  MOVF   4B,W
0EC5:  SUBLW  02
0EC6:  BTFSC  03.0
0EC7:  GOTO   6DD
0EC8:  XORLW  FF
0EC9:  BTFSS  03.2
0ECA:  GOTO   6CF
0ECB:  MOVF   4A,W
0ECC:  SUBLW  E7
0ECD:  BTFSC  03.0
0ECE:  GOTO   6DD
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0ECF:  MOVLW  E8
0ED0:  SUBWF  4A,F
0ED1:  MOVLW  03
0ED2:  BTFSS  03.0
0ED3:  MOVLW  04
0ED4:  SUBWF  4B,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0ED5:  INCF   48,F
0ED6:  BTFSC  03.2
0ED7:  INCF   49,F
....................             CiclosL+=25;         // Compensador. 
0ED8:  MOVLW  19
0ED9:  ADDWF  4A,F
0EDA:  BTFSC  03.0
0EDB:  INCF   4B,F
0EDC:  GOTO   6C4
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
0EDD:  MOVF   49,W
0EDE:  SUBWF  47,W
0EDF:  BTFSS  03.0
0EE0:  GOTO   6E7
0EE1:  BTFSS  03.2
0EE2:  GOTO   65A
0EE3:  MOVF   46,W
0EE4:  SUBWF  48,W
0EE5:  BTFSS  03.0
0EE6:  GOTO   65A
....................                                          // tiempo indicado. 
....................    } 
0EE7:  BCF    03.6
0EE8:  RETURN
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /***************************************************************** 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... ****************************************************************** 
....................  
.................... ******************************************** 
.................... *   Formato de comando en la respuesta:    * 
.................... *   INICIO:COMANDO:DATOS:<-(FIN)           * 
.................... *   e.g. CMD:CMD_SSID_AND_PASS,DATA:       * 
.................... ******************************************** 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:OP,[op][port]:                 | 
.................... |-----------------------------------------------| 
.................... |> Realiaza Operaciones en el Puerto de Salida  | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,[1|0][0-7]:                       | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      op:    1   -> Encender                   | 
.................... |             0   -> Apagar                     | 
.................... |      port:  0-7 -> No. del puerto.            | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,10:  Enciende el PORT 0        | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NC,"SSID","KEY":               | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el SSID y Key de la    | 
.................... |  Red donde se conectara.                      | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NC,"SSID","KEY":                     | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      SSID:  "Nombre de la Red."               | 
.................... |                                               | 
.................... |      KEY:   "Clave."                          | 
.................... |                                               | 
.................... |** @e.g. CMD:NC,"myRed","12345678":            | 
.................... | Intentara conectarse y almacenar en la eeprom | 
.................... | al nombre de la red con key pasados como      | 
.................... | parametro.                                    | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NM,[ModeConection]:            | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el modo de la conexion | 
.................... |                                               | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NM,[1|2|3]:                          | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      ModeConection:  "1" -> STA               | 
.................... |                      "2" -> AP                | 
.................... |                      "3" -> STA/AP            | 
.................... |                                               | 
.................... |** @e.g. CMD:NM,3:                             | 
.................... |                                               | 
.................... +-----------------------------------------------+ 
.................... */ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio recepcion de request,  
.................... y retorna el ID de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
0529:  MOVLW  05
052A:  MOVWF  64
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
052B:  BCF    03.6
052C:  DECFSZ 49,W
052D:  GOTO   546
....................        
....................       if(buffer!=','){ 
052E:  BSF    03.6
052F:  MOVF   62,W
0530:  SUBLW  2C
0531:  BTFSS  03.2
0532:  GOTO   536
0533:  MOVF   63,F
0534:  BTFSC  03.2
0535:  GOTO   542
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
0536:  MOVLW  42
0537:  BCF    03.6
0538:  ADDWF  4D,W
0539:  MOVWF  04
053A:  BCF    03.7
053B:  BSF    03.6
053C:  MOVF   62,W
053D:  MOVWF  00
....................          flag_Pos_Resp_IPD++; 
053E:  BCF    03.6
053F:  INCF   4D,F
....................       }else{ 
0540:  GOTO   545
0541:  BSF    03.6
....................          flag_Pos_Resp_IPD       = 0x00; 
0542:  BCF    03.6
0543:  CLRF   4D
....................          flag_Resp_IPD           = 0x00; 
0544:  CLRF   49
....................       } 
....................    }else{ 
0545:  GOTO   55F
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
0546:  MOVF   4D,W
0547:  CALL   051
0548:  MOVWF  78
0549:  BSF    03.6
054A:  SUBWF  62,W
054B:  BTFSS  03.2
054C:  GOTO   55D
054D:  MOVF   63,F
054E:  BTFSS  03.2
054F:  GOTO   55D
....................       { 
....................          flag_Pos_Resp_IPD++; 
0550:  BCF    03.6
0551:  INCF   4D,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
0552:  BSF    03.6
0553:  MOVF   64,W
0554:  BCF    03.6
0555:  SUBWF  4D,W
0556:  BTFSS  03.2
0557:  GOTO   55B
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
0558:  MOVLW  01
0559:  MOVWF  49
....................             flag_Pos_Resp_IPD = 0; 
055A:  CLRF   4D
....................          } 
....................       }else{ 
055B:  GOTO   55F
055C:  BSF    03.6
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
055D:  BCF    03.6
055E:  CLRF   4D
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio comando,  
.................... y retorna el Comando enviado, Activa la bandera 
.................... de recepcion de datos 
.................... *********************************************************/ 
....................  
.................... void ESP8266_Get_CMD(char buffer[]){ 
*
0563:  MOVLW  04
0564:  MOVWF  63
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
0565:  BCF    03.6
0566:  DECFSZ 48,W
0567:  GOTO   582
....................     
....................       if(buffer!=','){ 
0568:  BSF    03.6
0569:  MOVF   61,W
056A:  SUBLW  2C
056B:  BTFSS  03.2
056C:  GOTO   570
056D:  MOVF   62,F
056E:  BTFSC  03.2
056F:  GOTO   57C
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
0570:  MOVLW  44
0571:  BCF    03.6
0572:  ADDWF  4C,W
0573:  MOVWF  04
0574:  BCF    03.7
0575:  BSF    03.6
0576:  MOVF   61,W
0577:  MOVWF  00
....................          flag_Pos_Resp_CMD++; 
0578:  BCF    03.6
0579:  INCF   4C,F
....................       }else{         
057A:  GOTO   581
057B:  BSF    03.6
....................          flag_Pos_Resp_CMD = 0x00; 
057C:  BCF    03.6
057D:  CLRF   4C
....................          flag_Resp_CMD     = 0x00; 
057E:  CLRF   48
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
057F:  MOVLW  01
0580:  MOVWF  4A
....................       } 
....................        
....................    }else{ 
0581:  GOTO   59B
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
0582:  MOVF   4C,W
0583:  CALL   05A
0584:  MOVWF  78
0585:  BSF    03.6
0586:  SUBWF  61,W
0587:  BTFSS  03.2
0588:  GOTO   599
0589:  MOVF   62,F
058A:  BTFSS  03.2
058B:  GOTO   599
....................       { 
....................          flag_Pos_Resp_CMD++; 
058C:  BCF    03.6
058D:  INCF   4C,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
058E:  BSF    03.6
058F:  MOVF   63,W
0590:  BCF    03.6
0591:  SUBWF  4C,W
0592:  BTFSS  03.2
0593:  GOTO   597
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
0594:  MOVLW  01
0595:  MOVWF  48
....................             flag_Pos_Resp_CMD = 0; 
0596:  CLRF   4C
....................          } 
....................       }else{ 
0597:  GOTO   59B
0598:  BSF    03.6
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
0599:  BCF    03.6
059A:  CLRF   4C
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion Verifica si la bandera de recepcion de datos esta 
.................... activa y almacena los datos entrantes en el arreglo 
.................... DATA_COMMAND, Finaliza la captura de caracteres cuando 
.................... encuentra el caracter ":". 
.................... Envia al ESP8266 el fin de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
*
059F:  BCF    03.6
05A0:  DECFSZ 4A,W
05A1:  GOTO   5D0
....................       if(buffer!=':'){ 
05A2:  BSF    03.6
05A3:  MOVF   61,W
05A4:  SUBLW  3A
05A5:  BTFSS  03.2
05A6:  GOTO   5AA
05A7:  MOVF   62,F
05A8:  BTFSC  03.2
05A9:  GOTO   5CB
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
05AA:  MOVLW  A0
05AB:  BCF    03.6
05AC:  ADDWF  4E,W
05AD:  MOVWF  04
05AE:  BCF    03.7
05AF:  BSF    03.6
05B0:  MOVF   61,W
05B1:  MOVWF  00
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
05B2:  BCF    03.6
05B3:  CLRF   47
05B4:  MOVF   4E,W
05B5:  MOVWF  46
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
05B6:  MOVF   4E,F
05B7:  BTFSS  03.2
05B8:  GOTO   5C8
05B9:  BSF    03.6
05BA:  MOVF   61,W
05BB:  SUBLW  2C
05BC:  BTFSC  03.2
05BD:  GOTO   5C0
05BE:  BCF    03.6
05BF:  GOTO   5C8
05C0:  MOVF   62,F
05C1:  BTFSC  03.2
05C2:  GOTO   5C5
05C3:  BCF    03.6
05C4:  GOTO   5C8
....................             flag_Pos_Resp_Data=0; 
05C5:  BCF    03.6
05C6:  CLRF   4E
....................          }else{ 
05C7:  GOTO   5C9
....................             flag_Pos_Resp_Data++; 
05C8:  INCF   4E,F
....................          } 
....................           
....................       }else{ 
05C9:  GOTO   5D0
05CA:  BSF    03.6
....................          flag_Pos_Resp_Data      = 0x00; 
05CB:  BCF    03.6
05CC:  CLRF   4E
....................          flag_Resp_StartGetData  = 0x00; 
05CD:  CLRF   4A
....................          flag_Resp_Ready         = 1; 
05CE:  MOVLW  01
05CF:  MOVWF  4B
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
.................... } 
....................  
.................... int run_command_wifi(void){ 
*
0B10:  BSF    03.6
0B11:  CLRF   44
0B12:  CLRF   45
....................    int8 ret = 0, optSelected = 0; 
....................    char ESP8266_Resp[13] = {'{','"','c','m','d','"',':','"','o','k','"','}'}; 
0B13:  MOVLW  7B
0B14:  MOVWF  46
0B15:  MOVLW  22
0B16:  MOVWF  47
0B17:  MOVLW  63
0B18:  MOVWF  48
0B19:  MOVLW  6D
0B1A:  MOVWF  49
0B1B:  MOVLW  64
0B1C:  MOVWF  4A
0B1D:  MOVLW  22
0B1E:  MOVWF  4B
0B1F:  MOVLW  3A
0B20:  MOVWF  4C
0B21:  MOVLW  22
0B22:  MOVWF  4D
0B23:  MOVLW  6F
0B24:  MOVWF  4E
0B25:  MOVLW  6B
0B26:  MOVWF  4F
0B27:  MOVLW  22
0B28:  MOVWF  50
0B29:  MOVLW  7D
0B2A:  MOVWF  51
0B2B:  CLRF   52
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
0B2C:  BCF    03.6
0B2D:  DECFSZ 4B,W
0B2E:  GOTO   591
....................        
....................       /************************** 
....................       *** Accede a las Salidas ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
0B2F:  MOVF   44,W
0B30:  SUBLW  4F
0B31:  BTFSS  03.2
0B32:  GOTO   384
0B33:  MOVF   45,W
0B34:  SUBLW  50
0B35:  BTFSS  03.2
0B36:  GOTO   384
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
0B37:  MOVLW  30
0B38:  BSF    03.5
0B39:  SUBWF  21,W
0B3A:  BCF    03.5
0B3B:  BSF    03.6
0B3C:  MOVWF  45
....................           
....................          switch(DATA_COMMAND[0]){ 
0B3D:  BSF    03.5
0B3E:  BCF    03.6
0B3F:  MOVF   20,W
0B40:  XORLW  30
0B41:  BCF    03.5
0B42:  BTFSC  03.2
0B43:  GOTO   348
0B44:  XORLW  01
0B45:  BTFSC  03.2
0B46:  GOTO   364
0B47:  GOTO   380
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
0B48:  BCF    03.0
0B49:  BSF    03.6
0B4A:  RLF    45,W
0B4B:  ADDLW  2C
0B4C:  MOVWF  04
0B4D:  BCF    03.7
0B4E:  INCF   04,F
0B4F:  MOVF   00,W
0B50:  MOVWF  56
0B51:  DECF   04,F
0B52:  MOVF   00,W
0B53:  MOVWF  55
0B54:  MOVWF  57
0B55:  CLRF   58
0B56:  CLRF   5A
0B57:  CLRF   59
0B58:  BCF    03.6
0B59:  CALL   2EE
0B5A:  BSF    03.6
0B5B:  MOVF   55,W
0B5C:  MOVWF  57
0B5D:  CLRF   58
0B5E:  CLRF   5A
0B5F:  MOVLW  80
0B60:  MOVWF  59
0B61:  BCF    03.6
0B62:  CALL   2EE
....................                break; 
0B63:  GOTO   380
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
0B64:  BCF    03.0
0B65:  BSF    03.6
0B66:  RLF    45,W
0B67:  ADDLW  2C
0B68:  MOVWF  04
0B69:  BCF    03.7
0B6A:  INCF   04,F
0B6B:  MOVF   00,W
0B6C:  MOVWF  56
0B6D:  DECF   04,F
0B6E:  MOVF   00,W
0B6F:  MOVWF  55
0B70:  MOVWF  57
0B71:  MOVLW  01
0B72:  MOVWF  58
0B73:  CLRF   5A
0B74:  CLRF   59
0B75:  BCF    03.6
0B76:  CALL   2EE
0B77:  BSF    03.6
0B78:  MOVF   55,W
0B79:  MOVWF  57
0B7A:  CLRF   58
0B7B:  CLRF   5A
0B7C:  MOVLW  80
0B7D:  MOVWF  59
0B7E:  BCF    03.6
0B7F:  CALL   2EE
....................                break; 
....................          } 
....................           
....................          ret = 1; 
0B80:  MOVLW  01
0B81:  BSF    03.6
0B82:  MOVWF  44
0B83:  BCF    03.6
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
0B84:  MOVF   44,W
0B85:  SUBLW  4E
0B86:  BTFSS  03.2
0B87:  GOTO   481
0B88:  MOVF   45,W
0B89:  SUBLW  43
0B8A:  BTFSS  03.2
0B8B:  GOTO   481
....................       { 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
0B8C:  BSF    03.6
0B8D:  CLRF   53
0B8E:  BCF    03.6
0B8F:  MOVF   47,F
0B90:  BTFSS  03.2
0B91:  GOTO   398
0B92:  BSF    03.6
0B93:  MOVF   53,W
0B94:  BCF    03.6
0B95:  SUBWF  46,W
0B96:  BTFSS  03.0
0B97:  GOTO   3C5
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
0B98:  MOVLW  01
0B99:  BSF    03.6
0B9A:  ADDWF  53,W
0B9B:  MOVWF  55
0B9C:  MOVLW  A0
0B9D:  ADDWF  53,W
0B9E:  MOVWF  04
0B9F:  BCF    03.7
0BA0:  MOVF   00,W
0BA1:  MOVWF  56
0BA2:  BCF    03.6
0BA3:  MOVF   0B,W
0BA4:  MOVWF  77
0BA5:  BCF    0B.7
0BA6:  BSF    03.6
0BA7:  MOVF   55,W
0BA8:  MOVWF  0D
0BA9:  MOVF   56,W
0BAA:  MOVWF  0C
0BAB:  BSF    03.5
0BAC:  BCF    0C.7
0BAD:  BSF    0C.2
0BAE:  MOVLW  55
0BAF:  MOVWF  0D
0BB0:  MOVLW  AA
0BB1:  MOVWF  0D
0BB2:  BSF    0C.1
0BB3:  BTFSC  0C.1
0BB4:  GOTO   3B3
0BB5:  BCF    0C.2
0BB6:  MOVF   77,W
0BB7:  BCF    03.5
0BB8:  BCF    03.6
0BB9:  IORWF  0B,F
....................             delay_ms(10); 
0BBA:  MOVLW  0A
0BBB:  BSF    03.6
0BBC:  MOVWF  56
0BBD:  BCF    0A.3
0BBE:  BCF    03.6
0BBF:  CALL   5DE
0BC0:  BSF    0A.3
0BC1:  BSF    03.6
0BC2:  INCF   53,F
0BC3:  GOTO   38E
0BC4:  BCF    03.6
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
0BC5:  MOVLW  01
0BC6:  BSF    03.6
0BC7:  ADDWF  53,W
0BC8:  MOVWF  55
0BC9:  BCF    03.6
0BCA:  MOVF   0B,W
0BCB:  MOVWF  77
0BCC:  BCF    0B.7
0BCD:  BSF    03.6
0BCE:  MOVF   55,W
0BCF:  MOVWF  0D
0BD0:  MOVLW  0D
0BD1:  MOVWF  0C
0BD2:  BSF    03.5
0BD3:  BCF    0C.7
0BD4:  BSF    0C.2
0BD5:  MOVLW  55
0BD6:  MOVWF  0D
0BD7:  MOVLW  AA
0BD8:  MOVWF  0D
0BD9:  BSF    0C.1
0BDA:  BTFSC  0C.1
0BDB:  GOTO   3DA
0BDC:  BCF    0C.2
0BDD:  MOVF   77,W
0BDE:  BCF    03.5
0BDF:  BCF    03.6
0BE0:  IORWF  0B,F
....................          delay_ms(10); 
0BE1:  MOVLW  0A
0BE2:  BSF    03.6
0BE3:  MOVWF  56
0BE4:  BCF    0A.3
0BE5:  BCF    03.6
0BE6:  CALL   5DE
0BE7:  BSF    0A.3
....................          write_eeprom(idxNC+2,0x0A); 
0BE8:  MOVLW  02
0BE9:  BSF    03.6
0BEA:  ADDWF  53,W
0BEB:  MOVWF  55
0BEC:  BCF    03.6
0BED:  MOVF   0B,W
0BEE:  MOVWF  77
0BEF:  BCF    0B.7
0BF0:  BSF    03.6
0BF1:  MOVF   55,W
0BF2:  MOVWF  0D
0BF3:  MOVLW  0A
0BF4:  MOVWF  0C
0BF5:  BSF    03.5
0BF6:  BCF    0C.7
0BF7:  BSF    0C.2
0BF8:  MOVLW  55
0BF9:  MOVWF  0D
0BFA:  MOVLW  AA
0BFB:  MOVWF  0D
0BFC:  BSF    0C.1
0BFD:  BTFSC  0C.1
0BFE:  GOTO   3FD
0BFF:  BCF    0C.2
0C00:  MOVF   77,W
0C01:  BCF    03.5
0C02:  BCF    03.6
0C03:  IORWF  0B,F
....................          delay_ms(10); 
0C04:  MOVLW  0A
0C05:  BSF    03.6
0C06:  MOVWF  56
0C07:  BCF    0A.3
0C08:  BCF    03.6
0C09:  CALL   5DE
0C0A:  BSF    0A.3
....................  
....................          // Responde la solicitud 
....................          //delay_ms(30); 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0C0B:  MOVLW  98
0C0C:  BSF    03.6
0C0D:  MOVWF  0D
0C0E:  MOVLW  00
0C0F:  MOVWF  0F
0C10:  BCF    03.0
0C11:  MOVLW  0B
0C12:  MOVWF  55
0C13:  BCF    03.6
0C14:  CALL   054
0C15:  MOVF   42,W
0C16:  BTFSS  0C.4
0C17:  GOTO   416
0C18:  MOVWF  19
0C19:  MOVLW  9E
0C1A:  BSF    03.6
0C1B:  MOVWF  0D
0C1C:  MOVLW  00
0C1D:  MOVWF  0F
0C1E:  BSF    03.0
0C1F:  MOVLW  05
0C20:  MOVWF  55
0C21:  BCF    03.6
0C22:  CALL   054
....................          delay_ms(60); 
0C23:  MOVLW  3C
0C24:  BSF    03.6
0C25:  MOVWF  56
0C26:  BCF    0A.3
0C27:  BCF    03.6
0C28:  CALL   5DE
0C29:  BSF    0A.3
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
0C2A:  MOVLW  46
0C2B:  MOVWF  04
0C2C:  BSF    03.7
....................          delay_ms(110); 
*
0C4A:  MOVLW  6E
0C4B:  BSF    03.6
0C4C:  MOVWF  56
0C4D:  BCF    0A.3
0C4E:  BCF    03.6
0C4F:  CALL   5DE
0C50:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0C51:  MOVLW  A2
0C52:  BSF    03.6
0C53:  MOVWF  0D
0C54:  MOVLW  00
0C55:  MOVWF  0F
0C56:  BCF    03.0
0C57:  MOVLW  0C
0C58:  MOVWF  55
0C59:  BCF    03.6
0C5A:  CALL   054
0C5B:  MOVF   42,W
0C5C:  BTFSS  0C.4
0C5D:  GOTO   45C
0C5E:  MOVWF  19
0C5F:  MOVLW  0D
0C60:  BTFSS  0C.4
0C61:  GOTO   460
0C62:  MOVWF  19
0C63:  MOVLW  0A
0C64:  BTFSS  0C.4
0C65:  GOTO   464
0C66:  MOVWF  19
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
0C67:  MOVLW  AB
0C68:  BSF    03.6
0C69:  MOVWF  0D
0C6A:  MOVLW  00
0C6B:  MOVWF  0F
0C6C:  BCF    03.6
0C6D:  CALL   0AA
....................          delay_ms(1000); 
0C6E:  MOVLW  04
0C6F:  BSF    03.6
0C70:  MOVWF  55
0C71:  MOVLW  FA
0C72:  MOVWF  56
0C73:  BCF    0A.3
0C74:  BCF    03.6
0C75:  CALL   5DE
0C76:  BSF    0A.3
0C77:  BSF    03.6
0C78:  DECFSZ 55,F
0C79:  GOTO   471
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
0C7A:  CLRF   0A
0C7B:  BCF    03.6
0C7C:  GOTO   000
....................          ret = 1; 
0C7D:  MOVLW  01
0C7E:  BSF    03.6
0C7F:  MOVWF  44
0C80:  BCF    03.6
....................       } // Fin comando NC 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
0C81:  MOVF   44,W
0C82:  SUBLW  4E
0C83:  BTFSS  03.2
0C84:  GOTO   513
0C85:  MOVF   45,W
0C86:  SUBLW  4D
0C87:  BTFSS  03.2
0C88:  GOTO   513
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
0C89:  MOVF   0B,W
0C8A:  MOVWF  77
0C8B:  BCF    0B.7
0C8C:  BSF    03.6
0C8D:  CLRF   0D
0C8E:  BSF    03.5
0C8F:  BCF    03.6
0C90:  MOVF   20,W
0C91:  BCF    03.5
0C92:  BSF    03.6
0C93:  MOVWF  0C
0C94:  BSF    03.5
0C95:  BCF    0C.7
0C96:  BSF    0C.2
0C97:  MOVLW  55
0C98:  MOVWF  0D
0C99:  MOVLW  AA
0C9A:  MOVWF  0D
0C9B:  BSF    0C.1
0C9C:  BTFSC  0C.1
0C9D:  GOTO   49C
0C9E:  BCF    0C.2
0C9F:  MOVF   77,W
0CA0:  BCF    03.5
0CA1:  BCF    03.6
0CA2:  IORWF  0B,F
....................          delay_ms(10); 
0CA3:  MOVLW  0A
0CA4:  BSF    03.6
0CA5:  MOVWF  56
0CA6:  BCF    0A.3
0CA7:  BCF    03.6
0CA8:  CALL   5DE
0CA9:  BSF    0A.3
....................           
....................          // Responde la solicitud 
....................          delay_ms(20); 
0CAA:  MOVLW  14
0CAB:  BSF    03.6
0CAC:  MOVWF  56
0CAD:  BCF    0A.3
0CAE:  BCF    03.6
0CAF:  CALL   5DE
0CB0:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0CB1:  MOVLW  B1
0CB2:  BSF    03.6
0CB3:  MOVWF  0D
0CB4:  MOVLW  00
0CB5:  MOVWF  0F
0CB6:  BCF    03.0
0CB7:  MOVLW  0B
0CB8:  MOVWF  55
0CB9:  BCF    03.6
0CBA:  CALL   054
0CBB:  MOVF   42,W
0CBC:  BTFSS  0C.4
0CBD:  GOTO   4BC
0CBE:  MOVWF  19
0CBF:  MOVLW  B7
0CC0:  BSF    03.6
0CC1:  MOVWF  0D
0CC2:  MOVLW  00
0CC3:  MOVWF  0F
0CC4:  BSF    03.0
0CC5:  MOVLW  05
0CC6:  MOVWF  55
0CC7:  BCF    03.6
0CC8:  CALL   054
....................          delay_ms(50); 
0CC9:  MOVLW  32
0CCA:  BSF    03.6
0CCB:  MOVWF  56
0CCC:  BCF    0A.3
0CCD:  BCF    03.6
0CCE:  CALL   5DE
0CCF:  BSF    0A.3
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
0CD0:  MOVLW  46
0CD1:  MOVWF  04
0CD2:  BSF    03.7
....................          delay_ms(100); 
*
0CF0:  MOVLW  64
0CF1:  BSF    03.6
0CF2:  MOVWF  56
0CF3:  BCF    0A.3
0CF4:  BCF    03.6
0CF5:  CALL   5DE
0CF6:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0CF7:  MOVLW  BB
0CF8:  BSF    03.6
0CF9:  MOVWF  0D
0CFA:  MOVLW  00
0CFB:  MOVWF  0F
0CFC:  BCF    03.0
0CFD:  MOVLW  0C
0CFE:  MOVWF  55
0CFF:  BCF    03.6
0D00:  CALL   054
0D01:  MOVF   42,W
0D02:  BTFSS  0C.4
0D03:  GOTO   502
0D04:  MOVWF  19
0D05:  MOVLW  0D
0D06:  BTFSS  0C.4
0D07:  GOTO   506
0D08:  MOVWF  19
0D09:  MOVLW  0A
0D0A:  BTFSS  0C.4
0D0B:  GOTO   50A
0D0C:  MOVWF  19
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
0D0D:  CLRF   0A
0D0E:  GOTO   000
....................           
....................          ret = 1; 
0D0F:  MOVLW  01
0D10:  BSF    03.6
0D11:  MOVWF  44
0D12:  BCF    03.6
....................       } // Fin comando OP 
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................        
....................       // Responde la solicitud 
....................       delay_ms(20); 
0D13:  MOVLW  14
0D14:  BSF    03.6
0D15:  MOVWF  56
0D16:  BCF    0A.3
0D17:  BCF    03.6
0D18:  CALL   5DE
0D19:  BSF    0A.3
....................       fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0D1A:  MOVLW  C4
0D1B:  BSF    03.6
0D1C:  MOVWF  0D
0D1D:  MOVLW  00
0D1E:  MOVWF  0F
0D1F:  BCF    03.0
0D20:  MOVLW  0B
0D21:  MOVWF  55
0D22:  BCF    03.6
0D23:  CALL   054
0D24:  MOVF   42,W
0D25:  BTFSS  0C.4
0D26:  GOTO   525
0D27:  MOVWF  19
0D28:  MOVLW  CA
0D29:  BSF    03.6
0D2A:  MOVWF  0D
0D2B:  MOVLW  00
0D2C:  MOVWF  0F
0D2D:  BSF    03.0
0D2E:  MOVLW  05
0D2F:  MOVWF  55
0D30:  BCF    03.6
0D31:  CALL   054
....................       delay_ms(50); 
0D32:  MOVLW  32
0D33:  BSF    03.6
0D34:  MOVWF  56
0D35:  BCF    0A.3
0D36:  BCF    03.6
0D37:  CALL   5DE
0D38:  BSF    0A.3
....................       fprintf(ESP8266, "%s",ESP8266_Resp); 
0D39:  MOVLW  46
0D3A:  MOVWF  04
0D3B:  BSF    03.7
....................       delay_ms(100); 
*
0D59:  MOVLW  64
0D5A:  BSF    03.6
0D5B:  MOVWF  56
0D5C:  BCF    0A.3
0D5D:  BCF    03.6
0D5E:  CALL   5DE
0D5F:  BSF    0A.3
....................       fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0D60:  MOVLW  CE
0D61:  BSF    03.6
0D62:  MOVWF  0D
0D63:  MOVLW  00
0D64:  MOVWF  0F
0D65:  BCF    03.0
0D66:  MOVLW  0C
0D67:  MOVWF  55
0D68:  BCF    03.6
0D69:  CALL   054
0D6A:  MOVF   42,W
0D6B:  BTFSS  0C.4
0D6C:  GOTO   56B
0D6D:  MOVWF  19
0D6E:  MOVLW  0D
0D6F:  BTFSS  0C.4
0D70:  GOTO   56F
0D71:  MOVWF  19
0D72:  MOVLW  0A
0D73:  BTFSS  0C.4
0D74:  GOTO   573
0D75:  MOVWF  19
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
0D76:  BSF    03.6
0D77:  CLRF   54
0D78:  BCF    03.6
0D79:  MOVF   47,F
0D7A:  BTFSS  03.2
0D7B:  GOTO   582
0D7C:  BSF    03.6
0D7D:  MOVF   54,W
0D7E:  BCF    03.6
0D7F:  SUBWF  46,W
0D80:  BTFSS  03.0
0D81:  GOTO   58B
....................          DATA_COMMAND[idxCb] = 0x00; 
0D82:  MOVLW  A0
0D83:  BSF    03.6
0D84:  ADDWF  54,W
0D85:  MOVWF  04
0D86:  BCF    03.7
0D87:  CLRF   00
0D88:  INCF   54,F
0D89:  GOTO   578
0D8A:  BCF    03.6
....................       } 
....................       COMMAND[0]       = 0x00; 
0D8B:  CLRF   44
....................       COMMAND[1]       = 0x00; 
0D8C:  CLRF   45
....................       ID_CONNETION[0]  = 0x00; 
0D8D:  CLRF   42
....................        
....................       // Reinicia el buffer 
....................       flag_Resp_Ready  = 0x00; 
0D8E:  CLRF   4B
....................       LEN_DATA_COMMAND = 0x00; 
0D8F:  CLRF   47
0D90:  CLRF   46
....................        
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return ret; 
0D91:  BSF    03.6
0D92:  MOVF   44,W
0D93:  MOVWF  78
0D94:  BCF    03.6
0D95:  RETURN
.................... } 
....................  
.................... #include "header/esp8266.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... #define  CMD_MODE             1 
.................... #define  CMD_DO_CONN          2 
.................... #define  CMD_CONN             3 
.................... #define  READY_RESPONSE_WIFI  4 
....................  
.................... /* Key flag responses */ 
.................... const int   Valid      = 0; 
.................... const int   CWJAP      = 1; 
.................... const int   NoAp       = 2; 
.................... const int   Connected  = 3; 
.................... const int   Fail       = 4; 
.................... const int   Error      = 5; 
....................  
.................... //#define  END_CMD_GET_IP       2 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... int  waitResp(void); 
.................... //void waitRespGetIP(char buffer); 
.................... void waitRespMajor(int buffer,int flag_resp); 
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int resp_Pos   = 1; 
.................... int resp_Flag  = 0; 
.................... int countResp  = 5;     //Conteo de Respuestas esperadas 
....................  
.................... char buffer_flag_Resp[2][6]   =   
.................... { 
....................    {0,0,0,0,0,0}, // Flag_Responses Command valid 
....................    {0,0,0,0,0,0}  // Flag_Pos_Responses 
.................... }; 
*
1086:  CLRF   53
1087:  CLRF   54
1088:  CLRF   55
1089:  CLRF   56
108A:  CLRF   57
108B:  CLRF   58
108C:  CLRF   59
108D:  CLRF   5A
108E:  CLRF   5B
108F:  CLRF   5C
1090:  CLRF   5D
1091:  CLRF   5E
....................  
....................  
.................... /*buffer_flag_Resp[resp_Flag][1] = 5;*/ 
.................... /*@TODO: Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    /**fprintf(ESP8266, "AT+RST\r\n"); 
....................    delay_ms(2000);**/ 
....................     
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
*
09B4:  BSF    03.6
09B5:  CLRF   0D
09B6:  BSF    03.5
09B7:  BCF    0C.7
09B8:  BSF    0C.0
09B9:  BCF    03.5
09BA:  MOVF   0C,W
09BB:  BCF    03.6
09BC:  MOVWF  5F
....................    delay_ms(10); 
09BD:  MOVLW  0A
09BE:  BSF    03.6
09BF:  MOVWF  56
09C0:  BCF    0A.3
09C1:  BCF    03.6
09C2:  CALL   5DE
09C3:  BSF    0A.3
....................    switch(modeStar){ 
09C4:  MOVF   5F,W
09C5:  XORLW  31
09C6:  BTFSC  03.2
09C7:  GOTO   1CE
09C8:  XORLW  03
09C9:  BTFSC  03.2
09CA:  GOTO   1CE
09CB:  XORLW  01
09CC:  BTFSS  03.2
09CD:  GOTO   1CF
....................       case '1': 
....................       case '2': 
....................       case '3': 
....................          break; 
09CE:  GOTO   1EE
....................       default: 
....................          write_eeprom(0x00,'3'); 
09CF:  MOVF   0B,W
09D0:  MOVWF  77
09D1:  BCF    0B.7
09D2:  BSF    03.6
09D3:  CLRF   0D
09D4:  MOVLW  33
09D5:  MOVWF  0C
09D6:  BSF    03.5
09D7:  BCF    0C.7
09D8:  BSF    0C.2
09D9:  MOVLW  55
09DA:  MOVWF  0D
09DB:  MOVLW  AA
09DC:  MOVWF  0D
09DD:  BSF    0C.1
09DE:  BTFSC  0C.1
09DF:  GOTO   1DE
09E0:  BCF    0C.2
09E1:  MOVF   77,W
09E2:  BCF    03.5
09E3:  BCF    03.6
09E4:  IORWF  0B,F
....................          delay_ms(10); 
09E5:  MOVLW  0A
09E6:  BSF    03.6
09E7:  MOVWF  56
09E8:  BCF    0A.3
09E9:  BCF    03.6
09EA:  CALL   5DE
09EB:  BSF    0A.3
....................          modeStar = '3'; 
09EC:  MOVLW  33
09ED:  MOVWF  5F
....................          break; 
....................    } 
....................    // Lanza el comando para configurar el modo de conexion 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeStar); 
09EE:  MOVLW  D7
09EF:  BSF    03.6
09F0:  MOVWF  0D
09F1:  MOVLW  00
09F2:  MOVWF  0F
09F3:  BCF    03.0
09F4:  MOVLW  0A
09F5:  MOVWF  55
09F6:  BCF    03.6
09F7:  CALL   054
09F8:  MOVF   5F,W
09F9:  BTFSS  0C.4
09FA:  GOTO   1F9
09FB:  MOVWF  19
09FC:  MOVLW  0D
09FD:  BTFSS  0C.4
09FE:  GOTO   1FD
09FF:  MOVWF  19
0A00:  MOVLW  0A
0A01:  BTFSS  0C.4
0A02:  GOTO   201
0A03:  MOVWF  19
....................    CMD_RUN =  CMD_MODE;  
0A04:  MOVLW  01
0A05:  MOVWF  4F
....................     
....................    // Espera por la respuesta OK del modulo 
....................    delay_ms(50); 
0A06:  MOVLW  32
0A07:  BSF    03.6
0A08:  MOVWF  56
0A09:  BCF    0A.3
0A0A:  BCF    03.6
0A0B:  CALL   5DE
0A0C:  BSF    0A.3
....................     
....................    // Lanza el comando para verificar si elmodulo ya se encuentra conectado 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
0A0D:  MOVLW  DF
0A0E:  BSF    03.6
0A0F:  MOVWF  0D
0A10:  MOVLW  00
0A11:  MOVWF  0F
0A12:  BCF    03.6
0A13:  CALL   0AA
....................    CMD_RUN =  CMD_DO_CONN; 
0A14:  MOVLW  02
0A15:  MOVWF  4F
....................  
....................    resp = waitResp(); 
0A16:  CALL   0FC
0A17:  MOVF   78,W
0A18:  BSF    03.6
0A19:  MOVWF  42
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
0A1A:  MOVF   42,W
0A1B:  SUBLW  02
0A1C:  BTFSS  03.2
0A1D:  GOTO   2A3
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
0A1E:  CLRF   43
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
0A1F:  MOVLW  10
0A20:  ADDWF  43,W
0A21:  MOVWF  04
0A22:  BSF    03.7
0A23:  MOVF   00,W
0A24:  SUBLW  0A
0A25:  BTFSC  03.2
0A26:  GOTO   250
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
0A27:  MOVLW  10
0A28:  ADDWF  43,W
0A29:  MOVWF  04
0A2A:  BSF    03.7
0A2B:  MOVLW  01
0A2C:  ADDWF  43,W
0A2D:  MOVWF  46
0A2E:  MOVF   46,W
0A2F:  MOVWF  0D
0A30:  BSF    03.5
0A31:  BCF    0C.7
0A32:  BSF    0C.0
0A33:  BCF    03.5
0A34:  MOVF   0C,W
0A35:  MOVWF  00
....................          delay_ms(10); 
0A36:  MOVLW  0A
0A37:  MOVWF  56
0A38:  BCF    0A.3
0A39:  BCF    03.6
0A3A:  CALL   5DE
0A3B:  BSF    0A.3
....................          if(SSIDAndKey[idxRE]==0xFF){ 
0A3C:  MOVLW  10
0A3D:  BSF    03.6
0A3E:  ADDWF  43,W
0A3F:  MOVWF  04
0A40:  BSF    03.7
0A41:  INCFSZ 00,W
0A42:  GOTO   246
....................             resp = 5; 
0A43:  MOVLW  05
0A44:  MOVWF  42
....................             break; 
0A45:  GOTO   250
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
0A46:  MOVLW  10
0A47:  ADDWF  43,W
0A48:  MOVWF  04
0A49:  BSF    03.7
0A4A:  MOVF   00,W
0A4B:  SUBLW  0A
0A4C:  BTFSC  03.2
....................             break; 
0A4D:  GOTO   250
....................          } 
....................          idxRE++; 
0A4E:  INCF   43,F
0A4F:  GOTO   21F
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
0A50:  MOVF   42,W
0A51:  SUBLW  05
0A52:  BTFSC  03.2
0A53:  GOTO   283
....................          fprintf(ESP8266, "AT+CWJAP=%s",SSIDAndKey);     /** AT+CWJAP="UNE_C06E","00986344200771" **/ 
0A54:  MOVLW  E5
0A55:  MOVWF  0D
0A56:  MOVLW  00
0A57:  MOVWF  0F
0A58:  BCF    03.0
0A59:  MOVLW  09
0A5A:  MOVWF  55
0A5B:  BCF    03.6
0A5C:  CALL   054
0A5D:  MOVLW  10
0A5E:  MOVWF  04
0A5F:  BSF    03.7
....................          CMD_RUN = CMD_CONN; 
*
0A7D:  MOVLW  03
0A7E:  MOVWF  4F
....................          resp    = waitResp(); 
0A7F:  CALL   0FC
0A80:  MOVF   78,W
0A81:  BSF    03.6
0A82:  MOVWF  42
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
0A83:  MOVF   42,W
0A84:  SUBLW  04
0A85:  BTFSC  03.2
0A86:  GOTO   28B
0A87:  MOVF   42,W
0A88:  SUBLW  05
0A89:  BTFSS  03.2
0A8A:  GOTO   2A3
....................          fprintf(ESP8266, "AT+CWMODE=%c\r\n","3"); 
0A8B:  MOVLW  EB
0A8C:  MOVWF  0D
0A8D:  MOVLW  00
0A8E:  MOVWF  0F
0A8F:  BCF    03.0
0A90:  MOVLW  0A
0A91:  MOVWF  55
0A92:  BCF    03.6
0A93:  CALL   054
0A94:  BTFSS  0C.4
0A95:  GOTO   294
0A96:  MOVWF  19
0A97:  MOVLW  0D
0A98:  BTFSS  0C.4
0A99:  GOTO   298
0A9A:  MOVWF  19
0A9B:  MOVLW  0A
0A9C:  BTFSS  0C.4
0A9D:  GOTO   29C
0A9E:  MOVWF  19
....................          CMD_RUN = CMD_MODE; 
0A9F:  MOVLW  01
0AA0:  MOVWF  4F
....................          waitResp(); 
0AA1:  CALL   0FC
0AA2:  BSF    03.6
....................       } 
....................    } // Fin del if(doConnect) 
....................  
....................    // Configura el modulo como server 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
0AA3:  MOVLW  F3
0AA4:  MOVWF  0D
0AA5:  MOVLW  00
0AA6:  MOVWF  0F
0AA7:  BCF    03.6
0AA8:  CALL   0AA
....................    delay_ms(1000); 
0AA9:  MOVLW  04
0AAA:  BSF    03.6
0AAB:  MOVWF  44
0AAC:  MOVLW  FA
0AAD:  MOVWF  56
0AAE:  BCF    0A.3
0AAF:  BCF    03.6
0AB0:  CALL   5DE
0AB1:  BSF    0A.3
0AB2:  BSF    03.6
0AB3:  DECFSZ 44,F
0AB4:  GOTO   2AC
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
0AB5:  MOVLW  FA
0AB6:  MOVWF  0D
0AB7:  MOVLW  00
0AB8:  MOVWF  0F
0AB9:  BCF    03.6
0ABA:  CALL   0AA
....................    delay_ms(1000); 
0ABB:  MOVLW  04
0ABC:  BSF    03.6
0ABD:  MOVWF  44
0ABE:  MOVLW  FA
0ABF:  MOVWF  56
0AC0:  BCF    0A.3
0AC1:  BCF    03.6
0AC2:  CALL   5DE
0AC3:  BSF    0A.3
0AC4:  BSF    03.6
0AC5:  DECFSZ 44,F
0AC6:  GOTO   2BE
....................     
....................    CMD_RUN = READY_RESPONSE_WIFI; 
0AC7:  MOVLW  04
0AC8:  BCF    03.6
0AC9:  MOVWF  4F
0ACA:  BCF    0A.3
0ACB:  BSF    0A.4
0ACC:  GOTO   0BE (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
04E5:  BCF    03.6
04E6:  MOVF   4F,W
04E7:  XORLW  01
04E8:  BTFSC  03.2
04E9:  GOTO   4F4
04EA:  XORLW  03
04EB:  BTFSC  03.2
04EC:  GOTO   4FB
04ED:  XORLW  01
04EE:  BTFSC  03.2
04EF:  GOTO   510
04F0:  XORLW  07
04F1:  BTFSC  03.2
04F2:  GOTO   525
04F3:  GOTO   525
....................             case CMD_MODE: 
....................                   waitRespMajor(buffer,Valid); 
04F4:  BSF    03.6
04F5:  MOVF   60,W
04F6:  MOVWF  61
04F7:  CLRF   62
04F8:  BCF    03.6
04F9:  CALL   3C0
....................                   break; 
04FA:  GOTO   5D1
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespMajor(buffer,NoAp); 
04FB:  BSF    03.6
04FC:  MOVF   60,W
04FD:  MOVWF  61
04FE:  MOVLW  02
04FF:  MOVWF  62
0500:  BCF    03.6
0501:  CALL   3C0
....................                   waitRespMajor(buffer,CWJAP); 
0502:  BSF    03.6
0503:  MOVF   60,W
0504:  MOVWF  61
0505:  MOVLW  01
0506:  MOVWF  62
0507:  BCF    03.6
0508:  CALL   3C0
....................                   waitRespMajor(buffer,Valid); 
0509:  BSF    03.6
050A:  MOVF   60,W
050B:  MOVWF  61
050C:  CLRF   62
050D:  BCF    03.6
050E:  CALL   3C0
....................                   break; 
050F:  GOTO   5D1
....................  
....................             case CMD_CONN: 
....................                   waitRespMajor(buffer,Connected); 
0510:  BSF    03.6
0511:  MOVF   60,W
0512:  MOVWF  61
0513:  MOVLW  03
0514:  MOVWF  62
0515:  BCF    03.6
0516:  CALL   3C0
....................                   waitRespMajor(buffer,Fail); 
0517:  BSF    03.6
0518:  MOVF   60,W
0519:  MOVWF  61
051A:  MOVLW  04
051B:  MOVWF  62
051C:  BCF    03.6
051D:  CALL   3C0
....................                   waitRespMajor(buffer,Valid); 
051E:  BSF    03.6
051F:  MOVF   60,W
0520:  MOVWF  61
0521:  CLRF   62
0522:  BCF    03.6
0523:  CALL   3C0
....................                   break; 
0524:  GOTO   5D1
....................                    
....................             case READY_RESPONSE_WIFI: 
....................             default: 
....................                   ESP8266_Get_IPD(buffer); 
0525:  BSF    03.6
0526:  CLRF   63
0527:  MOVF   60,W
0528:  MOVWF  62
....................                   ESP8266_Get_CMD(buffer); 
*
055F:  BSF    03.6
0560:  CLRF   62
0561:  MOVF   60,W
0562:  MOVWF  61
....................                   ESP8266_Get_Data(buffer); 
*
059B:  BSF    03.6
059C:  CLRF   62
059D:  MOVF   60,W
059E:  MOVWF  61
....................              
....................                   CMD_RUN = 0x00; 
*
05D0:  CLRF   4F
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
08FC:  BSF    03.6
08FD:  CLRF   44
08FE:  CLRF   45
08FF:  BCF    03.6
0900:  CLRF   2B
0901:  BTFSC  0B.7
0902:  BSF    2B.7
0903:  BCF    0B.7
.................... { 
....................    int ret=0,idx=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(buffer_flag_Resp[resp_Flag][Valid]==0){ 
0904:  MOVF   51,W
0905:  BSF    03.5
0906:  BSF    03.6
0907:  MOVWF  11
0908:  MOVLW  06
0909:  MOVWF  12
090A:  BCF    0A.3
090B:  BCF    03.5
090C:  BCF    03.6
090D:  CALL   397
090E:  BSF    0A.3
090F:  BTFSC  2B.7
0910:  BSF    0B.7
0911:  MOVLW  53
0912:  ADDWF  78,W
0913:  MOVWF  04
0914:  BCF    03.7
0915:  MOVF   00,F
0916:  BTFSS  03.2
0917:  GOTO   191
....................       idx++; 
0918:  BSF    03.6
0919:  INCF   45,F
091A:  BCF    03.6
091B:  CLRF   2B
091C:  BTFSC  0B.7
091D:  BSF    2B.7
091E:  BCF    0B.7
....................       if(buffer_flag_Resp[resp_Flag][idx]==1){ 
091F:  MOVF   51,W
0920:  BSF    03.5
0921:  BSF    03.6
0922:  MOVWF  11
0923:  MOVLW  06
0924:  MOVWF  12
0925:  BCF    0A.3
0926:  BCF    03.5
0927:  BCF    03.6
0928:  CALL   397
0929:  BSF    0A.3
092A:  BTFSC  2B.7
092B:  BSF    0B.7
092C:  BSF    03.6
092D:  MOVF   45,W
092E:  ADDWF  78,W
092F:  ADDLW  53
0930:  MOVWF  04
0931:  BCF    03.7
0932:  DECFSZ 00,W
0933:  GOTO   189
0934:  BCF    03.6
0935:  CLRF   2B
0936:  BTFSC  0B.7
0937:  BSF    2B.7
0938:  BCF    0B.7
....................          buffer_flag_Resp[resp_Pos][idx]   = 0; 
0939:  MOVF   50,W
093A:  BSF    03.5
093B:  BSF    03.6
093C:  MOVWF  11
093D:  MOVLW  06
093E:  MOVWF  12
093F:  BCF    0A.3
0940:  BCF    03.5
0941:  BCF    03.6
0942:  CALL   397
0943:  BSF    0A.3
0944:  BTFSC  2B.7
0945:  BSF    0B.7
0946:  BSF    03.6
0947:  MOVF   45,W
0948:  ADDWF  78,W
0949:  ADDLW  53
094A:  MOVWF  04
094B:  BCF    03.7
094C:  CLRF   00
094D:  BCF    03.6
094E:  CLRF   2B
094F:  BTFSC  0B.7
0950:  BSF    2B.7
0951:  BCF    0B.7
....................          buffer_flag_Resp[resp_Flag][idx]  = 0; 
0952:  MOVF   51,W
0953:  BSF    03.5
0954:  BSF    03.6
0955:  MOVWF  11
0956:  MOVLW  06
0957:  MOVWF  12
0958:  BCF    0A.3
0959:  BCF    03.5
095A:  BCF    03.6
095B:  CALL   397
095C:  BSF    0A.3
095D:  BTFSC  2B.7
095E:  BSF    0B.7
095F:  BSF    03.6
0960:  MOVF   45,W
0961:  ADDWF  78,W
0962:  ADDLW  53
0963:  MOVWF  04
0964:  BCF    03.7
0965:  CLRF   00
....................          
....................          if(idx == Fail || idx == Error){ 
0966:  MOVF   45,W
0967:  SUBLW  04
0968:  BTFSC  03.2
0969:  GOTO   16E
096A:  MOVF   45,W
096B:  SUBLW  05
096C:  BTFSS  03.2
096D:  GOTO   187
096E:  BCF    03.6
096F:  CLRF   2B
0970:  BTFSC  0B.7
0971:  BSF    2B.7
0972:  BCF    0B.7
....................             buffer_flag_Resp[resp_Flag][Valid]  = 1; 
0973:  MOVF   51,W
0974:  BSF    03.5
0975:  BSF    03.6
0976:  MOVWF  11
0977:  MOVLW  06
0978:  MOVWF  12
0979:  BCF    0A.3
097A:  BCF    03.5
097B:  BCF    03.6
097C:  CALL   397
097D:  BSF    0A.3
097E:  BTFSC  2B.7
097F:  BSF    0B.7
0980:  MOVLW  53
0981:  ADDWF  78,W
0982:  MOVWF  04
0983:  BCF    03.7
0984:  MOVLW  01
0985:  MOVWF  00
0986:  BSF    03.6
....................          } 
....................          ret = idx; 
0987:  MOVF   45,W
0988:  MOVWF  44
....................       } 
....................       // Reinicia el contador para no desbordar el array de flag_resp 
....................       if(idx>=countResp){ 
0989:  BCF    03.6
098A:  MOVF   52,W
098B:  BSF    03.6
098C:  SUBWF  45,W
098D:  BTFSC  03.0
....................          idx = 0; 
098E:  CLRF   45
....................       } 
098F:  GOTO   0FF
0990:  BCF    03.6
0991:  CLRF   2B
0992:  BTFSC  0B.7
0993:  BSF    2B.7
0994:  BCF    0B.7
....................        
....................    }; // Fin del loop 
....................     
....................    buffer_flag_Resp[resp_Flag][Valid] = 0; 
0995:  MOVF   51,W
0996:  BSF    03.5
0997:  BSF    03.6
0998:  MOVWF  11
0999:  MOVLW  06
099A:  MOVWF  12
099B:  BCF    0A.3
099C:  BCF    03.5
099D:  BCF    03.6
099E:  CALL   397
099F:  BSF    0A.3
09A0:  BTFSC  2B.7
09A1:  BSF    0B.7
09A2:  MOVLW  53
09A3:  ADDWF  78,W
09A4:  MOVWF  04
09A5:  BCF    03.7
09A6:  CLRF   00
....................    CMD_RUN = 0x00; 
09A7:  CLRF   4F
....................    delay_ms(10); 
09A8:  MOVLW  0A
09A9:  BSF    03.6
09AA:  MOVWF  56
09AB:  BCF    0A.3
09AC:  BCF    03.6
09AD:  CALL   5DE
09AE:  BSF    0A.3
....................    return ret; 
09AF:  BSF    03.6
09B0:  MOVF   44,W
09B1:  MOVWF  78
09B2:  BCF    03.6
09B3:  RETURN
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
.................... void waitRespMajor(int buffer,int flag_resp) 
*
03C0:  BSF    03.6
03C1:  CLRF   6D
03C2:  CLRF   6E
.................... { 
....................     
....................    char  strResp[10]; 
....................    int   lenResp = 0,restartFlag = 0; 
....................  
....................    switch(flag_resp) 
03C3:  MOVF   62,W
03C4:  ADDLW  FB
03C5:  BTFSC  03.0
03C6:  GOTO   45B
03C7:  ADDLW  05
03C8:  BCF    03.6
03C9:  GOTO   4D5
....................    { 
....................       case Valid: 
....................          strResp = "OK\r\n"; 
03CA:  BSF    03.5
03CB:  BSF    03.6
03CC:  CLRF   10
03CD:  CLRF   11
03CE:  MOVLW  63
03CF:  MOVWF  04
03D0:  BSF    03.7
03D1:  MOVF   10,W
03D2:  ADDWF  04,F
03D3:  MOVF   11,W
03D4:  BCF    03.5
03D5:  BCF    03.6
03D6:  CALL   062
03D7:  MOVWF  00
03D8:  IORLW  00
03D9:  BTFSC  03.2
03DA:  GOTO   3E2
03DB:  BSF    03.5
03DC:  BSF    03.6
03DD:  INCF   11,F
03DE:  INCF   10,F
03DF:  GOTO   3CE
03E0:  BCF    03.5
03E1:  BCF    03.6
....................          lenResp = 4; 
03E2:  MOVLW  04
03E3:  BSF    03.6
03E4:  MOVWF  6D
....................          // Como esta funcion es el ultimo caracter recibido no es necesario mantener 
....................          // Activa la bandera flag_Resp_Valid 
....................          restartFlag = 1; 
03E5:  MOVLW  01
03E6:  MOVWF  6E
....................          break; 
03E7:  GOTO   45B
....................  
....................       case NoAp: 
....................          strResp = "No Ap"; 
03E8:  BSF    03.5
03E9:  BSF    03.6
03EA:  CLRF   10
03EB:  CLRF   11
03EC:  MOVLW  63
03ED:  MOVWF  04
03EE:  BSF    03.7
03EF:  MOVF   10,W
03F0:  ADDWF  04,F
03F1:  MOVF   11,W
03F2:  BCF    03.5
03F3:  BCF    03.6
03F4:  CALL   06B
03F5:  MOVWF  00
03F6:  IORLW  00
03F7:  BTFSC  03.2
03F8:  GOTO   400
03F9:  BSF    03.5
03FA:  BSF    03.6
03FB:  INCF   11,F
03FC:  INCF   10,F
03FD:  GOTO   3EC
03FE:  BCF    03.5
03FF:  BCF    03.6
....................          lenResp = 5; 
0400:  MOVLW  05
0401:  BSF    03.6
0402:  MOVWF  6D
....................          break; 
0403:  GOTO   45B
....................  
....................       case CWJAP: 
....................          strResp = "+CWJAP:"; 
0404:  BSF    03.5
0405:  BSF    03.6
0406:  CLRF   10
0407:  CLRF   11
0408:  MOVLW  63
0409:  MOVWF  04
040A:  BSF    03.7
040B:  MOVF   10,W
040C:  ADDWF  04,F
040D:  MOVF   11,W
040E:  BCF    03.5
040F:  BCF    03.6
0410:  CALL   075
0411:  MOVWF  00
0412:  IORLW  00
0413:  BTFSC  03.2
0414:  GOTO   41C
0415:  BSF    03.5
0416:  BSF    03.6
0417:  INCF   11,F
0418:  INCF   10,F
0419:  GOTO   408
041A:  BCF    03.5
041B:  BCF    03.6
....................          lenResp = 7; 
041C:  MOVLW  07
041D:  BSF    03.6
041E:  MOVWF  6D
....................          break; 
041F:  GOTO   45B
....................           
....................       case Connected: 
....................          strResp = "CONNECTED"; 
0420:  BSF    03.5
0421:  BSF    03.6
0422:  CLRF   10
0423:  CLRF   11
0424:  MOVLW  63
0425:  MOVWF  04
0426:  BSF    03.7
0427:  MOVF   10,W
0428:  ADDWF  04,F
0429:  MOVF   11,W
042A:  BCF    03.5
042B:  BCF    03.6
042C:  CALL   081
042D:  MOVWF  00
042E:  IORLW  00
042F:  BTFSC  03.2
0430:  GOTO   438
0431:  BSF    03.5
0432:  BSF    03.6
0433:  INCF   11,F
0434:  INCF   10,F
0435:  GOTO   424
0436:  BCF    03.5
0437:  BCF    03.6
....................          lenResp = 9; 
0438:  MOVLW  09
0439:  BSF    03.6
043A:  MOVWF  6D
....................          break; 
043B:  GOTO   45B
....................        
....................       case Fail: 
....................          strResp = "FAIL"; 
043C:  BSF    03.5
043D:  BSF    03.6
043E:  CLRF   10
043F:  CLRF   11
0440:  MOVLW  63
0441:  MOVWF  04
0442:  BSF    03.7
0443:  MOVF   10,W
0444:  ADDWF  04,F
0445:  MOVF   11,W
0446:  BCF    03.5
0447:  BCF    03.6
0448:  CALL   08F
0449:  MOVWF  00
044A:  IORLW  00
044B:  BTFSC  03.2
044C:  GOTO   454
044D:  BSF    03.5
044E:  BSF    03.6
044F:  INCF   11,F
0450:  INCF   10,F
0451:  GOTO   440
0452:  BCF    03.5
0453:  BCF    03.6
....................          lenResp = 4; 
0454:  MOVLW  04
0455:  BSF    03.6
0456:  MOVWF  6D
....................          restartFlag = 1; 
0457:  MOVLW  01
0458:  MOVWF  6E
....................          break; 
0459:  GOTO   45B
045A:  BSF    03.6
....................    } 
....................  
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................  
....................    if(buffer == strResp[buffer_flag_Resp[resp_Pos][flag_resp]]) 
045B:  BCF    03.6
045C:  MOVF   50,W
045D:  BSF    03.5
045E:  BSF    03.6
045F:  MOVWF  11
0460:  MOVLW  06
0461:  MOVWF  12
0462:  BCF    03.5
0463:  BCF    03.6
0464:  CALL   397
0465:  BSF    03.6
0466:  MOVF   62,W
0467:  ADDWF  78,W
0468:  ADDLW  53
0469:  MOVWF  04
046A:  BCF    03.7
046B:  MOVLW  63
046C:  ADDWF  00,W
046D:  MOVWF  04
046E:  BSF    03.7
046F:  MOVF   00,W
0470:  SUBWF  61,W
0471:  BTFSS  03.2
0472:  GOTO   4AF
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       buffer_flag_Resp[resp_Pos][flag_resp]++; 
0473:  BCF    03.6
0474:  MOVF   50,W
0475:  BSF    03.5
0476:  BSF    03.6
0477:  MOVWF  11
0478:  MOVLW  06
0479:  MOVWF  12
047A:  BCF    03.5
047B:  BCF    03.6
047C:  CALL   397
047D:  BSF    03.6
047E:  MOVF   62,W
047F:  ADDWF  78,W
0480:  ADDLW  53
0481:  MOVWF  04
0482:  BCF    03.7
0483:  INCF   00,F
....................        
....................       if(buffer_flag_Resp[resp_Pos][flag_resp]==lenResp){ 
0484:  BCF    03.6
0485:  MOVF   50,W
0486:  BSF    03.5
0487:  BSF    03.6
0488:  MOVWF  11
0489:  MOVLW  06
048A:  MOVWF  12
048B:  BCF    03.5
048C:  BCF    03.6
048D:  CALL   397
048E:  BSF    03.6
048F:  MOVF   62,W
0490:  ADDWF  78,W
0491:  ADDLW  53
0492:  MOVWF  04
0493:  BCF    03.7
0494:  MOVF   6D,W
0495:  SUBWF  00,W
0496:  BTFSS  03.2
0497:  GOTO   4AB
....................          // Respuesta es valida 
....................          buffer_flag_Resp[resp_Flag][flag_resp]  = 1; 
0498:  BCF    03.6
0499:  MOVF   51,W
049A:  BSF    03.5
049B:  BSF    03.6
049C:  MOVWF  11
049D:  MOVLW  06
049E:  MOVWF  12
049F:  BCF    03.5
04A0:  BCF    03.6
04A1:  CALL   397
04A2:  BSF    03.6
04A3:  MOVF   62,W
04A4:  ADDWF  78,W
04A5:  ADDLW  53
04A6:  MOVWF  04
04A7:  BCF    03.7
04A8:  MOVLW  01
04A9:  MOVWF  00
....................       }else if(flag_resp == Valid) { 
04AA:  GOTO   4AE
04AB:  MOVF   62,F
04AC:  BTFSS  03.2
04AD:  GOTO   4AE
....................          // Reinicia la bandera para indicar el final del comando 
....................           //buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
....................       } 
....................         
....................    }else{ 
04AE:  GOTO   4D3
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       buffer_flag_Resp[resp_Pos][flag_resp]   = 0; 
04AF:  BCF    03.6
04B0:  MOVF   50,W
04B1:  BSF    03.5
04B2:  BSF    03.6
04B3:  MOVWF  11
04B4:  MOVLW  06
04B5:  MOVWF  12
04B6:  BCF    03.5
04B7:  BCF    03.6
04B8:  CALL   397
04B9:  BSF    03.6
04BA:  MOVF   62,W
04BB:  ADDWF  78,W
04BC:  ADDLW  53
04BD:  MOVWF  04
04BE:  BCF    03.7
04BF:  CLRF   00
....................  
....................       // Banderas que se reinician 
....................       if(restartFlag == 1){ 
04C0:  DECFSZ 6E,W
04C1:  GOTO   4D3
....................          buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
04C2:  BCF    03.6
04C3:  MOVF   51,W
04C4:  BSF    03.5
04C5:  BSF    03.6
04C6:  MOVWF  11
04C7:  MOVLW  06
04C8:  MOVWF  12
04C9:  BCF    03.5
04CA:  BCF    03.6
04CB:  CALL   397
04CC:  BSF    03.6
04CD:  MOVF   62,W
04CE:  ADDWF  78,W
04CF:  ADDLW  53
04D0:  MOVWF  04
04D1:  BCF    03.7
04D2:  CLRF   00
....................       } 
....................        
....................    } 
04D3:  BCF    03.6
04D4:  RETURN
.................... } 
....................  
.................... /********************************************************* 
....................  *    Espera por la respuesta del comando enviado desde 
....................  *    el menu. 
....................  *********************************************************/ 
.................... /*int waitRespCmdFromMenu(void) 
.................... { 
....................    int ret=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(flag_Resp_Valid==0){ 
....................     
....................       if(ESP8266_CMD_FROM_MENU==END_CMD_GET_IP){ 
....................          flag_Pos_Resp_GetIP  = 0; 
....................          flag_Resp_GetIP      = 0; 
....................          ret = 1; 
....................       }  
....................        
....................    } 
....................     
....................    return ret; 
.................... }*/ 
.................... /********************************************************* 
....................  *    Espera por la respuesta del comando enviado desde 
....................  *    el menu. 
....................  *********************************************************/ 
.................... /*void waitRespGetIP(char buffer) 
.................... { 
....................  
....................    const char ESP8266_RESP_GET_IP[7] ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
....................    int lenResp = 7; 
....................   
....................    if(flag_Resp_GetIP == 1){ 
....................       if(buffer!=','){ 
....................          DATA_CMD_GET_IP[flag_Pos_Resp_GetIP] = buffer; 
....................          flag_Pos_Resp_GetIP++; 
....................       }else{         
....................          flag_Pos_Resp_GetIP = 0x00; 
....................          flag_Resp_GetIP     = 0x00; 
....................           
....................          // Reinicia la bandera para liberar la captura de datos 
....................          // en la interrupcion 
....................          ESP8266_CMD_FROM_MENU=END_CMD_GET_IP; 
....................       } 
....................    }else{ 
....................       if(buffer == ESP8266_RESP_GET_IP[flag_Pos_Resp_GetIP] ) 
....................       { 
....................          flag_Pos_Resp_GetIP++; 
....................           
....................          if(flag_Pos_Resp_GetIP==lenResp){ 
....................             // Respuesta es valida 
....................             flag_Resp_GetIP   = 1; 
....................          } 
....................       }else{ 
....................          // Reinicia el contador 
....................          flag_Pos_Resp_GetIP  = 0; 
....................       } 
....................    }   
.................... }*/ 
....................  
.................... #include "header/menu.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_STA_IP     0 
....................   #define OPT_SHOW_STA_SSID   1 
....................   #define OPT_SHOW_AP_SSID    2 
....................   #define OPT_SHOW_AP_KEY     3 
....................   #define OPT_SHOW_AP_IP      4 
....................   #define OPT_MODE_AP         5 
....................   #define OPT_BACKLIGH        6 
....................   #define OPT_EXIT            7 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[9][17]    =  { {"ESTACION IP     "}, 
....................                                         {"ESTACION SSID   "}, 
....................                                         {"AP SSID         "}, 
....................                                         {"AP KEY          "}, 
....................                                         {"AP IP           "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacin     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 7; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
10C6:  BSF    03.6
10C7:  CLRF   42
10C8:  CLRF   43
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
10C9:  SWAPF  42,W
10CA:  MOVWF  77
10CB:  MOVLW  F0
10CC:  ANDWF  77,F
10CD:  MOVF   77,W
10CE:  MOVWF  44
10CF:  MOVLW  0C
10D0:  MOVWF  47
10D1:  BCF    0A.4
10D2:  BCF    03.6
10D3:  CALL   761
10D4:  BSF    0A.4
10D5:  MOVLW  04
10D6:  BSF    03.6
10D7:  MOVWF  0D
10D8:  MOVLW  01
10D9:  MOVWF  0F
10DA:  MOVF   44,W
10DB:  ADDWF  0D,F
10DC:  BTFSC  03.0
10DD:  INCF   0F,F
10DE:  BCF    0A.4
10DF:  BCF    03.6
10E0:  CALL   7BB
10E1:  BSF    0A.4
....................    showBottonMenu(); 
10E2:  BCF    0A.4
10E3:  BSF    0A.3
10E4:  CALL   2CD
10E5:  BSF    0A.4
10E6:  BCF    0A.3
....................    while(!exit){ 
10E7:  BSF    03.6
10E8:  MOVF   43,F
10E9:  BTFSS  03.2
10EA:  GOTO   15C
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
10EB:  BCF    0A.4
10EC:  BSF    0A.3
10ED:  BCF    03.6
10EE:  CALL   310
10EF:  BSF    0A.4
10F0:  BCF    0A.3
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
10F1:  BSF    03.5
10F2:  BSF    06.4
10F3:  BCF    03.5
10F4:  BTFSC  06.4
10F5:  GOTO   138
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
10F6:  MOVLW  02
10F7:  BSF    03.6
10F8:  MOVWF  44
10F9:  MOVLW  FA
10FA:  MOVWF  56
10FB:  BCF    0A.4
10FC:  BCF    03.6
10FD:  CALL   5DE
10FE:  BSF    0A.4
10FF:  BSF    03.6
1100:  DECFSZ 44,F
1101:  GOTO   0F9
....................          BEEP; 
1102:  MOVLW  04
1103:  MOVWF  45
1104:  MOVLW  B9
1105:  MOVWF  44
1106:  CLRF   47
1107:  MOVLW  14
1108:  MOVWF  46
1109:  BCF    0A.4
110A:  BSF    0A.3
110B:  BCF    03.6
110C:  CALL   596
110D:  BSF    0A.4
110E:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
110F:  BSF    03.6
1110:  INCF   42,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
1111:  MOVF   42,W
1112:  BCF    03.6
1113:  SUBWF  60,W
1114:  BTFSC  03.0
1115:  GOTO   119
....................             optSelected = 0; 
1116:  BSF    03.6
1117:  CLRF   42
1118:  BCF    03.6
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
1119:  BSF    03.6
111A:  SWAPF  42,W
111B:  MOVWF  77
111C:  MOVLW  F0
111D:  ANDWF  77,F
111E:  MOVF   77,W
111F:  MOVWF  44
1120:  MOVLW  0C
1121:  MOVWF  47
1122:  BCF    0A.4
1123:  BCF    03.6
1124:  CALL   761
1125:  BSF    0A.4
1126:  MOVLW  04
1127:  BSF    03.6
1128:  MOVWF  0D
1129:  MOVLW  01
112A:  MOVWF  0F
112B:  MOVF   44,W
112C:  ADDWF  0D,F
112D:  BTFSC  03.0
112E:  INCF   0F,F
112F:  BCF    0A.4
1130:  BCF    03.6
1131:  CALL   7BB
1132:  BSF    0A.4
....................          showBottonMenu(); 
1133:  BCF    0A.4
1134:  BSF    0A.3
1135:  CALL   2CD
1136:  BSF    0A.4
1137:  BCF    0A.3
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
1138:  BSF    03.5
1139:  BSF    06.5
113A:  BCF    03.5
113B:  BTFSC  06.5
113C:  GOTO   15A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
113D:  MOVLW  02
113E:  BSF    03.6
113F:  MOVWF  44
1140:  MOVLW  FA
1141:  MOVWF  56
1142:  BCF    0A.4
1143:  BCF    03.6
1144:  CALL   5DE
1145:  BSF    0A.4
1146:  BSF    03.6
1147:  DECFSZ 44,F
1148:  GOTO   140
....................          BEEP; 
1149:  MOVLW  04
114A:  MOVWF  45
114B:  MOVLW  B9
114C:  MOVWF  44
114D:  CLRF   47
114E:  MOVLW  14
114F:  MOVWF  46
1150:  BCF    0A.4
1151:  BSF    0A.3
1152:  BCF    03.6
1153:  CALL   596
1154:  BSF    0A.4
1155:  BCF    0A.3
....................          // Rompe el Loop 
....................          exit = 1; 
1156:  MOVLW  01
1157:  BSF    03.6
1158:  MOVWF  43
1159:  BCF    03.6
....................       } // Fin KEY_OK 
115A:  GOTO   0E7
115B:  BSF    03.6
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
115C:  MOVLW  01
115D:  ADDWF  42,W
115E:  MOVWF  78
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
....................   printf(lcd_putc, "SALIR"); 
....................    
....................   while(1){ 
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
....................            // Elimina el rebote 
....................            delay_ms(500); 
....................            break; 
....................      } 
....................   } 
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
0ACD:  MOVLW  01
0ACE:  BSF    03.6
0ACF:  MOVWF  48
0AD0:  MOVLW  02
0AD1:  MOVWF  49
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
*
0AE6:  MOVLW  5C
0AE7:  BSF    03.6
0AE8:  MOVWF  0D
0AE9:  MOVLW  03
0AEA:  MOVWF  0F
0AEB:  BCF    03.6
0AEC:  CALL   000
0AED:  RETURN
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
1163:  BSF    03.6
1164:  CLRF   42
1165:  CLRF   43
1166:  BCF    03.6
1167:  CLRF   2B
1168:  BTFSC  0B.7
1169:  BSF    2B.7
116A:  BCF    0B.7
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
116B:  BSF    03.6
116C:  MOVF   42,W
116D:  BSF    03.5
116E:  MOVWF  11
116F:  MOVLW  0F
1170:  MOVWF  12
1171:  BCF    0A.4
1172:  BCF    03.5
1173:  BCF    03.6
1174:  CALL   397
1175:  BSF    0A.4
1176:  BTFSC  2B.7
1177:  BSF    0B.7
1178:  MOVF   78,W
1179:  BSF    03.6
117A:  MOVWF  44
117B:  MOVLW  0C
117C:  MOVWF  47
117D:  BCF    0A.4
117E:  BCF    03.6
117F:  CALL   761
1180:  BSF    0A.4
1181:  MOVLW  44
1182:  BSF    03.6
1183:  MOVWF  0D
1184:  MOVLW  01
1185:  MOVWF  0F
1186:  MOVF   44,W
1187:  ADDWF  0D,F
1188:  BTFSC  03.0
1189:  INCF   0F,F
118A:  BCF    0A.4
118B:  BCF    03.6
118C:  CALL   7BB
118D:  BSF    0A.4
....................    showBottonMenu(); 
118E:  BCF    0A.4
118F:  BSF    0A.3
1190:  CALL   2CD
1191:  BSF    0A.4
1192:  BCF    0A.3
....................     
....................    while(!exit){ 
1193:  BSF    03.6
1194:  MOVF   43,F
1195:  BTFSS  03.2
1196:  GOTO   23C
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
1197:  BCF    0A.4
1198:  BSF    0A.3
1199:  BCF    03.6
119A:  CALL   310
119B:  BSF    0A.4
119C:  BCF    0A.3
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
119D:  BSF    03.5
119E:  BSF    06.4
119F:  BCF    03.5
11A0:  BTFSC  06.4
11A1:  GOTO   1F1
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
11A2:  MOVLW  02
11A3:  BSF    03.6
11A4:  MOVWF  44
11A5:  MOVLW  FA
11A6:  MOVWF  56
11A7:  BCF    0A.4
11A8:  BCF    03.6
11A9:  CALL   5DE
11AA:  BSF    0A.4
11AB:  BSF    03.6
11AC:  DECFSZ 44,F
11AD:  GOTO   1A5
....................          BEEP; 
11AE:  MOVLW  04
11AF:  MOVWF  45
11B0:  MOVLW  B9
11B1:  MOVWF  44
11B2:  CLRF   47
11B3:  MOVLW  14
11B4:  MOVWF  46
11B5:  BCF    0A.4
11B6:  BSF    0A.3
11B7:  BCF    03.6
11B8:  CALL   596
11B9:  BSF    0A.4
11BA:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
11BB:  BSF    03.6
11BC:  INCF   42,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
11BD:  MOVF   42,W
11BE:  BCF    03.6
11BF:  SUBWF  61,W
11C0:  BTFSC  03.0
11C1:  GOTO   1C5
....................             optSelected = 0; 
11C2:  BSF    03.6
11C3:  CLRF   42
11C4:  BCF    03.6
11C5:  CLRF   2B
11C6:  BTFSC  0B.7
11C7:  BSF    2B.7
11C8:  BCF    0B.7
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
11C9:  BSF    03.6
11CA:  MOVF   42,W
11CB:  BSF    03.5
11CC:  MOVWF  11
11CD:  MOVLW  0F
11CE:  MOVWF  12
11CF:  BCF    0A.4
11D0:  BCF    03.5
11D1:  BCF    03.6
11D2:  CALL   397
11D3:  BSF    0A.4
11D4:  BTFSC  2B.7
11D5:  BSF    0B.7
11D6:  MOVF   78,W
11D7:  BSF    03.6
11D8:  MOVWF  44
11D9:  MOVLW  0C
11DA:  MOVWF  47
11DB:  BCF    0A.4
11DC:  BCF    03.6
11DD:  CALL   761
11DE:  BSF    0A.4
11DF:  MOVLW  44
11E0:  BSF    03.6
11E1:  MOVWF  0D
11E2:  MOVLW  01
11E3:  MOVWF  0F
11E4:  MOVF   44,W
11E5:  ADDWF  0D,F
11E6:  BTFSC  03.0
11E7:  INCF   0F,F
11E8:  BCF    0A.4
11E9:  BCF    03.6
11EA:  CALL   7BB
11EB:  BSF    0A.4
....................          showBottonMenu(); 
11EC:  BCF    0A.4
11ED:  BSF    0A.3
11EE:  CALL   2CD
11EF:  BSF    0A.4
11F0:  BCF    0A.3
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
11F1:  BSF    03.5
11F2:  BSF    06.5
11F3:  BCF    03.5
11F4:  BTFSC  06.5
11F5:  GOTO   23A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
11F6:  MOVLW  02
11F7:  BSF    03.6
11F8:  MOVWF  44
11F9:  MOVLW  FA
11FA:  MOVWF  56
11FB:  BCF    0A.4
11FC:  BCF    03.6
11FD:  CALL   5DE
11FE:  BSF    0A.4
11FF:  BSF    03.6
1200:  DECFSZ 44,F
1201:  GOTO   1F9
....................          BEEP; 
1202:  MOVLW  04
1203:  MOVWF  45
1204:  MOVLW  B9
1205:  MOVWF  44
1206:  CLRF   47
1207:  MOVLW  14
1208:  MOVWF  46
1209:  BCF    0A.4
120A:  BSF    0A.3
120B:  BCF    03.6
120C:  CALL   596
120D:  BSF    0A.4
120E:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
120F:  MOVF   61,W
1210:  BSF    03.6
1211:  SUBWF  42,W
1212:  BTFSS  03.2
1213:  GOTO   217
....................             exit = 1; 
1214:  MOVLW  01
1215:  MOVWF  43
....................          }else{ 
1216:  GOTO   23B
....................             output_high(PIN_OUT[optSelected]); 
1217:  BCF    03.0
1218:  RLF    42,W
1219:  ADDLW  2C
121A:  MOVWF  04
121B:  BCF    03.7
121C:  INCF   04,F
121D:  MOVF   00,W
121E:  MOVWF  45
121F:  DECF   04,F
1220:  MOVF   00,W
1221:  MOVWF  44
1222:  MOVWF  57
1223:  MOVLW  01
1224:  MOVWF  58
1225:  CLRF   5A
1226:  CLRF   59
1227:  BCF    0A.4
1228:  BSF    0A.3
1229:  BCF    03.6
122A:  CALL   2EE
122B:  BSF    0A.4
122C:  BCF    0A.3
122D:  BSF    03.6
122E:  MOVF   44,W
122F:  MOVWF  57
1230:  CLRF   58
1231:  CLRF   5A
1232:  MOVLW  80
1233:  MOVWF  59
1234:  BCF    0A.4
1235:  BSF    0A.3
1236:  BCF    03.6
1237:  CALL   2EE
1238:  BSF    0A.4
1239:  BCF    0A.3
123A:  BSF    03.6
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
123B:  GOTO   194
....................    } // FIN While Infinito 
....................  
....................    return 0; 
123C:  MOVLW  00
123D:  MOVWF  78
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
*
1242:  BSF    03.6
1243:  CLRF   42
1244:  CLRF   43
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
1245:  SWAPF  42,W
1246:  MOVWF  77
1247:  MOVLW  F0
1248:  ANDWF  77,F
1249:  MOVF   77,W
124A:  MOVWF  44
124B:  MOVLW  0C
124C:  MOVWF  47
124D:  BCF    0A.4
124E:  BCF    03.6
124F:  CALL   761
1250:  BSF    0A.4
1251:  MOVLW  DA
1252:  BSF    03.6
1253:  MOVWF  0D
1254:  MOVLW  01
1255:  MOVWF  0F
1256:  MOVF   44,W
1257:  ADDWF  0D,F
1258:  BTFSC  03.0
1259:  INCF   0F,F
125A:  BCF    0A.4
125B:  BCF    03.6
125C:  CALL   7BB
125D:  BSF    0A.4
....................    showBottonMenu(); 
125E:  BCF    0A.4
125F:  BSF    0A.3
1260:  CALL   2CD
1261:  BSF    0A.4
1262:  BCF    0A.3
....................     
....................    while(!exit){ 
1263:  BSF    03.6
1264:  MOVF   43,F
1265:  BTFSS  03.2
1266:  GOTO   2FE
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
1267:  BCF    0A.4
1268:  BSF    0A.3
1269:  BCF    03.6
126A:  CALL   310
126B:  BSF    0A.4
126C:  BCF    0A.3
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
126D:  BSF    03.5
126E:  BSF    06.4
126F:  BCF    03.5
1270:  BTFSC  06.4
1271:  GOTO   2B4
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1272:  MOVLW  02
1273:  BSF    03.6
1274:  MOVWF  44
1275:  MOVLW  FA
1276:  MOVWF  56
1277:  BCF    0A.4
1278:  BCF    03.6
1279:  CALL   5DE
127A:  BSF    0A.4
127B:  BSF    03.6
127C:  DECFSZ 44,F
127D:  GOTO   275
....................          BEEP; 
127E:  MOVLW  04
127F:  MOVWF  45
1280:  MOVLW  B9
1281:  MOVWF  44
1282:  CLRF   47
1283:  MOVLW  14
1284:  MOVWF  46
1285:  BCF    0A.4
1286:  BSF    0A.3
1287:  BCF    03.6
1288:  CALL   596
1289:  BSF    0A.4
128A:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
128B:  BSF    03.6
128C:  INCF   42,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
128D:  MOVF   42,W
128E:  BCF    03.6
128F:  SUBWF  62,W
1290:  BTFSC  03.0
1291:  GOTO   295
....................             optSelected = 0; 
1292:  BSF    03.6
1293:  CLRF   42
1294:  BCF    03.6
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
1295:  BSF    03.6
1296:  SWAPF  42,W
1297:  MOVWF  77
1298:  MOVLW  F0
1299:  ANDWF  77,F
129A:  MOVF   77,W
129B:  MOVWF  44
129C:  MOVLW  0C
129D:  MOVWF  47
129E:  BCF    0A.4
129F:  BCF    03.6
12A0:  CALL   761
12A1:  BSF    0A.4
12A2:  MOVLW  DA
12A3:  BSF    03.6
12A4:  MOVWF  0D
12A5:  MOVLW  01
12A6:  MOVWF  0F
12A7:  MOVF   44,W
12A8:  ADDWF  0D,F
12A9:  BTFSC  03.0
12AA:  INCF   0F,F
12AB:  BCF    0A.4
12AC:  BCF    03.6
12AD:  CALL   7BB
12AE:  BSF    0A.4
....................          showBottonMenu(); 
12AF:  BCF    0A.4
12B0:  BSF    0A.3
12B1:  CALL   2CD
12B2:  BSF    0A.4
12B3:  BCF    0A.3
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
12B4:  BSF    03.5
12B5:  BSF    06.5
12B6:  BCF    03.5
12B7:  BTFSC  06.5
12B8:  GOTO   2FC
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
12B9:  MOVLW  02
12BA:  BSF    03.6
12BB:  MOVWF  44
12BC:  MOVLW  FA
12BD:  MOVWF  56
12BE:  BCF    0A.4
12BF:  BCF    03.6
12C0:  CALL   5DE
12C1:  BSF    0A.4
12C2:  BSF    03.6
12C3:  DECFSZ 44,F
12C4:  GOTO   2BC
....................          BEEP; 
12C5:  MOVLW  04
12C6:  MOVWF  45
12C7:  MOVLW  B9
12C8:  MOVWF  44
12C9:  CLRF   47
12CA:  MOVLW  14
12CB:  MOVWF  46
12CC:  BCF    0A.4
12CD:  BSF    0A.3
12CE:  BCF    03.6
12CF:  CALL   596
12D0:  BSF    0A.4
12D1:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
12D2:  MOVF   62,W
12D3:  BSF    03.6
12D4:  SUBWF  42,W
12D5:  BTFSS  03.2
12D6:  GOTO   2DA
....................             exit = 1; 
12D7:  MOVLW  01
12D8:  MOVWF  43
....................          }else{ 
12D9:  GOTO   2FD
....................             output_low(PIN_OUT[optSelected]); 
12DA:  BCF    03.0
12DB:  RLF    42,W
12DC:  ADDLW  2C
12DD:  MOVWF  04
12DE:  BCF    03.7
12DF:  INCF   04,F
12E0:  MOVF   00,W
12E1:  MOVWF  45
12E2:  DECF   04,F
12E3:  MOVF   00,W
12E4:  MOVWF  44
12E5:  MOVWF  57
12E6:  CLRF   58
12E7:  CLRF   5A
12E8:  CLRF   59
12E9:  BCF    0A.4
12EA:  BSF    0A.3
12EB:  BCF    03.6
12EC:  CALL   2EE
12ED:  BSF    0A.4
12EE:  BCF    0A.3
12EF:  BSF    03.6
12F0:  MOVF   44,W
12F1:  MOVWF  57
12F2:  CLRF   58
12F3:  CLRF   5A
12F4:  MOVLW  80
12F5:  MOVWF  59
12F6:  BCF    0A.4
12F7:  BSF    0A.3
12F8:  BCF    03.6
12F9:  CALL   2EE
12FA:  BSF    0A.4
12FB:  BCF    0A.3
12FC:  BSF    03.6
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
12FD:  GOTO   264
....................    } // FIN While Infinito 
....................  
....................    return 0; 
12FE:  MOVLW  00
12FF:  MOVWF  78
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
....................  
....................    /******************************************** 
....................    *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................    *********************************************/ 
....................    run_command_wifi(); 
*
1304:  BCF    0A.4
1305:  BSF    0A.3
1306:  CALL   310
1307:  BSF    0A.4
1308:  BCF    0A.3
....................    /********************************************/ 
....................     
....................    int optSelected = 0; 
....................    int exit = 0; 
1309:  BSF    03.6
130A:  CLRF   42
130B:  CLRF   43
130C:  BCF    03.6
130D:  CLRF   2B
130E:  BTFSC  0B.7
130F:  BSF    2B.7
1310:  BCF    0B.7
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
1311:  BSF    03.6
1312:  MOVF   42,W
1313:  BSF    03.5
1314:  MOVWF  11
1315:  MOVLW  11
1316:  MOVWF  12
1317:  BCF    0A.4
1318:  BCF    03.5
1319:  BCF    03.6
131A:  CALL   397
131B:  BSF    0A.4
131C:  BTFSC  2B.7
131D:  BSF    0B.7
131E:  MOVF   78,W
131F:  BSF    03.6
1320:  MOVWF  44
1321:  MOVLW  0C
1322:  MOVWF  47
1323:  BCF    0A.4
1324:  BCF    03.6
1325:  CALL   761
1326:  BSF    0A.4
1327:  MOVLW  7A
1328:  BSF    03.6
1329:  MOVWF  0D
132A:  MOVLW  02
132B:  MOVWF  0F
132C:  MOVF   44,W
132D:  ADDWF  0D,F
132E:  BTFSC  03.0
132F:  INCF   0F,F
1330:  BCF    0A.4
1331:  BCF    03.6
1332:  CALL   7BB
1333:  BSF    0A.4
....................    showBottonMenu(); 
1334:  BCF    0A.4
1335:  BSF    0A.3
1336:  CALL   2CD
1337:  BSF    0A.4
1338:  BCF    0A.3
....................     
....................    while(!exit){ 
1339:  BSF    03.6
133A:  MOVF   43,F
133B:  BTFSS  03.2
133C:  GOTO   3E9
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
133D:  BSF    03.5
133E:  BCF    03.6
133F:  BSF    06.4
1340:  BCF    03.5
1341:  BTFSC  06.4
1342:  GOTO   392
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1343:  MOVLW  02
1344:  BSF    03.6
1345:  MOVWF  44
1346:  MOVLW  FA
1347:  MOVWF  56
1348:  BCF    0A.4
1349:  BCF    03.6
134A:  CALL   5DE
134B:  BSF    0A.4
134C:  BSF    03.6
134D:  DECFSZ 44,F
134E:  GOTO   346
....................          BEEP; 
134F:  MOVLW  04
1350:  MOVWF  45
1351:  MOVLW  B9
1352:  MOVWF  44
1353:  CLRF   47
1354:  MOVLW  14
1355:  MOVWF  46
1356:  BCF    0A.4
1357:  BSF    0A.3
1358:  BCF    03.6
1359:  CALL   596
135A:  BSF    0A.4
135B:  BCF    0A.3
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
135C:  BSF    03.6
135D:  INCF   42,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
135E:  MOVF   42,W
135F:  BCF    03.6
1360:  SUBWF  63,W
1361:  BTFSC  03.0
1362:  GOTO   366
....................             optSelected = 0; 
1363:  BSF    03.6
1364:  CLRF   42
1365:  BCF    03.6
1366:  CLRF   2B
1367:  BTFSC  0B.7
1368:  BSF    2B.7
1369:  BCF    0B.7
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
136A:  BSF    03.6
136B:  MOVF   42,W
136C:  BSF    03.5
136D:  MOVWF  11
136E:  MOVLW  11
136F:  MOVWF  12
1370:  BCF    0A.4
1371:  BCF    03.5
1372:  BCF    03.6
1373:  CALL   397
1374:  BSF    0A.4
1375:  BTFSC  2B.7
1376:  BSF    0B.7
1377:  MOVF   78,W
1378:  BSF    03.6
1379:  MOVWF  44
137A:  MOVLW  0C
137B:  MOVWF  47
137C:  BCF    0A.4
137D:  BCF    03.6
137E:  CALL   761
137F:  BSF    0A.4
1380:  MOVLW  7A
1381:  BSF    03.6
1382:  MOVWF  0D
1383:  MOVLW  02
1384:  MOVWF  0F
1385:  MOVF   44,W
1386:  ADDWF  0D,F
1387:  BTFSC  03.0
1388:  INCF   0F,F
1389:  BCF    0A.4
138A:  BCF    03.6
138B:  CALL   7BB
138C:  BSF    0A.4
....................          showBottonMenu(); 
138D:  BCF    0A.4
138E:  BSF    0A.3
138F:  CALL   2CD
1390:  BSF    0A.4
1391:  BCF    0A.3
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
1392:  BSF    03.5
1393:  BSF    06.5
1394:  BCF    03.5
1395:  BTFSC  06.5
1396:  GOTO   3E7
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1397:  MOVLW  02
1398:  BSF    03.6
1399:  MOVWF  44
139A:  MOVLW  FA
139B:  MOVWF  56
139C:  BCF    0A.4
139D:  BCF    03.6
139E:  CALL   5DE
139F:  BSF    0A.4
13A0:  BSF    03.6
13A1:  DECFSZ 44,F
13A2:  GOTO   39A
....................          BEEP; 
13A3:  MOVLW  04
13A4:  MOVWF  45
13A5:  MOVLW  B9
13A6:  MOVWF  44
13A7:  CLRF   47
13A8:  MOVLW  14
13A9:  MOVWF  46
13AA:  BCF    0A.4
13AB:  BSF    0A.3
13AC:  BCF    03.6
13AD:  CALL   596
13AE:  BSF    0A.4
13AF:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
13B0:  MOVF   63,W
13B1:  BSF    03.6
13B2:  SUBWF  42,W
13B3:  BTFSS  03.2
13B4:  GOTO   3B8
....................             exit = 1; 
13B5:  MOVLW  01
13B6:  MOVWF  43
....................          }else{ 
13B7:  GOTO   3E8
....................             executeSetup(optSelected); 
13B8:  MOVF   42,W
13B9:  MOVWF  44
13BA:  BCF    03.6
13BB:  CLRF   2B
13BC:  BTFSC  0B.7
13BD:  BSF    2B.7
13BE:  BCF    0B.7
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
13BF:  BSF    03.6
13C0:  MOVF   42,W
13C1:  BSF    03.5
13C2:  MOVWF  11
13C3:  MOVLW  11
13C4:  MOVWF  12
13C5:  BCF    0A.4
13C6:  BCF    03.5
13C7:  BCF    03.6
13C8:  CALL   397
13C9:  BSF    0A.4
13CA:  BTFSC  2B.7
13CB:  BSF    0B.7
13CC:  MOVF   78,W
13CD:  BSF    03.6
13CE:  MOVWF  44
13CF:  MOVLW  0C
13D0:  MOVWF  47
13D1:  BCF    0A.4
13D2:  BCF    03.6
13D3:  CALL   761
13D4:  BSF    0A.4
13D5:  MOVLW  7A
13D6:  BSF    03.6
13D7:  MOVWF  0D
13D8:  MOVLW  02
13D9:  MOVWF  0F
13DA:  MOVF   44,W
13DB:  ADDWF  0D,F
13DC:  BTFSC  03.0
13DD:  INCF   0F,F
13DE:  BCF    0A.4
13DF:  BCF    03.6
13E0:  CALL   7BB
13E1:  BSF    0A.4
....................             showBottonMenu(); 
13E2:  BCF    0A.4
13E3:  BSF    0A.3
13E4:  CALL   2CD
13E5:  BSF    0A.4
13E6:  BCF    0A.3
13E7:  BSF    03.6
....................          } 
....................       } // Fin KEY_OK 
13E8:  GOTO   33A
....................    } // FIN While Infinito 
....................  
....................    return 0; 
13E9:  MOVLW  00
13EA:  MOVWF  78
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................   /* 
....................   switch(optSelect){ 
....................       
....................      case OPT_SHOW_STA_IP: 
....................         //printf(lcd_putc, "\fOPT_SHOW_STA_IP"); 
....................         break; 
....................          
....................      case OPT_SHOW_STA_SSID: 
....................         //printf(lcd_putc, "\fOPT_SHOW_STA_SSID"); 
....................         break; 
....................          
....................      case OPT_SHOW_AP_SSID: 
....................         //printf(lcd_putc, "\fOPT_SHOW_AP_SSID"); 
....................         break; 
....................          
....................      case OPT_SHOW_AP_KEY: 
....................         //printf(lcd_putc, "\fOPT_SHOW_AP_KEY"); 
....................         break; 
....................          
....................      case OPT_SHOW_AP_IP: 
....................         //printf(lcd_putc, "\fOPT_SHOW_AP_IP"); 
....................         break; 
....................          
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
....................         break; 
....................          
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
....................            printf(lcd_putc, "\fBacklight On"); 
....................         }else{ 
....................            printf(lcd_putc, "\fBacklight Off"); 
....................         } 
....................         break; 
....................          
....................      case OPT_EXIT: 
....................         break; 
....................          
....................   } 
....................    
....................   if(optSelect!=OPT_EXIT){ 
....................    pressExit(); 
....................   }*/ 
.................... } 
....................    
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
....................   showBottonMenu(); 
....................    
....................   while(!exit){ 
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
....................         BEEP; 
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
....................            optSelected = 0; 
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
....................         showBottonMenu(); 
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
....................         BEEP; 
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
....................            exit = 1; 
....................         }else{ 
....................            switch(optSelected){ 
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
....................                  write_eeprom(0,'1'); 
....................                  delay_ms(10); 
....................                  printf(lcd_putc, "\fConfig Cliente"); 
....................                  break; 
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
....................                  write_eeprom(0,'2'); 
....................                  delay_ms(10); 
....................                  printf(lcd_putc, "\fConfig AP"); 
....................                  break; 
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
....................                  write_eeprom(0,'3'); 
....................                  delay_ms(10); 
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
....................                  break; 
....................            } 
....................            pressExit(); 
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
....................            showBottonMenu(); 
....................         } 
....................      } // Fin KEY_OK 
....................   } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
.................... #ZERO_RAM 
.................... /******************************************** 
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
04DE:  BTFSS  0C.5
04DF:  GOTO   4DE
04E0:  MOVF   1A,W
04E1:  BSF    03.6
04E2:  MOVWF  5F
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
04E3:  MOVF   5F,W
04E4:  MOVWF  60
*
05D1:  BCF    0C.5
05D2:  BCF    0A.3
05D3:  BCF    0A.4
05D4:  GOTO   02D
.................... } 
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  57
1004:  MOVWF  77
1005:  MOVLW  20
1006:  MOVWF  04
1007:  BCF    03.7
1008:  CLRF   00
1009:  INCF   04,F
100A:  DECFSZ 77,F
100B:  GOTO   008
100C:  CLRF   78
100D:  CLRF   79
100E:  CLRF   7A
100F:  CLRF   7B
1010:  CLRF   7C
1011:  CLRF   7D
1012:  CLRF   7E
1013:  MOVLW  50
1014:  MOVWF  77
1015:  MOVLW  A0
1016:  MOVWF  04
1017:  BCF    03.7
1018:  CLRF   00
1019:  INCF   04,F
101A:  DECFSZ 77,F
101B:  GOTO   018
101C:  MOVLW  60
101D:  MOVWF  77
101E:  MOVLW  10
101F:  MOVWF  04
1020:  BSF    03.7
1021:  CLRF   00
1022:  INCF   04,F
1023:  DECFSZ 77,F
1024:  GOTO   021
1025:  BCF    03.7
1026:  MOVLW  60
1027:  MOVWF  77
1028:  MOVLW  90
1029:  MOVWF  04
102A:  BSF    03.7
102B:  CLRF   00
102C:  INCF   04,F
102D:  DECFSZ 77,F
102E:  GOTO   02B
102F:  BCF    03.7
1030:  CLRF   20
1031:  BSF    03.5
1032:  BSF    03.6
1033:  BSF    07.3
1034:  MOVLW  08
1035:  BCF    03.6
1036:  MOVWF  19
1037:  MOVLW  02
1038:  MOVWF  1A
1039:  MOVLW  A6
103A:  MOVWF  18
103B:  MOVLW  90
103C:  BCF    03.5
103D:  MOVWF  18
103E:  BSF    03.5
103F:  BCF    06.0
1040:  BCF    03.5
1041:  BSF    06.0
1042:  CLRF   47
1043:  CLRF   46
1044:  CLRF   48
1045:  CLRF   49
1046:  CLRF   4A
1047:  CLRF   4B
1048:  CLRF   4C
1049:  CLRF   4D
104A:  CLRF   4E
104B:  CLRF   4F
104C:  MOVLW  01
104D:  MOVWF  50
104E:  CLRF   51
104F:  MOVLW  05
1050:  MOVWF  52
1051:  MOVLW  02
1052:  MOVWF  60
1053:  MOVLW  08
1054:  MOVWF  61
1055:  MOVWF  62
1056:  MOVLW  07
1057:  MOVWF  63
1058:  MOVLW  03
1059:  MOVWF  64
105A:  CLRF   65
105B:  BSF    03.5
105C:  BSF    03.6
105D:  MOVF   09,W
105E:  ANDLW  C0
105F:  MOVWF  09
1060:  BCF    03.6
1061:  BCF    1F.4
1062:  BCF    1F.5
1063:  MOVLW  00
1064:  BSF    03.6
1065:  MOVWF  08
1066:  BCF    03.5
1067:  CLRF   07
1068:  CLRF   08
1069:  CLRF   09
106A:  BCF    03.7
....................    {       
....................       /*for(int idxNC=0;idxNC<=255;idxNC++){ 
....................          write_eeprom(idxNC,0xFF); 
....................          delay_ms(10); 
....................       }*/ 
....................           
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
*
1092:  MOVLW  02
1093:  BSF    03.6
1094:  MOVWF  42
1095:  MOVLW  FA
1096:  MOVWF  56
1097:  BCF    0A.4
1098:  BCF    03.6
1099:  CALL   5DE
109A:  BSF    0A.4
109B:  BSF    03.6
109C:  DECFSZ 42,F
109D:  GOTO   095
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
109E:  MOVLW  30
109F:  BSF    03.5
10A0:  BCF    03.6
10A1:  MOVWF  15
10A2:  BCF    01.7
....................       set_tris_b(0b00110010); 
10A3:  MOVLW  32
10A4:  MOVWF  06
....................       enable_interrupts(INT_RDA);  
10A5:  BSF    0C.5
....................       enable_interrupts(GLOBAL);  
10A6:  MOVLW  C0
10A7:  BCF    03.5
10A8:  IORWF  0B,F
....................        
....................       // Inicializa la LCD 
....................       lcd_init(); 
10A9:  BCF    0A.4
10AA:  GOTO   70B
10AB:  BSF    0A.4
....................       printf(lcd_putc, "\fConfigurando..."); 
10AC:  MOVLW  D5
10AD:  BSF    03.6
10AE:  MOVWF  0D
10AF:  MOVLW  05
10B0:  MOVWF  0F
10B1:  BCF    0A.4
10B2:  BSF    0A.3
10B3:  BCF    03.6
10B4:  CALL   000
10B5:  BSF    0A.4
10B6:  BCF    0A.3
....................        
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
10B7:  BSF    03.5
10B8:  BCF    08.3
10B9:  BCF    03.5
10BA:  BSF    08.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
10BB:  BCF    0A.4
10BC:  BSF    0A.3
10BD:  GOTO   1B4
10BE:  BSF    0A.4
10BF:  BCF    0A.3
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
10C0:  MOVF   65,W
10C1:  ADDLW  FC
10C2:  BTFSC  03.0
10C3:  GOTO   3EE
10C4:  ADDLW  04
10C5:  GOTO   3F0
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
*
115F:  MOVF   78,W
1160:  BCF    03.6
1161:  MOVWF  65
....................                break; 
1162:  GOTO   3EE
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
*
123E:  MOVF   78,W
123F:  BCF    03.6
1240:  MOVWF  65
....................                break; 
1241:  GOTO   3EE
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
*
1300:  MOVF   78,W
1301:  BCF    03.6
1302:  MOVWF  65
....................                break; 
1303:  GOTO   3EE
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
*
13EB:  MOVF   78,W
13EC:  BCF    03.6
13ED:  MOVWF  65
....................                break; 
....................          } // Fin del Switch(menuActive) 
13EE:  GOTO   0C0
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
13EF:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
