CCS PCH C Compiler, Version 5.015, 5967               21-dic.-17 22:25

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   10968 bytes (17%)
                           Largest free fragment is 54564
               RAM used:   361 (9%) at main() level
                           458 (12%) worst case
               Stack used: 14 locations (10 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   2900
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  F9D.5
0004A:  GOTO   0054
0004E:  BTFSC  F9E.5
00050:  GOTO   0B68
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          MAIN.C: Funcion principal 
....................  
.................... *******************************************************/ 
....................  
.................... #include "header/config.h" 
.................... #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
00096:  MOVFF  FF2,0D
0009A:  BCF    FF2.7
0009C:  CLRF   FF7
0009E:  ADDLW  B0
000A0:  MOVWF  FF6
000A2:  MOVLW  00
000A4:  ADDWFC FF7,F
000A6:  TBLRD*+
000A8:  MOVF   FF5,W
000AA:  BTFSC  0D.7
000AC:  BSF    FF2.7
000AE:  RETURN 0
000B0:  DATA 22,7C
000B2:  DATA 21,7C
000B4:  DATA 20,7C
000B6:  DATA 04,7C
000B8:  DATA 00,7C
000BA:  DATA 01,7C
000BC:  DATA 02,7C
000BE:  DATA 03,7C
000C0:  CLRF   FF7
000C2:  ADDLW  D0
000C4:  MOVWF  FF6
000C6:  MOVLW  00
000C8:  ADDWFC FF7,F
000CA:  TBLRD*+
000CC:  MOVF   FF5,W
000CE:  RETURN 0
000D0:  DATA 2B,49
000D2:  DATA 50,44
000D4:  DATA 2C,00
000D6:  CLRF   FF7
000D8:  ADDLW  E6
000DA:  MOVWF  FF6
000DC:  MOVLW  00
000DE:  ADDWFC FF7,F
000E0:  TBLRD*+
000E2:  MOVF   FF5,W
000E4:  RETURN 0
000E6:  DATA 43,4D
000E8:  DATA 44,3A
000EA:  CLRF   FF7
000EC:  ADDLW  FA
000EE:  MOVWF  FF6
000F0:  MOVLW  00
000F2:  ADDWFC FF7,F
000F4:  TBLRD*+
000F6:  MOVF   FF5,W
000F8:  RETURN 0
000FA:  DATA 4F,4B
000FC:  DATA 0D,0A
000FE:  DATA 00,00
00100:  CLRF   FF7
00102:  ADDLW  10
00104:  MOVWF  FF6
00106:  MOVLW  01
00108:  ADDWFC FF7,F
0010A:  TBLRD*+
0010C:  MOVF   FF5,W
0010E:  RETURN 0
00110:  DATA 4E,6F
00112:  DATA 20,41
00114:  DATA 70,00
00116:  CLRF   FF7
00118:  ADDLW  26
0011A:  MOVWF  FF6
0011C:  MOVLW  01
0011E:  ADDWFC FF7,F
00120:  TBLRD*+
00122:  MOVF   FF5,W
00124:  RETURN 0
00126:  DATA 2B,43
00128:  DATA 57,4A
0012A:  DATA 41,50
0012C:  DATA 3A,00
0012E:  CLRF   FF7
00130:  ADDLW  3E
00132:  MOVWF  FF6
00134:  MOVLW  01
00136:  ADDWFC FF7,F
00138:  TBLRD*+
0013A:  MOVF   FF5,W
0013C:  RETURN 0
0013E:  DATA 43,4F
00140:  DATA 4E,4E
00142:  DATA 45,43
00144:  DATA 54,45
00146:  DATA 44,00
00148:  CLRF   FF7
0014A:  ADDLW  58
0014C:  MOVWF  FF6
0014E:  MOVLW  01
00150:  ADDWFC FF7,F
00152:  TBLRD*+
00154:  MOVF   FF5,W
00156:  RETURN 0
00158:  DATA 46,41
0015A:  DATA 49,4C
0015C:  DATA 00,00
0015E:  DATA 41,54
00160:  DATA 2B,43
00162:  DATA 49,50
00164:  DATA 53,45
00166:  DATA 4E,44
00168:  DATA 3D,25
0016A:  DATA 63,2C
0016C:  DATA 25,75
0016E:  DATA 0D,0A
00170:  DATA 00,00
00172:  DATA 41,54
00174:  DATA 2B,43
00176:  DATA 49,50
00178:  DATA 43,4C
0017A:  DATA 4F,53
0017C:  DATA 45,3D
0017E:  DATA 25,63
00180:  DATA 0D,0A
00182:  DATA 00,00
00184:  DATA 41,54
00186:  DATA 2B,43
00188:  DATA 49,50
0018A:  DATA 53,45
0018C:  DATA 4E,44
0018E:  DATA 3D,25
00190:  DATA 63,2C
00192:  DATA 25,75
00194:  DATA 0D,0A
00196:  DATA 00,00
00198:  DATA 41,54
0019A:  DATA 2B,43
0019C:  DATA 49,50
0019E:  DATA 43,4C
001A0:  DATA 4F,53
001A2:  DATA 45,3D
001A4:  DATA 25,63
001A6:  DATA 0D,0A
001A8:  DATA 00,00
001AA:  DATA 41,54
001AC:  DATA 2B,43
001AE:  DATA 57,51
001B0:  DATA 41,50
001B2:  DATA 0A,0D
001B4:  DATA 00,00
001B6:  DATA 41,54
001B8:  DATA 2B,43
001BA:  DATA 49,50
001BC:  DATA 53,45
001BE:  DATA 4E,44
001C0:  DATA 3D,25
001C2:  DATA 63,2C
001C4:  DATA 25,75
001C6:  DATA 0D,0A
001C8:  DATA 00,00
001CA:  DATA 41,54
001CC:  DATA 2B,43
001CE:  DATA 49,50
001D0:  DATA 43,4C
001D2:  DATA 4F,53
001D4:  DATA 45,3D
001D6:  DATA 25,63
001D8:  DATA 0D,0A
001DA:  DATA 00,00
001DC:  DATA 41,54
001DE:  DATA 2B,43
001E0:  DATA 57,53
001E2:  DATA 41,50
001E4:  DATA 5F,44
001E6:  DATA 45,46
001E8:  DATA 3D,25
001EA:  DATA 73,2C
001EC:  DATA 31,2C
001EE:  DATA 34,0D
001F0:  DATA 0A,00
001F2:  DATA 41,54
001F4:  DATA 2B,43
001F6:  DATA 49,50
001F8:  DATA 53,45
001FA:  DATA 4E,44
001FC:  DATA 3D,25
001FE:  DATA 63,2C
00200:  DATA 25,75
00202:  DATA 0D,0A
00204:  DATA 00,00
00206:  DATA 41,54
00208:  DATA 2B,43
0020A:  DATA 49,50
0020C:  DATA 43,4C
0020E:  DATA 4F,53
00210:  DATA 45,3D
00212:  DATA 25,63
00214:  DATA 0D,0A
00216:  DATA 00,00
00218:  DATA 41,54
0021A:  DATA 2B,43
0021C:  DATA 49,50
0021E:  DATA 53,45
00220:  DATA 4E,44
00222:  DATA 3D,25
00224:  DATA 63,2C
00226:  DATA 25,75
00228:  DATA 0D,0A
0022A:  DATA 00,00
0022C:  DATA 41,54
0022E:  DATA 2B,43
00230:  DATA 49,50
00232:  DATA 43,4C
00234:  DATA 4F,53
00236:  DATA 45,3D
00238:  DATA 25,63
0023A:  DATA 0D,0A
0023C:  DATA 00,00
0023E:  DATA 41,54
00240:  DATA 2B,52
00242:  DATA 53,54
00244:  DATA 0D,0A
00246:  DATA 00,00
00248:  DATA 41,54
0024A:  DATA 2B,43
0024C:  DATA 57,4D
0024E:  DATA 4F,44
00250:  DATA 45,3D
00252:  DATA 25,63
00254:  DATA 0D,0A
00256:  DATA 00,00
00258:  DATA 41,54
0025A:  DATA 2B,43
0025C:  DATA 57,4A
0025E:  DATA 41,50
00260:  DATA 3F,0D
00262:  DATA 0A,00
00264:  DATA 41,54
00266:  DATA 2B,43
00268:  DATA 57,4A
0026A:  DATA 41,50
0026C:  DATA 3D,25
0026E:  DATA 73,00
00270:  DATA 41,54
00272:  DATA 2B,43
00274:  DATA 57,4D
00276:  DATA 4F,44
00278:  DATA 45,3D
0027A:  DATA 25,63
0027C:  DATA 0D,0A
0027E:  DATA 00,00
00280:  DATA 41,54
00282:  DATA 2B,43
00284:  DATA 49,50
00286:  DATA 4D,55
00288:  DATA 58,3D
0028A:  DATA 31,0D
0028C:  DATA 0A,00
0028E:  DATA 41,54
00290:  DATA 2B,43
00292:  DATA 49,50
00294:  DATA 53,45
00296:  DATA 52,56
00298:  DATA 45,52
0029A:  DATA 3D,31
0029C:  DATA 2C,38
0029E:  DATA 30,0D
002A0:  DATA 0A,00
002A2:  DATA 45,6E
002A4:  DATA 63,65
002A6:  DATA 6E,64
002A8:  DATA 65,72
002AA:  DATA 20,4D
002AC:  DATA 61,6E
002AE:  DATA 75,61
002B0:  DATA 6C,00
002B2:  DATA 41,70
002B4:  DATA 61,67
002B6:  DATA 61,64
002B8:  DATA 6F,20
002BA:  DATA 4D,61
002BC:  DATA 6E,75
002BE:  DATA 61,6C
002C0:  DATA 20,00
002C2:  DATA 43,6F
002C4:  DATA 6E,66
002C6:  DATA 69,67
002C8:  DATA 75,72
002CA:  DATA 61,63
002CC:  DATA 69,6F
002CE:  DATA 6E,20
002D0:  DATA 20,00
002D2:  DATA 00,00
002D4:  DATA 00,00
002D6:  DATA 00,00
002D8:  DATA 00,00
002DA:  DATA 00,00
002DC:  DATA 00,00
002DE:  DATA 00,00
002E0:  DATA 00,00
002E2:  DATA 45,53
002E4:  DATA 54,41
002E6:  DATA 43,49
002E8:  DATA 4F,4E
002EA:  DATA 20,49
002EC:  DATA 50,20
002EE:  DATA 20,20
002F0:  DATA 20,20
002F2:  DATA 00,45
002F4:  DATA 53,54
002F6:  DATA 41,43
002F8:  DATA 49,4F
002FA:  DATA 4E,20
002FC:  DATA 53,53
002FE:  DATA 49,44
00300:  DATA 20,20
00302:  DATA 20,00
00304:  DATA 41,50
00306:  DATA 20,53
00308:  DATA 53,49
0030A:  DATA 44,20
0030C:  DATA 20,20
0030E:  DATA 20,20
00310:  DATA 20,20
00312:  DATA 20,20
00314:  DATA 00,41
00316:  DATA 50,20
00318:  DATA 4B,45
0031A:  DATA 59,20
0031C:  DATA 20,20
0031E:  DATA 20,20
00320:  DATA 20,20
00322:  DATA 20,20
00324:  DATA 20,00
00326:  DATA 41,50
00328:  DATA 20,49
0032A:  DATA 50,20
0032C:  DATA 20,20
0032E:  DATA 20,20
00330:  DATA 20,20
00332:  DATA 20,20
00334:  DATA 20,20
00336:  DATA 00,43
00338:  DATA 6F,6E
0033A:  DATA 66,20
0033C:  DATA 41,63
0033E:  DATA 63,65
00340:  DATA 73,73
00342:  DATA 6F,20
00344:  DATA 52,65
00346:  DATA 64,00
00348:  DATA 42,6F
0034A:  DATA 72,72
0034C:  DATA 61,72
0034E:  DATA 20,61
00350:  DATA 20,46
00352:  DATA 61,62
00354:  DATA 72,69
00356:  DATA 63,61
00358:  DATA 00,4F
0035A:  DATA 6E,2F
0035C:  DATA 4F,66
0035E:  DATA 66,20
00360:  DATA 42,61
00362:  DATA 63,6B
00364:  DATA 6C,69
00366:  DATA 67,68
00368:  DATA 74,00
0036A:  DATA 53,41
0036C:  DATA 4C,49
0036E:  DATA 52,20
00370:  DATA 20,20
00372:  DATA 20,20
00374:  DATA 20,20
00376:  DATA 20,20
00378:  DATA 20,20
0037A:  DATA 00,00
0037C:  DATA 45,73
0037E:  DATA 74,61
00380:  DATA 63,69
00382:  DATA F3,6E
00384:  DATA 20,20
00386:  DATA 20,20
00388:  DATA 20,00
0038A:  DATA 41,63
0038C:  DATA 63,65
0038E:  DATA 73,73
00390:  DATA 20,50
00392:  DATA 6F,69
00394:  DATA 6E,74
00396:  DATA 20,00
00398:  DATA 45,73
0039A:  DATA 74,61
0039C:  DATA 63,69
0039E:  DATA 6F,6E
003A0:  DATA 20,2B
003A2:  DATA 20,41
003A4:  DATA 50,00
003A6:  DATA 53,41
003A8:  DATA 4C,49
003AA:  DATA 52,20
003AC:  DATA 20,20
003AE:  DATA 20,20
003B0:  DATA 20,20
003B2:  DATA 20,00
003B4:  DATA 00,00
003B6:  DATA 00,00
003B8:  DATA 00,00
003BA:  DATA 00,00
003BC:  DATA 00,00
003BE:  DATA 00,00
003C0:  DATA 00,00
003C2:  DATA 53,41
003C4:  DATA 4C,49
003C6:  DATA 52,00
003C8:  DATA 5B,53
003CA:  DATA 49,47
003CC:  DATA 5D,20
003CE:  DATA 20,20
003D0:  DATA 20,20
003D2:  DATA 20,5B
003D4:  DATA 45,4E
003D6:  DATA 54,5D
003D8:  DATA 00,00
003DA:  DATA 0C,4F
003DC:  DATA 6E,20
003DE:  DATA 2D,3E
003E0:  DATA 20,25
003E2:  DATA 73,00
003E4:  DATA 0C,4F
003E6:  DATA 6E,20
003E8:  DATA 2D,3E
003EA:  DATA 20,25
003EC:  DATA 73,00
003EE:  DATA 0C,4F
003F0:  DATA 66,66
003F2:  DATA 2D,3E
003F4:  DATA 20,25
003F6:  DATA 73,00
003F8:  DATA 0C,4F
003FA:  DATA 66,66
003FC:  DATA 2D,3E
003FE:  DATA 20,25
00400:  DATA 73,00
00402:  DATA 41,54
00404:  DATA 2B,43
00406:  DATA 49,46
00408:  DATA 53,52
0040A:  DATA 0D,0A
0040C:  DATA 00,00
0040E:  DATA 0C,43
00410:  DATA 61,72
00412:  DATA 67,61
00414:  DATA 6E,64
00416:  DATA 6F,2E
00418:  DATA 2E,2E
0041A:  DATA 00,00
0041C:  DATA 41,54
0041E:  DATA 2B,43
00420:  DATA 49,46
00422:  DATA 53,52
00424:  DATA 0D,0A
00426:  DATA 00,00
00428:  DATA 0C,43
0042A:  DATA 61,72
0042C:  DATA 67,61
0042E:  DATA 6E,64
00430:  DATA 6F,2E
00432:  DATA 2E,2E
00434:  DATA 00,00
00436:  DATA 41,54
00438:  DATA 2B,43
0043A:  DATA 57,4A
0043C:  DATA 41,50
0043E:  DATA 3F,0D
00440:  DATA 0A,00
00442:  DATA 0C,43
00444:  DATA 61,72
00446:  DATA 67,61
00448:  DATA 6E,64
0044A:  DATA 6F,2E
0044C:  DATA 2E,2E
0044E:  DATA 00,00
00450:  DATA 0C,44
00452:  DATA 65,73
00454:  DATA 68,61
00456:  DATA 62,69
00458:  DATA 6C,69
0045A:  DATA 74,61
0045C:  DATA 64,6F
0045E:  DATA 00,00
00460:  DATA 41,54
00462:  DATA 2B,43
00464:  DATA 57,53
00466:  DATA 41,50
00468:  DATA 3F,0D
0046A:  DATA 0A,00
0046C:  DATA 0C,43
0046E:  DATA 61,72
00470:  DATA 67,61
00472:  DATA 6E,64
00474:  DATA 6F,2E
00476:  DATA 2E,2E
00478:  DATA 00,00
0047A:  DATA 0C,44
0047C:  DATA 65,73
0047E:  DATA 68,61
00480:  DATA 62,69
00482:  DATA 6C,69
00484:  DATA 74,61
00486:  DATA 64,6F
00488:  DATA 00,00
0048A:  DATA 41,54
0048C:  DATA 2B,43
0048E:  DATA 57,53
00490:  DATA 41,50
00492:  DATA 3F,0D
00494:  DATA 0A,00
00496:  DATA 0C,43
00498:  DATA 61,72
0049A:  DATA 67,61
0049C:  DATA 6E,64
0049E:  DATA 6F,2E
004A0:  DATA 2E,2E
004A2:  DATA 00,00
004A4:  DATA 0C,44
004A6:  DATA 65,73
004A8:  DATA 68,61
004AA:  DATA 62,69
004AC:  DATA 6C,69
004AE:  DATA 74,61
004B0:  DATA 64,6F
004B2:  DATA 00,00
004B4:  DATA 0C,42
004B6:  DATA 6F,72
004B8:  DATA 72,61
004BA:  DATA 6E,64
004BC:  DATA 6F,20
004BE:  DATA 45,45
004C0:  DATA 45,50
004C2:  DATA 52,4F
004C4:  DATA 4D,00
004C6:  DATA 0C,42
004C8:  DATA 6F,72
004CA:  DATA 72,61
004CC:  DATA 6E,64
004CE:  DATA 6F,20
004D0:  DATA 52,45
004D2:  DATA 44,00
004D4:  DATA 41,54
004D6:  DATA 2B,43
004D8:  DATA 57,51
004DA:  DATA 41,50
004DC:  DATA 0A,0D
004DE:  DATA 00,00
004E0:  DATA 41,54
004E2:  DATA 2B,52
004E4:  DATA 53,54
004E6:  DATA 0A,0D
004E8:  DATA 00,00
004EA:  DATA 41,54
004EC:  DATA 2B,43
004EE:  DATA 57,53
004F0:  DATA 41,50
004F2:  DATA 5F,44
004F4:  DATA 45,46
004F6:  DATA 3D,22
004F8:  DATA 4B,72
004FA:  DATA 69,76
004FC:  DATA 65,72
004FE:  DATA 20,53
00500:  DATA 6D,61
00502:  DATA 72,74
00504:  DATA 48,6F
00506:  DATA 6D,65
00508:  DATA 22,2C
0050A:  DATA 22,6B
0050C:  DATA 72,69
0050E:  DATA 76,65
00510:  DATA 72,35
00512:  DATA 36,31
00514:  DATA 30,36
00516:  DATA 22,2C
00518:  DATA 31,2C
0051A:  DATA 34,0D
0051C:  DATA 0A,00
0051E:  DATA 0C,42
00520:  DATA 61,63
00522:  DATA 6B,6C
00524:  DATA 69,67
00526:  DATA 68,74
00528:  DATA 20,4F
0052A:  DATA 6E,00
0052C:  DATA 0C,42
0052E:  DATA 61,63
00530:  DATA 6B,6C
00532:  DATA 69,67
00534:  DATA 68,74
00536:  DATA 20,4F
00538:  DATA 66,66
0053A:  DATA 00,00
0053C:  DATA 41,54
0053E:  DATA 2B,43
00540:  DATA 57,4D
00542:  DATA 4F,44
00544:  DATA 45,5F
00546:  DATA 44,45
00548:  DATA 46,3D
0054A:  DATA 31,0D
0054C:  DATA 0A,00
0054E:  DATA 0C,43
00550:  DATA 6F,6E
00552:  DATA 66,69
00554:  DATA 67,20
00556:  DATA 43,6C
00558:  DATA 69,65
0055A:  DATA 6E,74
0055C:  DATA 65,00
0055E:  DATA 41,54
00560:  DATA 2B,43
00562:  DATA 57,4D
00564:  DATA 4F,44
00566:  DATA 45,5F
00568:  DATA 44,45
0056A:  DATA 46,3D
0056C:  DATA 32,0D
0056E:  DATA 0A,00
00570:  DATA 0C,43
00572:  DATA 6F,6E
00574:  DATA 66,69
00576:  DATA 67,20
00578:  DATA 41,50
0057A:  DATA 00,00
0057C:  DATA 41,54
0057E:  DATA 2B,43
00580:  DATA 57,4D
00582:  DATA 4F,44
00584:  DATA 45,5F
00586:  DATA 44,45
00588:  DATA 46,3D
0058A:  DATA 33,0D
0058C:  DATA 0A,00
0058E:  DATA 0C,43
00590:  DATA 6F,6E
00592:  DATA 66,69
00594:  DATA 67,20
00596:  DATA 43,6C
00598:  DATA 69,65
0059A:  DATA 6E,74
0059C:  DATA 65,41
0059E:  DATA 50,00
*
00792:  ADDWF  FE8,W
00794:  CLRF   FF7
00796:  RLCF   FF7,F
00798:  ADDLW  AD
0079A:  MOVWF  FF6
0079C:  MOVLW  07
0079E:  ADDWFC FF7,F
007A0:  TBLRD*-
007A2:  MOVF   FF5,W
007A4:  MOVWF  FFA
007A6:  TBLRD*
007A8:  MOVF   FF5,W
007AA:  MOVWF  FF9
007AC:  DATA B6,05
007AE:  DATA 0E,06
007B0:  DATA E4,05
007B2:  DATA 38,06
007B4:  DATA 62,06
*
00862:  ADDWF  FE8,W
00864:  CLRF   FF7
00866:  RLCF   FF7,F
00868:  ADDLW  7D
0086A:  MOVWF  FF6
0086C:  MOVLW  08
0086E:  ADDWFC FF7,F
00870:  TBLRD*-
00872:  MOVF   FF5,W
00874:  MOVWF  FFA
00876:  TBLRD*
00878:  MOVF   FF5,W
0087A:  MOVWF  FF9
0087C:  DATA 56,08
0087E:  DATA 56,08
00880:  DATA 56,08
00882:  DATA 56,08
00884:  DATA 56,08
*
008FC:  ADDWF  FE8,W
008FE:  CLRF   FF7
00900:  RLCF   FF7,F
00902:  ADDLW  17
00904:  MOVWF  FF6
00906:  MOVLW  09
00908:  ADDWFC FF7,F
0090A:  TBLRD*-
0090C:  MOVF   FF5,W
0090E:  MOVWF  FFA
00910:  TBLRD*
00912:  MOVF   FF5,W
00914:  MOVWF  FF9
00916:  DATA F0,08
00918:  DATA F0,08
0091A:  DATA F0,08
0091C:  DATA F0,08
*
00B80:  DATA 0C,49
00B82:  DATA 6E,69
00B84:  DATA 63,69
00B86:  DATA 61,6E
00B88:  DATA 64,6F
00B8A:  DATA 2E,2E
00B8C:  DATA 2E,00
*
00EDA:  TBLRD*+
00EDC:  MOVF   FF5,F
00EDE:  BZ    0EF8
00EE0:  MOVFF  FF6,16F
00EE4:  MOVFF  FF7,170
00EE8:  MOVFF  FF5,171
00EEC:  RCALL  0E6E
00EEE:  MOVFF  16F,FF6
00EF2:  MOVFF  170,FF7
00EF6:  BRA    0EDA
00EF8:  RETURN 0
00EFA:  TBLRD*+
00EFC:  MOVF   FF5,F
00EFE:  BZ    0F1A
00F00:  MOVFF  FF6,1B0
00F04:  MOVFF  FF7,1B1
00F08:  MOVF   FF5,W
00F0A:  BTFSS  F9E.4
00F0C:  BRA    0F0A
00F0E:  MOVWF  FAD
00F10:  MOVFF  1B0,FF6
00F14:  MOVFF  1B1,FF7
00F18:  BRA    0EFA
00F1A:  RETURN 0
00F1C:  TBLRD*+
00F1E:  MOVFF  FF6,1B1
00F22:  MOVFF  FF7,1B2
00F26:  MOVF   FF5,W
00F28:  BTFSS  F9E.4
00F2A:  BRA    0F28
00F2C:  MOVWF  FAD
00F2E:  MOVFF  1B1,FF6
00F32:  MOVFF  1B2,FF7
00F36:  MOVLB  1
00F38:  DECFSZ xB0,F
00F3A:  BRA    0F3E
00F3C:  BRA    0F42
00F3E:  MOVLB  0
00F40:  BRA    0F1C
00F42:  MOVLB  0
00F44:  RETURN 0
*
01036:  MOVF   FEF,F
01038:  BZ    105A
0103A:  MOVFF  FEA,1B1
0103E:  MOVFF  FE9,1B0
01042:  MOVF   FEF,W
01044:  BTFSS  F9E.4
01046:  BRA    1044
01048:  MOVWF  FAD
0104A:  MOVFF  1B1,FEA
0104E:  MOVFF  1B0,FE9
01052:  INCF   FE9,F
01054:  BTFSC  FD8.2
01056:  INCF   FEA,F
01058:  BRA    1036
0105A:  RETURN 0
*
0128C:  MOVLB  1
0128E:  MOVF   xB3,W
01290:  CLRF   01
01292:  SUBWF  xB2,W
01294:  BC    129C
01296:  MOVFF  1B2,00
0129A:  BRA    12B4
0129C:  CLRF   00
0129E:  MOVLW  08
012A0:  MOVWF  xB4
012A2:  RLCF   xB2,F
012A4:  RLCF   00,F
012A6:  MOVF   xB3,W
012A8:  SUBWF  00,W
012AA:  BTFSC  FD8.0
012AC:  MOVWF  00
012AE:  RLCF   01,F
012B0:  DECFSZ xB4,F
012B2:  BRA    12A2
012B4:  MOVLB  0
012B6:  RETURN 0
012B8:  MOVF   01,W
012BA:  MOVFF  1B0,1B2
012BE:  MOVLW  64
012C0:  MOVLB  1
012C2:  MOVWF  xB3
012C4:  MOVLB  0
012C6:  RCALL  128C
012C8:  MOVFF  00,1B0
012CC:  MOVF   01,W
012CE:  MOVLW  30
012D0:  BNZ   12E2
012D2:  MOVLB  1
012D4:  BTFSS  xB1.1
012D6:  BRA    12F4
012D8:  BTFSC  xB1.3
012DA:  BRA    12F4
012DC:  BTFSC  xB1.4
012DE:  MOVLW  20
012E0:  BRA    12EA
012E2:  MOVLB  1
012E4:  BCF    xB1.3
012E6:  BCF    xB1.4
012E8:  BSF    xB1.0
012EA:  ADDWF  01,F
012EC:  MOVF   01,W
012EE:  BTFSS  F9E.4
012F0:  BRA    12EE
012F2:  MOVWF  FAD
012F4:  MOVFF  1B0,1B2
012F8:  MOVLW  0A
012FA:  MOVWF  xB3
012FC:  MOVLB  0
012FE:  RCALL  128C
01300:  MOVFF  00,1B0
01304:  MOVF   01,W
01306:  MOVLW  30
01308:  BNZ   131A
0130A:  MOVLB  1
0130C:  BTFSC  xB1.3
0130E:  BRA    1326
01310:  BTFSS  xB1.0
01312:  BRA    1326
01314:  BTFSC  xB1.4
01316:  MOVLW  20
01318:  MOVLB  0
0131A:  ADDWF  01,F
0131C:  MOVF   01,W
0131E:  BTFSS  F9E.4
01320:  BRA    131E
01322:  MOVWF  FAD
01324:  MOVLB  1
01326:  MOVLW  30
01328:  ADDWF  xB0,F
0132A:  MOVF   xB0,W
0132C:  BTFSS  F9E.4
0132E:  BRA    132C
01330:  MOVWF  FAD
01332:  MOVLB  0
01334:  RETURN 0
01336:  MOVLB  1
01338:  MOVF   xB2,W
0133A:  ANDLW  07
0133C:  MOVWF  00
0133E:  RRCF   xB2,W
01340:  MOVWF  01
01342:  RRCF   01,F
01344:  RRCF   01,F
01346:  MOVLW  1F
01348:  ANDWF  01,F
0134A:  MOVF   01,W
0134C:  ADDWF  xB4,W
0134E:  MOVWF  FE9
01350:  MOVLW  00
01352:  ADDWFC xB5,W
01354:  MOVWF  FEA
01356:  CLRF   01
01358:  INCF   01,F
0135A:  INCF   00,F
0135C:  BRA    1360
0135E:  RLCF   01,F
01360:  DECFSZ 00,F
01362:  BRA    135E
01364:  MOVF   xB3,F
01366:  BZ    136E
01368:  MOVF   01,W
0136A:  IORWF  FEF,F
0136C:  BRA    1374
0136E:  COMF   01,F
01370:  MOVF   01,W
01372:  ANDWF  FEF,F
01374:  MOVLB  0
01376:  RETURN 0
*
01C64:  BTFSC  FD8.1
01C66:  BRA    1C70
01C68:  MOVLW  01
01C6A:  MOVWF  FEA
01C6C:  MOVLW  84
01C6E:  MOVWF  FE9
01C70:  CLRF   00
01C72:  CLRF   01
01C74:  CLRF   02
01C76:  CLRF   03
01C78:  MOVLB  1
01C7A:  CLRF   x84
01C7C:  CLRF   x85
01C7E:  CLRF   x86
01C80:  CLRF   x87
01C82:  MOVF   x83,W
01C84:  IORWF  x82,W
01C86:  IORWF  x81,W
01C88:  IORWF  x80,W
01C8A:  BZ    1CE4
01C8C:  MOVLW  20
01C8E:  MOVWF  x88
01C90:  BCF    FD8.0
01C92:  RLCF   x7C,F
01C94:  RLCF   x7D,F
01C96:  RLCF   x7E,F
01C98:  RLCF   x7F,F
01C9A:  RLCF   x84,F
01C9C:  RLCF   x85,F
01C9E:  RLCF   x86,F
01CA0:  RLCF   x87,F
01CA2:  MOVF   x83,W
01CA4:  SUBWF  x87,W
01CA6:  BNZ   1CB8
01CA8:  MOVF   x82,W
01CAA:  SUBWF  x86,W
01CAC:  BNZ   1CB8
01CAE:  MOVF   x81,W
01CB0:  SUBWF  x85,W
01CB2:  BNZ   1CB8
01CB4:  MOVF   x80,W
01CB6:  SUBWF  x84,W
01CB8:  BNC   1CD8
01CBA:  MOVF   x80,W
01CBC:  SUBWF  x84,F
01CBE:  MOVF   x81,W
01CC0:  BTFSS  FD8.0
01CC2:  INCFSZ x81,W
01CC4:  SUBWF  x85,F
01CC6:  MOVF   x82,W
01CC8:  BTFSS  FD8.0
01CCA:  INCFSZ x82,W
01CCC:  SUBWF  x86,F
01CCE:  MOVF   x83,W
01CD0:  BTFSS  FD8.0
01CD2:  INCFSZ x83,W
01CD4:  SUBWF  x87,F
01CD6:  BSF    FD8.0
01CD8:  RLCF   00,F
01CDA:  RLCF   01,F
01CDC:  RLCF   02,F
01CDE:  RLCF   03,F
01CE0:  DECFSZ x88,F
01CE2:  BRA    1C90
01CE4:  MOVFF  184,FEF
01CE8:  MOVFF  185,FEC
01CEC:  MOVFF  186,FEC
01CF0:  MOVFF  187,FEC
01CF4:  MOVLB  0
01CF6:  GOTO   1DCE (RETURN)
01CFA:  MOVLB  1
01CFC:  CLRF   x84
01CFE:  CLRF   x85
01D00:  MOVLW  01
01D02:  MOVWF  x86
01D04:  CLRF   FDA
01D06:  CLRF   FD9
01D08:  MOVWF  x89
01D0A:  MOVLW  7C
01D0C:  MOVWF  x88
01D0E:  MOVLW  01
01D10:  MOVWF  FEA
01D12:  MOVLW  80
01D14:  MOVWF  FE9
01D16:  MOVFF  189,FE2
01D1A:  MOVFF  188,FE1
01D1E:  MOVFF  186,187
01D22:  BCF    FD8.0
01D24:  MOVF   FE5,W
01D26:  MULWF  FEE
01D28:  MOVF   FF3,W
01D2A:  ADDWFC x84,F
01D2C:  MOVF   FF4,W
01D2E:  ADDWFC x85,F
01D30:  DECFSZ x87,F
01D32:  BRA    1D22
01D34:  MOVFF  184,FDE
01D38:  MOVFF  185,184
01D3C:  CLRF   x85
01D3E:  BTFSC  FD8.0
01D40:  INCF   x85,F
01D42:  INCF   x88,F
01D44:  BTFSC  FD8.2
01D46:  INCF   x89,F
01D48:  INCF   x86,F
01D4A:  MOVF   x86,W
01D4C:  SUBLW  05
01D4E:  BNZ   1D0E
01D50:  MOVLB  0
01D52:  GOTO   1DFE (RETURN)
*
01FB0:  TBLRD*+
01FB2:  MOVFF  FF6,16D
01FB6:  MOVFF  FF7,16E
01FBA:  MOVFF  FF5,171
01FBE:  CALL   0E6E
01FC2:  MOVFF  16D,FF6
01FC6:  MOVFF  16E,FF7
01FCA:  MOVLB  1
01FCC:  DECFSZ x6C,F
01FCE:  BRA    1FD2
01FD0:  BRA    1FD6
01FD2:  MOVLB  0
01FD4:  BRA    1FB0
01FD6:  MOVLB  0
01FD8:  RETURN 0
01FDA:  MOVF   FEF,F
01FDC:  BZ    1FFE
01FDE:  MOVFF  FEA,16D
01FE2:  MOVFF  FE9,16C
01FE6:  MOVFF  FEF,171
01FEA:  CALL   0E6E
01FEE:  MOVFF  16D,FEA
01FF2:  MOVFF  16C,FE9
01FF6:  INCF   FE9,F
01FF8:  BTFSC  FD8.2
01FFA:  INCF   FEA,F
01FFC:  BRA    1FDA
01FFE:  RETURN 0
*
02794:  MOVFF  FF2,0D
02798:  BCF    FF2.7
0279A:  ADDWF  FE8,W
0279C:  CLRF   FF7
0279E:  RLCF   FF7,F
027A0:  ADDLW  B9
027A2:  MOVWF  FF6
027A4:  MOVLW  27
027A6:  ADDWFC FF7,F
027A8:  TBLRD*-
027AA:  MOVF   FF5,W
027AC:  MOVWF  FFA
027AE:  TBLRD*
027B0:  MOVF   FF5,W
027B2:  BTFSC  0D.7
027B4:  BSF    FF2.7
027B6:  MOVWF  FF9
027B8:  DATA 5E,25
027BA:  DATA 98,25
027BC:  DATA E6,25
027BE:  DATA 34,26
027C0:  DATA 24,25
027C2:  DATA 50,27
027C4:  DATA 82,26
027C6:  DATA 56,27
027C8:  DATA 7C,27
*
02AB0:  MOVFF  FF2,0D
02AB4:  BCF    FF2.7
02AB6:  ADDWF  FE8,W
02AB8:  CLRF   FF7
02ABA:  RLCF   FF7,F
02ABC:  ADDLW  D5
02ABE:  MOVWF  FF6
02AC0:  MOVLW  2A
02AC2:  ADDWFC FF7,F
02AC4:  TBLRD*-
02AC6:  MOVF   FF5,W
02AC8:  MOVWF  FFA
02ACA:  TBLRD*
02ACC:  MOVF   FF5,W
02ACE:  BTFSC  0D.7
02AD0:  BSF    FF2.7
02AD2:  MOVWF  FF9
02AD4:  DATA 7C,2A
02AD6:  DATA 88,2A
02AD8:  DATA 94,2A
02ADA:  DATA A0,2A
....................  
.................... #list 
....................  
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20M) 
*
00B8E:  MOVLW  01
00B90:  MOVWF  FEA
00B92:  MOVLW  B1
00B94:  MOVWF  FE9
00B96:  MOVF   FEF,W
00B98:  BZ    0BB4
00B9A:  MOVLW  06
00B9C:  MOVWF  01
00B9E:  CLRF   00
00BA0:  DECFSZ 00,F
00BA2:  BRA    0BA0
00BA4:  DECFSZ 01,F
00BA6:  BRA    0B9E
00BA8:  MOVLW  7B
00BAA:  MOVWF  00
00BAC:  DECFSZ 00,F
00BAE:  BRA    0BAC
00BB0:  DECFSZ FEF,F
00BB2:  BRA    0B9A
00BB4:  RETURN 0
*
01D56:  MOVLW  03
01D58:  MOVLB  1
01D5A:  SUBWF  x7D,F
01D5C:  BNC   1D72
01D5E:  MOVLW  01
01D60:  MOVWF  FEA
01D62:  MOVLW  7D
01D64:  MOVWF  FE9
01D66:  MOVF   FEF,W
01D68:  BZ    1D72
01D6A:  BRA    1D6E
01D6C:  BRA    1D6E
01D6E:  DECFSZ FEF,F
01D70:  BRA    1D6C
01D72:  MOVLB  0
01D74:  RETURN 0
.................... /* RS232 */ 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... const int16 PIN_OUT[8]={ 
....................                         PIN_E2, 
....................                         PIN_E1, 
....................                         PIN_E0, 
....................                         PIN_A4, 
....................                         PIN_A0, 
....................                         PIN_A1, 
....................                         PIN_A2, 
....................                         PIN_A3 
....................                         }; 
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00D08:  BSF    F95.4
....................    output_float(LCD_DATA5); 
00D0A:  BSF    F95.5
....................    output_float(LCD_DATA6); 
00D0C:  BSF    F95.6
....................    output_float(LCD_DATA7); 
00D0E:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00D10:  BSF    F8C.1
00D12:  BCF    F95.1
....................    delay_cycles(1); 
00D14:  NOP   
....................    lcd_output_enable(1); 
00D16:  BSF    F8C.0
00D18:  BCF    F95.0
....................    delay_cycles(1); 
00D1A:  NOP   
....................    high = lcd_read_nibble(); 
00D1C:  RCALL  0CB2
00D1E:  MOVFF  01,179
....................        
....................    lcd_output_enable(0); 
00D22:  BCF    F8C.0
00D24:  BCF    F95.0
....................    delay_cycles(1); 
00D26:  NOP   
....................    lcd_output_enable(1); 
00D28:  BSF    F8C.0
00D2A:  BCF    F95.0
....................    delay_us(1); 
00D2C:  BRA    0D2E
00D2E:  BRA    0D30
00D30:  NOP   
....................    low = lcd_read_nibble(); 
00D32:  RCALL  0CB2
00D34:  MOVFF  01,178
....................        
....................    lcd_output_enable(0); 
00D38:  BCF    F8C.0
00D3A:  BCF    F95.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00D3C:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00D3E:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00D40:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00D42:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00D44:  MOVLB  1
00D46:  SWAPF  x79,W
00D48:  MOVWF  00
00D4A:  MOVLW  F0
00D4C:  ANDWF  00,F
00D4E:  MOVF   00,W
00D50:  IORWF  x78,W
00D52:  MOVWF  01
00D54:  MOVLB  0
00D56:  GOTO   0D66 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00CB2:  MOVLB  1
00CB4:  CLRF   x7A
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00CB6:  BSF    F95.4
00CB8:  MOVLW  00
00CBA:  BTFSC  F83.4
00CBC:  MOVLW  01
00CBE:  IORWF  x7A,F
....................    n |= input(LCD_DATA5) << 1; 
00CC0:  BSF    F95.5
00CC2:  MOVLW  00
00CC4:  BTFSC  F83.5
00CC6:  MOVLW  01
00CC8:  MOVWF  00
00CCA:  BCF    FD8.0
00CCC:  RLCF   00,F
00CCE:  MOVF   00,W
00CD0:  IORWF  x7A,F
....................    n |= input(LCD_DATA6) << 2; 
00CD2:  BSF    F95.6
00CD4:  MOVLW  00
00CD6:  BTFSC  F83.6
00CD8:  MOVLW  01
00CDA:  MOVWF  00
00CDC:  RLCF   00,F
00CDE:  RLCF   00,F
00CE0:  MOVLW  FC
00CE2:  ANDWF  00,F
00CE4:  MOVF   00,W
00CE6:  IORWF  x7A,F
....................    n |= input(LCD_DATA7) << 3; 
00CE8:  BSF    F95.7
00CEA:  MOVLW  00
00CEC:  BTFSC  F83.7
00CEE:  MOVLW  01
00CF0:  MOVWF  00
00CF2:  RLCF   00,F
00CF4:  RLCF   00,F
00CF6:  RLCF   00,F
00CF8:  MOVLW  F8
00CFA:  ANDWF  00,F
00CFC:  MOVF   00,W
00CFE:  IORWF  x7A,F
....................     
....................    return(n); 
00D00:  MOVFF  17A,01
....................   #else 
00D04:  MOVLB  0
00D06:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00C66:  MOVLB  1
00C68:  BTFSC  x79.0
00C6A:  BRA    0C70
00C6C:  BCF    F8C.4
00C6E:  BRA    0C72
00C70:  BSF    F8C.4
00C72:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00C74:  BTFSC  x79.1
00C76:  BRA    0C7C
00C78:  BCF    F8C.5
00C7A:  BRA    0C7E
00C7C:  BSF    F8C.5
00C7E:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00C80:  BTFSC  x79.2
00C82:  BRA    0C88
00C84:  BCF    F8C.6
00C86:  BRA    0C8A
00C88:  BSF    F8C.6
00C8A:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00C8C:  BTFSC  x79.3
00C8E:  BRA    0C94
00C90:  BCF    F8C.7
00C92:  BRA    0C96
00C94:  BSF    F8C.7
00C96:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00C98:  NOP   
....................    lcd_output_enable(1); 
00C9A:  BSF    F8C.0
00C9C:  BCF    F95.0
....................    delay_us(2); 
00C9E:  MOVLW  02
00CA0:  MOVWF  00
00CA2:  DECFSZ 00,F
00CA4:  BRA    0CA2
00CA6:  BRA    0CA8
00CA8:  NOP   
....................    lcd_output_enable(0); 
00CAA:  BCF    F8C.0
00CAC:  BCF    F95.0
00CAE:  MOVLB  0
00CB0:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00D5A:  BCF    F95.0
....................    lcd_rs_tris(); 
00D5C:  BCF    F95.2
....................    lcd_rw_tris(); 
00D5E:  BCF    F95.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00D60:  BCF    F8C.2
00D62:  BCF    F95.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
00D64:  BRA    0D08
00D66:  MOVFF  01,178
00D6A:  MOVLB  1
00D6C:  BTFSS  01.7
00D6E:  BRA    0D74
00D70:  MOVLB  0
00D72:  BRA    0D64
....................    lcd_output_rs(address); 
00D74:  MOVF   x76,F
00D76:  BNZ   0D7C
00D78:  BCF    F8C.2
00D7A:  BRA    0D7E
00D7C:  BSF    F8C.2
00D7E:  BCF    F95.2
....................    delay_cycles(1); 
00D80:  NOP   
....................    lcd_output_rw(0); 
00D82:  BCF    F8C.1
00D84:  BCF    F95.1
....................    delay_cycles(1); 
00D86:  NOP   
....................    lcd_output_enable(0); 
00D88:  BCF    F8C.0
00D8A:  BCF    F95.0
....................    lcd_send_nibble(n >> 4); 
00D8C:  SWAPF  x77,W
00D8E:  MOVWF  x78
00D90:  MOVLW  0F
00D92:  ANDWF  x78,F
00D94:  MOVFF  178,179
00D98:  MOVLB  0
00D9A:  RCALL  0C66
....................    lcd_send_nibble(n & 0xf); 
00D9C:  MOVLB  1
00D9E:  MOVF   x77,W
00DA0:  ANDLW  0F
00DA2:  MOVWF  x78
00DA4:  MOVWF  x79
00DA6:  MOVLB  0
00DA8:  RCALL  0C66
00DAA:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00DAC:  MOVLW  28
00DAE:  MOVLB  1
00DB0:  MOVWF  x69
00DB2:  MOVLW  0C
00DB4:  MOVWF  x6A
00DB6:  MOVLW  01
00DB8:  MOVWF  x6B
00DBA:  MOVLW  06
00DBC:  MOVWF  x6C
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00DBE:  BCF    F8C.0
00DC0:  BCF    F95.0
....................    lcd_output_rs(0); 
00DC2:  BCF    F8C.2
00DC4:  BCF    F95.2
....................    lcd_output_rw(0); 
00DC6:  BCF    F8C.1
00DC8:  BCF    F95.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00DCA:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00DCC:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00DCE:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00DD0:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00DD2:  BCF    F95.0
....................    lcd_rs_tris(); 
00DD4:  BCF    F95.2
....................    lcd_rw_tris(); 
00DD6:  BCF    F95.1
....................  #endif 
....................      
....................    delay_ms(15); 
00DD8:  MOVLW  0F
00DDA:  MOVWF  xB1
00DDC:  MOVLB  0
00DDE:  RCALL  0B8E
....................    for(i=1;i<=3;++i) 
00DE0:  MOVLW  01
00DE2:  MOVLB  1
00DE4:  MOVWF  x68
00DE6:  MOVF   x68,W
00DE8:  SUBLW  03
00DEA:  BNC   0E04
....................    { 
....................        lcd_send_nibble(3); 
00DEC:  MOVLW  03
00DEE:  MOVWF  x79
00DF0:  MOVLB  0
00DF2:  RCALL  0C66
....................        delay_ms(5); 
00DF4:  MOVLW  05
00DF6:  MOVLB  1
00DF8:  MOVWF  xB1
00DFA:  MOVLB  0
00DFC:  RCALL  0B8E
00DFE:  MOVLB  1
00E00:  INCF   x68,F
00E02:  BRA    0DE6
....................    } 
....................     
....................    lcd_send_nibble(2); 
00E04:  MOVLW  02
00E06:  MOVWF  x79
00E08:  MOVLB  0
00E0A:  RCALL  0C66
....................    delay_ms(5); 
00E0C:  MOVLW  05
00E0E:  MOVLB  1
00E10:  MOVWF  xB1
00E12:  MOVLB  0
00E14:  RCALL  0B8E
....................    for(i=0;i<=3;++i) 
00E16:  MOVLB  1
00E18:  CLRF   x68
00E1A:  MOVF   x68,W
00E1C:  SUBLW  03
00E1E:  BNC   0E42
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00E20:  CLRF   03
00E22:  MOVF   x68,W
00E24:  ADDLW  69
00E26:  MOVWF  FE9
00E28:  MOVLW  01
00E2A:  ADDWFC 03,W
00E2C:  MOVWF  FEA
00E2E:  MOVFF  FEF,16D
00E32:  CLRF   x76
00E34:  MOVFF  16D,177
00E38:  MOVLB  0
00E3A:  RCALL  0D5A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00E3C:  MOVLB  1
00E3E:  INCF   x68,F
00E40:  BRA    0E1A
00E42:  MOVLB  0
00E44:  GOTO   2A58 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00E48:  MOVLB  1
00E4A:  DECFSZ x73,W
00E4C:  BRA    0E50
00E4E:  BRA    0E56
....................       address=LCD_LINE_TWO; 
00E50:  MOVLW  40
00E52:  MOVWF  x74
00E54:  BRA    0E58
....................    else 
....................       address=0; 
00E56:  CLRF   x74
....................       
....................    address+=x-1; 
00E58:  MOVLW  01
00E5A:  SUBWF  x72,W
00E5C:  ADDWF  x74,F
....................    lcd_send_byte(0,0x80|address); 
00E5E:  MOVF   x74,W
00E60:  IORLW  80
00E62:  MOVWF  x75
00E64:  CLRF   x76
00E66:  MOVWF  x77
00E68:  MOVLB  0
00E6A:  RCALL  0D5A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00E6C:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00E6E:  MOVLB  1
00E70:  MOVF   x71,W
00E72:  XORLW  07
00E74:  MOVLB  0
00E76:  BZ    0E86
00E78:  XORLW  0B
00E7A:  BZ    0E94
00E7C:  XORLW  06
00E7E:  BZ    0EAC
00E80:  XORLW  02
00E82:  BZ    0EBC
00E84:  BRA    0ECA
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00E86:  MOVLW  01
00E88:  MOVLB  1
00E8A:  MOVWF  x72
00E8C:  MOVWF  x73
00E8E:  MOVLB  0
00E90:  RCALL  0E48
00E92:  BRA    0ED8
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
00E94:  MOVLB  1
00E96:  CLRF   x76
00E98:  MOVLW  01
00E9A:  MOVWF  x77
00E9C:  MOVLB  0
00E9E:  RCALL  0D5A
....................                      delay_ms(2); 
00EA0:  MOVLW  02
00EA2:  MOVLB  1
00EA4:  MOVWF  xB1
00EA6:  MOVLB  0
00EA8:  RCALL  0B8E
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
00EAA:  BRA    0ED8
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00EAC:  MOVLW  01
00EAE:  MOVLB  1
00EB0:  MOVWF  x72
00EB2:  MOVLW  02
00EB4:  MOVWF  x73
00EB6:  MOVLB  0
00EB8:  RCALL  0E48
00EBA:  BRA    0ED8
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00EBC:  MOVLB  1
00EBE:  CLRF   x76
00EC0:  MOVLW  10
00EC2:  MOVWF  x77
00EC4:  MOVLB  0
00EC6:  RCALL  0D5A
00EC8:  BRA    0ED8
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
00ECA:  MOVLW  01
00ECC:  MOVLB  1
00ECE:  MOVWF  x76
00ED0:  MOVFF  171,177
00ED4:  MOVLB  0
00ED6:  RCALL  0D5A
....................      #endif 
....................    } 
00ED8:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
01D76:  MOVLB  1
01D78:  CLRF   x73
01D7A:  CLRF   x72
01D7C:  CLRF   x75
01D7E:  CLRF   x74
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
01D80:  MOVF   x6F,F
01D82:  BNZ   1D8C
01D84:  MOVF   x6E,W
01D86:  SUBLW  13
01D88:  BTFSC  FD8.0
01D8A:  BRA    1EBA
01D8C:  MOVF   x6F,W
01D8E:  SUBLW  4E
01D90:  BTFSS  FD8.0
01D92:  BRA    1EBA
01D94:  BNZ   1D9E
01D96:  MOVF   x6E,W
01D98:  SUBLW  20
01D9A:  BTFSS  FD8.0
01D9C:  BRA    1EBA
....................       tmp=100000; 
01D9E:  CLRF   x7B
01DA0:  MOVLW  01
01DA2:  MOVWF  x7A
01DA4:  MOVLW  86
01DA6:  MOVWF  x79
01DA8:  MOVLW  A0
01DAA:  MOVWF  x78
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
01DAC:  BCF    FD8.1
01DAE:  MOVFF  17B,17F
01DB2:  MOVFF  17A,17E
01DB6:  MOVFF  179,17D
01DBA:  MOVFF  178,17C
01DBE:  CLRF   x83
01DC0:  CLRF   x82
01DC2:  MOVFF  16F,181
01DC6:  MOVFF  16E,180
01DCA:  MOVLB  0
01DCC:  BRA    1C64
01DCE:  MOVFF  03,17B
01DD2:  MOVFF  02,17A
01DD6:  MOVFF  01,179
01DDA:  MOVFF  00,178
....................       tmp*=5;    
01DDE:  MOVFF  17B,17F
01DE2:  MOVFF  17A,17E
01DE6:  MOVFF  179,17D
01DEA:  MOVFF  178,17C
01DEE:  MOVLB  1
01DF0:  CLRF   x83
01DF2:  CLRF   x82
01DF4:  CLRF   x81
01DF6:  MOVLW  05
01DF8:  MOVWF  x80
01DFA:  MOVLB  0
01DFC:  BRA    1CFA
01DFE:  MOVFF  03,17B
01E02:  MOVFF  02,17A
01E06:  MOVFF  01,179
01E0A:  MOVFF  00,178
....................       uS=tmp; 
01E0E:  MOVFF  179,177
01E12:  MOVFF  178,176
....................       do{ 
....................          output_high(Speaker);   // Genera la frecuancia deseada 
01E16:  BCF    F93.2
01E18:  BSF    F8A.2
....................          delay_us(uS);           // con los retardos mientras 
01E1A:  MOVFF  177,17C
01E1E:  MOVLB  1
01E20:  INCF   x7C,F
01E22:  DECF   x7C,F
01E24:  BTFSC  FD8.2
01E26:  BRA    1E32
01E28:  SETF   x7D
01E2A:  MOVLB  0
01E2C:  RCALL  1D56
01E2E:  MOVLB  1
01E30:  BRA    1E22
01E32:  MOVFF  176,17D
01E36:  MOVLB  0
01E38:  RCALL  1D56
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
01E3A:  MOVLB  1
01E3C:  MOVF   x76,W
01E3E:  ADDWF  x74,F
01E40:  MOVF   x77,W
01E42:  ADDWFC x75,F
....................          output_low(Speaker);    // en dos partes para repartir el  
01E44:  BCF    F93.2
01E46:  BCF    F8A.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
01E48:  MOVFF  177,17C
01E4C:  INCF   x7C,F
01E4E:  DECF   x7C,F
01E50:  BTFSC  FD8.2
01E52:  BRA    1E5E
01E54:  SETF   x7D
01E56:  MOVLB  0
01E58:  RCALL  1D56
01E5A:  MOVLB  1
01E5C:  BRA    1E4E
01E5E:  MOVFF  176,17D
01E62:  MOVLB  0
01E64:  RCALL  1D56
....................          CiclosL+=(uS);          //  
01E66:  MOVLB  1
01E68:  MOVF   x76,W
01E6A:  ADDWF  x74,F
01E6C:  MOVF   x77,W
01E6E:  ADDWFC x75,F
....................          CiclosL+=25;            // Compensador. 
01E70:  MOVLW  19
01E72:  ADDWF  x74,F
01E74:  MOVLW  00
01E76:  ADDWFC x75,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
01E78:  MOVF   x75,W
01E7A:  SUBLW  02
01E7C:  BC    1EA0
01E7E:  XORLW  FF
01E80:  BNZ   1E88
01E82:  MOVF   x74,W
01E84:  SUBLW  E7
01E86:  BC    1EA0
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
01E88:  MOVLW  E8
01E8A:  SUBWF  x74,F
01E8C:  MOVLW  03
01E8E:  SUBWFB x75,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
01E90:  INCF   x72,F
01E92:  BTFSC  FD8.2
01E94:  INCF   x73,F
....................             CiclosL+=25;         // Compensador. 
01E96:  MOVLW  19
01E98:  ADDWF  x74,F
01E9A:  MOVLW  00
01E9C:  ADDWFC x75,F
01E9E:  BRA    1E78
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
01EA0:  MOVF   x73,W
01EA2:  SUBWF  x71,W
01EA4:  BNC   1EBA
01EA6:  BTFSC  FD8.2
01EA8:  BRA    1EAE
01EAA:  MOVLB  0
01EAC:  BRA    1E16
01EAE:  MOVF   x70,W
01EB0:  SUBWF  x72,W
01EB2:  BTFSC  FD8.0
01EB4:  BRA    1EBA
01EB6:  MOVLB  0
01EB8:  BRA    1E16
....................                                          // tiempo indicado. 
....................    } 
01EBA:  MOVLB  0
01EBC:  RETURN 0
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          CMD_WIFI.H: Comandos Ejecutados desde 
....................                               wifi. 
....................  
.................... *******************************************************/ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando  
.................... // ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /********************************************************** 
....................    Funcion Busca la cadena de inicio recepcion de request,  
....................    y retorna el ID de la conexion 
.................... ***********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
00960:  MOVLW  05
00962:  MOVLB  1
00964:  MOVWF  xBC
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
00966:  DECFSZ 55,W
00968:  BRA    0990
....................        
....................       if(buffer!=','){ 
0096A:  MOVF   xBA,W
0096C:  SUBLW  2C
0096E:  BNZ   0974
00970:  MOVF   xBB,F
00972:  BZ    098A
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
00974:  CLRF   03
00976:  MOVF   59,W
00978:  ADDLW  1C
0097A:  MOVWF  FE9
0097C:  MOVLW  00
0097E:  ADDWFC 03,W
00980:  MOVWF  FEA
00982:  MOVFF  1BA,FEF
....................          flag_Pos_Resp_IPD++; 
00986:  INCF   59,F
....................       }else{ 
00988:  BRA    098E
....................          flag_Pos_Resp_IPD       = 0x00; 
0098A:  CLRF   59
....................          flag_Resp_IPD           = 0x00; 
0098C:  CLRF   55
....................       } 
....................    }else{ 
0098E:  BRA    09C2
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
00990:  CLRF   03
00992:  MOVF   59,W
00994:  MOVFF  FF2,1BD
00998:  BCF    FF2.7
0099A:  MOVLB  0
0099C:  CALL   00C0
009A0:  MOVLB  1
009A2:  BTFSC  xBD.7
009A4:  BSF    FF2.7
009A6:  MOVWF  01
009A8:  SUBWF  xBA,W
009AA:  BNZ   09C0
009AC:  MOVF   xBB,F
009AE:  BNZ   09C0
....................       { 
....................          flag_Pos_Resp_IPD++; 
009B0:  INCF   59,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
009B2:  MOVF   xBC,W
009B4:  SUBWF  59,W
009B6:  BNZ   09BE
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
009B8:  MOVLW  01
009BA:  MOVWF  55
....................             flag_Pos_Resp_IPD = 0; 
009BC:  CLRF   59
....................          } 
....................       }else{ 
009BE:  BRA    09C2
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
009C0:  CLRF   59
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
009C2:  MOVLB  0
009C4:  GOTO   0B4A (RETURN)
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
....................    Busca la cadena de inicio comando, y retorna el  
....................    Comando enviado, Activa la bandera de recepcion  
....................    de datos 
.................... *********************************************************/ 
.................... void ESP8266_Get_CMD(char buffer[]){ 
009C8:  MOVLW  04
009CA:  MOVLB  1
009CC:  MOVWF  xBC
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
009CE:  DECFSZ 54,W
009D0:  BRA    09FC
....................     
....................       if(buffer!=','){ 
009D2:  MOVF   xBA,W
009D4:  SUBLW  2C
009D6:  BNZ   09DC
009D8:  MOVF   xBB,F
009DA:  BZ    09F2
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
009DC:  CLRF   03
009DE:  MOVF   58,W
009E0:  ADDLW  1E
009E2:  MOVWF  FE9
009E4:  MOVLW  00
009E6:  ADDWFC 03,W
009E8:  MOVWF  FEA
009EA:  MOVFF  1BA,FEF
....................          flag_Pos_Resp_CMD++; 
009EE:  INCF   58,F
....................       }else{         
009F0:  BRA    09FA
....................          flag_Pos_Resp_CMD = 0x00; 
009F2:  CLRF   58
....................          flag_Resp_CMD     = 0x00; 
009F4:  CLRF   54
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
009F6:  MOVLW  01
009F8:  MOVWF  56
....................       } 
....................        
....................    }else{ 
009FA:  BRA    0A2E
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
009FC:  CLRF   03
009FE:  MOVF   58,W
00A00:  MOVFF  FF2,1BD
00A04:  BCF    FF2.7
00A06:  MOVLB  0
00A08:  CALL   00D6
00A0C:  MOVLB  1
00A0E:  BTFSC  xBD.7
00A10:  BSF    FF2.7
00A12:  MOVWF  01
00A14:  SUBWF  xBA,W
00A16:  BNZ   0A2C
00A18:  MOVF   xBB,F
00A1A:  BNZ   0A2C
....................       { 
....................          flag_Pos_Resp_CMD++; 
00A1C:  INCF   58,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
00A1E:  MOVF   xBC,W
00A20:  SUBWF  58,W
00A22:  BNZ   0A2A
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
00A24:  MOVLW  01
00A26:  MOVWF  54
....................             flag_Pos_Resp_CMD = 0; 
00A28:  CLRF   58
....................          } 
....................       }else{ 
00A2A:  BRA    0A2E
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
00A2C:  CLRF   58
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00A2E:  MOVLB  0
00A30:  GOTO   0B56 (RETURN)
.................... } 
....................  
.................... /*********************************************************** 
....................    Verifica si la bandera de recepcion de datos esta 
....................    activa y almacena los datos entrantes en el arreglo 
....................    DATA_COMMAND, Finaliza la captura de caracteres cuando 
....................    encuentra el caracter ":". 
.................... ************************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
00A34:  DECFSZ 56,W
00A36:  BRA    0A7A
....................       if(buffer!=':'){ 
00A38:  MOVLB  1
00A3A:  MOVF   xBA,W
00A3C:  SUBLW  3A
00A3E:  BNZ   0A44
00A40:  MOVF   xBB,F
00A42:  BZ    0A72
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
00A44:  CLRF   03
00A46:  MOVF   5A,W
00A48:  ADDLW  20
00A4A:  MOVWF  FE9
00A4C:  MOVLW  00
00A4E:  ADDWFC 03,W
00A50:  MOVWF  FEA
00A52:  MOVFF  1BA,FEF
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
00A56:  CLRF   53
00A58:  MOVFF  5A,52
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
00A5C:  MOVF   5A,F
00A5E:  BNZ   0A6E
00A60:  MOVF   xBA,W
00A62:  SUBLW  2C
00A64:  BNZ   0A6E
00A66:  MOVF   xBB,F
00A68:  BNZ   0A6E
....................             flag_Pos_Resp_Data=0; 
00A6A:  CLRF   5A
....................          }else{ 
00A6C:  BRA    0A70
....................             flag_Pos_Resp_Data++; 
00A6E:  INCF   5A,F
....................          } 
....................           
....................       }else{ 
00A70:  BRA    0A7A
....................          flag_Pos_Resp_Data      = 0x00; 
00A72:  CLRF   5A
....................          flag_Resp_StartGetData  = 0x00; 
00A74:  CLRF   56
....................          flag_Resp_Ready         = 1; 
00A76:  MOVLW  01
00A78:  MOVWF  57
00A7A:  MOVLB  0
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
00A7C:  GOTO   0B62 (RETURN)
.................... } // Fin Funcion ESP8266_Get_Data 
....................  
.................... /***************************************************** 
....................    Verifica si se ha recibido algun comando enviado 
....................    por WiFi y lo ejecuta.  
.................... *****************************************************/ 
.................... int run_command_wifi(void){ 
*
01378:  MOVLB  1
0137A:  CLRF   x6E
0137C:  CLRF   x6F
0137E:  CLRF   x70
01380:  CLRF   x71
01382:  MOVLW  0C
01384:  MOVWF  x72
....................    int8 reset = 0, optSelected  = 0,counter = 0, idxRSTNC = 0,lenResponse = 12; 
....................    char response[57] = "{\"cmd\":\"ok\"}"; 
01386:  MOVLW  7B
01388:  MOVWF  x73
0138A:  MOVLW  22
0138C:  MOVWF  x74
0138E:  MOVLW  63
01390:  MOVWF  x75
01392:  MOVLW  6D
01394:  MOVWF  x76
01396:  MOVLW  64
01398:  MOVWF  x77
0139A:  MOVLW  22
0139C:  MOVWF  x78
0139E:  MOVLW  3A
013A0:  MOVWF  x79
013A2:  MOVLW  22
013A4:  MOVWF  x7A
013A6:  MOVLW  6F
013A8:  MOVWF  x7B
013AA:  MOVLW  6B
013AC:  MOVWF  x7C
013AE:  MOVLW  22
013B0:  MOVWF  x7D
013B2:  MOVLW  7D
013B4:  MOVWF  x7E
013B6:  CLRF   x7F
....................     
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
013B8:  DECFSZ 57,W
013BA:  GOTO   1C5C
....................     
....................       /***************************** 
....................       *** Reinicia el Dispositivo ** 
....................       *** CMD:OP,[0|1][0-7]:      ** 
....................       *****************************/ 
....................       if(COMMAND[0]=='R' && 
....................          COMMAND[1]=='S') 
013BE:  MOVF   1E,W
013C0:  SUBLW  52
013C2:  BNZ   147A
013C4:  MOVF   1F,W
013C6:  SUBLW  53
013C8:  BNZ   147A
....................       { 
....................          // Responde la solicitud 
....................          delay_ms(30); 
013CA:  MOVLW  1E
013CC:  MOVWF  xB1
013CE:  MOVLB  0
013D0:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
013D4:  MOVLW  5E
013D6:  MOVWF  FF6
013D8:  MOVLW  01
013DA:  MOVWF  FF7
013DC:  MOVLW  0B
013DE:  MOVLB  1
013E0:  MOVWF  xB0
013E2:  MOVLB  0
013E4:  RCALL  0F1C
013E6:  MOVF   1C,W
013E8:  BTFSS  F9E.4
013EA:  BRA    13E8
013EC:  MOVWF  FAD
013EE:  MOVLW  2C
013F0:  BTFSS  F9E.4
013F2:  BRA    13F0
013F4:  MOVWF  FAD
013F6:  MOVFF  172,1B0
013FA:  MOVLW  1B
013FC:  MOVLB  1
013FE:  MOVWF  xB1
01400:  MOVLB  0
01402:  RCALL  12B8
01404:  MOVLW  0D
01406:  BTFSS  F9E.4
01408:  BRA    1406
0140A:  MOVWF  FAD
0140C:  MOVLW  0A
0140E:  BTFSS  F9E.4
01410:  BRA    140E
01412:  MOVWF  FAD
....................          delay_ms(60); 
01414:  MOVLW  3C
01416:  MOVLB  1
01418:  MOVWF  xB1
0141A:  MOVLB  0
0141C:  CALL   0B8E
....................          fprintf(ESP8266, "%s",response); 
01420:  MOVLW  01
01422:  MOVWF  FEA
01424:  MOVLW  73
01426:  MOVWF  FE9
01428:  RCALL  1036
....................          delay_ms(120); 
0142A:  MOVLW  78
0142C:  MOVLB  1
0142E:  MOVWF  xB1
01430:  MOVLB  0
01432:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01436:  MOVLW  72
01438:  MOVWF  FF6
0143A:  MOVLW  01
0143C:  MOVWF  FF7
0143E:  MOVLW  0C
01440:  MOVLB  1
01442:  MOVWF  xB0
01444:  MOVLB  0
01446:  RCALL  0F1C
01448:  MOVF   1C,W
0144A:  BTFSS  F9E.4
0144C:  BRA    144A
0144E:  MOVWF  FAD
01450:  MOVLW  0D
01452:  BTFSS  F9E.4
01454:  BRA    1452
01456:  MOVWF  FAD
01458:  MOVLW  0A
0145A:  BTFSS  F9E.4
0145C:  BRA    145A
0145E:  MOVWF  FAD
....................          delay_ms(500); 
01460:  MOVLW  02
01462:  MOVLB  1
01464:  MOVWF  xB0
01466:  MOVLW  FA
01468:  MOVWF  xB1
0146A:  MOVLB  0
0146C:  CALL   0B8E
01470:  MOVLB  1
01472:  DECFSZ xB0,F
01474:  BRA    1466
....................           
....................          reset = 1;          
01476:  MOVLW  01
01478:  MOVWF  x6E
....................       } // Fin comando RS 
....................        
....................       /************************** 
....................       *** Activa o desactiva   ** 
....................       *** los puertos          ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
0147A:  MOVF   1E,W
0147C:  SUBLW  4F
0147E:  BNZ   1534
01480:  MOVF   1F,W
01482:  SUBLW  50
01484:  BNZ   1534
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
01486:  MOVLW  30
01488:  SUBWF  21,W
0148A:  MOVWF  x6F
....................           
....................          switch(DATA_COMMAND[0]){ 
0148C:  MOVF   20,W
0148E:  XORLW  30
01490:  MOVLB  0
01492:  BZ    149A
01494:  XORLW  01
01496:  BZ    14E6
01498:  BRA    1532
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
0149A:  BCF    FD8.0
0149C:  MOVLB  1
0149E:  RLCF   x6F,W
014A0:  CLRF   03
014A2:  MOVFF  FF2,1B0
014A6:  BCF    FF2.7
014A8:  MOVLB  0
014AA:  CALL   0096
014AE:  TBLRD*+
014B0:  MOVFF  FF5,03
014B4:  MOVLB  1
014B6:  BTFSC  xB0.7
014B8:  BSF    FF2.7
014BA:  MOVWF  xB0
014BC:  MOVFF  03,1B1
014C0:  MOVWF  xB2
014C2:  CLRF   xB3
014C4:  MOVLW  0F
014C6:  MOVWF  xB5
014C8:  MOVLW  89
014CA:  MOVWF  xB4
014CC:  MOVLB  0
014CE:  RCALL  1336
014D0:  MOVFF  1B0,1B2
014D4:  MOVLB  1
014D6:  CLRF   xB3
014D8:  MOVLW  0F
014DA:  MOVWF  xB5
014DC:  MOVLW  92
014DE:  MOVWF  xB4
014E0:  MOVLB  0
014E2:  RCALL  1336
....................                break; 
014E4:  BRA    1532
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
014E6:  BCF    FD8.0
014E8:  MOVLB  1
014EA:  RLCF   x6F,W
014EC:  CLRF   03
014EE:  MOVFF  FF2,1B0
014F2:  BCF    FF2.7
014F4:  MOVLB  0
014F6:  CALL   0096
014FA:  TBLRD*+
014FC:  MOVFF  FF5,03
01500:  MOVLB  1
01502:  BTFSC  xB0.7
01504:  BSF    FF2.7
01506:  MOVWF  xB0
01508:  MOVFF  03,1B1
0150C:  MOVWF  xB2
0150E:  MOVLW  01
01510:  MOVWF  xB3
01512:  MOVLW  0F
01514:  MOVWF  xB5
01516:  MOVLW  89
01518:  MOVWF  xB4
0151A:  MOVLB  0
0151C:  RCALL  1336
0151E:  MOVFF  1B0,1B2
01522:  MOVLB  1
01524:  CLRF   xB3
01526:  MOVLW  0F
01528:  MOVWF  xB5
0152A:  MOVLW  92
0152C:  MOVWF  xB4
0152E:  MOVLB  0
01530:  RCALL  1336
....................                break; 
01532:  MOVLB  1
....................          } 
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
01534:  MOVF   1E,W
01536:  SUBLW  4E
01538:  BTFSS  FD8.2
0153A:  BRA    1740
0153C:  MOVF   1F,W
0153E:  SUBLW  43
01540:  BTFSS  FD8.2
01542:  BRA    1740
....................       { 
....................          // Borra la eeprom para almacenar las nuevas credenciales 
....................          // Desde la posicion 0x01 hasta 0x027 
....................          for(idxRSTNC=1;idxRSTNC<=27;idxRSTNC++){ 
01544:  MOVLW  01
01546:  MOVWF  x71
01548:  MOVF   x71,W
0154A:  SUBLW  1B
0154C:  BNC   158A
....................             write_eeprom(idxRSTNC,0xFF); 
0154E:  MOVF   FF2,W
01550:  MOVWF  00
01552:  BCF    FF2.7
01554:  CLRF   FAA
01556:  MOVFF  171,FA9
0155A:  SETF   FA8
0155C:  BCF    FA6.6
0155E:  BCF    FA6.7
01560:  BSF    FA6.2
01562:  MOVLB  F
01564:  MOVLW  55
01566:  MOVWF  FA7
01568:  MOVLW  AA
0156A:  MOVWF  FA7
0156C:  BSF    FA6.1
0156E:  BTFSC  FA6.1
01570:  BRA    156E
01572:  BCF    FA6.2
01574:  MOVF   00,W
01576:  IORWF  FF2,F
....................             delay_ms(10); 
01578:  MOVLW  0A
0157A:  MOVLB  1
0157C:  MOVWF  xB1
0157E:  MOVLB  0
01580:  CALL   0B8E
01584:  MOVLB  1
01586:  INCF   x71,F
01588:  BRA    1548
....................          } 
....................           
....................          // Guarda las nuevas credenciales 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
0158A:  CLRF   xAC
0158C:  MOVF   53,F
0158E:  BNZ   1596
01590:  MOVF   xAC,W
01592:  SUBWF  52,W
01594:  BNC   15EC
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
01596:  MOVLW  01
01598:  ADDWF  xAC,W
0159A:  MOVWF  xB0
0159C:  CLRF   03
0159E:  MOVF   xAC,W
015A0:  ADDLW  20
015A2:  MOVWF  FE9
015A4:  MOVLW  00
015A6:  ADDWFC 03,W
015A8:  MOVWF  FEA
015AA:  MOVFF  FEF,1B1
015AE:  MOVF   FF2,W
015B0:  MOVWF  00
015B2:  BCF    FF2.7
015B4:  CLRF   FAA
015B6:  MOVFF  1B0,FA9
015BA:  MOVFF  1B1,FA8
015BE:  BCF    FA6.6
015C0:  BCF    FA6.7
015C2:  BSF    FA6.2
015C4:  MOVLB  F
015C6:  MOVLW  55
015C8:  MOVWF  FA7
015CA:  MOVLW  AA
015CC:  MOVWF  FA7
015CE:  BSF    FA6.1
015D0:  BTFSC  FA6.1
015D2:  BRA    15D0
015D4:  BCF    FA6.2
015D6:  MOVF   00,W
015D8:  IORWF  FF2,F
....................             delay_ms(10); 
015DA:  MOVLW  0A
015DC:  MOVLB  1
015DE:  MOVWF  xB1
015E0:  MOVLB  0
015E2:  CALL   0B8E
015E6:  MOVLB  1
015E8:  INCF   xAC,F
015EA:  BRA    158C
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
015EC:  MOVLW  01
015EE:  ADDWF  xAC,W
015F0:  MOVWF  xB0
015F2:  MOVF   FF2,W
015F4:  MOVWF  00
015F6:  BCF    FF2.7
015F8:  CLRF   FAA
015FA:  MOVFF  1B0,FA9
015FE:  MOVLW  0D
01600:  MOVWF  FA8
01602:  BCF    FA6.6
01604:  BCF    FA6.7
01606:  BSF    FA6.2
01608:  MOVLB  F
0160A:  MOVLW  55
0160C:  MOVWF  FA7
0160E:  MOVLW  AA
01610:  MOVWF  FA7
01612:  BSF    FA6.1
01614:  BTFSC  FA6.1
01616:  BRA    1614
01618:  BCF    FA6.2
0161A:  MOVF   00,W
0161C:  IORWF  FF2,F
....................          delay_ms(10); 
0161E:  MOVLW  0A
01620:  MOVLB  1
01622:  MOVWF  xB1
01624:  MOVLB  0
01626:  CALL   0B8E
....................          write_eeprom(idxNC+2,0x0A); 
0162A:  MOVLW  02
0162C:  MOVLB  1
0162E:  ADDWF  xAC,W
01630:  MOVWF  xB0
01632:  MOVF   FF2,W
01634:  MOVWF  00
01636:  BCF    FF2.7
01638:  CLRF   FAA
0163A:  MOVFF  1B0,FA9
0163E:  MOVLW  0A
01640:  MOVWF  FA8
01642:  BCF    FA6.6
01644:  BCF    FA6.7
01646:  BSF    FA6.2
01648:  MOVLB  F
0164A:  MOVLW  55
0164C:  MOVWF  FA7
0164E:  MOVLW  AA
01650:  MOVWF  FA7
01652:  BSF    FA6.1
01654:  BTFSC  FA6.1
01656:  BRA    1654
01658:  BCF    FA6.2
0165A:  MOVF   00,W
0165C:  IORWF  FF2,F
....................          delay_ms(10); 
0165E:  MOVLW  0A
01660:  MOVLB  1
01662:  MOVWF  xB1
01664:  MOVLB  0
01666:  CALL   0B8E
....................  
....................          // Responde la solicitud 
....................          delay_ms(30); 
0166A:  MOVLW  1E
0166C:  MOVLB  1
0166E:  MOVWF  xB1
01670:  MOVLB  0
01672:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01676:  MOVLW  84
01678:  MOVWF  FF6
0167A:  MOVLW  01
0167C:  MOVWF  FF7
0167E:  MOVLW  0B
01680:  MOVLB  1
01682:  MOVWF  xB0
01684:  MOVLB  0
01686:  RCALL  0F1C
01688:  MOVF   1C,W
0168A:  BTFSS  F9E.4
0168C:  BRA    168A
0168E:  MOVWF  FAD
01690:  MOVLW  2C
01692:  BTFSS  F9E.4
01694:  BRA    1692
01696:  MOVWF  FAD
01698:  MOVFF  172,1B0
0169C:  MOVLW  1B
0169E:  MOVLB  1
016A0:  MOVWF  xB1
016A2:  MOVLB  0
016A4:  RCALL  12B8
016A6:  MOVLW  0D
016A8:  BTFSS  F9E.4
016AA:  BRA    16A8
016AC:  MOVWF  FAD
016AE:  MOVLW  0A
016B0:  BTFSS  F9E.4
016B2:  BRA    16B0
016B4:  MOVWF  FAD
....................          delay_ms(60); 
016B6:  MOVLW  3C
016B8:  MOVLB  1
016BA:  MOVWF  xB1
016BC:  MOVLB  0
016BE:  CALL   0B8E
....................          fprintf(ESP8266, "%s",response); 
016C2:  MOVLW  01
016C4:  MOVWF  FEA
016C6:  MOVLW  73
016C8:  MOVWF  FE9
016CA:  RCALL  1036
....................          delay_ms(120); 
016CC:  MOVLW  78
016CE:  MOVLB  1
016D0:  MOVWF  xB1
016D2:  MOVLB  0
016D4:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
016D8:  MOVLW  98
016DA:  MOVWF  FF6
016DC:  MOVLW  01
016DE:  MOVWF  FF7
016E0:  MOVLW  0C
016E2:  MOVLB  1
016E4:  MOVWF  xB0
016E6:  MOVLB  0
016E8:  RCALL  0F1C
016EA:  MOVF   1C,W
016EC:  BTFSS  F9E.4
016EE:  BRA    16EC
016F0:  MOVWF  FAD
016F2:  MOVLW  0D
016F4:  BTFSS  F9E.4
016F6:  BRA    16F4
016F8:  MOVWF  FAD
016FA:  MOVLW  0A
016FC:  BTFSS  F9E.4
016FE:  BRA    16FC
01700:  MOVWF  FAD
....................          delay_ms(500); 
01702:  MOVLW  02
01704:  MOVLB  1
01706:  MOVWF  xB0
01708:  MOVLW  FA
0170A:  MOVWF  xB1
0170C:  MOVLB  0
0170E:  CALL   0B8E
01712:  MOVLB  1
01714:  DECFSZ xB0,F
01716:  BRA    1708
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
01718:  MOVLW  AA
0171A:  MOVWF  FF6
0171C:  MOVLW  01
0171E:  MOVWF  FF7
01720:  MOVLB  0
01722:  CALL   0EFA
....................          delay_ms(1000); 
01726:  MOVLW  04
01728:  MOVLB  1
0172A:  MOVWF  xB0
0172C:  MOVLW  FA
0172E:  MOVWF  xB1
01730:  MOVLB  0
01732:  CALL   0B8E
01736:  MOVLB  1
01738:  DECFSZ xB0,F
0173A:  BRA    172C
....................           
....................          reset = 1; 
0173C:  MOVLW  01
0173E:  MOVWF  x6E
....................       } // Fin comando NC 
....................        
....................       /********************************** 
....................       *** Cambia el SSID y Key del AP  ** 
....................       *** CMD:AP,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='A' && 
....................          COMMAND[1]=='P') 
01740:  MOVF   1E,W
01742:  SUBLW  41
01744:  BTFSS  FD8.2
01746:  BRA    1848
01748:  MOVF   1F,W
0174A:  SUBLW  50
0174C:  BTFSS  FD8.2
0174E:  BRA    1848
....................       { 
....................          // Responde la solicitud 
....................          delay_ms(20); 
01750:  MOVLW  14
01752:  MOVWF  xB1
01754:  MOVLB  0
01756:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
0175A:  MOVLW  B6
0175C:  MOVWF  FF6
0175E:  MOVLW  01
01760:  MOVWF  FF7
01762:  MOVLW  0B
01764:  MOVLB  1
01766:  MOVWF  xB0
01768:  MOVLB  0
0176A:  CALL   0F1C
0176E:  MOVF   1C,W
01770:  BTFSS  F9E.4
01772:  BRA    1770
01774:  MOVWF  FAD
01776:  MOVLW  2C
01778:  BTFSS  F9E.4
0177A:  BRA    1778
0177C:  MOVWF  FAD
0177E:  MOVFF  172,1B0
01782:  MOVLW  1B
01784:  MOVLB  1
01786:  MOVWF  xB1
01788:  MOVLB  0
0178A:  RCALL  12B8
0178C:  MOVLW  0D
0178E:  BTFSS  F9E.4
01790:  BRA    178E
01792:  MOVWF  FAD
01794:  MOVLW  0A
01796:  BTFSS  F9E.4
01798:  BRA    1796
0179A:  MOVWF  FAD
....................          delay_ms(50); 
0179C:  MOVLW  32
0179E:  MOVLB  1
017A0:  MOVWF  xB1
017A2:  MOVLB  0
017A4:  CALL   0B8E
....................          fprintf(ESP8266, "%s",response); 
017A8:  MOVLW  01
017AA:  MOVWF  FEA
017AC:  MOVLW  73
017AE:  MOVWF  FE9
017B0:  RCALL  1036
....................          delay_ms(100); 
017B2:  MOVLW  64
017B4:  MOVLB  1
017B6:  MOVWF  xB1
017B8:  MOVLB  0
017BA:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
017BE:  MOVLW  CA
017C0:  MOVWF  FF6
017C2:  MOVLW  01
017C4:  MOVWF  FF7
017C6:  MOVLW  0C
017C8:  MOVLB  1
017CA:  MOVWF  xB0
017CC:  MOVLB  0
017CE:  CALL   0F1C
017D2:  MOVF   1C,W
017D4:  BTFSS  F9E.4
017D6:  BRA    17D4
017D8:  MOVWF  FAD
017DA:  MOVLW  0D
017DC:  BTFSS  F9E.4
017DE:  BRA    17DC
017E0:  MOVWF  FAD
017E2:  MOVLW  0A
017E4:  BTFSS  F9E.4
017E6:  BRA    17E4
017E8:  MOVWF  FAD
....................          delay_ms(500); 
017EA:  MOVLW  02
017EC:  MOVLB  1
017EE:  MOVWF  xB0
017F0:  MOVLW  FA
017F2:  MOVWF  xB1
017F4:  MOVLB  0
017F6:  CALL   0B8E
017FA:  MOVLB  1
017FC:  DECFSZ xB0,F
017FE:  BRA    17F0
....................           
....................          fprintf(ESP8266, "AT+CWSAP_DEF=%s,1,4\r\n",DATA_COMMAND); 
01800:  MOVLW  DC
01802:  MOVWF  FF6
01804:  MOVLW  01
01806:  MOVWF  FF7
01808:  MOVLW  0D
0180A:  MOVWF  xB0
0180C:  MOVLB  0
0180E:  CALL   0F1C
01812:  CLRF   FEA
01814:  MOVLW  20
01816:  MOVWF  FE9
01818:  RCALL  1036
0181A:  MOVLW  EB
0181C:  MOVWF  FF6
0181E:  MOVLW  01
01820:  MOVWF  FF7
01822:  MOVLW  06
01824:  MOVLB  1
01826:  MOVWF  xB0
01828:  MOVLB  0
0182A:  CALL   0F1C
....................          delay_ms(1000); 
0182E:  MOVLW  04
01830:  MOVLB  1
01832:  MOVWF  xB0
01834:  MOVLW  FA
01836:  MOVWF  xB1
01838:  MOVLB  0
0183A:  CALL   0B8E
0183E:  MOVLB  1
01840:  DECFSZ xB0,F
01842:  BRA    1834
....................          reset = 1; 
01844:  MOVLW  01
01846:  MOVWF  x6E
....................       } // Fin comando AP 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
01848:  MOVF   1E,W
0184A:  SUBLW  4E
0184C:  BTFSS  FD8.2
0184E:  BRA    193C
01850:  MOVF   1F,W
01852:  SUBLW  4D
01854:  BNZ   193C
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
01856:  MOVF   FF2,W
01858:  MOVWF  00
0185A:  BCF    FF2.7
0185C:  CLRF   FAA
0185E:  CLRF   FA9
01860:  MOVFF  20,FA8
01864:  BCF    FA6.6
01866:  BCF    FA6.7
01868:  BSF    FA6.2
0186A:  MOVLB  F
0186C:  MOVLW  55
0186E:  MOVWF  FA7
01870:  MOVLW  AA
01872:  MOVWF  FA7
01874:  BSF    FA6.1
01876:  BTFSC  FA6.1
01878:  BRA    1876
0187A:  BCF    FA6.2
0187C:  MOVF   00,W
0187E:  IORWF  FF2,F
....................          delay_ms(10); 
01880:  MOVLW  0A
01882:  MOVLB  1
01884:  MOVWF  xB1
01886:  MOVLB  0
01888:  CALL   0B8E
....................           
....................          // Responde la solicitud 
....................          delay_ms(20); 
0188C:  MOVLW  14
0188E:  MOVLB  1
01890:  MOVWF  xB1
01892:  MOVLB  0
01894:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01898:  MOVLW  F2
0189A:  MOVWF  FF6
0189C:  MOVLW  01
0189E:  MOVWF  FF7
018A0:  MOVLW  0B
018A2:  MOVLB  1
018A4:  MOVWF  xB0
018A6:  MOVLB  0
018A8:  CALL   0F1C
018AC:  MOVF   1C,W
018AE:  BTFSS  F9E.4
018B0:  BRA    18AE
018B2:  MOVWF  FAD
018B4:  MOVLW  2C
018B6:  BTFSS  F9E.4
018B8:  BRA    18B6
018BA:  MOVWF  FAD
018BC:  MOVFF  172,1B0
018C0:  MOVLW  1B
018C2:  MOVLB  1
018C4:  MOVWF  xB1
018C6:  MOVLB  0
018C8:  RCALL  12B8
018CA:  MOVLW  0D
018CC:  BTFSS  F9E.4
018CE:  BRA    18CC
018D0:  MOVWF  FAD
018D2:  MOVLW  0A
018D4:  BTFSS  F9E.4
018D6:  BRA    18D4
018D8:  MOVWF  FAD
....................          delay_ms(50); 
018DA:  MOVLW  32
018DC:  MOVLB  1
018DE:  MOVWF  xB1
018E0:  MOVLB  0
018E2:  CALL   0B8E
....................          fprintf(ESP8266, "%s",response); 
018E6:  MOVLW  01
018E8:  MOVWF  FEA
018EA:  MOVLW  73
018EC:  MOVWF  FE9
018EE:  CALL   1036
....................          delay_ms(100); 
018F2:  MOVLW  64
018F4:  MOVLB  1
018F6:  MOVWF  xB1
018F8:  MOVLB  0
018FA:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
018FE:  MOVLW  06
01900:  MOVWF  FF6
01902:  MOVLW  02
01904:  MOVWF  FF7
01906:  MOVLW  0C
01908:  MOVLB  1
0190A:  MOVWF  xB0
0190C:  MOVLB  0
0190E:  CALL   0F1C
01912:  MOVF   1C,W
01914:  BTFSS  F9E.4
01916:  BRA    1914
01918:  MOVWF  FAD
0191A:  MOVLW  0D
0191C:  BTFSS  F9E.4
0191E:  BRA    191C
01920:  MOVWF  FAD
01922:  MOVLW  0A
01924:  BTFSS  F9E.4
01926:  BRA    1924
01928:  MOVWF  FAD
....................          delay_ms(100); 
0192A:  MOVLW  64
0192C:  MOVLB  1
0192E:  MOVWF  xB1
01930:  MOVLB  0
01932:  CALL   0B8E
....................          reset = 1; 
01936:  MOVLW  01
01938:  MOVLB  1
0193A:  MOVWF  x6E
....................       } // Fin comando NM 
....................        
....................       /********************************* 
....................       *** Optiene el estado de Puerto ** 
....................       *** CMD:OS,0:                   ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='S') 
0193C:  MOVF   1E,W
0193E:  SUBLW  4F
01940:  BTFSS  FD8.2
01942:  BRA    1A70
01944:  MOVF   1F,W
01946:  SUBLW  53
01948:  BTFSS  FD8.2
0194A:  BRA    1A70
....................       { 
....................          //char  response[57]; 
....................           
....................          response[0]  = '{'; 
0194C:  MOVLW  7B
0194E:  MOVWF  x73
....................          response[1]  = '"'; 
01950:  MOVLW  22
01952:  MOVWF  x74
....................          response[2]  = '0'; 
01954:  MOVLW  30
01956:  MOVWF  x75
....................          response[3]  = '"'; 
01958:  MOVLW  22
0195A:  MOVWF  x76
....................          response[4]  = ':'; 
0195C:  MOVLW  3A
0195E:  MOVWF  x77
....................          response[5]  = input_state(PIN_OUT[0])+ 48; 
01960:  MOVLW  00
01962:  BTFSC  F84.2
01964:  MOVLW  01
01966:  ADDLW  30
01968:  MOVWF  x78
....................          response[6]  = ','; 
0196A:  MOVLW  2C
0196C:  MOVWF  x79
....................           
....................          response[7]   = '"'; 
0196E:  MOVLW  22
01970:  MOVWF  x7A
....................          response[8]   = '1'; 
01972:  MOVLW  31
01974:  MOVWF  x7B
....................          response[9]   = '"'; 
01976:  MOVLW  22
01978:  MOVWF  x7C
....................          response[10]  = ':'; 
0197A:  MOVLW  3A
0197C:  MOVWF  x7D
....................          response[11]  = input_state(PIN_OUT[1])+ 48; 
0197E:  MOVLW  00
01980:  BTFSC  F84.1
01982:  MOVLW  01
01984:  ADDLW  30
01986:  MOVWF  x7E
....................          response[12]  = ','; 
01988:  MOVLW  2C
0198A:  MOVWF  x7F
....................           
....................          response[13]  = '"'; 
0198C:  MOVLW  22
0198E:  MOVWF  x80
....................          response[14]  = '2'; 
01990:  MOVLW  32
01992:  MOVWF  x81
....................          response[15]  = '"'; 
01994:  MOVLW  22
01996:  MOVWF  x82
....................          response[16]  = ':'; 
01998:  MOVLW  3A
0199A:  MOVWF  x83
....................          response[17]  = input_state(PIN_OUT[2])+ 48; 
0199C:  MOVLW  00
0199E:  BTFSC  F84.0
019A0:  MOVLW  01
019A2:  ADDLW  30
019A4:  MOVWF  x84
....................          response[18]  = ','; 
019A6:  MOVLW  2C
019A8:  MOVWF  x85
....................           
....................          response[19]  = '"'; 
019AA:  MOVLW  22
019AC:  MOVWF  x86
....................          response[20]  = '3'; 
019AE:  MOVLW  33
019B0:  MOVWF  x87
....................          response[21]  = '"'; 
019B2:  MOVLW  22
019B4:  MOVWF  x88
....................          response[22]  = ':'; 
019B6:  MOVLW  3A
019B8:  MOVWF  x89
....................          response[23]  = input_state(PIN_OUT[3])+ 48; 
019BA:  MOVLW  00
019BC:  BTFSC  F80.4
019BE:  MOVLW  01
019C0:  ADDLW  30
019C2:  MOVWF  x8A
....................          response[24]  = ','; 
019C4:  MOVLW  2C
019C6:  MOVWF  x8B
....................           
....................          response[25]  = '"'; 
019C8:  MOVLW  22
019CA:  MOVWF  x8C
....................          response[26]  = '4'; 
019CC:  MOVLW  34
019CE:  MOVWF  x8D
....................          response[27]  = '"'; 
019D0:  MOVLW  22
019D2:  MOVWF  x8E
....................          response[28]  = ':'; 
019D4:  MOVLW  3A
019D6:  MOVWF  x8F
....................          response[29]  = input_state(PIN_OUT[4])+ 48; 
019D8:  MOVLW  00
019DA:  BTFSC  F80.0
019DC:  MOVLW  01
019DE:  ADDLW  30
019E0:  MOVWF  x90
....................          response[30]  = ','; 
019E2:  MOVLW  2C
019E4:  MOVWF  x91
....................           
....................          response[31]  = '"'; 
019E6:  MOVLW  22
019E8:  MOVWF  x92
....................          response[32]  = '5'; 
019EA:  MOVLW  35
019EC:  MOVWF  x93
....................          response[33]  = '"'; 
019EE:  MOVLW  22
019F0:  MOVWF  x94
....................          response[34]  = ':'; 
019F2:  MOVLW  3A
019F4:  MOVWF  x95
....................          response[35]  = input_state(PIN_OUT[5])+ 48; 
019F6:  MOVLW  00
019F8:  BTFSC  F80.1
019FA:  MOVLW  01
019FC:  ADDLW  30
019FE:  MOVWF  x96
....................          response[36]  = ','; 
01A00:  MOVLW  2C
01A02:  MOVWF  x97
....................           
....................          response[37]  = '"'; 
01A04:  MOVLW  22
01A06:  MOVWF  x98
....................          response[38]  = '6'; 
01A08:  MOVLW  36
01A0A:  MOVWF  x99
....................          response[39]  = '"'; 
01A0C:  MOVLW  22
01A0E:  MOVWF  x9A
....................          response[40]  = ':'; 
01A10:  MOVLW  3A
01A12:  MOVWF  x9B
....................          response[41]  = input_state(PIN_OUT[6])+ 48; 
01A14:  MOVLW  00
01A16:  BTFSC  F80.2
01A18:  MOVLW  01
01A1A:  ADDLW  30
01A1C:  MOVWF  x9C
....................          response[42]  = ','; 
01A1E:  MOVLW  2C
01A20:  MOVWF  x9D
....................           
....................          response[43]  = '"'; 
01A22:  MOVLW  22
01A24:  MOVWF  x9E
....................          response[44]  = '7'; 
01A26:  MOVLW  37
01A28:  MOVWF  x9F
....................          response[45]  = '"'; 
01A2A:  MOVLW  22
01A2C:  MOVWF  xA0
....................          response[46]  = ':'; 
01A2E:  MOVLW  3A
01A30:  MOVWF  xA1
....................          response[47]  = input_state(PIN_OUT[7])+ 48; 
01A32:  MOVLW  00
01A34:  BTFSC  F80.3
01A36:  MOVLW  01
01A38:  ADDLW  30
01A3A:  MOVWF  xA2
....................          response[48]  = ','; 
01A3C:  MOVLW  2C
01A3E:  MOVWF  xA3
....................           
....................          response[49]  = '"'; 
01A40:  MOVLW  22
01A42:  MOVWF  xA4
....................          response[50]  = 'M'; 
01A44:  MOVLW  4D
01A46:  MOVWF  xA5
....................          response[51]  = '"'; 
01A48:  MOVLW  22
01A4A:  MOVWF  xA6
....................          response[52]  = ':'; 
01A4C:  MOVLW  3A
01A4E:  MOVWF  xA7
....................          response[53]  = read_eeprom(0x00); 
01A50:  MOVFF  FF2,1B0
01A54:  BCF    FF2.7
01A56:  CLRF   FAA
01A58:  CLRF   FA9
01A5A:  BCF    FA6.6
01A5C:  BCF    FA6.7
01A5E:  BSF    FA6.0
01A60:  MOVF   FA8,W
01A62:  BTFSC  xB0.7
01A64:  BSF    FF2.7
01A66:  MOVWF  xA8
....................           
....................          response[54]  = '}'; 
01A68:  MOVLW  7D
01A6A:  MOVWF  xA9
....................          lenResponse   = 55; 
01A6C:  MOVLW  37
01A6E:  MOVWF  x72
....................       } // Fin comando OS 
....................        
....................       /*********************************** 
....................       *** Cambia el Nombre de Puerto    ** 
....................       *** lo almacena en la EEPROM      ** 
....................       *** CMD:NO,0NombreChar[10]:       ** 
....................       ***********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='O') 
01A70:  MOVF   1E,W
01A72:  SUBLW  4E
01A74:  BTFSS  FD8.2
01A76:  BRA    1B5C
01A78:  MOVF   1F,W
01A7A:  SUBLW  4F
01A7C:  BNZ   1B5C
....................       { 
....................           
....................          int posIni = 0, posFin = 0; 
01A7E:  CLRF   xAD
01A80:  CLRF   xAE
....................          optSelected =(int) ( DATA_COMMAND[0] - 48); 
01A82:  MOVLW  30
01A84:  SUBWF  20,W
01A86:  MOVWF  x6F
....................          posIni =( 10 * optSelected ) + 40; 
01A88:  MOVF   x6F,W
01A8A:  MULLW  0A
01A8C:  MOVF   FF3,W
01A8E:  ADDLW  28
01A90:  MOVWF  xAD
....................          posFin = posIni + 10; 
01A92:  MOVLW  0A
01A94:  ADDWF  xAD,W
01A96:  MOVWF  xAE
....................           
....................          // Guarda el nuevo nombre 
....................          for(idxRSTNC=posIni;idxRSTNC<(posIni+LEN_DATA_COMMAND);idxRSTNC++){ 
01A98:  MOVFF  1AD,171
01A9C:  MOVF   xAD,W
01A9E:  ADDWF  52,W
01AA0:  MOVWF  01
01AA2:  MOVLW  00
01AA4:  ADDWFC 53,W
01AA6:  MOVWF  03
01AA8:  MOVF   01,W
01AAA:  MOVF   03,F
01AAC:  BNZ   1AB4
01AAE:  MOVF   01,W
01AB0:  SUBWF  x71,W
01AB2:  BC    1B06
....................             counter++; 
01AB4:  INCF   x70,F
....................             write_eeprom(idxRSTNC,DATA_COMMAND[counter]); 
01AB6:  CLRF   03
01AB8:  MOVF   x70,W
01ABA:  ADDLW  20
01ABC:  MOVWF  FE9
01ABE:  MOVLW  00
01AC0:  ADDWFC 03,W
01AC2:  MOVWF  FEA
01AC4:  MOVFF  FEF,1B0
01AC8:  MOVF   FF2,W
01ACA:  MOVWF  00
01ACC:  BCF    FF2.7
01ACE:  CLRF   FAA
01AD0:  MOVFF  171,FA9
01AD4:  MOVFF  1B0,FA8
01AD8:  BCF    FA6.6
01ADA:  BCF    FA6.7
01ADC:  BSF    FA6.2
01ADE:  MOVLB  F
01AE0:  MOVLW  55
01AE2:  MOVWF  FA7
01AE4:  MOVLW  AA
01AE6:  MOVWF  FA7
01AE8:  BSF    FA6.1
01AEA:  BTFSC  FA6.1
01AEC:  BRA    1AEA
01AEE:  BCF    FA6.2
01AF0:  MOVF   00,W
01AF2:  IORWF  FF2,F
....................             delay_ms(10); 
01AF4:  MOVLW  0A
01AF6:  MOVLB  1
01AF8:  MOVWF  xB1
01AFA:  MOVLB  0
01AFC:  CALL   0B8E
01B00:  MOVLB  1
01B02:  INCF   x71,F
01B04:  BRA    1A9C
....................          } 
....................           
....................          // Borra el restante de la eeprom para almacenar las nuevas credenciales 
....................          for(idxRSTNC=(posIni+LEN_DATA_COMMAND+1);idxRSTNC<=posFin;idxRSTNC++){ 
01B06:  MOVF   xAD,W
01B08:  ADDWF  52,W
01B0A:  MOVWF  xB0
01B0C:  MOVLW  00
01B0E:  ADDWFC 53,W
01B10:  MOVWF  xB1
01B12:  MOVLW  01
01B14:  ADDWF  xB0,W
01B16:  MOVWF  x71
01B18:  MOVF   x71,W
01B1A:  SUBWF  xAE,W
01B1C:  BNC   1B5A
....................             write_eeprom(idxRSTNC,0xFF); 
01B1E:  MOVF   FF2,W
01B20:  MOVWF  00
01B22:  BCF    FF2.7
01B24:  CLRF   FAA
01B26:  MOVFF  171,FA9
01B2A:  SETF   FA8
01B2C:  BCF    FA6.6
01B2E:  BCF    FA6.7
01B30:  BSF    FA6.2
01B32:  MOVLB  F
01B34:  MOVLW  55
01B36:  MOVWF  FA7
01B38:  MOVLW  AA
01B3A:  MOVWF  FA7
01B3C:  BSF    FA6.1
01B3E:  BTFSC  FA6.1
01B40:  BRA    1B3E
01B42:  BCF    FA6.2
01B44:  MOVF   00,W
01B46:  IORWF  FF2,F
....................             delay_ms(10); 
01B48:  MOVLW  0A
01B4A:  MOVLB  1
01B4C:  MOVWF  xB1
01B4E:  MOVLB  0
01B50:  CALL   0B8E
01B54:  MOVLB  1
01B56:  INCF   x71,F
01B58:  BRA    1B18
....................          } 
....................           
....................          counter = 0; 
01B5A:  CLRF   x70
....................          //reset = 1; //Reinicia el Dispositivo 
....................       } // Fin comando NO 
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................       if(reset==0){ 
01B5C:  MOVF   x6E,F
01B5E:  BNZ   1C0C
....................          // Responde la solicitud 
....................          delay_ms(20); 
01B60:  MOVLW  14
01B62:  MOVWF  xB1
01B64:  MOVLB  0
01B66:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01B6A:  MOVLW  18
01B6C:  MOVWF  FF6
01B6E:  MOVLW  02
01B70:  MOVWF  FF7
01B72:  MOVLW  0B
01B74:  MOVLB  1
01B76:  MOVWF  xB0
01B78:  MOVLB  0
01B7A:  CALL   0F1C
01B7E:  MOVF   1C,W
01B80:  BTFSS  F9E.4
01B82:  BRA    1B80
01B84:  MOVWF  FAD
01B86:  MOVLW  2C
01B88:  BTFSS  F9E.4
01B8A:  BRA    1B88
01B8C:  MOVWF  FAD
01B8E:  MOVFF  172,1B0
01B92:  MOVLW  1B
01B94:  MOVLB  1
01B96:  MOVWF  xB1
01B98:  MOVLB  0
01B9A:  CALL   12B8
01B9E:  MOVLW  0D
01BA0:  BTFSS  F9E.4
01BA2:  BRA    1BA0
01BA4:  MOVWF  FAD
01BA6:  MOVLW  0A
01BA8:  BTFSS  F9E.4
01BAA:  BRA    1BA8
01BAC:  MOVWF  FAD
....................          delay_ms(50); 
01BAE:  MOVLW  32
01BB0:  MOVLB  1
01BB2:  MOVWF  xB1
01BB4:  MOVLB  0
01BB6:  CALL   0B8E
....................          fprintf(ESP8266, "%s",response); 
01BBA:  MOVLW  01
01BBC:  MOVWF  FEA
01BBE:  MOVLW  73
01BC0:  MOVWF  FE9
01BC2:  CALL   1036
....................          delay_ms(100); 
01BC6:  MOVLW  64
01BC8:  MOVLB  1
01BCA:  MOVWF  xB1
01BCC:  MOVLB  0
01BCE:  CALL   0B8E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01BD2:  MOVLW  2C
01BD4:  MOVWF  FF6
01BD6:  MOVLW  02
01BD8:  MOVWF  FF7
01BDA:  MOVLW  0C
01BDC:  MOVLB  1
01BDE:  MOVWF  xB0
01BE0:  MOVLB  0
01BE2:  CALL   0F1C
01BE6:  MOVF   1C,W
01BE8:  BTFSS  F9E.4
01BEA:  BRA    1BE8
01BEC:  MOVWF  FAD
01BEE:  MOVLW  0D
01BF0:  BTFSS  F9E.4
01BF2:  BRA    1BF0
01BF4:  MOVWF  FAD
01BF6:  MOVLW  0A
01BF8:  BTFSS  F9E.4
01BFA:  BRA    1BF8
01BFC:  MOVWF  FAD
....................          delay_ms(100); 
01BFE:  MOVLW  64
01C00:  MOVLB  1
01C02:  MOVWF  xB1
01C04:  MOVLB  0
01C06:  CALL   0B8E
01C0A:  MOVLB  1
....................       } 
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
01C0C:  CLRF   xAF
01C0E:  MOVF   53,F
01C10:  BNZ   1C18
01C12:  MOVF   xAF,W
01C14:  SUBWF  52,W
01C16:  BNC   1C2C
....................          DATA_COMMAND[idxCb] = 0x00; 
01C18:  CLRF   03
01C1A:  MOVF   xAF,W
01C1C:  ADDLW  20
01C1E:  MOVWF  FE9
01C20:  MOVLW  00
01C22:  ADDWFC 03,W
01C24:  MOVWF  FEA
01C26:  CLRF   FEF
01C28:  INCF   xAF,F
01C2A:  BRA    1C0E
....................       } 
....................       for(idxCb=0;idxCb<=56;idxCb++){ 
01C2C:  CLRF   xAF
01C2E:  MOVF   xAF,W
01C30:  SUBLW  38
01C32:  BNC   1C48
....................       response[idxCb] = 0x00; 
01C34:  CLRF   03
01C36:  MOVF   xAF,W
01C38:  ADDLW  73
01C3A:  MOVWF  FE9
01C3C:  MOVLW  01
01C3E:  ADDWFC 03,W
01C40:  MOVWF  FEA
01C42:  CLRF   FEF
01C44:  INCF   xAF,F
01C46:  BRA    1C2E
....................       } 
....................       COMMAND[0]       = 0x00; 
01C48:  CLRF   1E
....................       COMMAND[1]       = 0x00; 
01C4A:  CLRF   1F
....................       ID_CONNETION[0]  = 0x00; 
01C4C:  CLRF   1C
....................        
....................       flag_Resp_Ready  = 0x00; 
01C4E:  CLRF   57
....................       LEN_DATA_COMMAND = 0x00; 
01C50:  CLRF   53
01C52:  CLRF   52
....................        
....................       if(reset==1){ 
01C54:  DECFSZ x6E,W
01C56:  BRA    1C5C
....................          reset = 0; 
01C58:  CLRF   x6E
....................           // Reinicia el dispositivo 
....................          reset_cpu(); 
01C5A:  RESET
....................       } 
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return reset; 
01C5C:  MOVFF  16E,01
01C60:  MOVLB  0
01C62:  RETURN 0
.................... } // Fin de la Funcion run_command_wifi() 
....................  
.................... #include "header/esp8266.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          esp8266.H: Inicializa el Modulo esp8266 y 
....................                              maneja las interrupciones USART 
....................                              para procesar los comandos wifi. 
....................  
.................... *******************************************************/ 
....................  
.................... /* 
....................      **  Funcionamiento de las funciones de Busqueda y comparacion  
....................      **  de String. 
....................      ** 
....................  
.................... Cuenta el numero de aciertos de manera secuencial cuando compara los  
.................... caracteres que recibe por el usart vs una cadena constante. Si el  
.................... numero de aciertos es igual a la cadena entonces las cadenas son iguales 
.................... y almacena en una estructura los siguientes caracteres recibidos hasta  
.................... que encuentre el caracter del fin de la cadena (":"). 
....................  
.................... */ 
....................  
.................... #define  CMD_MODE                   1 
.................... #define  CMD_DO_CONN                2 
.................... #define  CMD_CONN                   3 
.................... #define  READY_RESPONSE_WIFI        4  
.................... #define  CMD_GET_IP_FROM_MENU       5 
.................... #define  CMD_GET_AP_INFO_FROM_MENU  6 
.................... #define  CMD_GET_STA_INFO_FROM_MENU 7 
....................  
.................... /* Key flag responses */ 
.................... const int   Valid      = 0; 
.................... const int   CWJAP      = 1; 
.................... const int   NoAp       = 2; 
.................... const int   Connected  = 3; 
.................... const int   Fail       = 4; 
.................... const int   Error      = 5; 
....................  
.................... /* Declaracion de Funciones */ 
.................... void getIP(int buffer); 
.................... void getAPInfo(int buffer); 
.................... void getSTAInfo(int buffer); 
.................... int  waitResp(void); 
.................... void waitRespMajor(int buffer,int flag_resp); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int resp_Pos   = 1; 
.................... int resp_Flag  = 0; 
.................... int countResp  = 5;     //Conteo de Respuestas esperadas 
....................  
.................... char buffer_flag_Resp[2][6]   =   
.................... { 
....................    {0,0,0,0,0,0}, // Flag_Responses Command valid 
....................    {0,0,0,0,0,0}  // Flag_Pos_Responses 
.................... }; 
....................  
.................... char buffer_Resp_CMD[5][16]   = 
.................... { 
....................    {"0.0.0.0"},   // IP    AP 
....................    {"0.0.0.0"},   // IP    STA 
....................    {""},          // SSID  AP 
....................    {""},          // Key   AP 
....................    {""}           // SSID  STA 
.................... }; 
....................  
.................... int flag_Resp_Get_IP_CMD = 0; 
.................... int flag_Pos_Get_IP_CMD  = 0; 
....................  
.................... int flag_Resp_Get_AP_Info_CMD = 0; 
.................... int flag_Pos_Get_AP_Info_CMD  = 0; 
....................  
.................... int flag_Resp_Get_STA_Info_CMD = 0; 
.................... int flag_Pos_Get_STA_Info_CMD  = 0; 
....................  
.................... /* Variables que se setean con la data de la EEPROM */ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    //        comentarlo durante etapa de desarrollo 
....................    //        Configurar el USART a 9600bps 
....................    fprintf(ESP8266, "AT+RST\r\n"); 
*
0105C:  MOVLW  3E
0105E:  MOVWF  FF6
01060:  MOVLW  02
01062:  MOVWF  FF7
01064:  RCALL  0EFA
....................    delay_ms(3000); 
01066:  MOVLW  0C
01068:  MOVLB  1
0106A:  MOVWF  x6A
0106C:  MOVLW  FA
0106E:  MOVWF  xB1
01070:  MOVLB  0
01072:  RCALL  0B8E
01074:  MOVLB  1
01076:  DECFSZ x6A,F
01078:  BRA    106C
....................     
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
0107A:  MOVFF  FF2,16A
0107E:  BCF    FF2.7
01080:  CLRF   FAA
01082:  CLRF   FA9
01084:  BCF    FA6.6
01086:  BCF    FA6.7
01088:  BSF    FA6.0
0108A:  MOVF   FA8,W
0108C:  BTFSC  x6A.7
0108E:  BSF    FF2.7
01090:  MOVLB  0
01092:  MOVWF  xC1
....................    delay_ms(10); 
01094:  MOVLW  0A
01096:  MOVLB  1
01098:  MOVWF  xB1
0109A:  MOVLB  0
0109C:  RCALL  0B8E
....................    switch(modeStar){ 
0109E:  MOVF   xC1,W
010A0:  XORLW  31
010A2:  BZ    10AE
010A4:  XORLW  03
010A6:  BZ    10AE
010A8:  XORLW  01
010AA:  BZ    10AE
010AC:  BRA    10B0
....................       case '1': 
....................       case '2': 
....................       case '3': 
....................          break; 
010AE:  BRA    10E8
....................       default: 
....................          write_eeprom(0x00,'3'); 
010B0:  MOVF   FF2,W
010B2:  MOVWF  00
010B4:  BCF    FF2.7
010B6:  CLRF   FAA
010B8:  CLRF   FA9
010BA:  MOVLW  33
010BC:  MOVWF  FA8
010BE:  BCF    FA6.6
010C0:  BCF    FA6.7
010C2:  BSF    FA6.2
010C4:  MOVLB  F
010C6:  MOVLW  55
010C8:  MOVWF  FA7
010CA:  MOVLW  AA
010CC:  MOVWF  FA7
010CE:  BSF    FA6.1
010D0:  BTFSC  FA6.1
010D2:  BRA    10D0
010D4:  BCF    FA6.2
010D6:  MOVF   00,W
010D8:  IORWF  FF2,F
....................          delay_ms(10); 
010DA:  MOVLW  0A
010DC:  MOVLB  1
010DE:  MOVWF  xB1
010E0:  MOVLB  0
010E2:  RCALL  0B8E
....................          modeStar = '3'; 
010E4:  MOVLW  33
010E6:  MOVWF  xC1
....................          break; 
....................    } 
....................    // Lanza el comando para configurar el modo de conexion 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeStar); 
010E8:  MOVLW  48
010EA:  MOVWF  FF6
010EC:  MOVLW  02
010EE:  MOVWF  FF7
010F0:  MOVLW  0A
010F2:  MOVLB  1
010F4:  MOVWF  xB0
010F6:  MOVLB  0
010F8:  RCALL  0F1C
010FA:  MOVF   xC1,W
010FC:  BTFSS  F9E.4
010FE:  BRA    10FC
01100:  MOVWF  FAD
01102:  MOVLW  0D
01104:  BTFSS  F9E.4
01106:  BRA    1104
01108:  MOVWF  FAD
0110A:  MOVLW  0A
0110C:  BTFSS  F9E.4
0110E:  BRA    110C
01110:  MOVWF  FAD
....................    CMD_RUN =  CMD_MODE;  
01112:  MOVLW  01
01114:  MOVWF  5B
....................    delay_ms(50); 
01116:  MOVLW  32
01118:  MOVLB  1
0111A:  MOVWF  xB1
0111C:  MOVLB  0
0111E:  RCALL  0B8E
....................     
....................    // Lanza el comando para verificar si elmodulo ya se encuentra conectado 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
01120:  MOVLW  58
01122:  MOVWF  FF6
01124:  MOVLW  02
01126:  MOVWF  FF7
01128:  RCALL  0EFA
....................    CMD_RUN =  CMD_DO_CONN; 
0112A:  MOVLW  02
0112C:  MOVWF  5B
....................  
....................    resp = waitResp(); 
0112E:  RCALL  0F46
01130:  MOVFF  01,168
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
01134:  MOVLB  1
01136:  MOVF   x68,W
01138:  SUBLW  02
0113A:  BTFSS  FD8.2
0113C:  BRA    1228
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
0113E:  CLRF   x69
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
01140:  CLRF   03
01142:  MOVF   x69,W
01144:  ADDLW  C2
01146:  MOVWF  FE9
01148:  MOVLW  00
0114A:  ADDWFC 03,W
0114C:  MOVWF  FEA
0114E:  MOVF   FEF,W
01150:  SUBLW  0A
01152:  BZ    11BE
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
01154:  CLRF   03
01156:  MOVF   x69,W
01158:  ADDLW  C2
0115A:  MOVWF  FE9
0115C:  MOVLW  00
0115E:  ADDWFC 03,W
01160:  MOVWF  FEA
01162:  MOVLW  01
01164:  ADDWF  x69,W
01166:  MOVWF  x6C
01168:  MOVFF  FF2,16D
0116C:  BCF    FF2.7
0116E:  CLRF   FAA
01170:  MOVFF  16C,FA9
01174:  BCF    FA6.6
01176:  BCF    FA6.7
01178:  BSF    FA6.0
0117A:  MOVF   FA8,W
0117C:  BTFSC  x6D.7
0117E:  BSF    FF2.7
01180:  MOVWF  FEF
....................          delay_ms(10); 
01182:  MOVLW  0A
01184:  MOVWF  xB1
01186:  MOVLB  0
01188:  RCALL  0B8E
....................          if(SSIDAndKey[idxRE]==0xFF){ 
0118A:  CLRF   03
0118C:  MOVLB  1
0118E:  MOVF   x69,W
01190:  ADDLW  C2
01192:  MOVWF  FE9
01194:  MOVLW  00
01196:  ADDWFC 03,W
01198:  MOVWF  FEA
0119A:  INCFSZ FEF,W
0119C:  BRA    11A4
....................             resp = 5; 
0119E:  MOVLW  05
011A0:  MOVWF  x68
....................             break; 
011A2:  BRA    11BE
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
011A4:  CLRF   03
011A6:  MOVF   x69,W
011A8:  ADDLW  C2
011AA:  MOVWF  FE9
011AC:  MOVLW  00
011AE:  ADDWFC 03,W
011B0:  MOVWF  FEA
011B2:  MOVF   FEF,W
011B4:  SUBLW  0A
011B6:  BNZ   11BA
....................             break; 
011B8:  BRA    11BE
....................          } 
....................          idxRE++; 
011BA:  INCF   x69,F
011BC:  BRA    1140
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
011BE:  MOVF   x68,W
011C0:  SUBLW  05
011C2:  BZ    11E8
....................          fprintf(ESP8266, "AT+CWJAP=%s",SSIDAndKey); 
011C4:  MOVLW  64
011C6:  MOVWF  FF6
011C8:  MOVLW  02
011CA:  MOVWF  FF7
011CC:  MOVLW  09
011CE:  MOVWF  xB0
011D0:  MOVLB  0
011D2:  RCALL  0F1C
011D4:  CLRF   FEA
011D6:  MOVLW  C2
011D8:  MOVWF  FE9
011DA:  RCALL  1036
....................          CMD_RUN = CMD_CONN; 
011DC:  MOVLW  03
011DE:  MOVWF  5B
....................          resp    = waitResp(); 
011E0:  RCALL  0F46
011E2:  MOVFF  01,168
011E6:  MOVLB  1
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
011E8:  MOVF   x68,W
011EA:  SUBLW  04
011EC:  BZ    11F4
011EE:  MOVF   x68,W
011F0:  SUBLW  05
011F2:  BNZ   1228
....................          fprintf(ESP8266, "AT+CWMODE=%c\r\n","3"); 
011F4:  MOVLW  70
011F6:  MOVWF  FF6
011F8:  MOVLW  02
011FA:  MOVWF  FF7
011FC:  MOVLW  0A
011FE:  MOVWF  xB0
01200:  MOVLB  0
01202:  RCALL  0F1C
01204:  MOVLB  4
01206:  MOVF   xC6,W
01208:  BTFSS  F9E.4
0120A:  BRA    1208
0120C:  MOVWF  FAD
0120E:  MOVLW  0D
01210:  BTFSS  F9E.4
01212:  BRA    1210
01214:  MOVWF  FAD
01216:  MOVLW  0A
01218:  BTFSS  F9E.4
0121A:  BRA    1218
0121C:  MOVWF  FAD
....................          CMD_RUN = CMD_MODE; 
0121E:  MOVLW  01
01220:  MOVWF  5B
....................          waitResp(); 
01222:  MOVLB  0
01224:  RCALL  0F46
01226:  MOVLB  1
....................       } 
....................    } // Fin del if(doConnect) 
....................  
....................    // Configura el modulo como server 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
01228:  MOVLW  80
0122A:  MOVWF  FF6
0122C:  MOVLW  02
0122E:  MOVWF  FF7
01230:  MOVLB  0
01232:  RCALL  0EFA
....................    delay_ms(1000); 
01234:  MOVLW  04
01236:  MOVLB  1
01238:  MOVWF  x6A
0123A:  MOVLW  FA
0123C:  MOVWF  xB1
0123E:  MOVLB  0
01240:  RCALL  0B8E
01242:  MOVLB  1
01244:  DECFSZ x6A,F
01246:  BRA    123A
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
01248:  MOVLW  8E
0124A:  MOVWF  FF6
0124C:  MOVLW  02
0124E:  MOVWF  FF7
01250:  MOVLB  0
01252:  RCALL  0EFA
....................    delay_ms(1000); 
01254:  MOVLW  04
01256:  MOVLB  1
01258:  MOVWF  x6A
0125A:  MOVLW  FA
0125C:  MOVWF  xB1
0125E:  MOVLB  0
01260:  RCALL  0B8E
01262:  MOVLB  1
01264:  DECFSZ x6A,F
01266:  BRA    125A
....................     
....................    CMD_RUN = READY_RESPONSE_WIFI; 
01268:  MOVLW  04
0126A:  MOVWF  5B
0126C:  MOVLB  0
0126E:  GOTO   2A6C (RETURN)
.................... } 
....................  
.................... /********************************************************** 
....................    Funcion encangada de procesar las respuestas del modulo,  
....................    debe ser llamada durante la interrupcion del USART 
.................... ***********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
00A80:  MOVF   5B,W
00A82:  XORLW  01
00A84:  BZ    0AA0
00A86:  XORLW  03
00A88:  BZ    0AAE
00A8A:  XORLW  01
00A8C:  BZ    0AD8
00A8E:  XORLW  06
00A90:  BZ    0B02
00A92:  XORLW  03
00A94:  BZ    0B16
00A96:  XORLW  01
00A98:  BZ    0B2A
00A9A:  XORLW  03
00A9C:  BZ    0B3E
00A9E:  BRA    0B3E
....................             case CMD_MODE: 
....................                   waitRespMajor(buffer,Valid); 
00AA0:  MOVFF  1B9,1BA
00AA4:  MOVLB  1
00AA6:  CLRF   xBB
00AA8:  MOVLB  0
00AAA:  RCALL  05A0
....................                   break; 
00AAC:  BRA    0B64
....................  
....................             case CMD_DO_CONN: 
....................                   waitRespMajor(buffer,NoAp); 
00AAE:  MOVFF  1B9,1BA
00AB2:  MOVLW  02
00AB4:  MOVLB  1
00AB6:  MOVWF  xBB
00AB8:  MOVLB  0
00ABA:  RCALL  05A0
....................                   waitRespMajor(buffer,CWJAP); 
00ABC:  MOVFF  1B9,1BA
00AC0:  MOVLW  01
00AC2:  MOVLB  1
00AC4:  MOVWF  xBB
00AC6:  MOVLB  0
00AC8:  RCALL  05A0
....................                   waitRespMajor(buffer,Valid); 
00ACA:  MOVFF  1B9,1BA
00ACE:  MOVLB  1
00AD0:  CLRF   xBB
00AD2:  MOVLB  0
00AD4:  RCALL  05A0
....................                   break; 
00AD6:  BRA    0B64
....................  
....................             case CMD_CONN: 
....................                   waitRespMajor(buffer,Connected); 
00AD8:  MOVFF  1B9,1BA
00ADC:  MOVLW  03
00ADE:  MOVLB  1
00AE0:  MOVWF  xBB
00AE2:  MOVLB  0
00AE4:  RCALL  05A0
....................                   waitRespMajor(buffer,Fail); 
00AE6:  MOVFF  1B9,1BA
00AEA:  MOVLW  04
00AEC:  MOVLB  1
00AEE:  MOVWF  xBB
00AF0:  MOVLB  0
00AF2:  RCALL  05A0
....................                   waitRespMajor(buffer,Valid); 
00AF4:  MOVFF  1B9,1BA
00AF8:  MOVLB  1
00AFA:  CLRF   xBB
00AFC:  MOVLB  0
00AFE:  RCALL  05A0
....................                   break; 
00B00:  BRA    0B64
....................              
....................             case CMD_GET_IP_FROM_MENU: 
....................                   getIP(buffer); 
00B02:  MOVFF  1B9,1BA
00B06:  BRA    07B6
....................                   waitRespMajor(buffer,Valid); 
00B08:  MOVFF  1B9,1BA
00B0C:  MOVLB  1
00B0E:  CLRF   xBB
00B10:  MOVLB  0
00B12:  RCALL  05A0
....................                   break; 
00B14:  BRA    0B64
....................                    
....................             case CMD_GET_AP_INFO_FROM_MENU: 
....................                   getAPInfo(buffer); 
00B16:  MOVFF  1B9,1BA
00B1A:  BRA    0886
....................                   waitRespMajor(buffer,Valid); 
00B1C:  MOVFF  1B9,1BA
00B20:  MOVLB  1
00B22:  CLRF   xBB
00B24:  MOVLB  0
00B26:  RCALL  05A0
....................                   break; 
00B28:  BRA    0B64
....................              
....................             case CMD_GET_STA_INFO_FROM_MENU: 
....................                   getSTAInfo(buffer); 
00B2A:  MOVFF  1B9,1BA
00B2E:  BRA    091E
....................                   waitRespMajor(buffer,Valid); 
00B30:  MOVFF  1B9,1BA
00B34:  MOVLB  1
00B36:  CLRF   xBB
00B38:  MOVLB  0
00B3A:  RCALL  05A0
....................                   break; 
00B3C:  BRA    0B64
....................                    
....................             case READY_RESPONSE_WIFI: 
....................             default: 
....................                   ESP8266_Get_IPD(buffer); 
00B3E:  MOVLB  1
00B40:  CLRF   xBB
00B42:  MOVFF  1B9,1BA
00B46:  MOVLB  0
00B48:  BRA    0960
....................                   ESP8266_Get_CMD(buffer); 
00B4A:  MOVLB  1
00B4C:  CLRF   xBB
00B4E:  MOVFF  1B9,1BA
00B52:  MOVLB  0
00B54:  BRA    09C8
....................                   ESP8266_Get_Data(buffer); 
00B56:  MOVLB  1
00B58:  CLRF   xBB
00B5A:  MOVFF  1B9,1BA
00B5E:  MOVLB  0
00B60:  BRA    0A34
....................              
....................                   CMD_RUN = 0x00; 
00B62:  CLRF   5B
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
00B64:  GOTO   0B7A (RETURN)
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
00F46:  MOVLB  1
00F48:  CLRF   x6C
00F4A:  CLRF   x6D
.................... { 
....................    int ret=0,idx=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(buffer_flag_Resp[resp_Flag][Valid]==0){ 
00F4C:  MOVF   5D,W
00F4E:  MULLW  06
00F50:  MOVF   FF3,W
00F52:  CLRF   x6F
00F54:  MOVWF  x6E
00F56:  MOVLW  5F
00F58:  ADDWF  x6E,W
00F5A:  MOVWF  FE9
00F5C:  MOVLW  00
00F5E:  ADDWFC x6F,W
00F60:  MOVWF  FEA
00F62:  MOVF   FEF,F
00F64:  BNZ   100A
....................       idx++; 
00F66:  INCF   x6D,F
....................       if(buffer_flag_Resp[resp_Flag][idx]==1){ 
00F68:  MOVF   5D,W
00F6A:  MULLW  06
00F6C:  MOVF   FF3,W
00F6E:  CLRF   x6F
00F70:  MOVWF  x6E
00F72:  CLRF   03
00F74:  MOVF   x6D,W
00F76:  ADDWF  x6E,W
00F78:  MOVWF  01
00F7A:  MOVF   x6F,W
00F7C:  ADDWFC 03,F
00F7E:  MOVF   01,W
00F80:  ADDLW  5F
00F82:  MOVWF  FE9
00F84:  MOVLW  00
00F86:  ADDWFC 03,W
00F88:  MOVWF  FEA
00F8A:  DECFSZ FEF,W
00F8C:  BRA    1000
....................          buffer_flag_Resp[resp_Pos][idx]   = 0; 
00F8E:  MOVF   5C,W
00F90:  MULLW  06
00F92:  MOVF   FF3,W
00F94:  CLRF   x6F
00F96:  MOVWF  x6E
00F98:  CLRF   03
00F9A:  MOVF   x6D,W
00F9C:  ADDWF  x6E,W
00F9E:  MOVWF  01
00FA0:  MOVF   x6F,W
00FA2:  ADDWFC 03,F
00FA4:  MOVF   01,W
00FA6:  ADDLW  5F
00FA8:  MOVWF  FE9
00FAA:  MOVLW  00
00FAC:  ADDWFC 03,W
00FAE:  MOVWF  FEA
00FB0:  CLRF   FEF
....................          buffer_flag_Resp[resp_Flag][idx]  = 0; 
00FB2:  MOVF   5D,W
00FB4:  MULLW  06
00FB6:  MOVF   FF3,W
00FB8:  CLRF   x6F
00FBA:  MOVWF  x6E
00FBC:  CLRF   03
00FBE:  MOVF   x6D,W
00FC0:  ADDWF  x6E,W
00FC2:  MOVWF  01
00FC4:  MOVF   x6F,W
00FC6:  ADDWFC 03,F
00FC8:  MOVF   01,W
00FCA:  ADDLW  5F
00FCC:  MOVWF  FE9
00FCE:  MOVLW  00
00FD0:  ADDWFC 03,W
00FD2:  MOVWF  FEA
00FD4:  CLRF   FEF
....................          
....................          if(idx == Fail || idx == Error){ 
00FD6:  MOVF   x6D,W
00FD8:  SUBLW  04
00FDA:  BZ    0FE2
00FDC:  MOVF   x6D,W
00FDE:  SUBLW  05
00FE0:  BNZ   0FFC
....................             buffer_flag_Resp[resp_Flag][Valid]  = 1; 
00FE2:  MOVF   5D,W
00FE4:  MULLW  06
00FE6:  MOVF   FF3,W
00FE8:  CLRF   x6F
00FEA:  MOVWF  x6E
00FEC:  MOVLW  5F
00FEE:  ADDWF  x6E,W
00FF0:  MOVWF  FE9
00FF2:  MOVLW  00
00FF4:  ADDWFC x6F,W
00FF6:  MOVWF  FEA
00FF8:  MOVLW  01
00FFA:  MOVWF  FEF
....................          } 
....................          ret = idx; 
00FFC:  MOVFF  16D,16C
....................       } 
....................       // Reinicia el contador para no desbordar el array de flag_resp 
....................       if(idx>=countResp){ 
01000:  MOVF   5E,W
01002:  SUBWF  x6D,W
01004:  BNC   1008
....................          idx = 0; 
01006:  CLRF   x6D
....................       } 
01008:  BRA    0F4C
....................        
....................    }; // Fin del loop 
....................     
....................    buffer_flag_Resp[resp_Flag][Valid] = 0; 
0100A:  MOVF   5D,W
0100C:  MULLW  06
0100E:  MOVF   FF3,W
01010:  CLRF   x6F
01012:  MOVWF  x6E
01014:  MOVLW  5F
01016:  ADDWF  x6E,W
01018:  MOVWF  FE9
0101A:  MOVLW  00
0101C:  ADDWFC x6F,W
0101E:  MOVWF  FEA
01020:  CLRF   FEF
....................    CMD_RUN = 0x00; 
01022:  CLRF   5B
....................    delay_ms(10); 
01024:  MOVLW  0A
01026:  MOVWF  xB1
01028:  MOVLB  0
0102A:  RCALL  0B8E
....................    return ret; 
0102C:  MOVLB  1
0102E:  MOVFF  16C,01
01032:  MOVLB  0
01034:  RETURN 0
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
.................... void waitRespMajor(int buffer,int flag_resp) 
*
005A0:  MOVLB  1
005A2:  CLRF   xC6
005A4:  CLRF   xC7
.................... { 
....................     
....................    char  strResp[10]; 
....................    int   lenResp = 0,restartFlag = 0; 
....................  
....................    switch(flag_resp) 
005A6:  MOVF   xBB,W
005A8:  ADDLW  FB
005AA:  BTFSC  FD8.0
005AC:  BRA    0692
005AE:  ADDLW  05
005B0:  MOVLB  0
005B2:  GOTO   0792
....................    { 
....................       case Valid: 
....................          strResp = "OK\r\n"; 
005B6:  MOVLW  01
005B8:  MOVWF  FEA
005BA:  MOVLW  BC
005BC:  MOVWF  FE9
005BE:  MOVFF  FF2,1C8
005C2:  BCF    FF2.7
005C4:  MOVLW  00
005C6:  RCALL  00EA
005C8:  TBLRD*-
005CA:  TBLRD*+
005CC:  MOVF   FF5,W
005CE:  MOVWF  FEE
005D0:  IORLW  00
005D2:  BNZ   05CA
005D4:  MOVLB  1
005D6:  BTFSC  xC8.7
005D8:  BSF    FF2.7
....................          lenResp = 4; 
005DA:  MOVLW  04
005DC:  MOVWF  xC6
....................          restartFlag = 1; 
005DE:  MOVLW  01
005E0:  MOVWF  xC7
....................          break; 
005E2:  BRA    0692
....................  
....................       case NoAp: 
....................          strResp = "No Ap"; 
005E4:  MOVLW  01
005E6:  MOVWF  FEA
005E8:  MOVLW  BC
005EA:  MOVWF  FE9
005EC:  MOVFF  FF2,1C8
005F0:  BCF    FF2.7
005F2:  MOVLW  00
005F4:  RCALL  0100
005F6:  TBLRD*-
005F8:  TBLRD*+
005FA:  MOVF   FF5,W
005FC:  MOVWF  FEE
005FE:  IORLW  00
00600:  BNZ   05F8
00602:  MOVLB  1
00604:  BTFSC  xC8.7
00606:  BSF    FF2.7
....................          lenResp = 5; 
00608:  MOVLW  05
0060A:  MOVWF  xC6
....................          break; 
0060C:  BRA    0692
....................  
....................       case CWJAP: 
....................          strResp = "+CWJAP:"; 
0060E:  MOVLW  01
00610:  MOVWF  FEA
00612:  MOVLW  BC
00614:  MOVWF  FE9
00616:  MOVFF  FF2,1C8
0061A:  BCF    FF2.7
0061C:  MOVLW  00
0061E:  RCALL  0116
00620:  TBLRD*-
00622:  TBLRD*+
00624:  MOVF   FF5,W
00626:  MOVWF  FEE
00628:  IORLW  00
0062A:  BNZ   0622
0062C:  MOVLB  1
0062E:  BTFSC  xC8.7
00630:  BSF    FF2.7
....................          lenResp = 7; 
00632:  MOVLW  07
00634:  MOVWF  xC6
....................          break; 
00636:  BRA    0692
....................           
....................       case Connected: 
....................          strResp = "CONNECTED"; 
00638:  MOVLW  01
0063A:  MOVWF  FEA
0063C:  MOVLW  BC
0063E:  MOVWF  FE9
00640:  MOVFF  FF2,1C8
00644:  BCF    FF2.7
00646:  MOVLW  00
00648:  RCALL  012E
0064A:  TBLRD*-
0064C:  TBLRD*+
0064E:  MOVF   FF5,W
00650:  MOVWF  FEE
00652:  IORLW  00
00654:  BNZ   064C
00656:  MOVLB  1
00658:  BTFSC  xC8.7
0065A:  BSF    FF2.7
....................          lenResp = 9; 
0065C:  MOVLW  09
0065E:  MOVWF  xC6
....................          break; 
00660:  BRA    0692
....................        
....................       case Fail: 
....................          strResp = "FAIL"; 
00662:  MOVLW  01
00664:  MOVWF  FEA
00666:  MOVLW  BC
00668:  MOVWF  FE9
0066A:  MOVFF  FF2,1C8
0066E:  BCF    FF2.7
00670:  MOVLW  00
00672:  RCALL  0148
00674:  TBLRD*-
00676:  TBLRD*+
00678:  MOVF   FF5,W
0067A:  MOVWF  FEE
0067C:  IORLW  00
0067E:  BNZ   0676
00680:  MOVLB  1
00682:  BTFSC  xC8.7
00684:  BSF    FF2.7
....................          lenResp = 4; 
00686:  MOVLW  04
00688:  MOVWF  xC6
....................          restartFlag = 1; 
0068A:  MOVLW  01
0068C:  MOVWF  xC7
....................          break; 
0068E:  BRA    0692
00690:  MOVLB  1
....................    } 
....................  
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................  
....................    if(buffer == strResp[buffer_flag_Resp[resp_Pos][flag_resp]]) 
00692:  MOVF   5C,W
00694:  MULLW  06
00696:  MOVF   FF3,W
00698:  CLRF   xC9
0069A:  MOVWF  xC8
0069C:  CLRF   03
0069E:  MOVF   xBB,W
006A0:  ADDWF  xC8,W
006A2:  MOVWF  01
006A4:  MOVF   xC9,W
006A6:  ADDWFC 03,F
006A8:  MOVF   01,W
006AA:  ADDLW  5F
006AC:  MOVWF  FE9
006AE:  MOVLW  00
006B0:  ADDWFC 03,W
006B2:  MOVWF  FEA
006B4:  CLRF   03
006B6:  MOVF   FEF,W
006B8:  ADDLW  BC
006BA:  MOVWF  FE9
006BC:  MOVLW  01
006BE:  ADDWFC 03,W
006C0:  MOVWF  FEA
006C2:  MOVF   FEF,W
006C4:  SUBWF  xBA,W
006C6:  BNZ   0742
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       buffer_flag_Resp[resp_Pos][flag_resp]++; 
006C8:  MOVF   5C,W
006CA:  MULLW  06
006CC:  MOVF   FF3,W
006CE:  CLRF   xC9
006D0:  MOVWF  xC8
006D2:  CLRF   03
006D4:  MOVF   xBB,W
006D6:  ADDWF  xC8,W
006D8:  MOVWF  01
006DA:  MOVF   xC9,W
006DC:  ADDWFC 03,F
006DE:  MOVF   01,W
006E0:  ADDLW  5F
006E2:  MOVWF  FE9
006E4:  MOVLW  00
006E6:  ADDWFC 03,W
006E8:  MOVWF  FEA
006EA:  INCF   FEF,F
....................        
....................       if(buffer_flag_Resp[resp_Pos][flag_resp]==lenResp){ 
006EC:  MOVF   5C,W
006EE:  MULLW  06
006F0:  MOVF   FF3,W
006F2:  CLRF   xC9
006F4:  MOVWF  xC8
006F6:  CLRF   03
006F8:  MOVF   xBB,W
006FA:  ADDWF  xC8,W
006FC:  MOVWF  01
006FE:  MOVF   xC9,W
00700:  ADDWFC 03,F
00702:  MOVF   01,W
00704:  ADDLW  5F
00706:  MOVWF  FE9
00708:  MOVLW  00
0070A:  ADDWFC 03,W
0070C:  MOVWF  FEA
0070E:  MOVF   xC6,W
00710:  SUBWF  FEF,W
00712:  BNZ   073C
....................          // Respuesta es valida 
....................          buffer_flag_Resp[resp_Flag][flag_resp]  = 1; 
00714:  MOVF   5D,W
00716:  MULLW  06
00718:  MOVF   FF3,W
0071A:  CLRF   xC9
0071C:  MOVWF  xC8
0071E:  CLRF   03
00720:  MOVF   xBB,W
00722:  ADDWF  xC8,W
00724:  MOVWF  01
00726:  MOVF   xC9,W
00728:  ADDWFC 03,F
0072A:  MOVF   01,W
0072C:  ADDLW  5F
0072E:  MOVWF  FE9
00730:  MOVLW  00
00732:  ADDWFC 03,W
00734:  MOVWF  FEA
00736:  MOVLW  01
00738:  MOVWF  FEF
....................       }else if(flag_resp == Valid) { 
0073A:  BRA    0740
0073C:  MOVF   xBB,F
0073E:  BNZ   0740
....................          // Reinicia la bandera para indicar el final del comando 
....................           //buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
....................       } 
....................         
....................    }else{ 
00740:  BRA    078E
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       buffer_flag_Resp[resp_Pos][flag_resp]   = 0; 
00742:  MOVF   5C,W
00744:  MULLW  06
00746:  MOVF   FF3,W
00748:  CLRF   xC9
0074A:  MOVWF  xC8
0074C:  CLRF   03
0074E:  MOVF   xBB,W
00750:  ADDWF  xC8,W
00752:  MOVWF  01
00754:  MOVF   xC9,W
00756:  ADDWFC 03,F
00758:  MOVF   01,W
0075A:  ADDLW  5F
0075C:  MOVWF  FE9
0075E:  MOVLW  00
00760:  ADDWFC 03,W
00762:  MOVWF  FEA
00764:  CLRF   FEF
....................  
....................       // Banderas que se reinician 
....................       if(restartFlag == 1){ 
00766:  DECFSZ xC7,W
00768:  BRA    078E
....................          buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
0076A:  MOVF   5D,W
0076C:  MULLW  06
0076E:  MOVF   FF3,W
00770:  CLRF   xC9
00772:  MOVWF  xC8
00774:  CLRF   03
00776:  MOVF   xBB,W
00778:  ADDWF  xC8,W
0077A:  MOVWF  01
0077C:  MOVF   xC9,W
0077E:  ADDWFC 03,F
00780:  MOVF   01,W
00782:  ADDLW  5F
00784:  MOVWF  FE9
00786:  MOVLW  00
00788:  ADDWFC 03,W
0078A:  MOVWF  FEA
0078C:  CLRF   FEF
....................       } 
....................        
....................    } 
0078E:  MOVLB  0
00790:  RETURN 0
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la IP del modo AP, STA, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getIP(int buffer) 
.................... { 
....................    const int END_GET_IP_CMD = 6; 
....................     
....................    // bandera de IP_First esta habilita 
....................    if(flag_Resp_Get_IP_CMD==1){ 
*
007B6:  DECFSZ xBB,W
007B8:  BRA    0810
....................       // Fin de Get First IP 
....................       if(buffer == '"'){ 
007BA:  MOVLB  1
007BC:  MOVF   xBA,W
007BE:  SUBLW  22
007C0:  BNZ   07DE
....................          // Finaliza el almacenamiento en el buffer 
....................          if( modeStar=='1' || modeStar=='2' ){ 
007C2:  MOVLB  0
007C4:  MOVF   xC1,W
007C6:  SUBLW  31
007C8:  BZ    07D0
007CA:  MOVF   xC1,W
007CC:  SUBLW  32
007CE:  BNZ   07D8
....................             flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
007D0:  MOVLW  06
007D2:  MOVWF  xBB
....................             flag_Pos_Get_IP_CMD =0; 
007D4:  CLRF   xBC
....................          }else{ 
007D6:  BRA    07DA
....................             // Activa Bandera de IP_STACION, reinicia el contador de Pos 
....................             flag_Pos_Get_IP_CMD =0; 
007D8:  CLRF   xBC
....................          } 
....................  
....................       }else{ 
007DA:  BRA    080E
007DC:  MOVLB  1
....................          if(modeStar=='1'){ 
007DE:  MOVLB  0
007E0:  MOVF   xC1,W
007E2:  SUBLW  31
007E4:  BNZ   07FA
....................             // IP Estacion 
....................             buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
007E6:  CLRF   03
007E8:  MOVF   xBC,W
007EA:  ADDLW  7B
007EC:  MOVWF  FE9
007EE:  MOVLW  00
007F0:  ADDWFC 03,W
007F2:  MOVWF  FEA
007F4:  MOVFF  1BA,FEF
....................          }else{ 
007F8:  BRA    080C
....................             // IP AP 
....................              buffer_Resp_CMD[0][flag_Pos_Get_IP_CMD] = buffer; 
007FA:  CLRF   03
007FC:  MOVF   xBC,W
007FE:  ADDLW  6B
00800:  MOVWF  FE9
00802:  MOVLW  00
00804:  ADDWFC 03,W
00806:  MOVWF  FEA
00808:  MOVFF  1BA,FEF
....................          } 
....................          flag_Pos_Get_IP_CMD++; 
0080C:  INCF   xBC,F
....................       } // Fin del if(buffer == '"') 
....................     
....................    // bandera de IP_Second(Estacion) esta habilita 
....................    }else if(flag_Resp_Get_IP_CMD==5){ 
0080E:  BRA    0840
00810:  MOVF   xBB,W
00812:  SUBLW  05
00814:  BNZ   0840
....................        if(buffer == '"'){ 
00816:  MOVLB  1
00818:  MOVF   xBA,W
0081A:  SUBLW  22
0081C:  BNZ   082A
....................          flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
0081E:  MOVLW  06
00820:  MOVLB  0
00822:  MOVWF  xBB
....................          flag_Pos_Get_IP_CMD =0; 
00824:  CLRF   xBC
....................        }else{ 
00826:  BRA    0840
00828:  MOVLB  1
....................          buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
0082A:  CLRF   03
0082C:  MOVLB  0
0082E:  MOVF   xBC,W
00830:  ADDLW  7B
00832:  MOVWF  FE9
00834:  MOVLW  00
00836:  ADDWFC 03,W
00838:  MOVWF  FEA
0083A:  MOVFF  1BA,FEF
....................          flag_Pos_Get_IP_CMD++; 
0083E:  INCF   xBC,F
....................        } 
....................    } // Fin de if(flag_Resp_Get_IP_CMD) 
....................        
....................    if( buffer == '"'){ 
00840:  MOVLB  1
00842:  MOVF   xBA,W
00844:  SUBLW  22
00846:  BNZ   085C
....................       switch(flag_Resp_Get_IP_CMD){ 
00848:  MOVLB  0
0084A:  MOVF   xBB,W
0084C:  ADDLW  FB
0084E:  BC    085A
00850:  ADDLW  05
00852:  GOTO   0862
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................          case 4: 
....................             flag_Resp_Get_IP_CMD++; 
00856:  INCF   xBB,F
....................             flag_Pos_Get_IP_CMD =0; 
00858:  CLRF   xBC
....................             break; 
0085A:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
0085C:  MOVLB  0
0085E:  GOTO   0B08 (RETURN)
.................... } // Fin de la funcion getIP() 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo AP, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getAPInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_AP_Info_CMD==1){ 
*
00886:  DECFSZ xBD,W
00888:  BRA    08AE
....................        
....................       if(buffer != '"'){ 
0088A:  MOVLB  1
0088C:  MOVF   xBA,W
0088E:  SUBLW  22
00890:  BZ    08AA
....................          buffer_Resp_CMD[2][flag_Pos_Get_AP_Info_CMD] = buffer; 
00892:  CLRF   03
00894:  MOVLB  0
00896:  MOVF   xBE,W
00898:  ADDLW  8B
0089A:  MOVWF  FE9
0089C:  MOVLW  00
0089E:  ADDWFC 03,W
008A0:  MOVWF  FEA
008A2:  MOVFF  1BA,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
008A6:  INCF   xBE,F
008A8:  MOVLB  1
....................       } 
....................  
....................    }else if(flag_Resp_Get_AP_Info_CMD==3){ 
008AA:  BRA    08DC
008AC:  MOVLB  0
008AE:  MOVF   xBD,W
008B0:  SUBLW  03
008B2:  BNZ   08DA
....................        
....................       if(buffer != '"'){ 
008B4:  MOVLB  1
008B6:  MOVF   xBA,W
008B8:  SUBLW  22
008BA:  BZ    08D6
....................          buffer_Resp_CMD[3][flag_Pos_Get_AP_Info_CMD] = buffer; 
008BC:  CLRF   03
008BE:  MOVLB  0
008C0:  MOVF   xBE,W
008C2:  ADDLW  9B
008C4:  MOVWF  FE9
008C6:  MOVLW  00
008C8:  ADDWFC 03,W
008CA:  MOVWF  FEA
008CC:  MOVFF  1BA,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
008D0:  INCF   xBE,F
....................       }else{ 
008D2:  BRA    08DA
008D4:  MOVLB  1
....................          flag_Pos_Get_AP_Info_CMD =0; 
008D6:  MOVLB  0
008D8:  CLRF   xBE
008DA:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
008DC:  MOVF   xBA,W
008DE:  SUBLW  22
008E0:  BNZ   08F6
....................       switch(flag_Resp_Get_AP_Info_CMD){ 
008E2:  MOVLB  0
008E4:  MOVF   xBD,W
008E6:  ADDLW  FC
008E8:  BC    08F4
008EA:  ADDLW  04
008EC:  GOTO   08FC
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................             flag_Resp_Get_AP_Info_CMD++; 
008F0:  INCF   xBD,F
....................             flag_Pos_Get_AP_Info_CMD =0; 
008F2:  CLRF   xBE
....................             break; 
008F4:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
008F6:  MOVLB  0
008F8:  GOTO   0B1C (RETURN)
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo STA 
....................  *     
....................  *********************************************************/ 
.................... void getSTAInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_STA_Info_CMD==1){ 
*
0091E:  DECFSZ xBF,W
00920:  BRA    0940
....................        
....................       if(buffer != '"'){ 
00922:  MOVLB  1
00924:  MOVF   xBA,W
00926:  SUBLW  22
00928:  BZ    0942
....................          buffer_Resp_CMD[4][flag_Pos_Get_STA_Info_CMD] = buffer; 
0092A:  CLRF   03
0092C:  MOVLB  0
0092E:  MOVF   xC0,W
00930:  ADDLW  AB
00932:  MOVWF  FE9
00934:  MOVLW  00
00936:  ADDWFC 03,W
00938:  MOVWF  FEA
0093A:  MOVFF  1BA,FEF
....................          flag_Pos_Get_STA_Info_CMD++; 
0093E:  INCF   xC0,F
00940:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
00942:  MOVF   xBA,W
00944:  SUBLW  22
00946:  BNZ   095A
....................       switch(flag_Resp_Get_STA_Info_CMD){ 
00948:  MOVLB  0
0094A:  MOVF   xBF,W
0094C:  BZ    0954
0094E:  XORLW  01
00950:  BZ    0954
00952:  BRA    0958
....................          case 0: 
....................          case 1: 
....................             flag_Resp_Get_STA_Info_CMD++; 
00954:  INCF   xBF,F
....................             flag_Pos_Get_STA_Info_CMD =0; 
00956:  CLRF   xC0
....................             break; 
00958:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_STA_Info_CMD) 
....................    } // Fin del if(buffer == '"')  
0095A:  MOVLB  0
0095C:  GOTO   0B30 (RETURN)
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          menu.H: contiene las funciones que 
....................                           muestran y ejecutan las 
....................                           operaciones de los menus 
....................  
.................... *******************************************************/ 
....................  
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_STA_IP     0 
....................   #define OPT_SHOW_STA_SSID   1 
....................   #define OPT_SHOW_AP_SSID    2 
....................   #define OPT_SHOW_AP_KEY     3 
....................   #define OPT_SHOW_AP_IP      4 
....................   #define OPT_MODE_AP         5 
....................   #define OPT_RESET_ALL       6 
....................   #define OPT_BACKLIGH        7 
....................   #define OPT_EXIT            8 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... char  optMenuOn[10][11]            =   {{"Output 1  "}, 
....................                                         {"Output 2  "}, 
....................                                         {"Output 3  "}, 
....................                                         {"Output 4  "}, 
....................                                         {"Output 5  "}, 
....................                                         {"Output 6  "}, 
....................                                         {"Output 7  "}, 
....................                                         {"Output 8  "}, 
....................                                         {"SALIR     "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[9][17]    =  { {"ESTACION IP     "}, 
....................                                         {"ESTACION SSID   "}, 
....................                                         {"AP SSID         "}, 
....................                                         {"AP KEY          "}, 
....................                                         {"AP IP           "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"Borrar a Fabrica"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacin     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 8; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
....................  
.................... /*************************************************** 
....................    Carga el nombre de las opciones del menu On y Off 
.................... ***************************************************/ 
.................... void getNameMenusOutput(){ 
*
00BB6:  MOVLB  1
00BB8:  CLRF   x68
....................    int posIni = 0; 
....................     
....................    posIni = read_eeprom(0x00); 
00BBA:  MOVFF  FF2,16B
00BBE:  BCF    FF2.7
00BC0:  CLRF   FAA
00BC2:  CLRF   FA9
00BC4:  BCF    FA6.6
00BC6:  BCF    FA6.7
00BC8:  BSF    FA6.0
00BCA:  MOVF   FA8,W
00BCC:  BTFSC  x6B.7
00BCE:  BSF    FF2.7
00BD0:  MOVWF  x68
....................     
....................    if(posIni!=0xFF){ 
00BD2:  INCFSZ x68,W
00BD4:  BRA    0BD8
00BD6:  BRA    0C60
....................       posIni =0; 
00BD8:  CLRF   x68
....................       for(int idx=0;idx<8;idx++){ 
00BDA:  CLRF   x69
00BDC:  MOVF   x69,W
00BDE:  SUBLW  07
00BE0:  BNC   0C48
....................           
....................          posIni =( 10 * idx ) + 40; 
00BE2:  MOVF   x69,W
00BE4:  MULLW  0A
00BE6:  MOVF   FF3,W
00BE8:  ADDLW  28
00BEA:  MOVWF  x68
....................           
....................          for(int idxChar=0;idxChar<=9;idxChar++){ 
00BEC:  CLRF   x6A
00BEE:  MOVF   x6A,W
00BF0:  SUBLW  09
00BF2:  BNC   0C44
....................             optMenuOn[idx][idxChar]=read_eeprom(posIni+idxChar); 
00BF4:  MOVF   x69,W
00BF6:  MULLW  0B
00BF8:  MOVF   FF3,W
00BFA:  CLRF   x6C
00BFC:  MOVWF  x6B
00BFE:  CLRF   03
00C00:  MOVF   x6A,W
00C02:  ADDWF  x6B,W
00C04:  MOVWF  01
00C06:  MOVF   x6C,W
00C08:  ADDWFC 03,F
00C0A:  MOVF   01,W
00C0C:  ADDLW  F4
00C0E:  MOVWF  FE9
00C10:  MOVLW  00
00C12:  ADDWFC 03,W
00C14:  MOVWF  FEA
00C16:  MOVF   x6A,W
00C18:  ADDWF  x68,W
00C1A:  MOVWF  x6D
00C1C:  MOVFF  FF2,16E
00C20:  BCF    FF2.7
00C22:  CLRF   FAA
00C24:  MOVFF  16D,FA9
00C28:  BCF    FA6.6
00C2A:  BCF    FA6.7
00C2C:  BSF    FA6.0
00C2E:  MOVF   FA8,W
00C30:  BTFSC  x6E.7
00C32:  BSF    FF2.7
00C34:  MOVWF  FEF
....................             delay_ms(10); 
00C36:  MOVLW  0A
00C38:  MOVWF  xB1
00C3A:  MOVLB  0
00C3C:  RCALL  0B8E
00C3E:  MOVLB  1
00C40:  INCF   x6A,F
00C42:  BRA    0BEE
....................          } 
00C44:  INCF   x69,F
00C46:  BRA    0BDC
....................       } 
....................        
....................       optMenuOn[8][0]='\f'; 
00C48:  MOVLW  0C
00C4A:  MOVWF  x4C
....................       optMenuOn[8][1]='S'; 
00C4C:  MOVLW  53
00C4E:  MOVWF  x4D
....................       optMenuOn[8][2]='A'; 
00C50:  MOVLW  41
00C52:  MOVWF  x4E
....................       optMenuOn[8][3]='L'; 
00C54:  MOVLW  4C
00C56:  MOVWF  x4F
....................       optMenuOn[8][4]='I'; 
00C58:  MOVLW  49
00C5A:  MOVWF  x50
....................       optMenuOn[8][5]='R'; 
00C5C:  MOVLW  52
00C5E:  MOVWF  x51
....................    }    
00C60:  MOVLB  0
00C62:  GOTO   2A48 (RETURN)
.................... } // FIn de la funcion getNameMenusOutput 
....................  
.................... /*************************************************** 
....................    Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
01EBE:  MOVLB  1
01EC0:  CLRF   x68
01EC2:  CLRF   x69
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
01EC4:  MOVF   x68,W
01EC6:  MULLW  10
01EC8:  MOVF   FF3,W
01ECA:  CLRF   03
01ECC:  MOVWF  x6A
01ECE:  MOVLW  0C
01ED0:  MOVWF  x71
01ED2:  MOVLB  0
01ED4:  CALL   0E6E
01ED8:  MOVLW  A2
01EDA:  MOVWF  FF6
01EDC:  MOVLW  02
01EDE:  MOVWF  FF7
01EE0:  MOVLB  1
01EE2:  MOVF   x6A,W
01EE4:  ADDWF  FF6,F
01EE6:  MOVLW  00
01EE8:  ADDWFC FF7,F
01EEA:  MOVLB  0
01EEC:  CALL   0EDA
....................    showBottonMenu(); 
01EF0:  CALL   1272
....................    while(!exit){ 
01EF4:  MOVLB  1
01EF6:  MOVF   x69,F
01EF8:  BNZ   1FA4
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01EFA:  MOVLB  0
01EFC:  CALL   1378
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01F00:  BSF    F93.4
01F02:  BTFSC  F81.4
01F04:  BRA    1F6A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01F06:  MOVLW  02
01F08:  MOVLB  1
01F0A:  MOVWF  x6A
01F0C:  MOVLW  FA
01F0E:  MOVWF  xB1
01F10:  MOVLB  0
01F12:  CALL   0B8E
01F16:  MOVLB  1
01F18:  DECFSZ x6A,F
01F1A:  BRA    1F0C
....................          BEEP; 
01F1C:  MOVLW  04
01F1E:  MOVWF  x6F
01F20:  MOVLW  B9
01F22:  MOVWF  x6E
01F24:  CLRF   x71
01F26:  MOVLW  14
01F28:  MOVWF  x70
01F2A:  MOVLB  0
01F2C:  RCALL  1D76
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
01F2E:  MOVLB  1
01F30:  INCF   x68,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
01F32:  MOVF   x68,W
01F34:  SUBWF  x62,W
01F36:  BC    1F3A
....................             optSelected = 0; 
01F38:  CLRF   x68
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
01F3A:  MOVF   x68,W
01F3C:  MULLW  10
01F3E:  MOVF   FF3,W
01F40:  CLRF   03
01F42:  MOVWF  x6A
01F44:  MOVLW  0C
01F46:  MOVWF  x71
01F48:  MOVLB  0
01F4A:  CALL   0E6E
01F4E:  MOVLW  A2
01F50:  MOVWF  FF6
01F52:  MOVLW  02
01F54:  MOVWF  FF7
01F56:  MOVLB  1
01F58:  MOVF   x6A,W
01F5A:  ADDWF  FF6,F
01F5C:  MOVLW  00
01F5E:  ADDWFC FF7,F
01F60:  MOVLB  0
01F62:  CALL   0EDA
....................          showBottonMenu(); 
01F66:  CALL   1272
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01F6A:  BSF    F93.5
01F6C:  BTFSC  F81.5
01F6E:  BRA    1FA0
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01F70:  MOVLW  02
01F72:  MOVLB  1
01F74:  MOVWF  x6A
01F76:  MOVLW  FA
01F78:  MOVWF  xB1
01F7A:  MOVLB  0
01F7C:  CALL   0B8E
01F80:  MOVLB  1
01F82:  DECFSZ x6A,F
01F84:  BRA    1F76
....................          BEEP; 
01F86:  MOVLW  04
01F88:  MOVWF  x6F
01F8A:  MOVLW  B9
01F8C:  MOVWF  x6E
01F8E:  CLRF   x71
01F90:  MOVLW  14
01F92:  MOVWF  x70
01F94:  MOVLB  0
01F96:  RCALL  1D76
....................          // Rompe el Loop 
....................          exit = 1; 
01F98:  MOVLW  01
01F9A:  MOVLB  1
01F9C:  MOVWF  x69
01F9E:  MOVLB  0
....................       } // Fin KEY_OK 
01FA0:  BRA    1EF4
01FA2:  MOVLB  1
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
01FA4:  MOVLW  01
01FA6:  ADDWF  x68,W
01FA8:  MOVWF  01
01FAA:  MOVLB  0
01FAC:  GOTO   2A80 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
022A2:  MOVLW  0C
022A4:  MOVLB  1
022A6:  MOVWF  x72
022A8:  MOVLW  02
022AA:  MOVWF  x73
022AC:  MOVLB  0
022AE:  CALL   0E48
....................   printf(lcd_putc, "SALIR"); 
022B2:  MOVLW  C2
022B4:  MOVWF  FF6
022B6:  MOVLW  03
022B8:  MOVWF  FF7
022BA:  CALL   0EDA
....................    
....................   while(1){ 
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
022BE:  CALL   1378
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
022C2:  BSF    F93.5
022C4:  BTFSC  F81.5
022C6:  BRA    22E2
....................            // Elimina el rebote 
....................            delay_ms(500); 
022C8:  MOVLW  02
022CA:  MOVLB  1
022CC:  MOVWF  x6E
022CE:  MOVLW  FA
022D0:  MOVWF  xB1
022D2:  MOVLB  0
022D4:  CALL   0B8E
022D8:  MOVLB  1
022DA:  DECFSZ x6E,F
022DC:  BRA    22CE
....................            break; 
022DE:  BRA    22E6
022E0:  MOVLB  0
....................      } 
022E2:  BRA    22BE
022E4:  MOVLB  1
....................   } 
022E6:  MOVLB  0
022E8:  RETURN 0
.................... } // Fin de la funcion pressExit 
.................... /*************************************************** 
....................    Dibuja en la parte inferior del Display los botones de 
....................    Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
01272:  MOVLW  01
01274:  MOVLB  1
01276:  MOVWF  x72
01278:  MOVLW  02
0127A:  MOVWF  x73
0127C:  MOVLB  0
0127E:  RCALL  0E48
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
01280:  MOVLW  C8
01282:  MOVWF  FF6
01284:  MOVLW  03
01286:  MOVWF  FF7
01288:  RCALL  0EDA
0128A:  RETURN 0
.................... } 
....................  
.................... /*************************************************** 
....................    Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
02000:  MOVLB  1
02002:  CLRF   x68
02004:  CLRF   x69
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\fOn -> %s",optMenuOn[optSelected]); 
02006:  MOVF   x68,W
02008:  MULLW  0B
0200A:  MOVF   FF3,W
0200C:  CLRF   03
0200E:  ADDLW  F4
02010:  MOVWF  01
02012:  MOVLW  00
02014:  ADDWFC 03,F
02016:  MOVFF  01,16A
0201A:  MOVFF  03,16B
0201E:  MOVLW  DA
02020:  MOVWF  FF6
02022:  MOVLW  03
02024:  MOVWF  FF7
02026:  MOVLW  07
02028:  MOVWF  x6C
0202A:  MOVLB  0
0202C:  RCALL  1FB0
0202E:  MOVFF  16B,FEA
02032:  MOVFF  16A,FE9
02036:  RCALL  1FDA
....................    showBottonMenu(); 
02038:  CALL   1272
....................     
....................    while(!exit){ 
0203C:  MOVLB  1
0203E:  MOVF   x69,F
02040:  BTFSS  FD8.2
02042:  BRA    2148
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02044:  MOVLB  0
02046:  CALL   1378
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0204A:  BSF    F93.4
0204C:  BTFSC  F81.4
0204E:  BRA    20BA
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02050:  MOVLW  02
02052:  MOVLB  1
02054:  MOVWF  x6A
02056:  MOVLW  FA
02058:  MOVWF  xB1
0205A:  MOVLB  0
0205C:  CALL   0B8E
02060:  MOVLB  1
02062:  DECFSZ x6A,F
02064:  BRA    2056
....................          BEEP; 
02066:  MOVLW  04
02068:  MOVWF  x6F
0206A:  MOVLW  B9
0206C:  MOVWF  x6E
0206E:  CLRF   x71
02070:  MOVLW  14
02072:  MOVWF  x70
02074:  MOVLB  0
02076:  RCALL  1D76
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
02078:  MOVLB  1
0207A:  INCF   x68,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
0207C:  MOVF   x68,W
0207E:  SUBWF  x63,W
02080:  BC    2084
....................             optSelected = 0; 
02082:  CLRF   x68
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\fOn -> %s",optMenuOn[optSelected]); 
02084:  MOVF   x68,W
02086:  MULLW  0B
02088:  MOVF   FF3,W
0208A:  CLRF   03
0208C:  ADDLW  F4
0208E:  MOVWF  01
02090:  MOVLW  00
02092:  ADDWFC 03,F
02094:  MOVFF  01,16A
02098:  MOVFF  03,16B
0209C:  MOVLW  E4
0209E:  MOVWF  FF6
020A0:  MOVLW  03
020A2:  MOVWF  FF7
020A4:  MOVLW  07
020A6:  MOVWF  x6C
020A8:  MOVLB  0
020AA:  RCALL  1FB0
020AC:  MOVFF  16B,FEA
020B0:  MOVFF  16A,FE9
020B4:  RCALL  1FDA
....................          showBottonMenu(); 
020B6:  CALL   1272
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
020BA:  BSF    F93.5
020BC:  BTFSC  F81.5
020BE:  BRA    2144
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
020C0:  MOVLW  02
020C2:  MOVLB  1
020C4:  MOVWF  x6A
020C6:  MOVLW  FA
020C8:  MOVWF  xB1
020CA:  MOVLB  0
020CC:  CALL   0B8E
020D0:  MOVLB  1
020D2:  DECFSZ x6A,F
020D4:  BRA    20C6
....................          BEEP; 
020D6:  MOVLW  04
020D8:  MOVWF  x6F
020DA:  MOVLW  B9
020DC:  MOVWF  x6E
020DE:  CLRF   x71
020E0:  MOVLW  14
020E2:  MOVWF  x70
020E4:  MOVLB  0
020E6:  RCALL  1D76
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuOn){ 
020E8:  MOVLB  1
020EA:  MOVF   x63,W
020EC:  SUBWF  x68,W
020EE:  BNZ   20F6
....................             exit = 1; 
020F0:  MOVLW  01
020F2:  MOVWF  x69
....................          }else{ 
020F4:  BRA    2146
....................             output_high(PIN_OUT[optSelected]); 
020F6:  BCF    FD8.0
020F8:  RLCF   x68,W
020FA:  CLRF   03
020FC:  MOVFF  FF2,16A
02100:  BCF    FF2.7
02102:  MOVLB  0
02104:  CALL   0096
02108:  TBLRD*+
0210A:  MOVFF  FF5,03
0210E:  MOVLB  1
02110:  BTFSC  x6A.7
02112:  BSF    FF2.7
02114:  MOVWF  x6A
02116:  MOVFF  03,16B
0211A:  MOVWF  xB2
0211C:  MOVLW  01
0211E:  MOVWF  xB3
02120:  MOVLW  0F
02122:  MOVWF  xB5
02124:  MOVLW  89
02126:  MOVWF  xB4
02128:  MOVLB  0
0212A:  CALL   1336
0212E:  MOVFF  16A,1B2
02132:  MOVLB  1
02134:  CLRF   xB3
02136:  MOVLW  0F
02138:  MOVWF  xB5
0213A:  MOVLW  92
0213C:  MOVWF  xB4
0213E:  MOVLB  0
02140:  CALL   1336
02144:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
02146:  BRA    203E
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02148:  MOVLW  00
0214A:  MOVWF  01
0214C:  MOVLB  0
0214E:  GOTO   2A8C (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
....................    Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
02152:  MOVLB  1
02154:  CLRF   x68
02156:  CLRF   x69
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\fOff-> %s",optMenuOn[optSelected]); 
02158:  MOVF   x68,W
0215A:  MULLW  0B
0215C:  MOVF   FF3,W
0215E:  CLRF   03
02160:  ADDLW  F4
02162:  MOVWF  01
02164:  MOVLW  00
02166:  ADDWFC 03,F
02168:  MOVFF  01,16A
0216C:  MOVFF  03,16B
02170:  MOVLW  EE
02172:  MOVWF  FF6
02174:  MOVLW  03
02176:  MOVWF  FF7
02178:  MOVLW  07
0217A:  MOVWF  x6C
0217C:  MOVLB  0
0217E:  RCALL  1FB0
02180:  MOVFF  16B,FEA
02184:  MOVFF  16A,FE9
02188:  RCALL  1FDA
....................    showBottonMenu(); 
0218A:  CALL   1272
....................     
....................    while(!exit){ 
0218E:  MOVLB  1
02190:  MOVF   x69,F
02192:  BTFSS  FD8.2
02194:  BRA    2298
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02196:  MOVLB  0
02198:  CALL   1378
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0219C:  BSF    F93.4
0219E:  BTFSC  F81.4
021A0:  BRA    220C
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
021A2:  MOVLW  02
021A4:  MOVLB  1
021A6:  MOVWF  x6A
021A8:  MOVLW  FA
021AA:  MOVWF  xB1
021AC:  MOVLB  0
021AE:  CALL   0B8E
021B2:  MOVLB  1
021B4:  DECFSZ x6A,F
021B6:  BRA    21A8
....................          BEEP; 
021B8:  MOVLW  04
021BA:  MOVWF  x6F
021BC:  MOVLW  B9
021BE:  MOVWF  x6E
021C0:  CLRF   x71
021C2:  MOVLW  14
021C4:  MOVWF  x70
021C6:  MOVLB  0
021C8:  RCALL  1D76
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
021CA:  MOVLB  1
021CC:  INCF   x68,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
021CE:  MOVF   x68,W
021D0:  SUBWF  x64,W
021D2:  BC    21D6
....................             optSelected = 0; 
021D4:  CLRF   x68
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\fOff-> %s",optMenuOn[optSelected]); 
021D6:  MOVF   x68,W
021D8:  MULLW  0B
021DA:  MOVF   FF3,W
021DC:  CLRF   03
021DE:  ADDLW  F4
021E0:  MOVWF  01
021E2:  MOVLW  00
021E4:  ADDWFC 03,F
021E6:  MOVFF  01,16A
021EA:  MOVFF  03,16B
021EE:  MOVLW  F8
021F0:  MOVWF  FF6
021F2:  MOVLW  03
021F4:  MOVWF  FF7
021F6:  MOVLW  07
021F8:  MOVWF  x6C
021FA:  MOVLB  0
021FC:  RCALL  1FB0
021FE:  MOVFF  16B,FEA
02202:  MOVFF  16A,FE9
02206:  RCALL  1FDA
....................          showBottonMenu(); 
02208:  CALL   1272
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0220C:  BSF    F93.5
0220E:  BTFSC  F81.5
02210:  BRA    2294
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02212:  MOVLW  02
02214:  MOVLB  1
02216:  MOVWF  x6A
02218:  MOVLW  FA
0221A:  MOVWF  xB1
0221C:  MOVLB  0
0221E:  CALL   0B8E
02222:  MOVLB  1
02224:  DECFSZ x6A,F
02226:  BRA    2218
....................          BEEP; 
02228:  MOVLW  04
0222A:  MOVWF  x6F
0222C:  MOVLW  B9
0222E:  MOVWF  x6E
02230:  CLRF   x71
02232:  MOVLW  14
02234:  MOVWF  x70
02236:  MOVLB  0
02238:  RCALL  1D76
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
0223A:  MOVLB  1
0223C:  MOVF   x64,W
0223E:  SUBWF  x68,W
02240:  BNZ   2248
....................             exit = 1; 
02242:  MOVLW  01
02244:  MOVWF  x69
....................          }else{ 
02246:  BRA    2296
....................             output_low(PIN_OUT[optSelected]); 
02248:  BCF    FD8.0
0224A:  RLCF   x68,W
0224C:  CLRF   03
0224E:  MOVFF  FF2,16A
02252:  BCF    FF2.7
02254:  MOVLB  0
02256:  CALL   0096
0225A:  TBLRD*+
0225C:  MOVFF  FF5,03
02260:  MOVLB  1
02262:  BTFSC  x6A.7
02264:  BSF    FF2.7
02266:  MOVWF  x6A
02268:  MOVFF  03,16B
0226C:  MOVWF  xB2
0226E:  CLRF   xB3
02270:  MOVLW  0F
02272:  MOVWF  xB5
02274:  MOVLW  89
02276:  MOVWF  xB4
02278:  MOVLB  0
0227A:  CALL   1336
0227E:  MOVFF  16A,1B2
02282:  MOVLB  1
02284:  CLRF   xB3
02286:  MOVLW  0F
02288:  MOVWF  xB5
0228A:  MOVLW  92
0228C:  MOVWF  xB4
0228E:  MOVLB  0
02290:  CALL   1336
02294:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
02296:  BRA    2190
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02298:  MOVLW  00
0229A:  MOVWF  01
0229C:  MOVLB  0
0229E:  GOTO   2A98 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
....................    Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
*
027CA:  MOVLB  1
027CC:  CLRF   x68
027CE:  CLRF   x69
....................  
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
027D0:  MOVF   x68,W
027D2:  MULLW  11
027D4:  MOVF   FF3,W
027D6:  CLRF   03
027D8:  MOVWF  x6A
027DA:  MOVLW  0C
027DC:  MOVWF  x71
027DE:  MOVLB  0
027E0:  CALL   0E6E
027E4:  MOVLW  E2
027E6:  MOVWF  FF6
027E8:  MOVLW  02
027EA:  MOVWF  FF7
027EC:  MOVLB  1
027EE:  MOVF   x6A,W
027F0:  ADDWF  FF6,F
027F2:  MOVLW  00
027F4:  ADDWFC FF7,F
027F6:  MOVLB  0
027F8:  CALL   0EDA
....................    showBottonMenu(); 
027FC:  CALL   1272
....................     
....................    while(!exit){ 
02800:  MOVLB  1
02802:  MOVF   x69,F
02804:  BTFSS  FD8.2
02806:  BRA    28F6
....................  
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02808:  MOVLB  0
0280A:  CALL   1378
....................       /********************************************/ 
....................     
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0280E:  BSF    F93.4
02810:  BTFSC  F81.4
02812:  BRA    287A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02814:  MOVLW  02
02816:  MOVLB  1
02818:  MOVWF  x6A
0281A:  MOVLW  FA
0281C:  MOVWF  xB1
0281E:  MOVLB  0
02820:  CALL   0B8E
02824:  MOVLB  1
02826:  DECFSZ x6A,F
02828:  BRA    281A
....................          BEEP; 
0282A:  MOVLW  04
0282C:  MOVWF  x6F
0282E:  MOVLW  B9
02830:  MOVWF  x6E
02832:  CLRF   x71
02834:  MOVLW  14
02836:  MOVWF  x70
02838:  MOVLB  0
0283A:  CALL   1D76
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0283E:  MOVLB  1
02840:  INCF   x68,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
02842:  MOVF   x68,W
02844:  SUBWF  x65,W
02846:  BC    284A
....................             optSelected = 0; 
02848:  CLRF   x68
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0284A:  MOVF   x68,W
0284C:  MULLW  11
0284E:  MOVF   FF3,W
02850:  CLRF   03
02852:  MOVWF  x6A
02854:  MOVLW  0C
02856:  MOVWF  x71
02858:  MOVLB  0
0285A:  CALL   0E6E
0285E:  MOVLW  E2
02860:  MOVWF  FF6
02862:  MOVLW  02
02864:  MOVWF  FF7
02866:  MOVLB  1
02868:  MOVF   x6A,W
0286A:  ADDWF  FF6,F
0286C:  MOVLW  00
0286E:  ADDWFC FF7,F
02870:  MOVLB  0
02872:  CALL   0EDA
....................          showBottonMenu(); 
02876:  CALL   1272
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0287A:  BSF    F93.5
0287C:  BTFSC  F81.5
0287E:  BRA    28F2
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02880:  MOVLW  02
02882:  MOVLB  1
02884:  MOVWF  x6A
02886:  MOVLW  FA
02888:  MOVWF  xB1
0288A:  MOVLB  0
0288C:  CALL   0B8E
02890:  MOVLB  1
02892:  DECFSZ x6A,F
02894:  BRA    2886
....................          BEEP; 
02896:  MOVLW  04
02898:  MOVWF  x6F
0289A:  MOVLW  B9
0289C:  MOVWF  x6E
0289E:  CLRF   x71
028A0:  MOVLW  14
028A2:  MOVWF  x70
028A4:  MOVLB  0
028A6:  CALL   1D76
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
028AA:  MOVLB  1
028AC:  MOVF   x65,W
028AE:  SUBWF  x68,W
028B0:  BNZ   28B8
....................             exit = 1; 
028B2:  MOVLW  01
028B4:  MOVWF  x69
....................          }else{ 
028B6:  BRA    28F4
....................             executeSetup(optSelected); 
028B8:  MOVFF  168,16A
028BC:  MOVLB  0
028BE:  BRA    2512
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
028C0:  MOVLB  1
028C2:  MOVF   x68,W
028C4:  MULLW  11
028C6:  MOVF   FF3,W
028C8:  CLRF   03
028CA:  MOVWF  x6A
028CC:  MOVLW  0C
028CE:  MOVWF  x71
028D0:  MOVLB  0
028D2:  CALL   0E6E
028D6:  MOVLW  E2
028D8:  MOVWF  FF6
028DA:  MOVLW  02
028DC:  MOVWF  FF7
028DE:  MOVLB  1
028E0:  MOVF   x6A,W
028E2:  ADDWF  FF6,F
028E4:  MOVLW  00
028E6:  ADDWFC FF7,F
028E8:  MOVLB  0
028EA:  CALL   0EDA
....................             showBottonMenu(); 
028EE:  CALL   1272
028F2:  MOVLB  1
....................          } 
....................       } // Fin KEY_OK 
028F4:  BRA    2802
....................    } // FIN While Infinito 
....................  
....................    return 0; 
028F6:  MOVLW  00
028F8:  MOVWF  01
028FA:  MOVLB  0
028FC:  GOTO   2AA2 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
....................    Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................     
....................    
....................   switch(optSelect){ 
*
02512:  MOVLB  1
02514:  MOVF   x6A,W
02516:  ADDLW  F7
02518:  BTFSC  FD8.0
0251A:  BRA    2782
0251C:  ADDLW  09
0251E:  MOVLB  0
02520:  GOTO   2794
....................    
....................      case OPT_SHOW_AP_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
02524:  MOVLW  02
02526:  MOVWF  FF6
02528:  MOVLW  04
0252A:  MOVWF  FF7
0252C:  CALL   0EFA
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
02530:  MOVLW  05
02532:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
02534:  MOVLW  0E
02536:  MOVWF  FF6
02538:  MOVLW  04
0253A:  MOVWF  FF7
0253C:  CALL   0EDA
....................         waitResp(); 
02540:  CALL   0F46
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[0]); 
02544:  MOVLW  0C
02546:  MOVLB  1
02548:  MOVWF  x71
0254A:  MOVLB  0
0254C:  CALL   0E6E
02550:  CLRF   FEA
02552:  MOVLW  6B
02554:  MOVWF  FE9
02556:  RCALL  1FDA
....................         flag_Resp_Get_IP_CMD = 0; 
02558:  CLRF   xBB
....................         break; 
0255A:  MOVLB  1
0255C:  BRA    2782
....................          
....................      case OPT_SHOW_STA_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
0255E:  MOVLW  1C
02560:  MOVWF  FF6
02562:  MOVLW  04
02564:  MOVWF  FF7
02566:  CALL   0EFA
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
0256A:  MOVLW  05
0256C:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
0256E:  MOVLW  28
02570:  MOVWF  FF6
02572:  MOVLW  04
02574:  MOVWF  FF7
02576:  CALL   0EDA
....................         waitResp(); 
0257A:  CALL   0F46
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[1]); 
0257E:  MOVLW  0C
02580:  MOVLB  1
02582:  MOVWF  x71
02584:  MOVLB  0
02586:  CALL   0E6E
0258A:  CLRF   FEA
0258C:  MOVLW  7B
0258E:  MOVWF  FE9
02590:  RCALL  1FDA
....................         flag_Resp_Get_IP_CMD = 0; 
02592:  CLRF   xBB
....................         break; 
02594:  MOVLB  1
02596:  BRA    2782
....................          
....................      case OPT_SHOW_STA_SSID: 
....................         if(modeStar!='2'){ 
02598:  MOVF   xC1,W
0259A:  SUBLW  32
0259C:  BZ    25D6
....................            fprintf(ESP8266, "AT+CWJAP?\r\n"); 
0259E:  MOVLW  36
025A0:  MOVWF  FF6
025A2:  MOVLW  04
025A4:  MOVWF  FF7
025A6:  CALL   0EFA
....................            CMD_RUN = CMD_GET_STA_INFO_FROM_MENU; 
025AA:  MOVLW  07
025AC:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
025AE:  MOVLW  42
025B0:  MOVWF  FF6
025B2:  MOVLW  04
025B4:  MOVWF  FF7
025B6:  CALL   0EDA
....................            waitResp(); 
025BA:  CALL   0F46
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[4]); 
025BE:  MOVLW  0C
025C0:  MOVLB  1
025C2:  MOVWF  x71
025C4:  MOVLB  0
025C6:  CALL   0E6E
025CA:  CLRF   FEA
025CC:  MOVLW  AB
025CE:  MOVWF  FE9
025D0:  RCALL  1FDA
....................            flag_Resp_Get_STA_Info_CMD=0; 
025D2:  CLRF   xBF
....................         }else{ 
025D4:  BRA    25E2
....................            printf(lcd_putc, "\fDeshabilitado"); 
025D6:  MOVLW  50
025D8:  MOVWF  FF6
025DA:  MOVLW  04
025DC:  MOVWF  FF7
025DE:  CALL   0EDA
....................         } 
....................         break; 
025E2:  MOVLB  1
025E4:  BRA    2782
....................          
....................      case OPT_SHOW_AP_SSID: 
....................         if(modeStar!='1'){ 
025E6:  MOVF   xC1,W
025E8:  SUBLW  31
025EA:  BZ    2624
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
025EC:  MOVLW  60
025EE:  MOVWF  FF6
025F0:  MOVLW  04
025F2:  MOVWF  FF7
025F4:  CALL   0EFA
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
025F8:  MOVLW  06
025FA:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
025FC:  MOVLW  6C
025FE:  MOVWF  FF6
02600:  MOVLW  04
02602:  MOVWF  FF7
02604:  CALL   0EDA
....................            waitResp(); 
02608:  CALL   0F46
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[2]); 
0260C:  MOVLW  0C
0260E:  MOVLB  1
02610:  MOVWF  x71
02612:  MOVLB  0
02614:  CALL   0E6E
02618:  CLRF   FEA
0261A:  MOVLW  8B
0261C:  MOVWF  FE9
0261E:  RCALL  1FDA
....................            flag_Resp_Get_AP_Info_CMD=0; 
02620:  CLRF   xBD
....................         }else{ 
02622:  BRA    2630
....................            printf(lcd_putc, "\fDeshabilitado"); 
02624:  MOVLW  7A
02626:  MOVWF  FF6
02628:  MOVLW  04
0262A:  MOVWF  FF7
0262C:  CALL   0EDA
....................         } 
....................         break; 
02630:  MOVLB  1
02632:  BRA    2782
....................          
....................      case OPT_SHOW_AP_KEY: 
....................         if(modeStar!='1'){ 
02634:  MOVF   xC1,W
02636:  SUBLW  31
02638:  BZ    2672
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
0263A:  MOVLW  8A
0263C:  MOVWF  FF6
0263E:  MOVLW  04
02640:  MOVWF  FF7
02642:  CALL   0EFA
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
02646:  MOVLW  06
02648:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
0264A:  MOVLW  96
0264C:  MOVWF  FF6
0264E:  MOVLW  04
02650:  MOVWF  FF7
02652:  CALL   0EDA
....................            waitResp(); 
02656:  CALL   0F46
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[3]); 
0265A:  MOVLW  0C
0265C:  MOVLB  1
0265E:  MOVWF  x71
02660:  MOVLB  0
02662:  CALL   0E6E
02666:  CLRF   FEA
02668:  MOVLW  9B
0266A:  MOVWF  FE9
0266C:  RCALL  1FDA
....................            flag_Resp_Get_AP_Info_CMD=0; 
0266E:  CLRF   xBD
....................         }else{ 
02670:  BRA    267E
....................            printf(lcd_putc, "\fDeshabilitado"); 
02672:  MOVLW  A4
02674:  MOVWF  FF6
02676:  MOVLW  04
02678:  MOVWF  FF7
0267A:  CALL   0EDA
....................         } 
....................         break; 
0267E:  MOVLB  1
02680:  BRA    2782
....................          
....................      case OPT_RESET_ALL: 
....................          printf(lcd_putc, "\fBorrando EEEPROM"); 
02682:  MOVLW  B4
02684:  MOVWF  FF6
02686:  MOVLW  04
02688:  MOVWF  FF7
0268A:  CALL   0EDA
....................          for(int idxNC=0x00;idxNC<=0x6E;idxNC++){ 
0268E:  MOVLB  1
02690:  CLRF   x6B
02692:  MOVF   x6B,W
02694:  SUBLW  6E
02696:  BNC   26D4
....................             write_eeprom(idxNC,0xFF); 
02698:  MOVF   FF2,W
0269A:  MOVWF  00
0269C:  BCF    FF2.7
0269E:  CLRF   FAA
026A0:  MOVFF  16B,FA9
026A4:  SETF   FA8
026A6:  BCF    FA6.6
026A8:  BCF    FA6.7
026AA:  BSF    FA6.2
026AC:  MOVLB  F
026AE:  MOVLW  55
026B0:  MOVWF  FA7
026B2:  MOVLW  AA
026B4:  MOVWF  FA7
026B6:  BSF    FA6.1
026B8:  BTFSC  FA6.1
026BA:  BRA    26B8
026BC:  BCF    FA6.2
026BE:  MOVF   00,W
026C0:  IORWF  FF2,F
....................             delay_ms(10); 
026C2:  MOVLW  0A
026C4:  MOVLB  1
026C6:  MOVWF  xB1
026C8:  MOVLB  0
026CA:  CALL   0B8E
026CE:  MOVLB  1
026D0:  INCF   x6B,F
026D2:  BRA    2692
....................          } 
....................          printf(lcd_putc, "\fBorrando RED"); 
026D4:  MOVLW  C6
026D6:  MOVWF  FF6
026D8:  MOVLW  04
026DA:  MOVWF  FF7
026DC:  MOVLB  0
026DE:  CALL   0EDA
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
026E2:  MOVLW  D4
026E4:  MOVWF  FF6
026E6:  MOVLW  04
026E8:  MOVWF  FF7
026EA:  CALL   0EFA
....................          delay_ms(1000); 
026EE:  MOVLW  04
026F0:  MOVLB  1
026F2:  MOVWF  x6C
026F4:  MOVLW  FA
026F6:  MOVWF  xB1
026F8:  MOVLB  0
026FA:  CALL   0B8E
026FE:  MOVLB  1
02700:  DECFSZ x6C,F
02702:  BRA    26F4
....................          fprintf(ESP8266, "AT+RST\n\r"); 
02704:  MOVLW  E0
02706:  MOVWF  FF6
02708:  MOVLW  04
0270A:  MOVWF  FF7
0270C:  MOVLB  0
0270E:  CALL   0EFA
....................          delay_ms(2000); 
02712:  MOVLW  08
02714:  MOVLB  1
02716:  MOVWF  x6C
02718:  MOVLW  FA
0271A:  MOVWF  xB1
0271C:  MOVLB  0
0271E:  CALL   0B8E
02722:  MOVLB  1
02724:  DECFSZ x6C,F
02726:  BRA    2718
....................          fprintf(ESP8266, "AT+CWSAP_DEF=\"Kriver SmartHome\",\"kriver56106\",1,4\r\n"); 
02728:  MOVLW  EA
0272A:  MOVWF  FF6
0272C:  MOVLW  04
0272E:  MOVWF  FF7
02730:  MOVLB  0
02732:  CALL   0EFA
....................          delay_ms(2000); 
02736:  MOVLW  08
02738:  MOVLB  1
0273A:  MOVWF  x6C
0273C:  MOVLW  FA
0273E:  MOVWF  xB1
02740:  MOVLB  0
02742:  CALL   0B8E
02746:  MOVLB  1
02748:  DECFSZ x6C,F
0274A:  BRA    273C
....................          reset_cpu(); 
0274C:  RESET
....................         break; 
0274E:  BRA    2782
....................      
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
02750:  BRA    22EA
....................         break;   
02752:  MOVLB  1
02754:  BRA    2782
....................          
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
02756:  BCF    F95.3
02758:  BTG    F8C.3
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
0275A:  BTFSS  F83.3
0275C:  BRA    276C
....................            printf(lcd_putc, "\fBacklight On"); 
0275E:  MOVLW  1E
02760:  MOVWF  FF6
02762:  MOVLW  05
02764:  MOVWF  FF7
02766:  CALL   0EDA
....................         }else{ 
0276A:  BRA    2778
....................            printf(lcd_putc, "\fBacklight Off"); 
0276C:  MOVLW  2C
0276E:  MOVWF  FF6
02770:  MOVLW  05
02772:  MOVWF  FF7
02774:  CALL   0EDA
....................         } 
....................         break; 
02778:  MOVLB  1
0277A:  BRA    2782
....................          
....................      case OPT_EXIT: 
....................         break; 
0277C:  MOVLB  1
0277E:  BRA    2782
02780:  MOVLB  1
....................          
....................   } 
....................    
....................   if(optSelect!=OPT_EXIT){ 
02782:  MOVF   x6A,W
02784:  SUBLW  08
02786:  BZ    278E
....................    pressExit(); 
02788:  MOVLB  0
0278A:  RCALL  22A2
0278C:  MOVLB  1
....................   } 
0278E:  MOVLB  0
02790:  GOTO   28C0 (RETURN)
.................... } 
....................    
.................... /*************************************************** 
....................    Despliega el menu MODE 
.................... ***************************************************/ 
.................... void setMenuModo(void){ 
*
022EA:  MOVLB  1
022EC:  CLRF   x6C
022EE:  CLRF   x6D
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
022F0:  MOVF   x6C,W
022F2:  MULLW  0E
022F4:  MOVF   FF3,W
022F6:  CLRF   03
022F8:  MOVWF  x6E
022FA:  MOVLW  0C
022FC:  MOVWF  x71
022FE:  MOVLB  0
02300:  CALL   0E6E
02304:  MOVLW  7C
02306:  MOVWF  FF6
02308:  MOVLW  03
0230A:  MOVWF  FF7
0230C:  MOVLB  1
0230E:  MOVF   x6E,W
02310:  ADDWF  FF6,F
02312:  MOVLW  00
02314:  ADDWFC FF7,F
02316:  MOVLB  0
02318:  CALL   0EDA
....................   showBottonMenu(); 
0231C:  CALL   1272
....................    
....................   while(!exit){ 
02320:  MOVLB  1
02322:  MOVF   x6D,F
02324:  BTFSS  FD8.2
02326:  BRA    250C
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02328:  MOVLB  0
0232A:  CALL   1378
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
0232E:  BSF    F93.4
02330:  BTFSC  F81.4
02332:  BRA    2398
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
02334:  MOVLW  02
02336:  MOVLB  1
02338:  MOVWF  x6E
0233A:  MOVLW  FA
0233C:  MOVWF  xB1
0233E:  MOVLB  0
02340:  CALL   0B8E
02344:  MOVLB  1
02346:  DECFSZ x6E,F
02348:  BRA    233A
....................         BEEP; 
0234A:  MOVLW  04
0234C:  MOVWF  x6F
0234E:  MOVLW  B9
02350:  MOVWF  x6E
02352:  CLRF   x71
02354:  MOVLW  14
02356:  MOVWF  x70
02358:  MOVLB  0
0235A:  RCALL  1D76
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
0235C:  MOVLB  1
0235E:  INCF   x6C,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
02360:  MOVF   x6C,W
02362:  SUBWF  x66,W
02364:  BC    2368
....................            optSelected = 0; 
02366:  CLRF   x6C
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
02368:  MOVF   x6C,W
0236A:  MULLW  0E
0236C:  MOVF   FF3,W
0236E:  CLRF   03
02370:  MOVWF  x6E
02372:  MOVLW  0C
02374:  MOVWF  x71
02376:  MOVLB  0
02378:  CALL   0E6E
0237C:  MOVLW  7C
0237E:  MOVWF  FF6
02380:  MOVLW  03
02382:  MOVWF  FF7
02384:  MOVLB  1
02386:  MOVF   x6E,W
02388:  ADDWF  FF6,F
0238A:  MOVLW  00
0238C:  ADDWFC FF7,F
0238E:  MOVLB  0
02390:  CALL   0EDA
....................         showBottonMenu(); 
02394:  CALL   1272
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
02398:  BSF    F93.5
0239A:  BTFSC  F81.5
0239C:  BRA    2508
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
0239E:  MOVLW  02
023A0:  MOVLB  1
023A2:  MOVWF  x6E
023A4:  MOVLW  FA
023A6:  MOVWF  xB1
023A8:  MOVLB  0
023AA:  CALL   0B8E
023AE:  MOVLB  1
023B0:  DECFSZ x6E,F
023B2:  BRA    23A4
....................         BEEP; 
023B4:  MOVLW  04
023B6:  MOVWF  x6F
023B8:  MOVLW  B9
023BA:  MOVWF  x6E
023BC:  CLRF   x71
023BE:  MOVLW  14
023C0:  MOVWF  x70
023C2:  MOVLB  0
023C4:  RCALL  1D76
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
023C6:  MOVLB  1
023C8:  MOVF   x66,W
023CA:  SUBWF  x6C,W
023CC:  BNZ   23D4
....................            exit = 1; 
023CE:  MOVLW  01
023D0:  MOVWF  x6D
....................         }else{ 
023D2:  BRA    250A
....................            switch(optSelected){ 
023D4:  MOVF   x6C,W
023D6:  XORLW  00
023D8:  MOVLB  0
023DA:  BZ    23E6
023DC:  XORLW  01
023DE:  BZ    2436
023E0:  XORLW  03
023E2:  BZ    2486
023E4:  BRA    24D4
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
023E6:  MOVLW  3C
023E8:  MOVWF  FF6
023EA:  MOVLW  05
023EC:  MOVWF  FF7
023EE:  CALL   0EFA
....................                  write_eeprom(0,'1'); 
023F2:  MOVF   FF2,W
023F4:  MOVWF  00
023F6:  BCF    FF2.7
023F8:  CLRF   FAA
023FA:  CLRF   FA9
023FC:  MOVLW  31
023FE:  MOVWF  FA8
02400:  BCF    FA6.6
02402:  BCF    FA6.7
02404:  BSF    FA6.2
02406:  MOVLB  F
02408:  MOVLW  55
0240A:  MOVWF  FA7
0240C:  MOVLW  AA
0240E:  MOVWF  FA7
02410:  BSF    FA6.1
02412:  BTFSC  FA6.1
02414:  BRA    2412
02416:  BCF    FA6.2
02418:  MOVF   00,W
0241A:  IORWF  FF2,F
....................                  delay_ms(10); 
0241C:  MOVLW  0A
0241E:  MOVLB  1
02420:  MOVWF  xB1
02422:  MOVLB  0
02424:  CALL   0B8E
....................                  printf(lcd_putc, "\fConfig Cliente"); 
02428:  MOVLW  4E
0242A:  MOVWF  FF6
0242C:  MOVLW  05
0242E:  MOVWF  FF7
02430:  CALL   0EDA
....................                  break; 
02434:  BRA    24D4
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
02436:  MOVLW  5E
02438:  MOVWF  FF6
0243A:  MOVLW  05
0243C:  MOVWF  FF7
0243E:  CALL   0EFA
....................                  write_eeprom(0,'2'); 
02442:  MOVF   FF2,W
02444:  MOVWF  00
02446:  BCF    FF2.7
02448:  CLRF   FAA
0244A:  CLRF   FA9
0244C:  MOVLW  32
0244E:  MOVWF  FA8
02450:  BCF    FA6.6
02452:  BCF    FA6.7
02454:  BSF    FA6.2
02456:  MOVLB  F
02458:  MOVLW  55
0245A:  MOVWF  FA7
0245C:  MOVLW  AA
0245E:  MOVWF  FA7
02460:  BSF    FA6.1
02462:  BTFSC  FA6.1
02464:  BRA    2462
02466:  BCF    FA6.2
02468:  MOVF   00,W
0246A:  IORWF  FF2,F
....................                  delay_ms(10); 
0246C:  MOVLW  0A
0246E:  MOVLB  1
02470:  MOVWF  xB1
02472:  MOVLB  0
02474:  CALL   0B8E
....................                  printf(lcd_putc, "\fConfig AP"); 
02478:  MOVLW  70
0247A:  MOVWF  FF6
0247C:  MOVLW  05
0247E:  MOVWF  FF7
02480:  CALL   0EDA
....................                  break; 
02484:  BRA    24D4
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
02486:  MOVLW  7C
02488:  MOVWF  FF6
0248A:  MOVLW  05
0248C:  MOVWF  FF7
0248E:  CALL   0EFA
....................                  write_eeprom(0,'3'); 
02492:  MOVF   FF2,W
02494:  MOVWF  00
02496:  BCF    FF2.7
02498:  CLRF   FAA
0249A:  CLRF   FA9
0249C:  MOVLW  33
0249E:  MOVWF  FA8
024A0:  BCF    FA6.6
024A2:  BCF    FA6.7
024A4:  BSF    FA6.2
024A6:  MOVLB  F
024A8:  MOVLW  55
024AA:  MOVWF  FA7
024AC:  MOVLW  AA
024AE:  MOVWF  FA7
024B0:  BSF    FA6.1
024B2:  BTFSC  FA6.1
024B4:  BRA    24B2
024B6:  BCF    FA6.2
024B8:  MOVF   00,W
024BA:  IORWF  FF2,F
....................                  delay_ms(10); 
024BC:  MOVLW  0A
024BE:  MOVLB  1
024C0:  MOVWF  xB1
024C2:  MOVLB  0
024C4:  CALL   0B8E
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
024C8:  MOVLW  8E
024CA:  MOVWF  FF6
024CC:  MOVLW  05
024CE:  MOVWF  FF7
024D0:  CALL   0EDA
....................                  break; 
....................            } 
....................            pressExit(); 
024D4:  RCALL  22A2
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
024D6:  MOVLB  1
024D8:  MOVF   x6C,W
024DA:  MULLW  0E
024DC:  MOVF   FF3,W
024DE:  CLRF   03
024E0:  MOVWF  x6E
024E2:  MOVLW  0C
024E4:  MOVWF  x71
024E6:  MOVLB  0
024E8:  CALL   0E6E
024EC:  MOVLW  7C
024EE:  MOVWF  FF6
024F0:  MOVLW  03
024F2:  MOVWF  FF7
024F4:  MOVLB  1
024F6:  MOVF   x6E,W
024F8:  ADDWF  FF6,F
024FA:  MOVLW  00
024FC:  ADDWFC FF7,F
024FE:  MOVLB  0
02500:  CALL   0EDA
....................            showBottonMenu(); 
02504:  CALL   1272
02508:  MOVLB  1
....................         } 
....................      } // Fin KEY_OK 
0250A:  BRA    2322
....................   } // FIN While Infinito 
0250C:  MOVLB  0
0250E:  GOTO   2752 (RETURN)
.................... } // Fin funcion setMenuModo 
....................  
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
....................    se dispara cuando se detectan datos de 
....................    llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
00B68:  BTFSS  F9E.5
00B6A:  BRA    0B68
00B6C:  MOVFF  FAE,1B8
00B70:  MOVLB  1
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
00B72:  MOVFF  1B8,1B9
00B76:  MOVLB  0
00B78:  BRA    0A80
00B7A:  BCF    F9E.5
00B7C:  GOTO   0054
.................... } 
....................    /************************ 
....................    ***      INIT         *** 
....................    *************************/ 
....................  
....................    void main() 
*
02900:  CLRF   FF8
02902:  BCF    FD0.7
02904:  BSF    07.7
02906:  BSF    FB8.3
02908:  MOVLW  2A
0290A:  MOVWF  FAF
0290C:  MOVLW  00
0290E:  MOVWF  FB0
02910:  MOVLW  A6
02912:  MOVWF  FAC
02914:  MOVLW  90
02916:  MOVWF  FAB
02918:  BCF    F93.0
0291A:  BSF    F8A.0
0291C:  CLRF   53
0291E:  CLRF   52
02920:  CLRF   54
02922:  CLRF   55
02924:  CLRF   56
02926:  CLRF   57
02928:  CLRF   58
0292A:  CLRF   59
0292C:  CLRF   5A
0292E:  CLRF   5B
02930:  MOVLW  01
02932:  MOVWF  5C
02934:  CLRF   5D
02936:  MOVLW  05
02938:  MOVWF  5E
0293A:  CLRF   xBB
0293C:  CLRF   xBC
0293E:  CLRF   xBD
02940:  CLRF   xBE
02942:  CLRF   xBF
02944:  CLRF   xC0
02946:  MOVLW  02
02948:  MOVLB  1
0294A:  MOVWF  x62
0294C:  MOVLW  08
0294E:  MOVWF  x63
02950:  MOVWF  x64
02952:  MOVWF  x65
02954:  MOVLW  03
02956:  MOVWF  x66
02958:  CLRF   x67
0295A:  MOVF   FC1,W
0295C:  ANDLW  C0
0295E:  IORLW  0F
02960:  MOVWF  FC1
02962:  MOVLW  07
02964:  MOVWF  FB4
02966:  BRA    29F0
02968:  DATA 02,00
0296A:  DATA 16,00
0296C:  DATA 00,0C
0296E:  DATA 40,5F
02970:  DATA 00,07
02972:  DATA 80,30
02974:  DATA 2E,30
02976:  DATA 2E,30
02978:  DATA 2E,30
0297A:  DATA 09,C0
0297C:  DATA 00,07
0297E:  DATA 80,30
02980:  DATA 2E,30
02982:  DATA 2E,30
02984:  DATA 2E,30
02986:  DATA 2A,C0
02988:  DATA 00,5D
0298A:  DATA 00,F4
0298C:  DATA 4F,75
0298E:  DATA 74,70
02990:  DATA 75,74
02992:  DATA 20,31
02994:  DATA 20,20
02996:  DATA 00,4F
02998:  DATA 75,74
0299A:  DATA 70,75
0299C:  DATA 74,20
0299E:  DATA 32,20
029A0:  DATA 20,00
029A2:  DATA 4F,75
029A4:  DATA 74,70
029A6:  DATA 75,74
029A8:  DATA 20,33
029AA:  DATA 20,20
029AC:  DATA 00,4F
029AE:  DATA 75,74
029B0:  DATA 70,75
029B2:  DATA 74,20
029B4:  DATA 34,20
029B6:  DATA 20,00
029B8:  DATA 4F,75
029BA:  DATA 74,70
029BC:  DATA 75,74
029BE:  DATA 20,35
029C0:  DATA 20,20
029C2:  DATA 00,4F
029C4:  DATA 75,74
029C6:  DATA 70,75
029C8:  DATA 74,20
029CA:  DATA 36,20
029CC:  DATA 20,00
029CE:  DATA 4F,75
029D0:  DATA 74,70
029D2:  DATA 75,74
029D4:  DATA 20,37
029D6:  DATA 20,20
029D8:  DATA 00,4F
029DA:  DATA 75,74
029DC:  DATA 70,75
029DE:  DATA 74,20
029E0:  DATA 38,20
029E2:  DATA 20,00
029E4:  DATA 53,41
029E6:  DATA 4C,49
029E8:  DATA 52,05
029EA:  DATA C0,20
029EC:  DATA 0C,C0
029EE:  DATA 00,00
029F0:  MOVLW  00
029F2:  MOVWF  FF8
029F4:  MOVLW  29
029F6:  MOVWF  FF7
029F8:  MOVLW  68
029FA:  MOVWF  FF6
029FC:  TBLRD*+
029FE:  MOVF   FF5,W
02A00:  MOVWF  00
02A02:  XORLW  00
02A04:  BZ    2A2C
02A06:  TBLRD*+
02A08:  MOVF   FF5,W
02A0A:  MOVWF  01
02A0C:  BTFSC  FE8.7
02A0E:  BRA    2A1A
02A10:  ANDLW  0F
02A12:  MOVWF  FEA
02A14:  TBLRD*+
02A16:  MOVFF  FF5,FE9
02A1A:  BTFSC  01.6
02A1C:  TBLRD*+
02A1E:  BTFSS  01.6
02A20:  TBLRD*+
02A22:  MOVFF  FF5,FEE
02A26:  DCFSNZ 00,F
02A28:  BRA    29FC
02A2A:  BRA    2A1E
02A2C:  CLRF   FF8
....................    {       
....................           
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(1000); 
02A2E:  MOVLW  04
02A30:  MOVWF  x68
02A32:  MOVLW  FA
02A34:  MOVWF  xB1
02A36:  MOVLB  0
02A38:  CALL   0B8E
02A3C:  MOVLB  1
02A3E:  DECFSZ x68,F
02A40:  BRA    2A32
....................        
....................        
....................       // Carga el nombre personalizado del puerto desde la eeprom 
....................       getNameMenusOutput(); 
02A42:  MOVLB  0
02A44:  GOTO   0BB6
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
02A48:  BCF    FF1.7
....................       set_tris_b(0b00110010); 
02A4A:  MOVLW  32
02A4C:  MOVWF  F93
....................       enable_interrupts(INT_RDA);  
02A4E:  BSF    F9D.5
....................       enable_interrupts(GLOBAL);  
02A50:  MOVLW  C0
02A52:  IORWF  FF2,F
....................        
....................       // Inicializa la LCD 
....................       lcd_init(); 
02A54:  GOTO   0DAC
....................       printf(lcd_putc, "\fIniciando..."); 
02A58:  MOVLW  80
02A5A:  MOVWF  FF6
02A5C:  MOVLW  0B
02A5E:  MOVWF  FF7
02A60:  CALL   0EDA
....................  
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
02A64:  BCF    F95.3
02A66:  BSF    F8C.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
02A68:  GOTO   105C
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
02A6C:  MOVLB  1
02A6E:  MOVF   x67,W
02A70:  ADDLW  FC
02A72:  BC    2AAC
02A74:  ADDLW  04
02A76:  MOVLB  0
02A78:  GOTO   2AB0
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
02A7C:  GOTO   1EBE
02A80:  MOVFF  01,167
....................                break; 
02A84:  MOVLB  1
02A86:  BRA    2AAC
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
02A88:  GOTO   2000
02A8C:  MOVFF  01,167
....................                break; 
02A90:  MOVLB  1
02A92:  BRA    2AAC
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
02A94:  GOTO   2152
02A98:  MOVFF  01,167
....................                break; 
02A9C:  MOVLB  1
02A9E:  BRA    2AAC
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
02AA0:  BRA    27CA
02AA2:  MOVFF  01,167
....................                break; 
02AA6:  MOVLB  1
02AA8:  BRA    2AAC
02AAA:  MOVLB  1
....................          } // Fin del Switch(menuActive) 
02AAC:  BRA    2A6E
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
02AAE:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
