CCS PCH C Compiler, Version 5.015, 5967               24-dic.-17 00:43

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   11456 bytes (17%)
                           Largest free fragment is 54076
               RAM used:   362 (9%) at main() level
                           461 (12%) worst case
               Stack used: 14 locations (10 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   2A44
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  F9D.5
0004A:  GOTO   0054
0004E:  BTFSC  F9E.5
00050:  GOTO   0BBC
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          MAIN.C: Funcion principal 
....................  
.................... *******************************************************/ 
....................  
.................... #include "header/config.h" 
.................... #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
00096:  MOVFF  FF2,0D
0009A:  BCF    FF2.7
0009C:  CLRF   FF7
0009E:  ADDLW  B0
000A0:  MOVWF  FF6
000A2:  MOVLW  00
000A4:  ADDWFC FF7,F
000A6:  TBLRD*+
000A8:  MOVF   FF5,W
000AA:  BTFSC  0D.7
000AC:  BSF    FF2.7
000AE:  RETURN 0
000B0:  DATA 22,7C
000B2:  DATA 21,7C
000B4:  DATA 20,7C
000B6:  DATA 04,7C
000B8:  DATA 00,7C
000BA:  DATA 01,7C
000BC:  DATA 02,7C
000BE:  DATA 03,7C
000C0:  CLRF   FF7
000C2:  ADDLW  D0
000C4:  MOVWF  FF6
000C6:  MOVLW  00
000C8:  ADDWFC FF7,F
000CA:  TBLRD*+
000CC:  MOVF   FF5,W
000CE:  RETURN 0
000D0:  DATA 2B,49
000D2:  DATA 50,44
000D4:  DATA 2C,00
000D6:  CLRF   FF7
000D8:  ADDLW  E6
000DA:  MOVWF  FF6
000DC:  MOVLW  00
000DE:  ADDWFC FF7,F
000E0:  TBLRD*+
000E2:  MOVF   FF5,W
000E4:  RETURN 0
000E6:  DATA 43,4D
000E8:  DATA 44,3A
000EA:  CLRF   FF7
000EC:  ADDLW  FA
000EE:  MOVWF  FF6
000F0:  MOVLW  00
000F2:  ADDWFC FF7,F
000F4:  TBLRD*+
000F6:  MOVF   FF5,W
000F8:  RETURN 0
000FA:  DATA 4F,4B
000FC:  DATA 0D,0A
000FE:  DATA 00,00
00100:  CLRF   FF7
00102:  ADDLW  10
00104:  MOVWF  FF6
00106:  MOVLW  01
00108:  ADDWFC FF7,F
0010A:  TBLRD*+
0010C:  MOVF   FF5,W
0010E:  RETURN 0
00110:  DATA 4E,6F
00112:  DATA 20,41
00114:  DATA 50,00
00116:  CLRF   FF7
00118:  ADDLW  26
0011A:  MOVWF  FF6
0011C:  MOVLW  01
0011E:  ADDWFC FF7,F
00120:  TBLRD*+
00122:  MOVF   FF5,W
00124:  RETURN 0
00126:  DATA 2B,43
00128:  DATA 57,4A
0012A:  DATA 41,50
0012C:  DATA 3A,00
0012E:  CLRF   FF7
00130:  ADDLW  3E
00132:  MOVWF  FF6
00134:  MOVLW  01
00136:  ADDWFC FF7,F
00138:  TBLRD*+
0013A:  MOVF   FF5,W
0013C:  RETURN 0
0013E:  DATA 43,4F
00140:  DATA 4E,4E
00142:  DATA 45,43
00144:  DATA 54,45
00146:  DATA 44,00
00148:  CLRF   FF7
0014A:  ADDLW  58
0014C:  MOVWF  FF6
0014E:  MOVLW  01
00150:  ADDWFC FF7,F
00152:  TBLRD*+
00154:  MOVF   FF5,W
00156:  RETURN 0
00158:  DATA 46,41
0015A:  DATA 49,4C
0015C:  DATA 00,00
0015E:  DATA 41,54
00160:  DATA 2B,43
00162:  DATA 49,50
00164:  DATA 53,45
00166:  DATA 4E,44
00168:  DATA 3D,25
0016A:  DATA 63,2C
0016C:  DATA 25,75
0016E:  DATA 0D,0A
00170:  DATA 00,00
00172:  DATA 41,54
00174:  DATA 2B,43
00176:  DATA 49,50
00178:  DATA 43,4C
0017A:  DATA 4F,53
0017C:  DATA 45,3D
0017E:  DATA 25,63
00180:  DATA 0D,0A
00182:  DATA 00,00
00184:  DATA 41,54
00186:  DATA 2B,43
00188:  DATA 49,50
0018A:  DATA 53,45
0018C:  DATA 4E,44
0018E:  DATA 3D,25
00190:  DATA 63,2C
00192:  DATA 25,75
00194:  DATA 0D,0A
00196:  DATA 00,00
00198:  DATA 41,54
0019A:  DATA 2B,43
0019C:  DATA 49,50
0019E:  DATA 43,4C
001A0:  DATA 4F,53
001A2:  DATA 45,3D
001A4:  DATA 25,63
001A6:  DATA 0D,0A
001A8:  DATA 00,00
001AA:  DATA 41,54
001AC:  DATA 2B,43
001AE:  DATA 57,51
001B0:  DATA 41,50
001B2:  DATA 0A,0D
001B4:  DATA 00,00
001B6:  DATA 41,54
001B8:  DATA 2B,43
001BA:  DATA 49,50
001BC:  DATA 53,45
001BE:  DATA 4E,44
001C0:  DATA 3D,25
001C2:  DATA 63,2C
001C4:  DATA 25,75
001C6:  DATA 0D,0A
001C8:  DATA 00,00
001CA:  DATA 41,54
001CC:  DATA 2B,43
001CE:  DATA 49,50
001D0:  DATA 43,4C
001D2:  DATA 4F,53
001D4:  DATA 45,3D
001D6:  DATA 25,63
001D8:  DATA 0D,0A
001DA:  DATA 00,00
001DC:  DATA 41,54
001DE:  DATA 2B,43
001E0:  DATA 57,53
001E2:  DATA 41,50
001E4:  DATA 5F,44
001E6:  DATA 45,46
001E8:  DATA 3D,25
001EA:  DATA 73,2C
001EC:  DATA 31,2C
001EE:  DATA 34,0D
001F0:  DATA 0A,00
001F2:  DATA 41,54
001F4:  DATA 2B,43
001F6:  DATA 49,50
001F8:  DATA 53,45
001FA:  DATA 4E,44
001FC:  DATA 3D,25
001FE:  DATA 63,2C
00200:  DATA 25,75
00202:  DATA 0D,0A
00204:  DATA 00,00
00206:  DATA 41,54
00208:  DATA 2B,43
0020A:  DATA 49,50
0020C:  DATA 43,4C
0020E:  DATA 4F,53
00210:  DATA 45,3D
00212:  DATA 25,63
00214:  DATA 0D,0A
00216:  DATA 00,00
00218:  DATA 41,54
0021A:  DATA 2B,43
0021C:  DATA 49,50
0021E:  DATA 53,45
00220:  DATA 4E,44
00222:  DATA 3D,25
00224:  DATA 63,2C
00226:  DATA 25,75
00228:  DATA 0D,0A
0022A:  DATA 00,00
0022C:  DATA 41,54
0022E:  DATA 2B,43
00230:  DATA 49,50
00232:  DATA 43,4C
00234:  DATA 4F,53
00236:  DATA 45,3D
00238:  DATA 25,63
0023A:  DATA 0D,0A
0023C:  DATA 00,00
0023E:  DATA 41,54
00240:  DATA 2B,43
00242:  DATA 57,4D
00244:  DATA 4F,44
00246:  DATA 45,3D
00248:  DATA 25,63
0024A:  DATA 0D,0A
0024C:  DATA 00,00
0024E:  DATA 41,54
00250:  DATA 2B,43
00252:  DATA 57,4A
00254:  DATA 41,50
00256:  DATA 3F,0D
00258:  DATA 0A,00
0025A:  DATA 41,54
0025C:  DATA 2B,43
0025E:  DATA 57,4A
00260:  DATA 41,50
00262:  DATA 3D,25
00264:  DATA 73,00
00266:  DATA 4C,61
00268:  DATA 6E,7A
0026A:  DATA 61,20
0026C:  DATA 63,6F
0026E:  DATA 6D,61
00270:  DATA 6E,64
00272:  DATA 6F,20
00274:  DATA 50,61
00276:  DATA 72,61
00278:  DATA 20,63
0027A:  DATA 6F,6E
0027C:  DATA 65,63
0027E:  DATA 74,61
00280:  DATA 72,73
00282:  DATA 65,20
00284:  DATA 61,20
00286:  DATA 75,6E
00288:  DATA 61,20
0028A:  DATA 72,65
0028C:  DATA 64,20
0028E:  DATA 0D,0A
00290:  DATA 00,00
00292:  DATA 53,69
00294:  DATA 6E,20
00296:  DATA 72,65
00298:  DATA 64,20
0029A:  DATA 65,6E
0029C:  DATA 74,6F
0029E:  DATA 6E,63
002A0:  DATA 65,73
002A2:  DATA 20,61
002A4:  DATA 63,74
002A6:  DATA 69,76
002A8:  DATA 61,20
002AA:  DATA 4D,6F
002AC:  DATA 64,6F
002AE:  DATA 20,41
002B0:  DATA 50,20
002B2:  DATA 0D,0A
002B4:  DATA 00,00
002B6:  DATA 41,54
002B8:  DATA 2B,43
002BA:  DATA 57,4D
002BC:  DATA 4F,44
002BE:  DATA 45,3D
002C0:  DATA 25,63
002C2:  DATA 0D,0A
002C4:  DATA 00,00
002C6:  DATA 41,54
002C8:  DATA 2B,43
002CA:  DATA 49,50
002CC:  DATA 4D,55
002CE:  DATA 58,3D
002D0:  DATA 31,0D
002D2:  DATA 0A,00
002D4:  DATA 41,54
002D6:  DATA 2B,43
002D8:  DATA 49,50
002DA:  DATA 53,45
002DC:  DATA 52,56
002DE:  DATA 45,52
002E0:  DATA 3D,31
002E2:  DATA 2C,38
002E4:  DATA 30,0D
002E6:  DATA 0A,00
002E8:  DATA 45,6E
002EA:  DATA 63,65
002EC:  DATA 6E,64
002EE:  DATA 65,72
002F0:  DATA 20,4D
002F2:  DATA 61,6E
002F4:  DATA 75,61
002F6:  DATA 6C,00
002F8:  DATA 41,70
002FA:  DATA 61,67
002FC:  DATA 61,64
002FE:  DATA 6F,20
00300:  DATA 4D,61
00302:  DATA 6E,75
00304:  DATA 61,6C
00306:  DATA 20,00
00308:  DATA 43,6F
0030A:  DATA 6E,66
0030C:  DATA 69,67
0030E:  DATA 75,72
00310:  DATA 61,63
00312:  DATA 69,6F
00314:  DATA 6E,20
00316:  DATA 20,00
00318:  DATA 00,00
0031A:  DATA 00,00
0031C:  DATA 00,00
0031E:  DATA 00,00
00320:  DATA 00,00
00322:  DATA 00,00
00324:  DATA 00,00
00326:  DATA 00,00
00328:  DATA 45,53
0032A:  DATA 54,41
0032C:  DATA 43,49
0032E:  DATA 4F,4E
00330:  DATA 20,49
00332:  DATA 50,20
00334:  DATA 20,20
00336:  DATA 20,20
00338:  DATA 00,45
0033A:  DATA 53,54
0033C:  DATA 41,43
0033E:  DATA 49,4F
00340:  DATA 4E,20
00342:  DATA 53,53
00344:  DATA 49,44
00346:  DATA 20,20
00348:  DATA 20,00
0034A:  DATA 41,50
0034C:  DATA 20,53
0034E:  DATA 53,49
00350:  DATA 44,20
00352:  DATA 20,20
00354:  DATA 20,20
00356:  DATA 20,20
00358:  DATA 20,20
0035A:  DATA 00,41
0035C:  DATA 50,20
0035E:  DATA 4B,45
00360:  DATA 59,20
00362:  DATA 20,20
00364:  DATA 20,20
00366:  DATA 20,20
00368:  DATA 20,20
0036A:  DATA 20,00
0036C:  DATA 41,50
0036E:  DATA 20,49
00370:  DATA 50,20
00372:  DATA 20,20
00374:  DATA 20,20
00376:  DATA 20,20
00378:  DATA 20,20
0037A:  DATA 20,20
0037C:  DATA 00,43
0037E:  DATA 6F,6E
00380:  DATA 66,20
00382:  DATA 41,63
00384:  DATA 63,65
00386:  DATA 73,73
00388:  DATA 6F,20
0038A:  DATA 52,65
0038C:  DATA 64,00
0038E:  DATA 42,6F
00390:  DATA 72,72
00392:  DATA 61,72
00394:  DATA 20,61
00396:  DATA 20,46
00398:  DATA 61,62
0039A:  DATA 72,69
0039C:  DATA 63,61
0039E:  DATA 00,4F
003A0:  DATA 6E,2F
003A2:  DATA 4F,66
003A4:  DATA 66,20
003A6:  DATA 42,61
003A8:  DATA 63,6B
003AA:  DATA 6C,69
003AC:  DATA 67,68
003AE:  DATA 74,00
003B0:  DATA 53,41
003B2:  DATA 4C,49
003B4:  DATA 52,20
003B6:  DATA 20,20
003B8:  DATA 20,20
003BA:  DATA 20,20
003BC:  DATA 20,20
003BE:  DATA 20,20
003C0:  DATA 00,00
003C2:  DATA 45,73
003C4:  DATA 74,61
003C6:  DATA 63,69
003C8:  DATA 6F,6E
003CA:  DATA 20,20
003CC:  DATA 20,20
003CE:  DATA 20,00
003D0:  DATA 41,63
003D2:  DATA 63,65
003D4:  DATA 73,73
003D6:  DATA 20,50
003D8:  DATA 6F,69
003DA:  DATA 6E,74
003DC:  DATA 20,00
003DE:  DATA 45,73
003E0:  DATA 74,61
003E2:  DATA 63,69
003E4:  DATA 6F,6E
003E6:  DATA 20,2B
003E8:  DATA 20,41
003EA:  DATA 50,00
003EC:  DATA 53,41
003EE:  DATA 4C,49
003F0:  DATA 52,20
003F2:  DATA 20,20
003F4:  DATA 20,20
003F6:  DATA 20,20
003F8:  DATA 20,00
003FA:  DATA 00,00
003FC:  DATA 00,00
003FE:  DATA 00,00
00400:  DATA 00,00
00402:  DATA 00,00
00404:  DATA 00,00
00406:  DATA 00,00
00408:  DATA 53,41
0040A:  DATA 4C,49
0040C:  DATA 52,00
0040E:  DATA 5B,53
00410:  DATA 49,47
00412:  DATA 5D,20
00414:  DATA 20,20
00416:  DATA 20,20
00418:  DATA 20,5B
0041A:  DATA 45,4E
0041C:  DATA 54,5D
0041E:  DATA 00,00
00420:  DATA 0C,4F
00422:  DATA 6E,20
00424:  DATA 2D,3E
00426:  DATA 20,25
00428:  DATA 73,00
0042A:  DATA 0C,4F
0042C:  DATA 6E,20
0042E:  DATA 2D,3E
00430:  DATA 20,25
00432:  DATA 73,00
00434:  DATA 0C,4F
00436:  DATA 66,66
00438:  DATA 2D,3E
0043A:  DATA 20,25
0043C:  DATA 73,00
0043E:  DATA 0C,4F
00440:  DATA 66,66
00442:  DATA 2D,3E
00444:  DATA 20,25
00446:  DATA 73,00
00448:  DATA 41,54
0044A:  DATA 2B,43
0044C:  DATA 49,46
0044E:  DATA 53,52
00450:  DATA 0D,0A
00452:  DATA 00,00
00454:  DATA 0C,43
00456:  DATA 61,72
00458:  DATA 67,61
0045A:  DATA 6E,64
0045C:  DATA 6F,2E
0045E:  DATA 2E,2E
00460:  DATA 00,00
00462:  DATA 41,54
00464:  DATA 2B,43
00466:  DATA 49,46
00468:  DATA 53,52
0046A:  DATA 0D,0A
0046C:  DATA 00,00
0046E:  DATA 0C,43
00470:  DATA 61,72
00472:  DATA 67,61
00474:  DATA 6E,64
00476:  DATA 6F,2E
00478:  DATA 2E,2E
0047A:  DATA 00,00
0047C:  DATA 41,54
0047E:  DATA 2B,43
00480:  DATA 57,4A
00482:  DATA 41,50
00484:  DATA 3F,0D
00486:  DATA 0A,00
00488:  DATA 0C,43
0048A:  DATA 61,72
0048C:  DATA 67,61
0048E:  DATA 6E,64
00490:  DATA 6F,2E
00492:  DATA 2E,2E
00494:  DATA 00,00
00496:  DATA 0C,44
00498:  DATA 65,73
0049A:  DATA 68,61
0049C:  DATA 62,69
0049E:  DATA 6C,69
004A0:  DATA 74,61
004A2:  DATA 64,6F
004A4:  DATA 00,00
004A6:  DATA 41,54
004A8:  DATA 2B,43
004AA:  DATA 57,53
004AC:  DATA 41,50
004AE:  DATA 3F,0D
004B0:  DATA 0A,00
004B2:  DATA 0C,43
004B4:  DATA 61,72
004B6:  DATA 67,61
004B8:  DATA 6E,64
004BA:  DATA 6F,2E
004BC:  DATA 2E,2E
004BE:  DATA 00,00
004C0:  DATA 0C,44
004C2:  DATA 65,73
004C4:  DATA 68,61
004C6:  DATA 62,69
004C8:  DATA 6C,69
004CA:  DATA 74,61
004CC:  DATA 64,6F
004CE:  DATA 00,00
004D0:  DATA 41,54
004D2:  DATA 2B,43
004D4:  DATA 57,53
004D6:  DATA 41,50
004D8:  DATA 3F,0D
004DA:  DATA 0A,00
004DC:  DATA 0C,43
004DE:  DATA 61,72
004E0:  DATA 67,61
004E2:  DATA 6E,64
004E4:  DATA 6F,2E
004E6:  DATA 2E,2E
004E8:  DATA 00,00
004EA:  DATA 0C,44
004EC:  DATA 65,73
004EE:  DATA 68,61
004F0:  DATA 62,69
004F2:  DATA 6C,69
004F4:  DATA 74,61
004F6:  DATA 64,6F
004F8:  DATA 00,00
004FA:  DATA 0C,42
004FC:  DATA 6F,72
004FE:  DATA 72,61
00500:  DATA 6E,64
00502:  DATA 6F,20
00504:  DATA 45,45
00506:  DATA 45,50
00508:  DATA 52,4F
0050A:  DATA 4D,00
0050C:  DATA 0C,42
0050E:  DATA 6F,72
00510:  DATA 72,61
00512:  DATA 6E,64
00514:  DATA 6F,20
00516:  DATA 52,45
00518:  DATA 44,00
0051A:  DATA 41,54
0051C:  DATA 2B,43
0051E:  DATA 57,51
00520:  DATA 41,50
00522:  DATA 0A,0D
00524:  DATA 00,00
00526:  DATA 41,54
00528:  DATA 2B,52
0052A:  DATA 53,54
0052C:  DATA 0A,0D
0052E:  DATA 00,00
00530:  DATA 41,54
00532:  DATA 2B,43
00534:  DATA 57,53
00536:  DATA 41,50
00538:  DATA 5F,44
0053A:  DATA 45,46
0053C:  DATA 3D,22
0053E:  DATA 4B,72
00540:  DATA 69,76
00542:  DATA 65,72
00544:  DATA 20,53
00546:  DATA 6D,61
00548:  DATA 72,74
0054A:  DATA 48,6F
0054C:  DATA 6D,65
0054E:  DATA 22,2C
00550:  DATA 22,6B
00552:  DATA 72,69
00554:  DATA 76,65
00556:  DATA 72,35
00558:  DATA 36,31
0055A:  DATA 30,36
0055C:  DATA 22,2C
0055E:  DATA 31,2C
00560:  DATA 34,0D
00562:  DATA 0A,00
00564:  DATA 0C,42
00566:  DATA 61,63
00568:  DATA 6B,6C
0056A:  DATA 69,67
0056C:  DATA 68,74
0056E:  DATA 20,4F
00570:  DATA 6E,00
00572:  DATA 0C,42
00574:  DATA 61,63
00576:  DATA 6B,6C
00578:  DATA 69,67
0057A:  DATA 68,74
0057C:  DATA 20,4F
0057E:  DATA 66,66
00580:  DATA 00,00
00582:  DATA 41,54
00584:  DATA 2B,43
00586:  DATA 57,4D
00588:  DATA 4F,44
0058A:  DATA 45,5F
0058C:  DATA 44,45
0058E:  DATA 46,3D
00590:  DATA 31,0D
00592:  DATA 0A,00
00594:  DATA 0C,43
00596:  DATA 6F,6E
00598:  DATA 66,69
0059A:  DATA 67,20
0059C:  DATA 43,6C
0059E:  DATA 69,65
005A0:  DATA 6E,74
005A2:  DATA 65,00
005A4:  DATA 41,54
005A6:  DATA 2B,43
005A8:  DATA 57,4D
005AA:  DATA 4F,44
005AC:  DATA 45,5F
005AE:  DATA 44,45
005B0:  DATA 46,3D
005B2:  DATA 32,0D
005B4:  DATA 0A,00
005B6:  DATA 0C,43
005B8:  DATA 6F,6E
005BA:  DATA 66,69
005BC:  DATA 67,20
005BE:  DATA 41,50
005C0:  DATA 00,00
005C2:  DATA 41,54
005C4:  DATA 2B,43
005C6:  DATA 57,4D
005C8:  DATA 4F,44
005CA:  DATA 45,5F
005CC:  DATA 44,45
005CE:  DATA 46,3D
005D0:  DATA 33,0D
005D2:  DATA 0A,00
005D4:  DATA 0C,43
005D6:  DATA 6F,6E
005D8:  DATA 66,69
005DA:  DATA 67,20
005DC:  DATA 43,6C
005DE:  DATA 69,65
005E0:  DATA 6E,74
005E2:  DATA 65,41
005E4:  DATA 50,00
005E6:  DATA 0C,52
005E8:  DATA 65,69
005EA:  DATA 6E,69
005EC:  DATA 63,69
005EE:  DATA 61,6E
005F0:  DATA 64,6F
005F2:  DATA 00,00
*
007E6:  ADDWF  FE8,W
007E8:  CLRF   FF7
007EA:  RLCF   FF7,F
007EC:  ADDLW  01
007EE:  MOVWF  FF6
007F0:  MOVLW  08
007F2:  ADDWFC FF7,F
007F4:  TBLRD*-
007F6:  MOVF   FF5,W
007F8:  MOVWF  FFA
007FA:  TBLRD*
007FC:  MOVF   FF5,W
007FE:  MOVWF  FF9
00800:  DATA 0A,06
00802:  DATA 62,06
00804:  DATA 38,06
00806:  DATA 8C,06
00808:  DATA B6,06
*
008B6:  ADDWF  FE8,W
008B8:  CLRF   FF7
008BA:  RLCF   FF7,F
008BC:  ADDLW  D1
008BE:  MOVWF  FF6
008C0:  MOVLW  08
008C2:  ADDWFC FF7,F
008C4:  TBLRD*-
008C6:  MOVF   FF5,W
008C8:  MOVWF  FFA
008CA:  TBLRD*
008CC:  MOVF   FF5,W
008CE:  MOVWF  FF9
008D0:  DATA AA,08
008D2:  DATA AA,08
008D4:  DATA AA,08
008D6:  DATA AA,08
008D8:  DATA AA,08
*
00950:  ADDWF  FE8,W
00952:  CLRF   FF7
00954:  RLCF   FF7,F
00956:  ADDLW  6B
00958:  MOVWF  FF6
0095A:  MOVLW  09
0095C:  ADDWFC FF7,F
0095E:  TBLRD*-
00960:  MOVF   FF5,W
00962:  MOVWF  FFA
00964:  TBLRD*
00966:  MOVF   FF5,W
00968:  MOVWF  FF9
0096A:  DATA 44,09
0096C:  DATA 44,09
0096E:  DATA 44,09
00970:  DATA 44,09
*
00BD4:  DATA 41,54
00BD6:  DATA 2B,52
00BD8:  DATA 53,54
00BDA:  DATA 0D,0A
00BDC:  DATA 00,00
00BDE:  DATA 0C,49
00BE0:  DATA 6E,69
00BE2:  DATA 63,69
00BE4:  DATA 61,6E
00BE6:  DATA 64,6F
00BE8:  DATA 2E,2E
00BEA:  DATA 2E,00
00BEC:  MOVLB  1
00BEE:  MOVF   xB5,W
00BF0:  ANDLW  07
00BF2:  MOVWF  00
00BF4:  RRCF   xB5,W
00BF6:  MOVWF  01
00BF8:  RRCF   01,F
00BFA:  RRCF   01,F
00BFC:  MOVLW  1F
00BFE:  ANDWF  01,F
00C00:  MOVF   01,W
00C02:  ADDWF  xB7,W
00C04:  MOVWF  FE9
00C06:  MOVLW  00
00C08:  ADDWFC xB8,W
00C0A:  MOVWF  FEA
00C0C:  CLRF   01
00C0E:  INCF   01,F
00C10:  INCF   00,F
00C12:  BRA    0C16
00C14:  RLCF   01,F
00C16:  DECFSZ 00,F
00C18:  BRA    0C14
00C1A:  MOVF   xB6,F
00C1C:  BZ    0C24
00C1E:  MOVF   01,W
00C20:  IORWF  FEF,F
00C22:  BRA    0C2A
00C24:  COMF   01,F
00C26:  MOVF   01,W
00C28:  ANDWF  FEF,F
00C2A:  MOVLB  0
00C2C:  RETURN 0
*
00C56:  TBLRD*+
00C58:  MOVF   FF5,F
00C5A:  BZ    0C76
00C5C:  MOVFF  FF6,1B3
00C60:  MOVFF  FF7,1B4
00C64:  MOVF   FF5,W
00C66:  BTFSS  F9E.4
00C68:  BRA    0C66
00C6A:  MOVWF  FAD
00C6C:  MOVFF  1B3,FF6
00C70:  MOVFF  1B4,FF7
00C74:  BRA    0C56
00C76:  RETURN 0
*
00EEC:  TBLRD*+
00EEE:  MOVF   FF5,F
00EF0:  BZ    0F0A
00EF2:  MOVFF  FF6,171
00EF6:  MOVFF  FF7,172
00EFA:  MOVFF  FF5,173
00EFE:  RCALL  0E80
00F00:  MOVFF  171,FF6
00F04:  MOVFF  172,FF7
00F08:  BRA    0EEC
00F0A:  RETURN 0
00F0C:  TBLRD*+
00F0E:  MOVFF  FF6,1B4
00F12:  MOVFF  FF7,1B5
00F16:  MOVF   FF5,W
00F18:  BTFSS  F9E.4
00F1A:  BRA    0F18
00F1C:  MOVWF  FAD
00F1E:  MOVFF  1B4,FF6
00F22:  MOVFF  1B5,FF7
00F26:  MOVLB  1
00F28:  DECFSZ xB3,F
00F2A:  BRA    0F2E
00F2C:  BRA    0F32
00F2E:  MOVLB  0
00F30:  BRA    0F0C
00F32:  MOVLB  0
00F34:  RETURN 0
*
01026:  MOVF   FEF,F
01028:  BZ    104A
0102A:  MOVFF  FEA,1B4
0102E:  MOVFF  FE9,1B3
01032:  MOVF   FEF,W
01034:  BTFSS  F9E.4
01036:  BRA    1034
01038:  MOVWF  FAD
0103A:  MOVFF  1B4,FEA
0103E:  MOVFF  1B3,FE9
01042:  INCF   FE9,F
01044:  BTFSC  FD8.2
01046:  INCF   FEA,F
01048:  BRA    1026
0104A:  RETURN 0
*
01092:  TBLRD*+
01094:  MOVF   FF5,F
01096:  BZ    10B0
01098:  MOVFF  FF6,16C
0109C:  MOVFF  FF7,16D
010A0:  MOVFF  FF5,16E
010A4:  BRA    104C
010A6:  MOVFF  16C,FF6
010AA:  MOVFF  16D,FF7
010AE:  BRA    1092
010B0:  RETURN 0
*
013BC:  MOVLB  1
013BE:  MOVF   xB6,W
013C0:  CLRF   01
013C2:  SUBWF  xB5,W
013C4:  BC    13CC
013C6:  MOVFF  1B5,00
013CA:  BRA    13E4
013CC:  CLRF   00
013CE:  MOVLW  08
013D0:  MOVWF  xB7
013D2:  RLCF   xB5,F
013D4:  RLCF   00,F
013D6:  MOVF   xB6,W
013D8:  SUBWF  00,W
013DA:  BTFSC  FD8.0
013DC:  MOVWF  00
013DE:  RLCF   01,F
013E0:  DECFSZ xB7,F
013E2:  BRA    13D2
013E4:  MOVLB  0
013E6:  RETURN 0
013E8:  MOVF   01,W
013EA:  MOVFF  1B3,1B5
013EE:  MOVLW  64
013F0:  MOVLB  1
013F2:  MOVWF  xB6
013F4:  MOVLB  0
013F6:  RCALL  13BC
013F8:  MOVFF  00,1B3
013FC:  MOVF   01,W
013FE:  MOVLW  30
01400:  BNZ   1412
01402:  MOVLB  1
01404:  BTFSS  xB4.1
01406:  BRA    1424
01408:  BTFSC  xB4.3
0140A:  BRA    1424
0140C:  BTFSC  xB4.4
0140E:  MOVLW  20
01410:  BRA    141A
01412:  MOVLB  1
01414:  BCF    xB4.3
01416:  BCF    xB4.4
01418:  BSF    xB4.0
0141A:  ADDWF  01,F
0141C:  MOVF   01,W
0141E:  BTFSS  F9E.4
01420:  BRA    141E
01422:  MOVWF  FAD
01424:  MOVFF  1B3,1B5
01428:  MOVLW  0A
0142A:  MOVWF  xB6
0142C:  MOVLB  0
0142E:  RCALL  13BC
01430:  MOVFF  00,1B3
01434:  MOVF   01,W
01436:  MOVLW  30
01438:  BNZ   144A
0143A:  MOVLB  1
0143C:  BTFSC  xB4.3
0143E:  BRA    1456
01440:  BTFSS  xB4.0
01442:  BRA    1456
01444:  BTFSC  xB4.4
01446:  MOVLW  20
01448:  MOVLB  0
0144A:  ADDWF  01,F
0144C:  MOVF   01,W
0144E:  BTFSS  F9E.4
01450:  BRA    144E
01452:  MOVWF  FAD
01454:  MOVLB  1
01456:  MOVLW  30
01458:  ADDWF  xB3,F
0145A:  MOVF   xB3,W
0145C:  BTFSS  F9E.4
0145E:  BRA    145C
01460:  MOVWF  FAD
01462:  MOVLB  0
01464:  RETURN 0
*
01D62:  BTFSC  FD8.1
01D64:  BRA    1D6E
01D66:  MOVLW  01
01D68:  MOVWF  FEA
01D6A:  MOVLW  86
01D6C:  MOVWF  FE9
01D6E:  CLRF   00
01D70:  CLRF   01
01D72:  CLRF   02
01D74:  CLRF   03
01D76:  MOVLB  1
01D78:  CLRF   x86
01D7A:  CLRF   x87
01D7C:  CLRF   x88
01D7E:  CLRF   x89
01D80:  MOVF   x85,W
01D82:  IORWF  x84,W
01D84:  IORWF  x83,W
01D86:  IORWF  x82,W
01D88:  BZ    1DE2
01D8A:  MOVLW  20
01D8C:  MOVWF  x8A
01D8E:  BCF    FD8.0
01D90:  RLCF   x7E,F
01D92:  RLCF   x7F,F
01D94:  RLCF   x80,F
01D96:  RLCF   x81,F
01D98:  RLCF   x86,F
01D9A:  RLCF   x87,F
01D9C:  RLCF   x88,F
01D9E:  RLCF   x89,F
01DA0:  MOVF   x85,W
01DA2:  SUBWF  x89,W
01DA4:  BNZ   1DB6
01DA6:  MOVF   x84,W
01DA8:  SUBWF  x88,W
01DAA:  BNZ   1DB6
01DAC:  MOVF   x83,W
01DAE:  SUBWF  x87,W
01DB0:  BNZ   1DB6
01DB2:  MOVF   x82,W
01DB4:  SUBWF  x86,W
01DB6:  BNC   1DD6
01DB8:  MOVF   x82,W
01DBA:  SUBWF  x86,F
01DBC:  MOVF   x83,W
01DBE:  BTFSS  FD8.0
01DC0:  INCFSZ x83,W
01DC2:  SUBWF  x87,F
01DC4:  MOVF   x84,W
01DC6:  BTFSS  FD8.0
01DC8:  INCFSZ x84,W
01DCA:  SUBWF  x88,F
01DCC:  MOVF   x85,W
01DCE:  BTFSS  FD8.0
01DD0:  INCFSZ x85,W
01DD2:  SUBWF  x89,F
01DD4:  BSF    FD8.0
01DD6:  RLCF   00,F
01DD8:  RLCF   01,F
01DDA:  RLCF   02,F
01DDC:  RLCF   03,F
01DDE:  DECFSZ x8A,F
01DE0:  BRA    1D8E
01DE2:  MOVFF  186,FEF
01DE6:  MOVFF  187,FEC
01DEA:  MOVFF  188,FEC
01DEE:  MOVFF  189,FEC
01DF2:  MOVLB  0
01DF4:  GOTO   1ECC (RETURN)
01DF8:  MOVLB  1
01DFA:  CLRF   x86
01DFC:  CLRF   x87
01DFE:  MOVLW  01
01E00:  MOVWF  x88
01E02:  CLRF   FDA
01E04:  CLRF   FD9
01E06:  MOVWF  x8B
01E08:  MOVLW  7E
01E0A:  MOVWF  x8A
01E0C:  MOVLW  01
01E0E:  MOVWF  FEA
01E10:  MOVLW  82
01E12:  MOVWF  FE9
01E14:  MOVFF  18B,FE2
01E18:  MOVFF  18A,FE1
01E1C:  MOVFF  188,189
01E20:  BCF    FD8.0
01E22:  MOVF   FE5,W
01E24:  MULWF  FEE
01E26:  MOVF   FF3,W
01E28:  ADDWFC x86,F
01E2A:  MOVF   FF4,W
01E2C:  ADDWFC x87,F
01E2E:  DECFSZ x89,F
01E30:  BRA    1E20
01E32:  MOVFF  186,FDE
01E36:  MOVFF  187,186
01E3A:  CLRF   x87
01E3C:  BTFSC  FD8.0
01E3E:  INCF   x87,F
01E40:  INCF   x8A,F
01E42:  BTFSC  FD8.2
01E44:  INCF   x8B,F
01E46:  INCF   x88,F
01E48:  MOVF   x88,W
01E4A:  SUBLW  05
01E4C:  BNZ   1E0C
01E4E:  MOVLB  0
01E50:  GOTO   1EFC (RETURN)
*
020AE:  TBLRD*+
020B0:  MOVFF  FF6,16F
020B4:  MOVFF  FF7,170
020B8:  MOVFF  FF5,173
020BC:  CALL   0E80
020C0:  MOVFF  16F,FF6
020C4:  MOVFF  170,FF7
020C8:  MOVLB  1
020CA:  DECFSZ x6E,F
020CC:  BRA    20D0
020CE:  BRA    20D4
020D0:  MOVLB  0
020D2:  BRA    20AE
020D4:  MOVLB  0
020D6:  RETURN 0
020D8:  MOVF   FEF,F
020DA:  BZ    20FC
020DC:  MOVFF  FEA,16F
020E0:  MOVFF  FE9,16E
020E4:  MOVFF  FEF,173
020E8:  CALL   0E80
020EC:  MOVFF  16F,FEA
020F0:  MOVFF  16E,FE9
020F4:  INCF   FE9,F
020F6:  BTFSC  FD8.2
020F8:  INCF   FEA,F
020FA:  BRA    20D8
020FC:  RETURN 0
*
02624:  MOVFF  FF2,0D
02628:  BCF    FF2.7
0262A:  ADDWF  FE8,W
0262C:  CLRF   FF7
0262E:  RLCF   FF7,F
02630:  ADDLW  49
02632:  MOVWF  FF6
02634:  MOVLW  26
02636:  ADDWFC FF7,F
02638:  TBLRD*-
0263A:  MOVF   FF5,W
0263C:  MOVWF  FFA
0263E:  TBLRD*
02640:  MOVF   FF5,W
02642:  BTFSC  0D.7
02644:  BSF    FF2.7
02646:  MOVWF  FF9
02648:  DATA EE,24
0264A:  DATA 40,25
0264C:  DATA 92,25
0264E:  DATA E4,25
*
028D8:  MOVFF  FF2,0D
028DC:  BCF    FF2.7
028DE:  ADDWF  FE8,W
028E0:  CLRF   FF7
028E2:  RLCF   FF7,F
028E4:  ADDLW  FD
028E6:  MOVWF  FF6
028E8:  MOVLW  28
028EA:  ADDWFC FF7,F
028EC:  TBLRD*-
028EE:  MOVF   FF5,W
028F0:  MOVWF  FFA
028F2:  TBLRD*
028F4:  MOVF   FF5,W
028F6:  BTFSC  0D.7
028F8:  BSF    FF2.7
028FA:  MOVWF  FF9
028FC:  DATA 9C,26
028FE:  DATA D6,26
02900:  DATA 24,27
02902:  DATA 72,27
02904:  DATA 62,26
02906:  DATA 8E,28
02908:  DATA C0,27
0290A:  DATA 94,28
0290C:  DATA BA,28
*
02C98:  MOVFF  FF2,0D
02C9C:  BCF    FF2.7
02C9E:  ADDWF  FE8,W
02CA0:  CLRF   FF7
02CA2:  RLCF   FF7,F
02CA4:  ADDLW  BD
02CA6:  MOVWF  FF6
02CA8:  MOVLW  2C
02CAA:  ADDWFC FF7,F
02CAC:  TBLRD*-
02CAE:  MOVF   FF5,W
02CB0:  MOVWF  FFA
02CB2:  TBLRD*
02CB4:  MOVF   FF5,W
02CB6:  BTFSC  0D.7
02CB8:  BSF    FF2.7
02CBA:  MOVWF  FF9
02CBC:  DATA 64,2C
02CBE:  DATA 70,2C
02CC0:  DATA 7C,2C
02CC2:  DATA 88,2C
....................  
.................... #list 
....................  
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20M) 
*
00C2E:  MOVLW  01
00C30:  MOVWF  FEA
00C32:  MOVLW  B4
00C34:  MOVWF  FE9
00C36:  MOVF   FEF,W
00C38:  BZ    0C54
00C3A:  MOVLW  06
00C3C:  MOVWF  01
00C3E:  CLRF   00
00C40:  DECFSZ 00,F
00C42:  BRA    0C40
00C44:  DECFSZ 01,F
00C46:  BRA    0C3E
00C48:  MOVLW  7B
00C4A:  MOVWF  00
00C4C:  DECFSZ 00,F
00C4E:  BRA    0C4C
00C50:  DECFSZ FEF,F
00C52:  BRA    0C3A
00C54:  RETURN 0
*
01E54:  MOVLW  03
01E56:  MOVLB  1
01E58:  SUBWF  x7F,F
01E5A:  BNC   1E70
01E5C:  MOVLW  01
01E5E:  MOVWF  FEA
01E60:  MOVLW  7F
01E62:  MOVWF  FE9
01E64:  MOVF   FEF,W
01E66:  BZ    1E70
01E68:  BRA    1E6C
01E6A:  BRA    1E6C
01E6C:  DECFSZ FEF,F
01E6E:  BRA    1E6A
01E70:  MOVLB  0
01E72:  RETURN 0
.................... /* RS232 */ 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
*
0104C:  BCF    F93.0
0104E:  BCF    F8A.0
01050:  MOVLW  08
01052:  MOVWF  01
01054:  BRA    1056
01056:  NOP   
01058:  BSF    01.7
0105A:  BRA    107C
0105C:  BCF    01.7
0105E:  MOVLB  1
01060:  RRCF   x6E,F
01062:  MOVLB  0
01064:  BTFSC  FD8.0
01066:  BSF    F8A.0
01068:  BTFSS  FD8.0
0106A:  BCF    F8A.0
0106C:  BSF    01.6
0106E:  BRA    107C
01070:  BCF    01.6
01072:  DECFSZ 01,F
01074:  BRA    105E
01076:  BRA    1078
01078:  NOP   
0107A:  BSF    F8A.0
0107C:  MOVLW  A7
0107E:  MOVWF  FE9
01080:  DECFSZ FE9,F
01082:  BRA    1080
01084:  BRA    1086
01086:  BTFSC  01.7
01088:  BRA    105C
0108A:  BTFSC  01.6
0108C:  BRA    1070
0108E:  GOTO   10A6 (RETURN)
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... const int16 PIN_OUT[8]={ 
....................                         PIN_E2, 
....................                         PIN_E1, 
....................                         PIN_E0, 
....................                         PIN_A4, 
....................                         PIN_A0, 
....................                         PIN_A1, 
....................                         PIN_A2, 
....................                         PIN_A3 
....................                         }; 
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00D1A:  BSF    F95.4
....................    output_float(LCD_DATA5); 
00D1C:  BSF    F95.5
....................    output_float(LCD_DATA6); 
00D1E:  BSF    F95.6
....................    output_float(LCD_DATA7); 
00D20:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00D22:  BSF    F8C.1
00D24:  BCF    F95.1
....................    delay_cycles(1); 
00D26:  NOP   
....................    lcd_output_enable(1); 
00D28:  BSF    F8C.0
00D2A:  BCF    F95.0
....................    delay_cycles(1); 
00D2C:  NOP   
....................    high = lcd_read_nibble(); 
00D2E:  RCALL  0CC4
00D30:  MOVFF  01,17B
....................        
....................    lcd_output_enable(0); 
00D34:  BCF    F8C.0
00D36:  BCF    F95.0
....................    delay_cycles(1); 
00D38:  NOP   
....................    lcd_output_enable(1); 
00D3A:  BSF    F8C.0
00D3C:  BCF    F95.0
....................    delay_us(1); 
00D3E:  BRA    0D40
00D40:  BRA    0D42
00D42:  NOP   
....................    low = lcd_read_nibble(); 
00D44:  RCALL  0CC4
00D46:  MOVFF  01,17A
....................        
....................    lcd_output_enable(0); 
00D4A:  BCF    F8C.0
00D4C:  BCF    F95.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00D4E:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00D50:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00D52:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00D54:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00D56:  MOVLB  1
00D58:  SWAPF  x7B,W
00D5A:  MOVWF  00
00D5C:  MOVLW  F0
00D5E:  ANDWF  00,F
00D60:  MOVF   00,W
00D62:  IORWF  x7A,W
00D64:  MOVWF  01
00D66:  MOVLB  0
00D68:  GOTO   0D78 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00CC4:  MOVLB  1
00CC6:  CLRF   x7C
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00CC8:  BSF    F95.4
00CCA:  MOVLW  00
00CCC:  BTFSC  F83.4
00CCE:  MOVLW  01
00CD0:  IORWF  x7C,F
....................    n |= input(LCD_DATA5) << 1; 
00CD2:  BSF    F95.5
00CD4:  MOVLW  00
00CD6:  BTFSC  F83.5
00CD8:  MOVLW  01
00CDA:  MOVWF  00
00CDC:  BCF    FD8.0
00CDE:  RLCF   00,F
00CE0:  MOVF   00,W
00CE2:  IORWF  x7C,F
....................    n |= input(LCD_DATA6) << 2; 
00CE4:  BSF    F95.6
00CE6:  MOVLW  00
00CE8:  BTFSC  F83.6
00CEA:  MOVLW  01
00CEC:  MOVWF  00
00CEE:  RLCF   00,F
00CF0:  RLCF   00,F
00CF2:  MOVLW  FC
00CF4:  ANDWF  00,F
00CF6:  MOVF   00,W
00CF8:  IORWF  x7C,F
....................    n |= input(LCD_DATA7) << 3; 
00CFA:  BSF    F95.7
00CFC:  MOVLW  00
00CFE:  BTFSC  F83.7
00D00:  MOVLW  01
00D02:  MOVWF  00
00D04:  RLCF   00,F
00D06:  RLCF   00,F
00D08:  RLCF   00,F
00D0A:  MOVLW  F8
00D0C:  ANDWF  00,F
00D0E:  MOVF   00,W
00D10:  IORWF  x7C,F
....................     
....................    return(n); 
00D12:  MOVFF  17C,01
....................   #else 
00D16:  MOVLB  0
00D18:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00C78:  MOVLB  1
00C7A:  BTFSC  x7B.0
00C7C:  BRA    0C82
00C7E:  BCF    F8C.4
00C80:  BRA    0C84
00C82:  BSF    F8C.4
00C84:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00C86:  BTFSC  x7B.1
00C88:  BRA    0C8E
00C8A:  BCF    F8C.5
00C8C:  BRA    0C90
00C8E:  BSF    F8C.5
00C90:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00C92:  BTFSC  x7B.2
00C94:  BRA    0C9A
00C96:  BCF    F8C.6
00C98:  BRA    0C9C
00C9A:  BSF    F8C.6
00C9C:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00C9E:  BTFSC  x7B.3
00CA0:  BRA    0CA6
00CA2:  BCF    F8C.7
00CA4:  BRA    0CA8
00CA6:  BSF    F8C.7
00CA8:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00CAA:  NOP   
....................    lcd_output_enable(1); 
00CAC:  BSF    F8C.0
00CAE:  BCF    F95.0
....................    delay_us(2); 
00CB0:  MOVLW  02
00CB2:  MOVWF  00
00CB4:  DECFSZ 00,F
00CB6:  BRA    0CB4
00CB8:  BRA    0CBA
00CBA:  NOP   
....................    lcd_output_enable(0); 
00CBC:  BCF    F8C.0
00CBE:  BCF    F95.0
00CC0:  MOVLB  0
00CC2:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00D6C:  BCF    F95.0
....................    lcd_rs_tris(); 
00D6E:  BCF    F95.2
....................    lcd_rw_tris(); 
00D70:  BCF    F95.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00D72:  BCF    F8C.2
00D74:  BCF    F95.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
00D76:  BRA    0D1A
00D78:  MOVFF  01,17A
00D7C:  MOVLB  1
00D7E:  BTFSS  01.7
00D80:  BRA    0D86
00D82:  MOVLB  0
00D84:  BRA    0D76
....................    lcd_output_rs(address); 
00D86:  MOVF   x78,F
00D88:  BNZ   0D8E
00D8A:  BCF    F8C.2
00D8C:  BRA    0D90
00D8E:  BSF    F8C.2
00D90:  BCF    F95.2
....................    delay_cycles(1); 
00D92:  NOP   
....................    lcd_output_rw(0); 
00D94:  BCF    F8C.1
00D96:  BCF    F95.1
....................    delay_cycles(1); 
00D98:  NOP   
....................    lcd_output_enable(0); 
00D9A:  BCF    F8C.0
00D9C:  BCF    F95.0
....................    lcd_send_nibble(n >> 4); 
00D9E:  SWAPF  x79,W
00DA0:  MOVWF  x7A
00DA2:  MOVLW  0F
00DA4:  ANDWF  x7A,F
00DA6:  MOVFF  17A,17B
00DAA:  MOVLB  0
00DAC:  RCALL  0C78
....................    lcd_send_nibble(n & 0xf); 
00DAE:  MOVLB  1
00DB0:  MOVF   x79,W
00DB2:  ANDLW  0F
00DB4:  MOVWF  x7A
00DB6:  MOVWF  x7B
00DB8:  MOVLB  0
00DBA:  RCALL  0C78
00DBC:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00DBE:  MOVLW  28
00DC0:  MOVLB  1
00DC2:  MOVWF  x6B
00DC4:  MOVLW  0C
00DC6:  MOVWF  x6C
00DC8:  MOVLW  01
00DCA:  MOVWF  x6D
00DCC:  MOVLW  06
00DCE:  MOVWF  x6E
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00DD0:  BCF    F8C.0
00DD2:  BCF    F95.0
....................    lcd_output_rs(0); 
00DD4:  BCF    F8C.2
00DD6:  BCF    F95.2
....................    lcd_output_rw(0); 
00DD8:  BCF    F8C.1
00DDA:  BCF    F95.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00DDC:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00DDE:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00DE0:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00DE2:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00DE4:  BCF    F95.0
....................    lcd_rs_tris(); 
00DE6:  BCF    F95.2
....................    lcd_rw_tris(); 
00DE8:  BCF    F95.1
....................  #endif 
....................      
....................    delay_ms(15); 
00DEA:  MOVLW  0F
00DEC:  MOVWF  xB4
00DEE:  MOVLB  0
00DF0:  RCALL  0C2E
....................    for(i=1;i<=3;++i) 
00DF2:  MOVLW  01
00DF4:  MOVLB  1
00DF6:  MOVWF  x6A
00DF8:  MOVF   x6A,W
00DFA:  SUBLW  03
00DFC:  BNC   0E16
....................    { 
....................        lcd_send_nibble(3); 
00DFE:  MOVLW  03
00E00:  MOVWF  x7B
00E02:  MOVLB  0
00E04:  RCALL  0C78
....................        delay_ms(5); 
00E06:  MOVLW  05
00E08:  MOVLB  1
00E0A:  MOVWF  xB4
00E0C:  MOVLB  0
00E0E:  RCALL  0C2E
00E10:  MOVLB  1
00E12:  INCF   x6A,F
00E14:  BRA    0DF8
....................    } 
....................     
....................    lcd_send_nibble(2); 
00E16:  MOVLW  02
00E18:  MOVWF  x7B
00E1A:  MOVLB  0
00E1C:  RCALL  0C78
....................    delay_ms(5); 
00E1E:  MOVLW  05
00E20:  MOVLB  1
00E22:  MOVWF  xB4
00E24:  MOVLB  0
00E26:  RCALL  0C2E
....................    for(i=0;i<=3;++i) 
00E28:  MOVLB  1
00E2A:  CLRF   x6A
00E2C:  MOVF   x6A,W
00E2E:  SUBLW  03
00E30:  BNC   0E54
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00E32:  CLRF   03
00E34:  MOVF   x6A,W
00E36:  ADDLW  6B
00E38:  MOVWF  FE9
00E3A:  MOVLW  01
00E3C:  ADDWFC 03,W
00E3E:  MOVWF  FEA
00E40:  MOVFF  FEF,16F
00E44:  CLRF   x78
00E46:  MOVFF  16F,179
00E4A:  MOVLB  0
00E4C:  RCALL  0D6C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00E4E:  MOVLB  1
00E50:  INCF   x6A,F
00E52:  BRA    0E2C
00E54:  MOVLB  0
00E56:  GOTO   2C20 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00E5A:  MOVLB  1
00E5C:  DECFSZ x75,W
00E5E:  BRA    0E62
00E60:  BRA    0E68
....................       address=LCD_LINE_TWO; 
00E62:  MOVLW  40
00E64:  MOVWF  x76
00E66:  BRA    0E6A
....................    else 
....................       address=0; 
00E68:  CLRF   x76
....................       
....................    address+=x-1; 
00E6A:  MOVLW  01
00E6C:  SUBWF  x74,W
00E6E:  ADDWF  x76,F
....................    lcd_send_byte(0,0x80|address); 
00E70:  MOVF   x76,W
00E72:  IORLW  80
00E74:  MOVWF  x77
00E76:  CLRF   x78
00E78:  MOVWF  x79
00E7A:  MOVLB  0
00E7C:  RCALL  0D6C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00E7E:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00E80:  MOVLB  1
00E82:  MOVF   x73,W
00E84:  XORLW  07
00E86:  MOVLB  0
00E88:  BZ    0E98
00E8A:  XORLW  0B
00E8C:  BZ    0EA6
00E8E:  XORLW  06
00E90:  BZ    0EBE
00E92:  XORLW  02
00E94:  BZ    0ECE
00E96:  BRA    0EDC
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00E98:  MOVLW  01
00E9A:  MOVLB  1
00E9C:  MOVWF  x74
00E9E:  MOVWF  x75
00EA0:  MOVLB  0
00EA2:  RCALL  0E5A
00EA4:  BRA    0EEA
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
00EA6:  MOVLB  1
00EA8:  CLRF   x78
00EAA:  MOVLW  01
00EAC:  MOVWF  x79
00EAE:  MOVLB  0
00EB0:  RCALL  0D6C
....................                      delay_ms(2); 
00EB2:  MOVLW  02
00EB4:  MOVLB  1
00EB6:  MOVWF  xB4
00EB8:  MOVLB  0
00EBA:  RCALL  0C2E
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
00EBC:  BRA    0EEA
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00EBE:  MOVLW  01
00EC0:  MOVLB  1
00EC2:  MOVWF  x74
00EC4:  MOVLW  02
00EC6:  MOVWF  x75
00EC8:  MOVLB  0
00ECA:  RCALL  0E5A
00ECC:  BRA    0EEA
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00ECE:  MOVLB  1
00ED0:  CLRF   x78
00ED2:  MOVLW  10
00ED4:  MOVWF  x79
00ED6:  MOVLB  0
00ED8:  RCALL  0D6C
00EDA:  BRA    0EEA
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
00EDC:  MOVLW  01
00EDE:  MOVLB  1
00EE0:  MOVWF  x78
00EE2:  MOVFF  173,179
00EE6:  MOVLB  0
00EE8:  RCALL  0D6C
....................      #endif 
....................    } 
00EEA:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
01E74:  MOVLB  1
01E76:  CLRF   x75
01E78:  CLRF   x74
01E7A:  CLRF   x77
01E7C:  CLRF   x76
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
01E7E:  MOVF   x71,F
01E80:  BNZ   1E8A
01E82:  MOVF   x70,W
01E84:  SUBLW  13
01E86:  BTFSC  FD8.0
01E88:  BRA    1FB8
01E8A:  MOVF   x71,W
01E8C:  SUBLW  4E
01E8E:  BTFSS  FD8.0
01E90:  BRA    1FB8
01E92:  BNZ   1E9C
01E94:  MOVF   x70,W
01E96:  SUBLW  20
01E98:  BTFSS  FD8.0
01E9A:  BRA    1FB8
....................       tmp=100000; 
01E9C:  CLRF   x7D
01E9E:  MOVLW  01
01EA0:  MOVWF  x7C
01EA2:  MOVLW  86
01EA4:  MOVWF  x7B
01EA6:  MOVLW  A0
01EA8:  MOVWF  x7A
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
01EAA:  BCF    FD8.1
01EAC:  MOVFF  17D,181
01EB0:  MOVFF  17C,180
01EB4:  MOVFF  17B,17F
01EB8:  MOVFF  17A,17E
01EBC:  CLRF   x85
01EBE:  CLRF   x84
01EC0:  MOVFF  171,183
01EC4:  MOVFF  170,182
01EC8:  MOVLB  0
01ECA:  BRA    1D62
01ECC:  MOVFF  03,17D
01ED0:  MOVFF  02,17C
01ED4:  MOVFF  01,17B
01ED8:  MOVFF  00,17A
....................       tmp*=5;    
01EDC:  MOVFF  17D,181
01EE0:  MOVFF  17C,180
01EE4:  MOVFF  17B,17F
01EE8:  MOVFF  17A,17E
01EEC:  MOVLB  1
01EEE:  CLRF   x85
01EF0:  CLRF   x84
01EF2:  CLRF   x83
01EF4:  MOVLW  05
01EF6:  MOVWF  x82
01EF8:  MOVLB  0
01EFA:  BRA    1DF8
01EFC:  MOVFF  03,17D
01F00:  MOVFF  02,17C
01F04:  MOVFF  01,17B
01F08:  MOVFF  00,17A
....................       uS=tmp; 
01F0C:  MOVFF  17B,179
01F10:  MOVFF  17A,178
....................       do{ 
....................          output_high(Speaker);   // Genera la frecuancia deseada 
01F14:  BCF    F93.2
01F16:  BSF    F8A.2
....................          delay_us(uS);           // con los retardos mientras 
01F18:  MOVFF  179,17E
01F1C:  MOVLB  1
01F1E:  INCF   x7E,F
01F20:  DECF   x7E,F
01F22:  BTFSC  FD8.2
01F24:  BRA    1F30
01F26:  SETF   x7F
01F28:  MOVLB  0
01F2A:  RCALL  1E54
01F2C:  MOVLB  1
01F2E:  BRA    1F20
01F30:  MOVFF  178,17F
01F34:  MOVLB  0
01F36:  RCALL  1E54
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
01F38:  MOVLB  1
01F3A:  MOVF   x78,W
01F3C:  ADDWF  x76,F
01F3E:  MOVF   x79,W
01F40:  ADDWFC x77,F
....................          output_low(Speaker);    // en dos partes para repartir el  
01F42:  BCF    F93.2
01F44:  BCF    F8A.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
01F46:  MOVFF  179,17E
01F4A:  INCF   x7E,F
01F4C:  DECF   x7E,F
01F4E:  BTFSC  FD8.2
01F50:  BRA    1F5C
01F52:  SETF   x7F
01F54:  MOVLB  0
01F56:  RCALL  1E54
01F58:  MOVLB  1
01F5A:  BRA    1F4C
01F5C:  MOVFF  178,17F
01F60:  MOVLB  0
01F62:  RCALL  1E54
....................          CiclosL+=(uS);          //  
01F64:  MOVLB  1
01F66:  MOVF   x78,W
01F68:  ADDWF  x76,F
01F6A:  MOVF   x79,W
01F6C:  ADDWFC x77,F
....................          CiclosL+=25;            // Compensador. 
01F6E:  MOVLW  19
01F70:  ADDWF  x76,F
01F72:  MOVLW  00
01F74:  ADDWFC x77,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
01F76:  MOVF   x77,W
01F78:  SUBLW  02
01F7A:  BC    1F9E
01F7C:  XORLW  FF
01F7E:  BNZ   1F86
01F80:  MOVF   x76,W
01F82:  SUBLW  E7
01F84:  BC    1F9E
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
01F86:  MOVLW  E8
01F88:  SUBWF  x76,F
01F8A:  MOVLW  03
01F8C:  SUBWFB x77,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
01F8E:  INCF   x74,F
01F90:  BTFSC  FD8.2
01F92:  INCF   x75,F
....................             CiclosL+=25;         // Compensador. 
01F94:  MOVLW  19
01F96:  ADDWF  x76,F
01F98:  MOVLW  00
01F9A:  ADDWFC x77,F
01F9C:  BRA    1F76
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
01F9E:  MOVF   x75,W
01FA0:  SUBWF  x73,W
01FA2:  BNC   1FB8
01FA4:  BTFSC  FD8.2
01FA6:  BRA    1FAC
01FA8:  MOVLB  0
01FAA:  BRA    1F14
01FAC:  MOVF   x72,W
01FAE:  SUBWF  x74,W
01FB0:  BTFSC  FD8.0
01FB2:  BRA    1FB8
01FB4:  MOVLB  0
01FB6:  BRA    1F14
....................                                          // tiempo indicado. 
....................    } 
01FB8:  MOVLB  0
01FBA:  RETURN 0
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          CMD_WIFI.H: Comandos Ejecutados desde 
....................                               wifi. 
....................  
.................... *******************************************************/ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando  
.................... // ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /********************************************************** 
....................    Funcion Busca la cadena de inicio recepcion de request,  
....................    y retorna el ID de la conexion 
.................... ***********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
009B4:  MOVLW  05
009B6:  MOVLB  1
009B8:  MOVWF  xBF
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
009BA:  DECFSZ 55,W
009BC:  BRA    09E4
....................        
....................       if(buffer!=','){ 
009BE:  MOVF   xBD,W
009C0:  SUBLW  2C
009C2:  BNZ   09C8
009C4:  MOVF   xBE,F
009C6:  BZ    09DE
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
009C8:  CLRF   03
009CA:  MOVF   59,W
009CC:  ADDLW  1C
009CE:  MOVWF  FE9
009D0:  MOVLW  00
009D2:  ADDWFC 03,W
009D4:  MOVWF  FEA
009D6:  MOVFF  1BD,FEF
....................          flag_Pos_Resp_IPD++; 
009DA:  INCF   59,F
....................       }else{ 
009DC:  BRA    09E2
....................          flag_Pos_Resp_IPD       = 0x00; 
009DE:  CLRF   59
....................          flag_Resp_IPD           = 0x00; 
009E0:  CLRF   55
....................       } 
....................    }else{ 
009E2:  BRA    0A16
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
009E4:  CLRF   03
009E6:  MOVF   59,W
009E8:  MOVFF  FF2,1C0
009EC:  BCF    FF2.7
009EE:  MOVLB  0
009F0:  CALL   00C0
009F4:  MOVLB  1
009F6:  BTFSC  xC0.7
009F8:  BSF    FF2.7
009FA:  MOVWF  01
009FC:  SUBWF  xBD,W
009FE:  BNZ   0A14
00A00:  MOVF   xBE,F
00A02:  BNZ   0A14
....................       { 
....................          flag_Pos_Resp_IPD++; 
00A04:  INCF   59,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
00A06:  MOVF   xBF,W
00A08:  SUBWF  59,W
00A0A:  BNZ   0A12
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
00A0C:  MOVLW  01
00A0E:  MOVWF  55
....................             flag_Pos_Resp_IPD = 0; 
00A10:  CLRF   59
....................          } 
....................       }else{ 
00A12:  BRA    0A16
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
00A14:  CLRF   59
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00A16:  MOVLB  0
00A18:  GOTO   0B9E (RETURN)
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
....................    Busca la cadena de inicio comando, y retorna el  
....................    Comando enviado, Activa la bandera de recepcion  
....................    de datos 
.................... *********************************************************/ 
.................... void ESP8266_Get_CMD(char buffer[]){ 
00A1C:  MOVLW  04
00A1E:  MOVLB  1
00A20:  MOVWF  xBF
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
00A22:  DECFSZ 54,W
00A24:  BRA    0A50
....................     
....................       if(buffer!=','){ 
00A26:  MOVF   xBD,W
00A28:  SUBLW  2C
00A2A:  BNZ   0A30
00A2C:  MOVF   xBE,F
00A2E:  BZ    0A46
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
00A30:  CLRF   03
00A32:  MOVF   58,W
00A34:  ADDLW  1E
00A36:  MOVWF  FE9
00A38:  MOVLW  00
00A3A:  ADDWFC 03,W
00A3C:  MOVWF  FEA
00A3E:  MOVFF  1BD,FEF
....................          flag_Pos_Resp_CMD++; 
00A42:  INCF   58,F
....................       }else{         
00A44:  BRA    0A4E
....................          flag_Pos_Resp_CMD = 0x00; 
00A46:  CLRF   58
....................          flag_Resp_CMD     = 0x00; 
00A48:  CLRF   54
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
00A4A:  MOVLW  01
00A4C:  MOVWF  56
....................       } 
....................        
....................    }else{ 
00A4E:  BRA    0A82
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
00A50:  CLRF   03
00A52:  MOVF   58,W
00A54:  MOVFF  FF2,1C0
00A58:  BCF    FF2.7
00A5A:  MOVLB  0
00A5C:  CALL   00D6
00A60:  MOVLB  1
00A62:  BTFSC  xC0.7
00A64:  BSF    FF2.7
00A66:  MOVWF  01
00A68:  SUBWF  xBD,W
00A6A:  BNZ   0A80
00A6C:  MOVF   xBE,F
00A6E:  BNZ   0A80
....................       { 
....................          flag_Pos_Resp_CMD++; 
00A70:  INCF   58,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
00A72:  MOVF   xBF,W
00A74:  SUBWF  58,W
00A76:  BNZ   0A7E
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
00A78:  MOVLW  01
00A7A:  MOVWF  54
....................             flag_Pos_Resp_CMD = 0; 
00A7C:  CLRF   58
....................          } 
....................       }else{ 
00A7E:  BRA    0A82
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
00A80:  CLRF   58
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00A82:  MOVLB  0
00A84:  GOTO   0BAA (RETURN)
.................... } 
....................  
.................... /*********************************************************** 
....................    Verifica si la bandera de recepcion de datos esta 
....................    activa y almacena los datos entrantes en el arreglo 
....................    DATA_COMMAND, Finaliza la captura de caracteres cuando 
....................    encuentra el caracter ":". 
.................... ************************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
00A88:  DECFSZ 56,W
00A8A:  BRA    0ACE
....................       if(buffer!=':'){ 
00A8C:  MOVLB  1
00A8E:  MOVF   xBD,W
00A90:  SUBLW  3A
00A92:  BNZ   0A98
00A94:  MOVF   xBE,F
00A96:  BZ    0AC6
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
00A98:  CLRF   03
00A9A:  MOVF   5A,W
00A9C:  ADDLW  20
00A9E:  MOVWF  FE9
00AA0:  MOVLW  00
00AA2:  ADDWFC 03,W
00AA4:  MOVWF  FEA
00AA6:  MOVFF  1BD,FEF
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
00AAA:  CLRF   53
00AAC:  MOVFF  5A,52
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
00AB0:  MOVF   5A,F
00AB2:  BNZ   0AC2
00AB4:  MOVF   xBD,W
00AB6:  SUBLW  2C
00AB8:  BNZ   0AC2
00ABA:  MOVF   xBE,F
00ABC:  BNZ   0AC2
....................             flag_Pos_Resp_Data=0; 
00ABE:  CLRF   5A
....................          }else{ 
00AC0:  BRA    0AC4
....................             flag_Pos_Resp_Data++; 
00AC2:  INCF   5A,F
....................          } 
....................           
....................       }else{ 
00AC4:  BRA    0ACE
....................          flag_Pos_Resp_Data      = 0x00; 
00AC6:  CLRF   5A
....................          flag_Resp_StartGetData  = 0x00; 
00AC8:  CLRF   56
....................          flag_Resp_Ready         = 1; 
00ACA:  MOVLW  01
00ACC:  MOVWF  57
00ACE:  MOVLB  0
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
00AD0:  GOTO   0BB6 (RETURN)
.................... } // Fin Funcion ESP8266_Get_Data 
....................  
.................... /***************************************************** 
....................    Verifica si se ha recibido algun comando enviado 
....................    por WiFi y lo ejecuta.  
.................... *****************************************************/ 
.................... int run_command_wifi(void){ 
*
01466:  MOVLB  1
01468:  CLRF   x71
0146A:  CLRF   x72
0146C:  CLRF   x73
0146E:  CLRF   x74
01470:  MOVLW  0C
01472:  MOVWF  x75
....................    int8 reset = 0, optSelected  = 0,counter = 0, idxRSTNC = 0,lenResponse = 12; 
....................    char response[57] = "{\"cmd\":\"ok\"}"; 
01474:  MOVLW  7B
01476:  MOVWF  x76
01478:  MOVLW  22
0147A:  MOVWF  x77
0147C:  MOVLW  63
0147E:  MOVWF  x78
01480:  MOVLW  6D
01482:  MOVWF  x79
01484:  MOVLW  64
01486:  MOVWF  x7A
01488:  MOVLW  22
0148A:  MOVWF  x7B
0148C:  MOVLW  3A
0148E:  MOVWF  x7C
01490:  MOVLW  22
01492:  MOVWF  x7D
01494:  MOVLW  6F
01496:  MOVWF  x7E
01498:  MOVLW  6B
0149A:  MOVWF  x7F
0149C:  MOVLW  22
0149E:  MOVWF  x80
014A0:  MOVLW  7D
014A2:  MOVWF  x81
014A4:  CLRF   x82
....................     
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
014A6:  DECFSZ 57,W
014A8:  GOTO   1D5A
....................     
....................       /***************************** 
....................       *** Reinicia el Dispositivo ** 
....................       *** CMD:OP,[0|1][0-7]:      ** 
....................       *****************************/ 
....................       if(COMMAND[0]=='R' && 
....................          COMMAND[1]=='S') 
014AC:  MOVF   1E,W
014AE:  SUBLW  52
014B0:  BNZ   1568
014B2:  MOVF   1F,W
014B4:  SUBLW  53
014B6:  BNZ   1568
....................       { 
....................          // Responde la solicitud 
....................          delay_ms(30); 
014B8:  MOVLW  1E
014BA:  MOVWF  xB4
014BC:  MOVLB  0
014BE:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
014C2:  MOVLW  5E
014C4:  MOVWF  FF6
014C6:  MOVLW  01
014C8:  MOVWF  FF7
014CA:  MOVLW  0B
014CC:  MOVLB  1
014CE:  MOVWF  xB3
014D0:  MOVLB  0
014D2:  RCALL  0F0C
014D4:  MOVF   1C,W
014D6:  BTFSS  F9E.4
014D8:  BRA    14D6
014DA:  MOVWF  FAD
014DC:  MOVLW  2C
014DE:  BTFSS  F9E.4
014E0:  BRA    14DE
014E2:  MOVWF  FAD
014E4:  MOVFF  175,1B3
014E8:  MOVLW  1B
014EA:  MOVLB  1
014EC:  MOVWF  xB4
014EE:  MOVLB  0
014F0:  RCALL  13E8
014F2:  MOVLW  0D
014F4:  BTFSS  F9E.4
014F6:  BRA    14F4
014F8:  MOVWF  FAD
014FA:  MOVLW  0A
014FC:  BTFSS  F9E.4
014FE:  BRA    14FC
01500:  MOVWF  FAD
....................          delay_ms(60); 
01502:  MOVLW  3C
01504:  MOVLB  1
01506:  MOVWF  xB4
01508:  MOVLB  0
0150A:  CALL   0C2E
....................          fprintf(ESP8266, "%s",response); 
0150E:  MOVLW  01
01510:  MOVWF  FEA
01512:  MOVLW  76
01514:  MOVWF  FE9
01516:  RCALL  1026
....................          delay_ms(120); 
01518:  MOVLW  78
0151A:  MOVLB  1
0151C:  MOVWF  xB4
0151E:  MOVLB  0
01520:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01524:  MOVLW  72
01526:  MOVWF  FF6
01528:  MOVLW  01
0152A:  MOVWF  FF7
0152C:  MOVLW  0C
0152E:  MOVLB  1
01530:  MOVWF  xB3
01532:  MOVLB  0
01534:  RCALL  0F0C
01536:  MOVF   1C,W
01538:  BTFSS  F9E.4
0153A:  BRA    1538
0153C:  MOVWF  FAD
0153E:  MOVLW  0D
01540:  BTFSS  F9E.4
01542:  BRA    1540
01544:  MOVWF  FAD
01546:  MOVLW  0A
01548:  BTFSS  F9E.4
0154A:  BRA    1548
0154C:  MOVWF  FAD
....................          delay_ms(500); 
0154E:  MOVLW  02
01550:  MOVLB  1
01552:  MOVWF  xB3
01554:  MOVLW  FA
01556:  MOVWF  xB4
01558:  MOVLB  0
0155A:  CALL   0C2E
0155E:  MOVLB  1
01560:  DECFSZ xB3,F
01562:  BRA    1554
....................           
....................          reset = 1;          
01564:  MOVLW  01
01566:  MOVWF  x71
....................       } // Fin comando RS 
....................        
....................       /************************** 
....................       *** Activa o desactiva   ** 
....................       *** los puertos          ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
01568:  MOVF   1E,W
0156A:  SUBLW  4F
0156C:  BNZ   162A
0156E:  MOVF   1F,W
01570:  SUBLW  50
01572:  BNZ   162A
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
01574:  MOVLW  30
01576:  SUBWF  21,W
01578:  MOVWF  x72
....................           
....................          switch(DATA_COMMAND[0]){ 
0157A:  MOVF   20,W
0157C:  XORLW  30
0157E:  MOVLB  0
01580:  BZ    1588
01582:  XORLW  01
01584:  BZ    15D8
01586:  BRA    1628
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
01588:  BCF    FD8.0
0158A:  MOVLB  1
0158C:  RLCF   x72,W
0158E:  CLRF   03
01590:  MOVFF  FF2,1B3
01594:  BCF    FF2.7
01596:  MOVLB  0
01598:  CALL   0096
0159C:  TBLRD*+
0159E:  MOVFF  FF5,03
015A2:  MOVLB  1
015A4:  BTFSC  xB3.7
015A6:  BSF    FF2.7
015A8:  MOVWF  xB3
015AA:  MOVFF  03,1B4
015AE:  MOVWF  xB5
015B0:  CLRF   xB6
015B2:  MOVLW  0F
015B4:  MOVWF  xB8
015B6:  MOVLW  89
015B8:  MOVWF  xB7
015BA:  MOVLB  0
015BC:  CALL   0BEC
015C0:  MOVFF  1B3,1B5
015C4:  MOVLB  1
015C6:  CLRF   xB6
015C8:  MOVLW  0F
015CA:  MOVWF  xB8
015CC:  MOVLW  92
015CE:  MOVWF  xB7
015D0:  MOVLB  0
015D2:  CALL   0BEC
....................                break; 
015D6:  BRA    1628
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
015D8:  BCF    FD8.0
015DA:  MOVLB  1
015DC:  RLCF   x72,W
015DE:  CLRF   03
015E0:  MOVFF  FF2,1B3
015E4:  BCF    FF2.7
015E6:  MOVLB  0
015E8:  CALL   0096
015EC:  TBLRD*+
015EE:  MOVFF  FF5,03
015F2:  MOVLB  1
015F4:  BTFSC  xB3.7
015F6:  BSF    FF2.7
015F8:  MOVWF  xB3
015FA:  MOVFF  03,1B4
015FE:  MOVWF  xB5
01600:  MOVLW  01
01602:  MOVWF  xB6
01604:  MOVLW  0F
01606:  MOVWF  xB8
01608:  MOVLW  89
0160A:  MOVWF  xB7
0160C:  MOVLB  0
0160E:  CALL   0BEC
01612:  MOVFF  1B3,1B5
01616:  MOVLB  1
01618:  CLRF   xB6
0161A:  MOVLW  0F
0161C:  MOVWF  xB8
0161E:  MOVLW  92
01620:  MOVWF  xB7
01622:  MOVLB  0
01624:  CALL   0BEC
....................                break; 
01628:  MOVLB  1
....................          } 
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
0162A:  MOVF   1E,W
0162C:  SUBLW  4E
0162E:  BTFSS  FD8.2
01630:  BRA    183A
01632:  MOVF   1F,W
01634:  SUBLW  43
01636:  BTFSS  FD8.2
01638:  BRA    183A
....................       { 
....................          // Borra la eeprom para almacenar las nuevas credenciales 
....................          // Desde la posicion 0x01 hasta 0x027 
....................          for(idxRSTNC=1;idxRSTNC<=27;idxRSTNC++){ 
0163A:  MOVLW  01
0163C:  MOVWF  x74
0163E:  MOVF   x74,W
01640:  SUBLW  1B
01642:  BNC   1680
....................             write_eeprom(idxRSTNC,0xFF); 
01644:  MOVF   FF2,W
01646:  MOVWF  00
01648:  BCF    FF2.7
0164A:  CLRF   FAA
0164C:  MOVFF  174,FA9
01650:  SETF   FA8
01652:  BCF    FA6.6
01654:  BCF    FA6.7
01656:  BSF    FA6.2
01658:  MOVLB  F
0165A:  MOVLW  55
0165C:  MOVWF  FA7
0165E:  MOVLW  AA
01660:  MOVWF  FA7
01662:  BSF    FA6.1
01664:  BTFSC  FA6.1
01666:  BRA    1664
01668:  BCF    FA6.2
0166A:  MOVF   00,W
0166C:  IORWF  FF2,F
....................             delay_ms(10); 
0166E:  MOVLW  0A
01670:  MOVLB  1
01672:  MOVWF  xB4
01674:  MOVLB  0
01676:  CALL   0C2E
0167A:  MOVLB  1
0167C:  INCF   x74,F
0167E:  BRA    163E
....................          } 
....................           
....................          // Guarda las nuevas credenciales 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
01680:  CLRF   xAF
01682:  MOVF   53,F
01684:  BNZ   168C
01686:  MOVF   xAF,W
01688:  SUBWF  52,W
0168A:  BNC   16E2
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
0168C:  MOVLW  01
0168E:  ADDWF  xAF,W
01690:  MOVWF  xB3
01692:  CLRF   03
01694:  MOVF   xAF,W
01696:  ADDLW  20
01698:  MOVWF  FE9
0169A:  MOVLW  00
0169C:  ADDWFC 03,W
0169E:  MOVWF  FEA
016A0:  MOVFF  FEF,1B4
016A4:  MOVF   FF2,W
016A6:  MOVWF  00
016A8:  BCF    FF2.7
016AA:  CLRF   FAA
016AC:  MOVFF  1B3,FA9
016B0:  MOVFF  1B4,FA8
016B4:  BCF    FA6.6
016B6:  BCF    FA6.7
016B8:  BSF    FA6.2
016BA:  MOVLB  F
016BC:  MOVLW  55
016BE:  MOVWF  FA7
016C0:  MOVLW  AA
016C2:  MOVWF  FA7
016C4:  BSF    FA6.1
016C6:  BTFSC  FA6.1
016C8:  BRA    16C6
016CA:  BCF    FA6.2
016CC:  MOVF   00,W
016CE:  IORWF  FF2,F
....................             delay_ms(10); 
016D0:  MOVLW  0A
016D2:  MOVLB  1
016D4:  MOVWF  xB4
016D6:  MOVLB  0
016D8:  CALL   0C2E
016DC:  MOVLB  1
016DE:  INCF   xAF,F
016E0:  BRA    1682
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
016E2:  MOVLW  01
016E4:  ADDWF  xAF,W
016E6:  MOVWF  xB3
016E8:  MOVF   FF2,W
016EA:  MOVWF  00
016EC:  BCF    FF2.7
016EE:  CLRF   FAA
016F0:  MOVFF  1B3,FA9
016F4:  MOVLW  0D
016F6:  MOVWF  FA8
016F8:  BCF    FA6.6
016FA:  BCF    FA6.7
016FC:  BSF    FA6.2
016FE:  MOVLB  F
01700:  MOVLW  55
01702:  MOVWF  FA7
01704:  MOVLW  AA
01706:  MOVWF  FA7
01708:  BSF    FA6.1
0170A:  BTFSC  FA6.1
0170C:  BRA    170A
0170E:  BCF    FA6.2
01710:  MOVF   00,W
01712:  IORWF  FF2,F
....................          delay_ms(10); 
01714:  MOVLW  0A
01716:  MOVLB  1
01718:  MOVWF  xB4
0171A:  MOVLB  0
0171C:  CALL   0C2E
....................          write_eeprom(idxNC+2,0x0A); 
01720:  MOVLW  02
01722:  MOVLB  1
01724:  ADDWF  xAF,W
01726:  MOVWF  xB3
01728:  MOVF   FF2,W
0172A:  MOVWF  00
0172C:  BCF    FF2.7
0172E:  CLRF   FAA
01730:  MOVFF  1B3,FA9
01734:  MOVLW  0A
01736:  MOVWF  FA8
01738:  BCF    FA6.6
0173A:  BCF    FA6.7
0173C:  BSF    FA6.2
0173E:  MOVLB  F
01740:  MOVLW  55
01742:  MOVWF  FA7
01744:  MOVLW  AA
01746:  MOVWF  FA7
01748:  BSF    FA6.1
0174A:  BTFSC  FA6.1
0174C:  BRA    174A
0174E:  BCF    FA6.2
01750:  MOVF   00,W
01752:  IORWF  FF2,F
....................          delay_ms(10); 
01754:  MOVLW  0A
01756:  MOVLB  1
01758:  MOVWF  xB4
0175A:  MOVLB  0
0175C:  CALL   0C2E
....................  
....................          // Responde la solicitud 
....................          delay_ms(30); 
01760:  MOVLW  1E
01762:  MOVLB  1
01764:  MOVWF  xB4
01766:  MOVLB  0
01768:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
0176C:  MOVLW  84
0176E:  MOVWF  FF6
01770:  MOVLW  01
01772:  MOVWF  FF7
01774:  MOVLW  0B
01776:  MOVLB  1
01778:  MOVWF  xB3
0177A:  MOVLB  0
0177C:  CALL   0F0C
01780:  MOVF   1C,W
01782:  BTFSS  F9E.4
01784:  BRA    1782
01786:  MOVWF  FAD
01788:  MOVLW  2C
0178A:  BTFSS  F9E.4
0178C:  BRA    178A
0178E:  MOVWF  FAD
01790:  MOVFF  175,1B3
01794:  MOVLW  1B
01796:  MOVLB  1
01798:  MOVWF  xB4
0179A:  MOVLB  0
0179C:  RCALL  13E8
0179E:  MOVLW  0D
017A0:  BTFSS  F9E.4
017A2:  BRA    17A0
017A4:  MOVWF  FAD
017A6:  MOVLW  0A
017A8:  BTFSS  F9E.4
017AA:  BRA    17A8
017AC:  MOVWF  FAD
....................          delay_ms(60); 
017AE:  MOVLW  3C
017B0:  MOVLB  1
017B2:  MOVWF  xB4
017B4:  MOVLB  0
017B6:  CALL   0C2E
....................          fprintf(ESP8266, "%s",response); 
017BA:  MOVLW  01
017BC:  MOVWF  FEA
017BE:  MOVLW  76
017C0:  MOVWF  FE9
017C2:  RCALL  1026
....................          delay_ms(120); 
017C4:  MOVLW  78
017C6:  MOVLB  1
017C8:  MOVWF  xB4
017CA:  MOVLB  0
017CC:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
017D0:  MOVLW  98
017D2:  MOVWF  FF6
017D4:  MOVLW  01
017D6:  MOVWF  FF7
017D8:  MOVLW  0C
017DA:  MOVLB  1
017DC:  MOVWF  xB3
017DE:  MOVLB  0
017E0:  CALL   0F0C
017E4:  MOVF   1C,W
017E6:  BTFSS  F9E.4
017E8:  BRA    17E6
017EA:  MOVWF  FAD
017EC:  MOVLW  0D
017EE:  BTFSS  F9E.4
017F0:  BRA    17EE
017F2:  MOVWF  FAD
017F4:  MOVLW  0A
017F6:  BTFSS  F9E.4
017F8:  BRA    17F6
017FA:  MOVWF  FAD
....................          delay_ms(500); 
017FC:  MOVLW  02
017FE:  MOVLB  1
01800:  MOVWF  xB3
01802:  MOVLW  FA
01804:  MOVWF  xB4
01806:  MOVLB  0
01808:  CALL   0C2E
0180C:  MOVLB  1
0180E:  DECFSZ xB3,F
01810:  BRA    1802
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
01812:  MOVLW  AA
01814:  MOVWF  FF6
01816:  MOVLW  01
01818:  MOVWF  FF7
0181A:  MOVLB  0
0181C:  CALL   0C56
....................          delay_ms(1000); 
01820:  MOVLW  04
01822:  MOVLB  1
01824:  MOVWF  xB3
01826:  MOVLW  FA
01828:  MOVWF  xB4
0182A:  MOVLB  0
0182C:  CALL   0C2E
01830:  MOVLB  1
01832:  DECFSZ xB3,F
01834:  BRA    1826
....................           
....................          reset = 1; 
01836:  MOVLW  01
01838:  MOVWF  x71
....................       } // Fin comando NC 
....................        
....................       /********************************** 
....................       *** Cambia el SSID y Key del AP  ** 
....................       *** CMD:AP,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='A' && 
....................          COMMAND[1]=='P') 
0183A:  MOVF   1E,W
0183C:  SUBLW  41
0183E:  BTFSS  FD8.2
01840:  BRA    1946
01842:  MOVF   1F,W
01844:  SUBLW  50
01846:  BTFSS  FD8.2
01848:  BRA    1946
....................       { 
....................          // Responde la solicitud 
....................          delay_ms(20); 
0184A:  MOVLW  14
0184C:  MOVWF  xB4
0184E:  MOVLB  0
01850:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01854:  MOVLW  B6
01856:  MOVWF  FF6
01858:  MOVLW  01
0185A:  MOVWF  FF7
0185C:  MOVLW  0B
0185E:  MOVLB  1
01860:  MOVWF  xB3
01862:  MOVLB  0
01864:  CALL   0F0C
01868:  MOVF   1C,W
0186A:  BTFSS  F9E.4
0186C:  BRA    186A
0186E:  MOVWF  FAD
01870:  MOVLW  2C
01872:  BTFSS  F9E.4
01874:  BRA    1872
01876:  MOVWF  FAD
01878:  MOVFF  175,1B3
0187C:  MOVLW  1B
0187E:  MOVLB  1
01880:  MOVWF  xB4
01882:  MOVLB  0
01884:  RCALL  13E8
01886:  MOVLW  0D
01888:  BTFSS  F9E.4
0188A:  BRA    1888
0188C:  MOVWF  FAD
0188E:  MOVLW  0A
01890:  BTFSS  F9E.4
01892:  BRA    1890
01894:  MOVWF  FAD
....................          delay_ms(50); 
01896:  MOVLW  32
01898:  MOVLB  1
0189A:  MOVWF  xB4
0189C:  MOVLB  0
0189E:  CALL   0C2E
....................          fprintf(ESP8266, "%s",response); 
018A2:  MOVLW  01
018A4:  MOVWF  FEA
018A6:  MOVLW  76
018A8:  MOVWF  FE9
018AA:  CALL   1026
....................          delay_ms(100); 
018AE:  MOVLW  64
018B0:  MOVLB  1
018B2:  MOVWF  xB4
018B4:  MOVLB  0
018B6:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
018BA:  MOVLW  CA
018BC:  MOVWF  FF6
018BE:  MOVLW  01
018C0:  MOVWF  FF7
018C2:  MOVLW  0C
018C4:  MOVLB  1
018C6:  MOVWF  xB3
018C8:  MOVLB  0
018CA:  CALL   0F0C
018CE:  MOVF   1C,W
018D0:  BTFSS  F9E.4
018D2:  BRA    18D0
018D4:  MOVWF  FAD
018D6:  MOVLW  0D
018D8:  BTFSS  F9E.4
018DA:  BRA    18D8
018DC:  MOVWF  FAD
018DE:  MOVLW  0A
018E0:  BTFSS  F9E.4
018E2:  BRA    18E0
018E4:  MOVWF  FAD
....................          delay_ms(500); 
018E6:  MOVLW  02
018E8:  MOVLB  1
018EA:  MOVWF  xB3
018EC:  MOVLW  FA
018EE:  MOVWF  xB4
018F0:  MOVLB  0
018F2:  CALL   0C2E
018F6:  MOVLB  1
018F8:  DECFSZ xB3,F
018FA:  BRA    18EC
....................           
....................          fprintf(ESP8266, "AT+CWSAP_DEF=%s,1,4\r\n",DATA_COMMAND); 
018FC:  MOVLW  DC
018FE:  MOVWF  FF6
01900:  MOVLW  01
01902:  MOVWF  FF7
01904:  MOVLW  0D
01906:  MOVWF  xB3
01908:  MOVLB  0
0190A:  CALL   0F0C
0190E:  CLRF   FEA
01910:  MOVLW  20
01912:  MOVWF  FE9
01914:  CALL   1026
01918:  MOVLW  EB
0191A:  MOVWF  FF6
0191C:  MOVLW  01
0191E:  MOVWF  FF7
01920:  MOVLW  06
01922:  MOVLB  1
01924:  MOVWF  xB3
01926:  MOVLB  0
01928:  CALL   0F0C
....................          delay_ms(1000); 
0192C:  MOVLW  04
0192E:  MOVLB  1
01930:  MOVWF  xB3
01932:  MOVLW  FA
01934:  MOVWF  xB4
01936:  MOVLB  0
01938:  CALL   0C2E
0193C:  MOVLB  1
0193E:  DECFSZ xB3,F
01940:  BRA    1932
....................          reset = 1; 
01942:  MOVLW  01
01944:  MOVWF  x71
....................       } // Fin comando AP 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
01946:  MOVF   1E,W
01948:  SUBLW  4E
0194A:  BTFSS  FD8.2
0194C:  BRA    1A3A
0194E:  MOVF   1F,W
01950:  SUBLW  4D
01952:  BNZ   1A3A
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
01954:  MOVF   FF2,W
01956:  MOVWF  00
01958:  BCF    FF2.7
0195A:  CLRF   FAA
0195C:  CLRF   FA9
0195E:  MOVFF  20,FA8
01962:  BCF    FA6.6
01964:  BCF    FA6.7
01966:  BSF    FA6.2
01968:  MOVLB  F
0196A:  MOVLW  55
0196C:  MOVWF  FA7
0196E:  MOVLW  AA
01970:  MOVWF  FA7
01972:  BSF    FA6.1
01974:  BTFSC  FA6.1
01976:  BRA    1974
01978:  BCF    FA6.2
0197A:  MOVF   00,W
0197C:  IORWF  FF2,F
....................          delay_ms(10); 
0197E:  MOVLW  0A
01980:  MOVLB  1
01982:  MOVWF  xB4
01984:  MOVLB  0
01986:  CALL   0C2E
....................           
....................          // Responde la solicitud 
....................          delay_ms(20); 
0198A:  MOVLW  14
0198C:  MOVLB  1
0198E:  MOVWF  xB4
01990:  MOVLB  0
01992:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01996:  MOVLW  F2
01998:  MOVWF  FF6
0199A:  MOVLW  01
0199C:  MOVWF  FF7
0199E:  MOVLW  0B
019A0:  MOVLB  1
019A2:  MOVWF  xB3
019A4:  MOVLB  0
019A6:  CALL   0F0C
019AA:  MOVF   1C,W
019AC:  BTFSS  F9E.4
019AE:  BRA    19AC
019B0:  MOVWF  FAD
019B2:  MOVLW  2C
019B4:  BTFSS  F9E.4
019B6:  BRA    19B4
019B8:  MOVWF  FAD
019BA:  MOVFF  175,1B3
019BE:  MOVLW  1B
019C0:  MOVLB  1
019C2:  MOVWF  xB4
019C4:  MOVLB  0
019C6:  RCALL  13E8
019C8:  MOVLW  0D
019CA:  BTFSS  F9E.4
019CC:  BRA    19CA
019CE:  MOVWF  FAD
019D0:  MOVLW  0A
019D2:  BTFSS  F9E.4
019D4:  BRA    19D2
019D6:  MOVWF  FAD
....................          delay_ms(50); 
019D8:  MOVLW  32
019DA:  MOVLB  1
019DC:  MOVWF  xB4
019DE:  MOVLB  0
019E0:  CALL   0C2E
....................          fprintf(ESP8266, "%s",response); 
019E4:  MOVLW  01
019E6:  MOVWF  FEA
019E8:  MOVLW  76
019EA:  MOVWF  FE9
019EC:  CALL   1026
....................          delay_ms(100); 
019F0:  MOVLW  64
019F2:  MOVLB  1
019F4:  MOVWF  xB4
019F6:  MOVLB  0
019F8:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
019FC:  MOVLW  06
019FE:  MOVWF  FF6
01A00:  MOVLW  02
01A02:  MOVWF  FF7
01A04:  MOVLW  0C
01A06:  MOVLB  1
01A08:  MOVWF  xB3
01A0A:  MOVLB  0
01A0C:  CALL   0F0C
01A10:  MOVF   1C,W
01A12:  BTFSS  F9E.4
01A14:  BRA    1A12
01A16:  MOVWF  FAD
01A18:  MOVLW  0D
01A1A:  BTFSS  F9E.4
01A1C:  BRA    1A1A
01A1E:  MOVWF  FAD
01A20:  MOVLW  0A
01A22:  BTFSS  F9E.4
01A24:  BRA    1A22
01A26:  MOVWF  FAD
....................          delay_ms(100); 
01A28:  MOVLW  64
01A2A:  MOVLB  1
01A2C:  MOVWF  xB4
01A2E:  MOVLB  0
01A30:  CALL   0C2E
....................          reset = 1; 
01A34:  MOVLW  01
01A36:  MOVLB  1
01A38:  MOVWF  x71
....................       } // Fin comando NM 
....................        
....................       /********************************* 
....................       *** Optiene el estado de Puerto ** 
....................       *** CMD:OS,0:                   ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='S') 
01A3A:  MOVF   1E,W
01A3C:  SUBLW  4F
01A3E:  BTFSS  FD8.2
01A40:  BRA    1B6E
01A42:  MOVF   1F,W
01A44:  SUBLW  53
01A46:  BTFSS  FD8.2
01A48:  BRA    1B6E
....................       { 
....................          //char  response[57]; 
....................           
....................          response[0]  = '{'; 
01A4A:  MOVLW  7B
01A4C:  MOVWF  x76
....................          response[1]  = '"'; 
01A4E:  MOVLW  22
01A50:  MOVWF  x77
....................          response[2]  = '0'; 
01A52:  MOVLW  30
01A54:  MOVWF  x78
....................          response[3]  = '"'; 
01A56:  MOVLW  22
01A58:  MOVWF  x79
....................          response[4]  = ':'; 
01A5A:  MOVLW  3A
01A5C:  MOVWF  x7A
....................          response[5]  = input_state(PIN_OUT[0])+ 48; 
01A5E:  MOVLW  00
01A60:  BTFSC  F84.2
01A62:  MOVLW  01
01A64:  ADDLW  30
01A66:  MOVWF  x7B
....................          response[6]  = ','; 
01A68:  MOVLW  2C
01A6A:  MOVWF  x7C
....................           
....................          response[7]   = '"'; 
01A6C:  MOVLW  22
01A6E:  MOVWF  x7D
....................          response[8]   = '1'; 
01A70:  MOVLW  31
01A72:  MOVWF  x7E
....................          response[9]   = '"'; 
01A74:  MOVLW  22
01A76:  MOVWF  x7F
....................          response[10]  = ':'; 
01A78:  MOVLW  3A
01A7A:  MOVWF  x80
....................          response[11]  = input_state(PIN_OUT[1])+ 48; 
01A7C:  MOVLW  00
01A7E:  BTFSC  F84.1
01A80:  MOVLW  01
01A82:  ADDLW  30
01A84:  MOVWF  x81
....................          response[12]  = ','; 
01A86:  MOVLW  2C
01A88:  MOVWF  x82
....................           
....................          response[13]  = '"'; 
01A8A:  MOVLW  22
01A8C:  MOVWF  x83
....................          response[14]  = '2'; 
01A8E:  MOVLW  32
01A90:  MOVWF  x84
....................          response[15]  = '"'; 
01A92:  MOVLW  22
01A94:  MOVWF  x85
....................          response[16]  = ':'; 
01A96:  MOVLW  3A
01A98:  MOVWF  x86
....................          response[17]  = input_state(PIN_OUT[2])+ 48; 
01A9A:  MOVLW  00
01A9C:  BTFSC  F84.0
01A9E:  MOVLW  01
01AA0:  ADDLW  30
01AA2:  MOVWF  x87
....................          response[18]  = ','; 
01AA4:  MOVLW  2C
01AA6:  MOVWF  x88
....................           
....................          response[19]  = '"'; 
01AA8:  MOVLW  22
01AAA:  MOVWF  x89
....................          response[20]  = '3'; 
01AAC:  MOVLW  33
01AAE:  MOVWF  x8A
....................          response[21]  = '"'; 
01AB0:  MOVLW  22
01AB2:  MOVWF  x8B
....................          response[22]  = ':'; 
01AB4:  MOVLW  3A
01AB6:  MOVWF  x8C
....................          response[23]  = input_state(PIN_OUT[3])+ 48; 
01AB8:  MOVLW  00
01ABA:  BTFSC  F80.4
01ABC:  MOVLW  01
01ABE:  ADDLW  30
01AC0:  MOVWF  x8D
....................          response[24]  = ','; 
01AC2:  MOVLW  2C
01AC4:  MOVWF  x8E
....................           
....................          response[25]  = '"'; 
01AC6:  MOVLW  22
01AC8:  MOVWF  x8F
....................          response[26]  = '4'; 
01ACA:  MOVLW  34
01ACC:  MOVWF  x90
....................          response[27]  = '"'; 
01ACE:  MOVLW  22
01AD0:  MOVWF  x91
....................          response[28]  = ':'; 
01AD2:  MOVLW  3A
01AD4:  MOVWF  x92
....................          response[29]  = input_state(PIN_OUT[4])+ 48; 
01AD6:  MOVLW  00
01AD8:  BTFSC  F80.0
01ADA:  MOVLW  01
01ADC:  ADDLW  30
01ADE:  MOVWF  x93
....................          response[30]  = ','; 
01AE0:  MOVLW  2C
01AE2:  MOVWF  x94
....................           
....................          response[31]  = '"'; 
01AE4:  MOVLW  22
01AE6:  MOVWF  x95
....................          response[32]  = '5'; 
01AE8:  MOVLW  35
01AEA:  MOVWF  x96
....................          response[33]  = '"'; 
01AEC:  MOVLW  22
01AEE:  MOVWF  x97
....................          response[34]  = ':'; 
01AF0:  MOVLW  3A
01AF2:  MOVWF  x98
....................          response[35]  = input_state(PIN_OUT[5])+ 48; 
01AF4:  MOVLW  00
01AF6:  BTFSC  F80.1
01AF8:  MOVLW  01
01AFA:  ADDLW  30
01AFC:  MOVWF  x99
....................          response[36]  = ','; 
01AFE:  MOVLW  2C
01B00:  MOVWF  x9A
....................           
....................          response[37]  = '"'; 
01B02:  MOVLW  22
01B04:  MOVWF  x9B
....................          response[38]  = '6'; 
01B06:  MOVLW  36
01B08:  MOVWF  x9C
....................          response[39]  = '"'; 
01B0A:  MOVLW  22
01B0C:  MOVWF  x9D
....................          response[40]  = ':'; 
01B0E:  MOVLW  3A
01B10:  MOVWF  x9E
....................          response[41]  = input_state(PIN_OUT[6])+ 48; 
01B12:  MOVLW  00
01B14:  BTFSC  F80.2
01B16:  MOVLW  01
01B18:  ADDLW  30
01B1A:  MOVWF  x9F
....................          response[42]  = ','; 
01B1C:  MOVLW  2C
01B1E:  MOVWF  xA0
....................           
....................          response[43]  = '"'; 
01B20:  MOVLW  22
01B22:  MOVWF  xA1
....................          response[44]  = '7'; 
01B24:  MOVLW  37
01B26:  MOVWF  xA2
....................          response[45]  = '"'; 
01B28:  MOVLW  22
01B2A:  MOVWF  xA3
....................          response[46]  = ':'; 
01B2C:  MOVLW  3A
01B2E:  MOVWF  xA4
....................          response[47]  = input_state(PIN_OUT[7])+ 48; 
01B30:  MOVLW  00
01B32:  BTFSC  F80.3
01B34:  MOVLW  01
01B36:  ADDLW  30
01B38:  MOVWF  xA5
....................          response[48]  = ','; 
01B3A:  MOVLW  2C
01B3C:  MOVWF  xA6
....................           
....................          response[49]  = '"'; 
01B3E:  MOVLW  22
01B40:  MOVWF  xA7
....................          response[50]  = 'M'; 
01B42:  MOVLW  4D
01B44:  MOVWF  xA8
....................          response[51]  = '"'; 
01B46:  MOVLW  22
01B48:  MOVWF  xA9
....................          response[52]  = ':'; 
01B4A:  MOVLW  3A
01B4C:  MOVWF  xAA
....................          response[53]  = read_eeprom(0x00); 
01B4E:  MOVFF  FF2,1B3
01B52:  BCF    FF2.7
01B54:  CLRF   FAA
01B56:  CLRF   FA9
01B58:  BCF    FA6.6
01B5A:  BCF    FA6.7
01B5C:  BSF    FA6.0
01B5E:  MOVF   FA8,W
01B60:  BTFSC  xB3.7
01B62:  BSF    FF2.7
01B64:  MOVWF  xAB
....................           
....................          response[54]  = '}'; 
01B66:  MOVLW  7D
01B68:  MOVWF  xAC
....................          lenResponse   = 55; 
01B6A:  MOVLW  37
01B6C:  MOVWF  x75
....................       } // Fin comando OS 
....................        
....................       /*********************************** 
....................       *** Cambia el Nombre de Puerto    ** 
....................       *** lo almacena en la EEPROM      ** 
....................       *** CMD:NO,0NombreChar[10]:       ** 
....................       ***********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='O') 
01B6E:  MOVF   1E,W
01B70:  SUBLW  4E
01B72:  BTFSS  FD8.2
01B74:  BRA    1C5A
01B76:  MOVF   1F,W
01B78:  SUBLW  4F
01B7A:  BNZ   1C5A
....................       { 
....................           
....................          int posIni = 0, posFin = 0; 
01B7C:  CLRF   xB0
01B7E:  CLRF   xB1
....................          optSelected =(int) ( DATA_COMMAND[0] - 48); 
01B80:  MOVLW  30
01B82:  SUBWF  20,W
01B84:  MOVWF  x72
....................          posIni =( 10 * optSelected ) + 40; 
01B86:  MOVF   x72,W
01B88:  MULLW  0A
01B8A:  MOVF   FF3,W
01B8C:  ADDLW  28
01B8E:  MOVWF  xB0
....................          posFin = posIni + 10; 
01B90:  MOVLW  0A
01B92:  ADDWF  xB0,W
01B94:  MOVWF  xB1
....................           
....................          // Guarda el nuevo nombre 
....................          for(idxRSTNC=posIni;idxRSTNC<(posIni+LEN_DATA_COMMAND);idxRSTNC++){ 
01B96:  MOVFF  1B0,174
01B9A:  MOVF   xB0,W
01B9C:  ADDWF  52,W
01B9E:  MOVWF  01
01BA0:  MOVLW  00
01BA2:  ADDWFC 53,W
01BA4:  MOVWF  03
01BA6:  MOVF   01,W
01BA8:  MOVF   03,F
01BAA:  BNZ   1BB2
01BAC:  MOVF   01,W
01BAE:  SUBWF  x74,W
01BB0:  BC    1C04
....................             counter++; 
01BB2:  INCF   x73,F
....................             write_eeprom(idxRSTNC,DATA_COMMAND[counter]); 
01BB4:  CLRF   03
01BB6:  MOVF   x73,W
01BB8:  ADDLW  20
01BBA:  MOVWF  FE9
01BBC:  MOVLW  00
01BBE:  ADDWFC 03,W
01BC0:  MOVWF  FEA
01BC2:  MOVFF  FEF,1B3
01BC6:  MOVF   FF2,W
01BC8:  MOVWF  00
01BCA:  BCF    FF2.7
01BCC:  CLRF   FAA
01BCE:  MOVFF  174,FA9
01BD2:  MOVFF  1B3,FA8
01BD6:  BCF    FA6.6
01BD8:  BCF    FA6.7
01BDA:  BSF    FA6.2
01BDC:  MOVLB  F
01BDE:  MOVLW  55
01BE0:  MOVWF  FA7
01BE2:  MOVLW  AA
01BE4:  MOVWF  FA7
01BE6:  BSF    FA6.1
01BE8:  BTFSC  FA6.1
01BEA:  BRA    1BE8
01BEC:  BCF    FA6.2
01BEE:  MOVF   00,W
01BF0:  IORWF  FF2,F
....................             delay_ms(10); 
01BF2:  MOVLW  0A
01BF4:  MOVLB  1
01BF6:  MOVWF  xB4
01BF8:  MOVLB  0
01BFA:  CALL   0C2E
01BFE:  MOVLB  1
01C00:  INCF   x74,F
01C02:  BRA    1B9A
....................          } 
....................           
....................          // Borra el restante de la eeprom para almacenar las nuevas credenciales 
....................          for(idxRSTNC=(posIni+LEN_DATA_COMMAND+1);idxRSTNC<=posFin;idxRSTNC++){ 
01C04:  MOVF   xB0,W
01C06:  ADDWF  52,W
01C08:  MOVWF  xB3
01C0A:  MOVLW  00
01C0C:  ADDWFC 53,W
01C0E:  MOVWF  xB4
01C10:  MOVLW  01
01C12:  ADDWF  xB3,W
01C14:  MOVWF  x74
01C16:  MOVF   x74,W
01C18:  SUBWF  xB1,W
01C1A:  BNC   1C58
....................             write_eeprom(idxRSTNC,0xFF); 
01C1C:  MOVF   FF2,W
01C1E:  MOVWF  00
01C20:  BCF    FF2.7
01C22:  CLRF   FAA
01C24:  MOVFF  174,FA9
01C28:  SETF   FA8
01C2A:  BCF    FA6.6
01C2C:  BCF    FA6.7
01C2E:  BSF    FA6.2
01C30:  MOVLB  F
01C32:  MOVLW  55
01C34:  MOVWF  FA7
01C36:  MOVLW  AA
01C38:  MOVWF  FA7
01C3A:  BSF    FA6.1
01C3C:  BTFSC  FA6.1
01C3E:  BRA    1C3C
01C40:  BCF    FA6.2
01C42:  MOVF   00,W
01C44:  IORWF  FF2,F
....................             delay_ms(10); 
01C46:  MOVLW  0A
01C48:  MOVLB  1
01C4A:  MOVWF  xB4
01C4C:  MOVLB  0
01C4E:  CALL   0C2E
01C52:  MOVLB  1
01C54:  INCF   x74,F
01C56:  BRA    1C16
....................          } 
....................           
....................          counter = 0; 
01C58:  CLRF   x73
....................          //reset = 1; //Reinicia el Dispositivo 
....................       } // Fin comando NO 
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................       if(reset==0){ 
01C5A:  MOVF   x71,F
01C5C:  BNZ   1D0A
....................          // Responde la solicitud 
....................          delay_ms(20); 
01C5E:  MOVLW  14
01C60:  MOVWF  xB4
01C62:  MOVLB  0
01C64:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01C68:  MOVLW  18
01C6A:  MOVWF  FF6
01C6C:  MOVLW  02
01C6E:  MOVWF  FF7
01C70:  MOVLW  0B
01C72:  MOVLB  1
01C74:  MOVWF  xB3
01C76:  MOVLB  0
01C78:  CALL   0F0C
01C7C:  MOVF   1C,W
01C7E:  BTFSS  F9E.4
01C80:  BRA    1C7E
01C82:  MOVWF  FAD
01C84:  MOVLW  2C
01C86:  BTFSS  F9E.4
01C88:  BRA    1C86
01C8A:  MOVWF  FAD
01C8C:  MOVFF  175,1B3
01C90:  MOVLW  1B
01C92:  MOVLB  1
01C94:  MOVWF  xB4
01C96:  MOVLB  0
01C98:  CALL   13E8
01C9C:  MOVLW  0D
01C9E:  BTFSS  F9E.4
01CA0:  BRA    1C9E
01CA2:  MOVWF  FAD
01CA4:  MOVLW  0A
01CA6:  BTFSS  F9E.4
01CA8:  BRA    1CA6
01CAA:  MOVWF  FAD
....................          delay_ms(50); 
01CAC:  MOVLW  32
01CAE:  MOVLB  1
01CB0:  MOVWF  xB4
01CB2:  MOVLB  0
01CB4:  CALL   0C2E
....................          fprintf(ESP8266, "%s",response); 
01CB8:  MOVLW  01
01CBA:  MOVWF  FEA
01CBC:  MOVLW  76
01CBE:  MOVWF  FE9
01CC0:  CALL   1026
....................          delay_ms(100); 
01CC4:  MOVLW  64
01CC6:  MOVLB  1
01CC8:  MOVWF  xB4
01CCA:  MOVLB  0
01CCC:  CALL   0C2E
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01CD0:  MOVLW  2C
01CD2:  MOVWF  FF6
01CD4:  MOVLW  02
01CD6:  MOVWF  FF7
01CD8:  MOVLW  0C
01CDA:  MOVLB  1
01CDC:  MOVWF  xB3
01CDE:  MOVLB  0
01CE0:  CALL   0F0C
01CE4:  MOVF   1C,W
01CE6:  BTFSS  F9E.4
01CE8:  BRA    1CE6
01CEA:  MOVWF  FAD
01CEC:  MOVLW  0D
01CEE:  BTFSS  F9E.4
01CF0:  BRA    1CEE
01CF2:  MOVWF  FAD
01CF4:  MOVLW  0A
01CF6:  BTFSS  F9E.4
01CF8:  BRA    1CF6
01CFA:  MOVWF  FAD
....................          delay_ms(100); 
01CFC:  MOVLW  64
01CFE:  MOVLB  1
01D00:  MOVWF  xB4
01D02:  MOVLB  0
01D04:  CALL   0C2E
01D08:  MOVLB  1
....................       } 
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
01D0A:  CLRF   xB2
01D0C:  MOVF   53,F
01D0E:  BNZ   1D16
01D10:  MOVF   xB2,W
01D12:  SUBWF  52,W
01D14:  BNC   1D2A
....................          DATA_COMMAND[idxCb] = 0x00; 
01D16:  CLRF   03
01D18:  MOVF   xB2,W
01D1A:  ADDLW  20
01D1C:  MOVWF  FE9
01D1E:  MOVLW  00
01D20:  ADDWFC 03,W
01D22:  MOVWF  FEA
01D24:  CLRF   FEF
01D26:  INCF   xB2,F
01D28:  BRA    1D0C
....................       } 
....................       for(idxCb=0;idxCb<=56;idxCb++){ 
01D2A:  CLRF   xB2
01D2C:  MOVF   xB2,W
01D2E:  SUBLW  38
01D30:  BNC   1D46
....................       response[idxCb] = 0x00; 
01D32:  CLRF   03
01D34:  MOVF   xB2,W
01D36:  ADDLW  76
01D38:  MOVWF  FE9
01D3A:  MOVLW  01
01D3C:  ADDWFC 03,W
01D3E:  MOVWF  FEA
01D40:  CLRF   FEF
01D42:  INCF   xB2,F
01D44:  BRA    1D2C
....................       } 
....................       COMMAND[0]       = 0x00; 
01D46:  CLRF   1E
....................       COMMAND[1]       = 0x00; 
01D48:  CLRF   1F
....................       ID_CONNETION[0]  = 0x00; 
01D4A:  CLRF   1C
....................        
....................       flag_Resp_Ready  = 0x00; 
01D4C:  CLRF   57
....................       LEN_DATA_COMMAND = 0x00; 
01D4E:  CLRF   53
01D50:  CLRF   52
....................        
....................       if(reset==1){ 
01D52:  DECFSZ x71,W
01D54:  BRA    1D5A
....................          reset = 0; 
01D56:  CLRF   x71
....................           // Reinicia el dispositivo 
....................          reset_cpu(); 
01D58:  RESET
....................       } 
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return reset; 
01D5A:  MOVFF  171,01
01D5E:  MOVLB  0
01D60:  RETURN 0
.................... } // Fin de la Funcion run_command_wifi() 
....................  
.................... #include "header/esp8266.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          esp8266.H: Inicializa el Modulo esp8266 y 
....................                              maneja las interrupciones USART 
....................                              para procesar los comandos wifi. 
....................  
.................... *******************************************************/ 
....................  
.................... /* 
....................      **  Funcionamiento de las funciones de Busqueda y comparacion  
....................      **  de String. 
....................      ** 
....................  
.................... Cuenta el numero de aciertos de manera secuencial cuando compara los  
.................... caracteres que recibe por el usart vs una cadena constante. Si el  
.................... numero de aciertos es igual a la cadena entonces las cadenas son iguales 
.................... y almacena en una estructura los siguientes caracteres recibidos hasta  
.................... que encuentre el caracter del fin de la cadena (":"). 
....................  
.................... */ 
.................... #define  CHPD_ESP8266               PIN_B3 
.................... #define  CMD_MODE                   1 
.................... #define  CMD_DO_CONN                2 
.................... #define  CMD_CONN                   3 
.................... #define  READY_RESPONSE_WIFI        4 
.................... #define  CMD_GET_IP_FROM_MENU       5 
.................... #define  CMD_GET_AP_INFO_FROM_MENU  6 
.................... #define  CMD_GET_STA_INFO_FROM_MENU 7 
....................  
.................... /* Key flag responses */ 
.................... const int   Valid      = 0; 
.................... const int   CWJAP      = 1; 
.................... const int   NoAp       = 2; 
.................... const int   Connected  = 3; 
.................... const int   Fail       = 4; 
.................... const int   Error      = 5; 
....................  
.................... /* Declaracion de Funciones */ 
.................... void getIP(int buffer); 
.................... void getAPInfo(int buffer); 
.................... void getSTAInfo(int buffer); 
.................... int  waitResp(void); 
.................... void waitRespMajor(int buffer,int flag_resp); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int resp_Pos   = 1; 
.................... int resp_Flag  = 0; 
.................... int countResp  = 5;     //Conteo de Respuestas esperadas 
....................  
.................... char buffer_flag_Resp[2][6]   =   
.................... { 
....................    {0,0,0,0,0,0}, // Flag_Responses Command valid 
....................    {0,0,0,0,0,0}  // Flag_Pos_Responses 
.................... }; 
....................  
.................... char buffer_Resp_CMD[5][16]   = 
.................... { 
....................    {"0.0.0.0"},   // IP    AP 
....................    {"0.0.0.0"},   // IP    STA 
....................    {"               "},   // SSID  AP 
....................    {"               "},   // Key   AP 
....................    {"               "}    // SSID  STA 
.................... }; 
....................  
.................... int flag_Resp_Get_IP_CMD = 0; 
.................... int flag_Pos_Get_IP_CMD  = 0; 
....................  
.................... int flag_Resp_Get_AP_Info_CMD = 0; 
.................... int flag_Pos_Get_AP_Info_CMD  = 0; 
....................  
.................... int flag_Resp_Get_STA_Info_CMD = 0; 
.................... int flag_Pos_Get_STA_Info_CMD  = 0; 
....................  
.................... /* Variables que se setean con la data de la EEPROM */ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
*
010B2:  MOVLB  1
010B4:  CLRF   x6A
.................... { 
....................    int resp=0; 
....................  
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
010B6:  MOVFF  FF2,16C
010BA:  BCF    FF2.7
010BC:  CLRF   FAA
010BE:  CLRF   FA9
010C0:  BCF    FA6.6
010C2:  BCF    FA6.7
010C4:  BSF    FA6.0
010C6:  MOVF   FA8,W
010C8:  BTFSC  x6C.7
010CA:  BSF    FF2.7
010CC:  MOVLB  0
010CE:  MOVWF  xC1
....................    delay_ms(10); 
010D0:  MOVLW  0A
010D2:  MOVLB  1
010D4:  MOVWF  xB4
010D6:  MOVLB  0
010D8:  RCALL  0C2E
....................    switch(modeStar){ 
010DA:  MOVF   xC1,W
010DC:  XORLW  31
010DE:  BZ    10EA
010E0:  XORLW  03
010E2:  BZ    10EA
010E4:  XORLW  01
010E6:  BZ    10EA
010E8:  BRA    10EC
....................       case '1': 
....................       case '2': 
....................       case '3': 
....................          break; 
010EA:  BRA    1124
....................       default: 
....................          write_eeprom(0x00,'3'); 
010EC:  MOVF   FF2,W
010EE:  MOVWF  00
010F0:  BCF    FF2.7
010F2:  CLRF   FAA
010F4:  CLRF   FA9
010F6:  MOVLW  33
010F8:  MOVWF  FA8
010FA:  BCF    FA6.6
010FC:  BCF    FA6.7
010FE:  BSF    FA6.2
01100:  MOVLB  F
01102:  MOVLW  55
01104:  MOVWF  FA7
01106:  MOVLW  AA
01108:  MOVWF  FA7
0110A:  BSF    FA6.1
0110C:  BTFSC  FA6.1
0110E:  BRA    110C
01110:  BCF    FA6.2
01112:  MOVF   00,W
01114:  IORWF  FF2,F
....................          delay_ms(10); 
01116:  MOVLW  0A
01118:  MOVLB  1
0111A:  MOVWF  xB4
0111C:  MOVLB  0
0111E:  RCALL  0C2E
....................          modeStar = '3'; 
01120:  MOVLW  33
01122:  MOVWF  xC1
....................          break; 
....................    } 
....................    // Lanza el comando para configurar el modo de conexion 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeStar); 
01124:  MOVLW  3E
01126:  MOVWF  FF6
01128:  MOVLW  02
0112A:  MOVWF  FF7
0112C:  MOVLW  0A
0112E:  MOVLB  1
01130:  MOVWF  xB3
01132:  MOVLB  0
01134:  RCALL  0F0C
01136:  MOVF   xC1,W
01138:  BTFSS  F9E.4
0113A:  BRA    1138
0113C:  MOVWF  FAD
0113E:  MOVLW  0D
01140:  BTFSS  F9E.4
01142:  BRA    1140
01144:  MOVWF  FAD
01146:  MOVLW  0A
01148:  BTFSS  F9E.4
0114A:  BRA    1148
0114C:  MOVWF  FAD
....................    CMD_RUN =  CMD_MODE;  
0114E:  MOVLW  01
01150:  MOVWF  5B
....................    delay_ms(50); 
01152:  MOVLW  32
01154:  MOVLB  1
01156:  MOVWF  xB4
01158:  MOVLB  0
0115A:  RCALL  0C2E
....................     
....................    // Lanza el comando para verificar si el modulo ya se encuentra conectado 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
0115C:  MOVLW  4E
0115E:  MOVWF  FF6
01160:  MOVLW  02
01162:  MOVWF  FF7
01164:  RCALL  0C56
....................    CMD_RUN  =  CMD_DO_CONN; 
01166:  MOVLW  02
01168:  MOVWF  5B
....................    resp     = waitResp(); 
0116A:  RCALL  0F36
0116C:  MOVFF  01,16A
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
01170:  MOVLB  1
01172:  MOVF   x6A,W
01174:  SUBLW  02
01176:  BTFSS  FD8.2
01178:  BRA    127C
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
0117A:  CLRF   x6B
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
0117C:  CLRF   03
0117E:  MOVF   x6B,W
01180:  ADDLW  C2
01182:  MOVWF  FE9
01184:  MOVLW  00
01186:  ADDWFC 03,W
01188:  MOVWF  FEA
0118A:  MOVF   FEF,W
0118C:  SUBLW  0A
0118E:  BZ    11FA
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
01190:  CLRF   03
01192:  MOVF   x6B,W
01194:  ADDLW  C2
01196:  MOVWF  FE9
01198:  MOVLW  00
0119A:  ADDWFC 03,W
0119C:  MOVWF  FEA
0119E:  MOVLW  01
011A0:  ADDWF  x6B,W
011A2:  MOVWF  x6E
011A4:  MOVFF  FF2,16F
011A8:  BCF    FF2.7
011AA:  CLRF   FAA
011AC:  MOVFF  16E,FA9
011B0:  BCF    FA6.6
011B2:  BCF    FA6.7
011B4:  BSF    FA6.0
011B6:  MOVF   FA8,W
011B8:  BTFSC  x6F.7
011BA:  BSF    FF2.7
011BC:  MOVWF  FEF
....................          delay_ms(10); 
011BE:  MOVLW  0A
011C0:  MOVWF  xB4
011C2:  MOVLB  0
011C4:  RCALL  0C2E
....................          if(SSIDAndKey[idxRE]==0xFF){ 
011C6:  CLRF   03
011C8:  MOVLB  1
011CA:  MOVF   x6B,W
011CC:  ADDLW  C2
011CE:  MOVWF  FE9
011D0:  MOVLW  00
011D2:  ADDWFC 03,W
011D4:  MOVWF  FEA
011D6:  INCFSZ FEF,W
011D8:  BRA    11E0
....................             resp = 5; 
011DA:  MOVLW  05
011DC:  MOVWF  x6A
....................             break; 
011DE:  BRA    11FA
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
011E0:  CLRF   03
011E2:  MOVF   x6B,W
011E4:  ADDLW  C2
011E6:  MOVWF  FE9
011E8:  MOVLW  00
011EA:  ADDWFC 03,W
011EC:  MOVWF  FEA
011EE:  MOVF   FEF,W
011F0:  SUBLW  0A
011F2:  BNZ   11F6
....................             break; 
011F4:  BRA    11FA
....................          } 
....................          idxRE++; 
011F6:  INCF   x6B,F
011F8:  BRA    117C
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
011FA:  MOVF   x6A,W
011FC:  SUBLW  05
011FE:  BZ    122E
....................          fprintf(ESP8266, "AT+CWJAP=%s",SSIDAndKey); 
01200:  MOVLW  5A
01202:  MOVWF  FF6
01204:  MOVLW  02
01206:  MOVWF  FF7
01208:  MOVLW  09
0120A:  MOVWF  xB3
0120C:  MOVLB  0
0120E:  RCALL  0F0C
01210:  CLRF   FEA
01212:  MOVLW  C2
01214:  MOVWF  FE9
01216:  RCALL  1026
....................          CMD_RUN = CMD_CONN; 
01218:  MOVLW  03
0121A:  MOVWF  5B
....................          fprintf(console,"Lanza comando Para conectarse a una red \r\n"); 
0121C:  MOVLW  66
0121E:  MOVWF  FF6
01220:  MOVLW  02
01222:  MOVWF  FF7
01224:  RCALL  1092
....................          resp    = waitResp(); 
01226:  RCALL  0F36
01228:  MOVFF  01,16A
0122C:  MOVLB  1
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
0122E:  MOVF   x6A,W
01230:  SUBLW  04
01232:  BZ    123A
01234:  MOVF   x6A,W
01236:  SUBLW  05
01238:  BNZ   127C
....................          fprintf(console,"Sin red entonces activa Modo AP \r\n"); 
0123A:  MOVLW  92
0123C:  MOVWF  FF6
0123E:  MOVLW  02
01240:  MOVWF  FF7
01242:  MOVLB  0
01244:  RCALL  1092
....................          fprintf(ESP8266, "AT+CWMODE=%c\r\n","3"); 
01246:  MOVLW  B6
01248:  MOVWF  FF6
0124A:  MOVLW  02
0124C:  MOVWF  FF7
0124E:  MOVLW  0A
01250:  MOVLB  1
01252:  MOVWF  xB3
01254:  MOVLB  0
01256:  RCALL  0F0C
01258:  MOVLB  4
0125A:  MOVF   xC8,W
0125C:  BTFSS  F9E.4
0125E:  BRA    125C
01260:  MOVWF  FAD
01262:  MOVLW  0D
01264:  BTFSS  F9E.4
01266:  BRA    1264
01268:  MOVWF  FAD
0126A:  MOVLW  0A
0126C:  BTFSS  F9E.4
0126E:  BRA    126C
01270:  MOVWF  FAD
....................          CMD_RUN = CMD_MODE; 
01272:  MOVLW  01
01274:  MOVWF  5B
....................          waitResp(); 
01276:  MOVLB  0
01278:  RCALL  0F36
0127A:  MOVLB  1
....................       } 
....................    } // Fin del if(doConnect) 
....................  
....................    // Configura el modulo como server 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
0127C:  MOVLW  C6
0127E:  MOVWF  FF6
01280:  MOVLW  02
01282:  MOVWF  FF7
01284:  MOVLB  0
01286:  RCALL  0C56
....................    delay_ms(1000); 
01288:  MOVLW  04
0128A:  MOVLB  1
0128C:  MOVWF  x6C
0128E:  MOVLW  FA
01290:  MOVWF  xB4
01292:  MOVLB  0
01294:  RCALL  0C2E
01296:  MOVLB  1
01298:  DECFSZ x6C,F
0129A:  BRA    128E
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
0129C:  MOVLW  D4
0129E:  MOVWF  FF6
012A0:  MOVLW  02
012A2:  MOVWF  FF7
012A4:  MOVLB  0
012A6:  RCALL  0C56
....................    delay_ms(1000); 
012A8:  MOVLW  04
012AA:  MOVLB  1
012AC:  MOVWF  x6C
012AE:  MOVLW  FA
012B0:  MOVWF  xB4
012B2:  MOVLB  0
012B4:  RCALL  0C2E
012B6:  MOVLB  1
012B8:  DECFSZ x6C,F
012BA:  BRA    12AE
....................     
....................    CMD_RUN = READY_RESPONSE_WIFI; 
012BC:  MOVLW  04
012BE:  MOVWF  5B
012C0:  MOVLB  0
012C2:  GOTO   2C48 (RETURN)
.................... } 
....................  
.................... /********************************************************** 
....................    Funcion encangada de procesar las respuestas del modulo,  
....................    debe ser llamada durante la interrupcion del USART 
.................... ***********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................  
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
00AD4:  MOVF   5B,W
00AD6:  XORLW  01
00AD8:  BZ    0AF4
00ADA:  XORLW  03
00ADC:  BZ    0B02
00ADE:  XORLW  01
00AE0:  BZ    0B2C
00AE2:  XORLW  06
00AE4:  BZ    0B56
00AE6:  XORLW  03
00AE8:  BZ    0B6A
00AEA:  XORLW  01
00AEC:  BZ    0B7E
00AEE:  XORLW  03
00AF0:  BZ    0B92
00AF2:  BRA    0B92
....................             case CMD_MODE: 
....................                   waitRespMajor(buffer,Valid); 
00AF4:  MOVFF  1BC,1BD
00AF8:  MOVLB  1
00AFA:  CLRF   xBE
00AFC:  MOVLB  0
00AFE:  RCALL  05F4
....................                   break; 
00B00:  BRA    0BB8
....................  
....................             case CMD_DO_CONN: 
....................                   waitRespMajor(buffer,NoAp); 
00B02:  MOVFF  1BC,1BD
00B06:  MOVLW  02
00B08:  MOVLB  1
00B0A:  MOVWF  xBE
00B0C:  MOVLB  0
00B0E:  RCALL  05F4
....................                   waitRespMajor(buffer,CWJAP); 
00B10:  MOVFF  1BC,1BD
00B14:  MOVLW  01
00B16:  MOVLB  1
00B18:  MOVWF  xBE
00B1A:  MOVLB  0
00B1C:  RCALL  05F4
....................                   waitRespMajor(buffer,Valid); 
00B1E:  MOVFF  1BC,1BD
00B22:  MOVLB  1
00B24:  CLRF   xBE
00B26:  MOVLB  0
00B28:  RCALL  05F4
....................                   break; 
00B2A:  BRA    0BB8
....................  
....................             case CMD_CONN: 
....................                   waitRespMajor(buffer,Connected); 
00B2C:  MOVFF  1BC,1BD
00B30:  MOVLW  03
00B32:  MOVLB  1
00B34:  MOVWF  xBE
00B36:  MOVLB  0
00B38:  RCALL  05F4
....................                   waitRespMajor(buffer,Fail); 
00B3A:  MOVFF  1BC,1BD
00B3E:  MOVLW  04
00B40:  MOVLB  1
00B42:  MOVWF  xBE
00B44:  MOVLB  0
00B46:  RCALL  05F4
....................                   waitRespMajor(buffer,Valid); 
00B48:  MOVFF  1BC,1BD
00B4C:  MOVLB  1
00B4E:  CLRF   xBE
00B50:  MOVLB  0
00B52:  RCALL  05F4
....................                   break; 
00B54:  BRA    0BB8
....................              
....................             case CMD_GET_IP_FROM_MENU: 
....................                   getIP(buffer); 
00B56:  MOVFF  1BC,1BD
00B5A:  BRA    080A
....................                   waitRespMajor(buffer,Valid); 
00B5C:  MOVFF  1BC,1BD
00B60:  MOVLB  1
00B62:  CLRF   xBE
00B64:  MOVLB  0
00B66:  RCALL  05F4
....................                   break; 
00B68:  BRA    0BB8
....................                    
....................             case CMD_GET_AP_INFO_FROM_MENU: 
....................                   getAPInfo(buffer); 
00B6A:  MOVFF  1BC,1BD
00B6E:  BRA    08DA
....................                   waitRespMajor(buffer,Valid); 
00B70:  MOVFF  1BC,1BD
00B74:  MOVLB  1
00B76:  CLRF   xBE
00B78:  MOVLB  0
00B7A:  RCALL  05F4
....................                   break; 
00B7C:  BRA    0BB8
....................              
....................             case CMD_GET_STA_INFO_FROM_MENU: 
....................                   getSTAInfo(buffer); 
00B7E:  MOVFF  1BC,1BD
00B82:  BRA    0972
....................                   waitRespMajor(buffer,Valid); 
00B84:  MOVFF  1BC,1BD
00B88:  MOVLB  1
00B8A:  CLRF   xBE
00B8C:  MOVLB  0
00B8E:  RCALL  05F4
....................                   break; 
00B90:  BRA    0BB8
....................                    
....................             case READY_RESPONSE_WIFI: 
....................             default: 
....................                   ESP8266_Get_IPD(buffer); 
00B92:  MOVLB  1
00B94:  CLRF   xBE
00B96:  MOVFF  1BC,1BD
00B9A:  MOVLB  0
00B9C:  BRA    09B4
....................                   ESP8266_Get_CMD(buffer); 
00B9E:  MOVLB  1
00BA0:  CLRF   xBE
00BA2:  MOVFF  1BC,1BD
00BA6:  MOVLB  0
00BA8:  BRA    0A1C
....................                   ESP8266_Get_Data(buffer); 
00BAA:  MOVLB  1
00BAC:  CLRF   xBE
00BAE:  MOVFF  1BC,1BD
00BB2:  MOVLB  0
00BB4:  BRA    0A88
....................                   CMD_RUN = 0x00; 
00BB6:  CLRF   5B
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
00BB8:  GOTO   0BCE (RETURN)
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
00F36:  MOVLB  1
00F38:  CLRF   x6E
00F3A:  CLRF   x6F
.................... { 
....................    int ret=0,idx=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(buffer_flag_Resp[resp_Flag][Valid]==0){ 
00F3C:  MOVF   5D,W
00F3E:  MULLW  06
00F40:  MOVF   FF3,W
00F42:  CLRF   x71
00F44:  MOVWF  x70
00F46:  MOVLW  5F
00F48:  ADDWF  x70,W
00F4A:  MOVWF  FE9
00F4C:  MOVLW  00
00F4E:  ADDWFC x71,W
00F50:  MOVWF  FEA
00F52:  MOVF   FEF,F
00F54:  BNZ   0FFA
....................       idx++; 
00F56:  INCF   x6F,F
....................       if(buffer_flag_Resp[resp_Flag][idx]==1){ 
00F58:  MOVF   5D,W
00F5A:  MULLW  06
00F5C:  MOVF   FF3,W
00F5E:  CLRF   x71
00F60:  MOVWF  x70
00F62:  CLRF   03
00F64:  MOVF   x6F,W
00F66:  ADDWF  x70,W
00F68:  MOVWF  01
00F6A:  MOVF   x71,W
00F6C:  ADDWFC 03,F
00F6E:  MOVF   01,W
00F70:  ADDLW  5F
00F72:  MOVWF  FE9
00F74:  MOVLW  00
00F76:  ADDWFC 03,W
00F78:  MOVWF  FEA
00F7A:  DECFSZ FEF,W
00F7C:  BRA    0FF0
....................          buffer_flag_Resp[resp_Pos][idx]   = 0; 
00F7E:  MOVF   5C,W
00F80:  MULLW  06
00F82:  MOVF   FF3,W
00F84:  CLRF   x71
00F86:  MOVWF  x70
00F88:  CLRF   03
00F8A:  MOVF   x6F,W
00F8C:  ADDWF  x70,W
00F8E:  MOVWF  01
00F90:  MOVF   x71,W
00F92:  ADDWFC 03,F
00F94:  MOVF   01,W
00F96:  ADDLW  5F
00F98:  MOVWF  FE9
00F9A:  MOVLW  00
00F9C:  ADDWFC 03,W
00F9E:  MOVWF  FEA
00FA0:  CLRF   FEF
....................          buffer_flag_Resp[resp_Flag][idx]  = 0; 
00FA2:  MOVF   5D,W
00FA4:  MULLW  06
00FA6:  MOVF   FF3,W
00FA8:  CLRF   x71
00FAA:  MOVWF  x70
00FAC:  CLRF   03
00FAE:  MOVF   x6F,W
00FB0:  ADDWF  x70,W
00FB2:  MOVWF  01
00FB4:  MOVF   x71,W
00FB6:  ADDWFC 03,F
00FB8:  MOVF   01,W
00FBA:  ADDLW  5F
00FBC:  MOVWF  FE9
00FBE:  MOVLW  00
00FC0:  ADDWFC 03,W
00FC2:  MOVWF  FEA
00FC4:  CLRF   FEF
....................  
....................          if(idx == Fail || idx == Error){ 
00FC6:  MOVF   x6F,W
00FC8:  SUBLW  04
00FCA:  BZ    0FD2
00FCC:  MOVF   x6F,W
00FCE:  SUBLW  05
00FD0:  BNZ   0FEC
....................             buffer_flag_Resp[resp_Flag][Valid]  = 1; 
00FD2:  MOVF   5D,W
00FD4:  MULLW  06
00FD6:  MOVF   FF3,W
00FD8:  CLRF   x71
00FDA:  MOVWF  x70
00FDC:  MOVLW  5F
00FDE:  ADDWF  x70,W
00FE0:  MOVWF  FE9
00FE2:  MOVLW  00
00FE4:  ADDWFC x71,W
00FE6:  MOVWF  FEA
00FE8:  MOVLW  01
00FEA:  MOVWF  FEF
....................          } 
....................          ret = idx; 
00FEC:  MOVFF  16F,16E
....................       } 
....................       // Reinicia el contador para no desbordar el array de flag_resp 
....................       if(idx>=countResp){ 
00FF0:  MOVF   5E,W
00FF2:  SUBWF  x6F,W
00FF4:  BNC   0FF8
....................          idx = 0; 
00FF6:  CLRF   x6F
....................       } 
00FF8:  BRA    0F3C
....................    }; // Fin del loop 
....................    buffer_flag_Resp[resp_Flag][Valid] = 0; 
00FFA:  MOVF   5D,W
00FFC:  MULLW  06
00FFE:  MOVF   FF3,W
01000:  CLRF   x71
01002:  MOVWF  x70
01004:  MOVLW  5F
01006:  ADDWF  x70,W
01008:  MOVWF  FE9
0100A:  MOVLW  00
0100C:  ADDWFC x71,W
0100E:  MOVWF  FEA
01010:  CLRF   FEF
....................    CMD_RUN = 0x00; 
01012:  CLRF   5B
....................    delay_ms(10); 
01014:  MOVLW  0A
01016:  MOVWF  xB4
01018:  MOVLB  0
0101A:  RCALL  0C2E
....................    return ret; 
0101C:  MOVLB  1
0101E:  MOVFF  16E,01
01022:  MOVLB  0
01024:  RETURN 0
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
.................... void waitRespMajor(int buffer,int flag_resp) 
*
005F4:  MOVLB  1
005F6:  CLRF   xC9
005F8:  CLRF   xCA
.................... { 
....................    char  strResp[10]; 
....................    int   lenResp = 0,restartFlag = 0; 
....................  
....................    switch(flag_resp) 
005FA:  MOVF   xBE,W
005FC:  ADDLW  FB
005FE:  BTFSC  FD8.0
00600:  BRA    06E6
00602:  ADDLW  05
00604:  MOVLB  0
00606:  GOTO   07E6
....................    { 
....................       case Valid: 
....................          strResp = "OK\r\n"; 
0060A:  MOVLW  01
0060C:  MOVWF  FEA
0060E:  MOVLW  BF
00610:  MOVWF  FE9
00612:  MOVFF  FF2,1CB
00616:  BCF    FF2.7
00618:  MOVLW  00
0061A:  RCALL  00EA
0061C:  TBLRD*-
0061E:  TBLRD*+
00620:  MOVF   FF5,W
00622:  MOVWF  FEE
00624:  IORLW  00
00626:  BNZ   061E
00628:  MOVLB  1
0062A:  BTFSC  xCB.7
0062C:  BSF    FF2.7
....................          lenResp = 4; 
0062E:  MOVLW  04
00630:  MOVWF  xC9
....................          restartFlag = 1; 
00632:  MOVLW  01
00634:  MOVWF  xCA
....................          break; 
00636:  BRA    06E6
....................  
....................       case NoAp: 
....................          strResp = "No AP"; 
00638:  MOVLW  01
0063A:  MOVWF  FEA
0063C:  MOVLW  BF
0063E:  MOVWF  FE9
00640:  MOVFF  FF2,1CB
00644:  BCF    FF2.7
00646:  MOVLW  00
00648:  RCALL  0100
0064A:  TBLRD*-
0064C:  TBLRD*+
0064E:  MOVF   FF5,W
00650:  MOVWF  FEE
00652:  IORLW  00
00654:  BNZ   064C
00656:  MOVLB  1
00658:  BTFSC  xCB.7
0065A:  BSF    FF2.7
....................          lenResp = 5; 
0065C:  MOVLW  05
0065E:  MOVWF  xC9
....................          break; 
00660:  BRA    06E6
....................  
....................       case CWJAP: 
....................          strResp = "+CWJAP:"; 
00662:  MOVLW  01
00664:  MOVWF  FEA
00666:  MOVLW  BF
00668:  MOVWF  FE9
0066A:  MOVFF  FF2,1CB
0066E:  BCF    FF2.7
00670:  MOVLW  00
00672:  RCALL  0116
00674:  TBLRD*-
00676:  TBLRD*+
00678:  MOVF   FF5,W
0067A:  MOVWF  FEE
0067C:  IORLW  00
0067E:  BNZ   0676
00680:  MOVLB  1
00682:  BTFSC  xCB.7
00684:  BSF    FF2.7
....................          lenResp = 7; 
00686:  MOVLW  07
00688:  MOVWF  xC9
....................          break; 
0068A:  BRA    06E6
....................           
....................       case Connected: 
....................          strResp = "CONNECTED"; 
0068C:  MOVLW  01
0068E:  MOVWF  FEA
00690:  MOVLW  BF
00692:  MOVWF  FE9
00694:  MOVFF  FF2,1CB
00698:  BCF    FF2.7
0069A:  MOVLW  00
0069C:  RCALL  012E
0069E:  TBLRD*-
006A0:  TBLRD*+
006A2:  MOVF   FF5,W
006A4:  MOVWF  FEE
006A6:  IORLW  00
006A8:  BNZ   06A0
006AA:  MOVLB  1
006AC:  BTFSC  xCB.7
006AE:  BSF    FF2.7
....................          lenResp = 9; 
006B0:  MOVLW  09
006B2:  MOVWF  xC9
....................          break; 
006B4:  BRA    06E6
....................        
....................       case Fail: 
....................          strResp = "FAIL"; 
006B6:  MOVLW  01
006B8:  MOVWF  FEA
006BA:  MOVLW  BF
006BC:  MOVWF  FE9
006BE:  MOVFF  FF2,1CB
006C2:  BCF    FF2.7
006C4:  MOVLW  00
006C6:  RCALL  0148
006C8:  TBLRD*-
006CA:  TBLRD*+
006CC:  MOVF   FF5,W
006CE:  MOVWF  FEE
006D0:  IORLW  00
006D2:  BNZ   06CA
006D4:  MOVLB  1
006D6:  BTFSC  xCB.7
006D8:  BSF    FF2.7
....................          lenResp = 4; 
006DA:  MOVLW  04
006DC:  MOVWF  xC9
....................          restartFlag = 1; 
006DE:  MOVLW  01
006E0:  MOVWF  xCA
....................          break; 
006E2:  BRA    06E6
006E4:  MOVLB  1
....................    } 
....................  
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................  
....................    if(buffer == strResp[buffer_flag_Resp[resp_Pos][flag_resp]]) 
006E6:  MOVF   5C,W
006E8:  MULLW  06
006EA:  MOVF   FF3,W
006EC:  CLRF   xCC
006EE:  MOVWF  xCB
006F0:  CLRF   03
006F2:  MOVF   xBE,W
006F4:  ADDWF  xCB,W
006F6:  MOVWF  01
006F8:  MOVF   xCC,W
006FA:  ADDWFC 03,F
006FC:  MOVF   01,W
006FE:  ADDLW  5F
00700:  MOVWF  FE9
00702:  MOVLW  00
00704:  ADDWFC 03,W
00706:  MOVWF  FEA
00708:  CLRF   03
0070A:  MOVF   FEF,W
0070C:  ADDLW  BF
0070E:  MOVWF  FE9
00710:  MOVLW  01
00712:  ADDWFC 03,W
00714:  MOVWF  FEA
00716:  MOVF   FEF,W
00718:  SUBWF  xBD,W
0071A:  BNZ   0796
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       buffer_flag_Resp[resp_Pos][flag_resp]++; 
0071C:  MOVF   5C,W
0071E:  MULLW  06
00720:  MOVF   FF3,W
00722:  CLRF   xCC
00724:  MOVWF  xCB
00726:  CLRF   03
00728:  MOVF   xBE,W
0072A:  ADDWF  xCB,W
0072C:  MOVWF  01
0072E:  MOVF   xCC,W
00730:  ADDWFC 03,F
00732:  MOVF   01,W
00734:  ADDLW  5F
00736:  MOVWF  FE9
00738:  MOVLW  00
0073A:  ADDWFC 03,W
0073C:  MOVWF  FEA
0073E:  INCF   FEF,F
....................        
....................       if(buffer_flag_Resp[resp_Pos][flag_resp]==lenResp){ 
00740:  MOVF   5C,W
00742:  MULLW  06
00744:  MOVF   FF3,W
00746:  CLRF   xCC
00748:  MOVWF  xCB
0074A:  CLRF   03
0074C:  MOVF   xBE,W
0074E:  ADDWF  xCB,W
00750:  MOVWF  01
00752:  MOVF   xCC,W
00754:  ADDWFC 03,F
00756:  MOVF   01,W
00758:  ADDLW  5F
0075A:  MOVWF  FE9
0075C:  MOVLW  00
0075E:  ADDWFC 03,W
00760:  MOVWF  FEA
00762:  MOVF   xC9,W
00764:  SUBWF  FEF,W
00766:  BNZ   0790
....................          // Respuesta es valida 
....................          buffer_flag_Resp[resp_Flag][flag_resp]  = 1; 
00768:  MOVF   5D,W
0076A:  MULLW  06
0076C:  MOVF   FF3,W
0076E:  CLRF   xCC
00770:  MOVWF  xCB
00772:  CLRF   03
00774:  MOVF   xBE,W
00776:  ADDWF  xCB,W
00778:  MOVWF  01
0077A:  MOVF   xCC,W
0077C:  ADDWFC 03,F
0077E:  MOVF   01,W
00780:  ADDLW  5F
00782:  MOVWF  FE9
00784:  MOVLW  00
00786:  ADDWFC 03,W
00788:  MOVWF  FEA
0078A:  MOVLW  01
0078C:  MOVWF  FEF
....................       }else if(flag_resp == Valid) { 
0078E:  BRA    0794
00790:  MOVF   xBE,F
00792:  BNZ   0794
....................          // Reinicia la bandera para indicar el final del comando 
....................          //buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
....................       } 
....................         
....................    }else{ 
00794:  BRA    07E2
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       buffer_flag_Resp[resp_Pos][flag_resp]   = 0; 
00796:  MOVF   5C,W
00798:  MULLW  06
0079A:  MOVF   FF3,W
0079C:  CLRF   xCC
0079E:  MOVWF  xCB
007A0:  CLRF   03
007A2:  MOVF   xBE,W
007A4:  ADDWF  xCB,W
007A6:  MOVWF  01
007A8:  MOVF   xCC,W
007AA:  ADDWFC 03,F
007AC:  MOVF   01,W
007AE:  ADDLW  5F
007B0:  MOVWF  FE9
007B2:  MOVLW  00
007B4:  ADDWFC 03,W
007B6:  MOVWF  FEA
007B8:  CLRF   FEF
....................  
....................       // Banderas que se reinician 
....................       if(restartFlag == 1){ 
007BA:  DECFSZ xCA,W
007BC:  BRA    07E2
....................          buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
007BE:  MOVF   5D,W
007C0:  MULLW  06
007C2:  MOVF   FF3,W
007C4:  CLRF   xCC
007C6:  MOVWF  xCB
007C8:  CLRF   03
007CA:  MOVF   xBE,W
007CC:  ADDWF  xCB,W
007CE:  MOVWF  01
007D0:  MOVF   xCC,W
007D2:  ADDWFC 03,F
007D4:  MOVF   01,W
007D6:  ADDLW  5F
007D8:  MOVWF  FE9
007DA:  MOVLW  00
007DC:  ADDWFC 03,W
007DE:  MOVWF  FEA
007E0:  CLRF   FEF
....................       } 
....................        
....................    } 
007E2:  MOVLB  0
007E4:  RETURN 0
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la IP del modo AP, STA, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getIP(int buffer) 
.................... { 
....................    const int END_GET_IP_CMD = 6; 
....................     
....................    // bandera de IP_First esta habilita 
....................    if(flag_Resp_Get_IP_CMD==1){ 
*
0080A:  DECFSZ xBB,W
0080C:  BRA    0864
....................       // Fin de Get First IP 
....................       if(buffer == '"'){ 
0080E:  MOVLB  1
00810:  MOVF   xBD,W
00812:  SUBLW  22
00814:  BNZ   0832
....................          // Finaliza el almacenamiento en el buffer 
....................          if( modeStar=='1' || modeStar=='2' ){ 
00816:  MOVLB  0
00818:  MOVF   xC1,W
0081A:  SUBLW  31
0081C:  BZ    0824
0081E:  MOVF   xC1,W
00820:  SUBLW  32
00822:  BNZ   082C
....................             flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
00824:  MOVLW  06
00826:  MOVWF  xBB
....................             flag_Pos_Get_IP_CMD =0; 
00828:  CLRF   xBC
....................          }else{ 
0082A:  BRA    082E
....................             // Activa Bandera de IP_STACION, reinicia el contador de Pos 
....................             flag_Pos_Get_IP_CMD =0; 
0082C:  CLRF   xBC
....................          } 
....................  
....................       }else{ 
0082E:  BRA    0862
00830:  MOVLB  1
....................          if(modeStar=='1'){ 
00832:  MOVLB  0
00834:  MOVF   xC1,W
00836:  SUBLW  31
00838:  BNZ   084E
....................             // IP Estacion 
....................             buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
0083A:  CLRF   03
0083C:  MOVF   xBC,W
0083E:  ADDLW  7B
00840:  MOVWF  FE9
00842:  MOVLW  00
00844:  ADDWFC 03,W
00846:  MOVWF  FEA
00848:  MOVFF  1BD,FEF
....................          }else{ 
0084C:  BRA    0860
....................             // IP AP 
....................              buffer_Resp_CMD[0][flag_Pos_Get_IP_CMD] = buffer; 
0084E:  CLRF   03
00850:  MOVF   xBC,W
00852:  ADDLW  6B
00854:  MOVWF  FE9
00856:  MOVLW  00
00858:  ADDWFC 03,W
0085A:  MOVWF  FEA
0085C:  MOVFF  1BD,FEF
....................          } 
....................          flag_Pos_Get_IP_CMD++; 
00860:  INCF   xBC,F
....................       } // Fin del if(buffer == '"') 
....................     
....................    // bandera de IP_Second(Estacion) esta habilita 
....................    }else if(flag_Resp_Get_IP_CMD==5){ 
00862:  BRA    0894
00864:  MOVF   xBB,W
00866:  SUBLW  05
00868:  BNZ   0894
....................        if(buffer == '"'){ 
0086A:  MOVLB  1
0086C:  MOVF   xBD,W
0086E:  SUBLW  22
00870:  BNZ   087E
....................          flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
00872:  MOVLW  06
00874:  MOVLB  0
00876:  MOVWF  xBB
....................          flag_Pos_Get_IP_CMD =0; 
00878:  CLRF   xBC
....................        }else{ 
0087A:  BRA    0894
0087C:  MOVLB  1
....................          buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
0087E:  CLRF   03
00880:  MOVLB  0
00882:  MOVF   xBC,W
00884:  ADDLW  7B
00886:  MOVWF  FE9
00888:  MOVLW  00
0088A:  ADDWFC 03,W
0088C:  MOVWF  FEA
0088E:  MOVFF  1BD,FEF
....................          flag_Pos_Get_IP_CMD++; 
00892:  INCF   xBC,F
....................        } 
....................    } // Fin de if(flag_Resp_Get_IP_CMD) 
....................        
....................    if( buffer == '"'){ 
00894:  MOVLB  1
00896:  MOVF   xBD,W
00898:  SUBLW  22
0089A:  BNZ   08B0
....................       switch(flag_Resp_Get_IP_CMD){ 
0089C:  MOVLB  0
0089E:  MOVF   xBB,W
008A0:  ADDLW  FB
008A2:  BC    08AE
008A4:  ADDLW  05
008A6:  GOTO   08B6
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................          case 4: 
....................             flag_Resp_Get_IP_CMD++; 
008AA:  INCF   xBB,F
....................             flag_Pos_Get_IP_CMD =0; 
008AC:  CLRF   xBC
....................             break; 
008AE:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
008B0:  MOVLB  0
008B2:  GOTO   0B5C (RETURN)
.................... } // Fin de la funcion getIP() 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo AP, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getAPInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_AP_Info_CMD==1){ 
*
008DA:  DECFSZ xBD,W
008DC:  BRA    0902
....................        
....................       if(buffer != '"'){ 
008DE:  MOVLB  1
008E0:  MOVF   xBD,W
008E2:  SUBLW  22
008E4:  BZ    08FE
....................          buffer_Resp_CMD[2][flag_Pos_Get_AP_Info_CMD] = buffer; 
008E6:  CLRF   03
008E8:  MOVLB  0
008EA:  MOVF   xBE,W
008EC:  ADDLW  8B
008EE:  MOVWF  FE9
008F0:  MOVLW  00
008F2:  ADDWFC 03,W
008F4:  MOVWF  FEA
008F6:  MOVFF  1BD,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
008FA:  INCF   xBE,F
008FC:  MOVLB  1
....................       } 
....................  
....................    }else if(flag_Resp_Get_AP_Info_CMD==3){ 
008FE:  BRA    0930
00900:  MOVLB  0
00902:  MOVF   xBD,W
00904:  SUBLW  03
00906:  BNZ   092E
....................        
....................       if(buffer != '"'){ 
00908:  MOVLB  1
0090A:  MOVF   xBD,W
0090C:  SUBLW  22
0090E:  BZ    092A
....................          buffer_Resp_CMD[3][flag_Pos_Get_AP_Info_CMD] = buffer; 
00910:  CLRF   03
00912:  MOVLB  0
00914:  MOVF   xBE,W
00916:  ADDLW  9B
00918:  MOVWF  FE9
0091A:  MOVLW  00
0091C:  ADDWFC 03,W
0091E:  MOVWF  FEA
00920:  MOVFF  1BD,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
00924:  INCF   xBE,F
....................       }else{ 
00926:  BRA    092E
00928:  MOVLB  1
....................          flag_Pos_Get_AP_Info_CMD =0; 
0092A:  MOVLB  0
0092C:  CLRF   xBE
0092E:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
00930:  MOVF   xBD,W
00932:  SUBLW  22
00934:  BNZ   094A
....................       switch(flag_Resp_Get_AP_Info_CMD){ 
00936:  MOVLB  0
00938:  MOVF   xBD,W
0093A:  ADDLW  FC
0093C:  BC    0948
0093E:  ADDLW  04
00940:  GOTO   0950
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................             flag_Resp_Get_AP_Info_CMD++; 
00944:  INCF   xBD,F
....................             flag_Pos_Get_AP_Info_CMD =0; 
00946:  CLRF   xBE
....................             break; 
00948:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
0094A:  MOVLB  0
0094C:  GOTO   0B70 (RETURN)
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo STA 
....................  *     
....................  *********************************************************/ 
.................... void getSTAInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_STA_Info_CMD==1){ 
*
00972:  DECFSZ xBF,W
00974:  BRA    0994
....................        
....................       if(buffer != '"'){ 
00976:  MOVLB  1
00978:  MOVF   xBD,W
0097A:  SUBLW  22
0097C:  BZ    0996
....................          buffer_Resp_CMD[4][flag_Pos_Get_STA_Info_CMD] = buffer; 
0097E:  CLRF   03
00980:  MOVLB  0
00982:  MOVF   xC0,W
00984:  ADDLW  AB
00986:  MOVWF  FE9
00988:  MOVLW  00
0098A:  ADDWFC 03,W
0098C:  MOVWF  FEA
0098E:  MOVFF  1BD,FEF
....................          flag_Pos_Get_STA_Info_CMD++; 
00992:  INCF   xC0,F
00994:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
00996:  MOVF   xBD,W
00998:  SUBLW  22
0099A:  BNZ   09AE
....................       switch(flag_Resp_Get_STA_Info_CMD){ 
0099C:  MOVLB  0
0099E:  MOVF   xBF,W
009A0:  BZ    09A8
009A2:  XORLW  01
009A4:  BZ    09A8
009A6:  BRA    09AC
....................          case 0: 
....................          case 1: 
....................             flag_Resp_Get_STA_Info_CMD++; 
009A8:  INCF   xBF,F
....................             flag_Pos_Get_STA_Info_CMD =0; 
009AA:  CLRF   xC0
....................             break; 
009AC:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_STA_Info_CMD) 
....................    } // Fin del if(buffer == '"')  
009AE:  MOVLB  0
009B0:  GOTO   0B84 (RETURN)
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          menu.H: contiene las funciones que 
....................                           muestran y ejecutan las 
....................                           operaciones de los menus 
....................  
.................... *******************************************************/ 
....................  
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_STA_IP     0 
....................   #define OPT_SHOW_STA_SSID   1 
....................   #define OPT_SHOW_AP_SSID    2 
....................   #define OPT_SHOW_AP_KEY     3 
....................   #define OPT_SHOW_AP_IP      4 
....................   #define OPT_MODE_AP         5 
....................   #define OPT_RESET_ALL       6 
....................   #define OPT_BACKLIGH        7 
....................   #define OPT_EXIT            8 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................     #define MODE_EXIT       3 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... char  optMenuOn[10][11]            =   {{"Output 1  "}, 
....................                                         {"Output 2  "}, 
....................                                         {"Output 3  "}, 
....................                                         {"Output 4  "}, 
....................                                         {"Output 5  "}, 
....................                                         {"Output 6  "}, 
....................                                         {"Output 7  "}, 
....................                                         {"Output 8  "}, 
....................                                         {"SALIR     "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[9][17]    =  { {"ESTACION IP     "}, 
....................                                         {"ESTACION SSID   "}, 
....................                                         {"AP SSID         "}, 
....................                                         {"AP KEY          "}, 
....................                                         {"AP IP           "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"Borrar a Fabrica"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacion     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 8; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo   = 3; 
....................  
....................  
.................... /*************************************************** 
....................    Carga el nombre de las opciones del menu On y Off 
.................... ***************************************************/ 
.................... void getNameMenusOutput(){ 
*
012C6:  MOVLB  1
012C8:  CLRF   x6A
012CA:  SETF   x6B
....................    int posIni = 0; 
....................    int hasData = 0xFF; 
....................    posIni = read_eeprom(0x00); 
012CC:  MOVFF  FF2,16E
012D0:  BCF    FF2.7
012D2:  CLRF   FAA
012D4:  CLRF   FA9
012D6:  BCF    FA6.6
012D8:  BCF    FA6.7
012DA:  BSF    FA6.0
012DC:  MOVF   FA8,W
012DE:  BTFSC  x6E.7
012E0:  BSF    FF2.7
012E2:  MOVWF  x6A
....................     
....................    if(posIni!=0xFF){ 
012E4:  INCFSZ x6A,W
012E6:  BRA    12EA
012E8:  BRA    139C
....................       posIni =0; 
012EA:  CLRF   x6A
....................       for(int idx=0;idx<8;idx++){ 
012EC:  CLRF   x6C
012EE:  MOVF   x6C,W
012F0:  SUBLW  07
012F2:  BNC   1384
....................           
....................          posIni =( 10 * idx ) + 40; 
012F4:  MOVF   x6C,W
012F6:  MULLW  0A
012F8:  MOVF   FF3,W
012FA:  ADDLW  28
012FC:  MOVWF  x6A
....................          hasData = read_eeprom(posIni); 
012FE:  MOVFF  FF2,16E
01302:  BCF    FF2.7
01304:  CLRF   FAA
01306:  MOVFF  16A,FA9
0130A:  BCF    FA6.6
0130C:  BCF    FA6.7
0130E:  BSF    FA6.0
01310:  MOVF   FA8,W
01312:  BTFSC  x6E.7
01314:  BSF    FF2.7
01316:  MOVWF  x6B
....................          delay_ms(10); 
01318:  MOVLW  0A
0131A:  MOVWF  xB4
0131C:  MOVLB  0
0131E:  RCALL  0C2E
....................           
....................          if(hasData!=0xFF){ 
01320:  MOVLB  1
01322:  INCFSZ x6B,W
01324:  BRA    1328
01326:  BRA    1380
....................             for(int idxChar=0;idxChar<=9;idxChar++){ 
01328:  CLRF   x6D
0132A:  MOVF   x6D,W
0132C:  SUBLW  09
0132E:  BNC   1380
....................                optMenuOn[idx][idxChar]=read_eeprom(posIni+idxChar); 
01330:  MOVF   x6C,W
01332:  MULLW  0B
01334:  MOVF   FF3,W
01336:  CLRF   x6F
01338:  MOVWF  x6E
0133A:  CLRF   03
0133C:  MOVF   x6D,W
0133E:  ADDWF  x6E,W
01340:  MOVWF  01
01342:  MOVF   x6F,W
01344:  ADDWFC 03,F
01346:  MOVF   01,W
01348:  ADDLW  F4
0134A:  MOVWF  FE9
0134C:  MOVLW  00
0134E:  ADDWFC 03,W
01350:  MOVWF  FEA
01352:  MOVF   x6D,W
01354:  ADDWF  x6A,W
01356:  MOVWF  x70
01358:  MOVFF  FF2,171
0135C:  BCF    FF2.7
0135E:  CLRF   FAA
01360:  MOVFF  170,FA9
01364:  BCF    FA6.6
01366:  BCF    FA6.7
01368:  BSF    FA6.0
0136A:  MOVF   FA8,W
0136C:  BTFSC  x71.7
0136E:  BSF    FF2.7
01370:  MOVWF  FEF
....................                delay_ms(10); 
01372:  MOVLW  0A
01374:  MOVWF  xB4
01376:  MOVLB  0
01378:  RCALL  0C2E
0137A:  MOVLB  1
0137C:  INCF   x6D,F
0137E:  BRA    132A
....................             } 
....................          } 
01380:  INCF   x6C,F
01382:  BRA    12EE
....................       } 
....................        
....................       optMenuOn[8][0]='\f'; 
01384:  MOVLW  0C
01386:  MOVWF  x4C
....................       optMenuOn[8][1]='S'; 
01388:  MOVLW  53
0138A:  MOVWF  x4D
....................       optMenuOn[8][2]='A'; 
0138C:  MOVLW  41
0138E:  MOVWF  x4E
....................       optMenuOn[8][3]='L'; 
01390:  MOVLW  4C
01392:  MOVWF  x4F
....................       optMenuOn[8][4]='I'; 
01394:  MOVLW  49
01396:  MOVWF  x50
....................       optMenuOn[8][5]='R'; 
01398:  MOVLW  52
0139A:  MOVWF  x51
....................    }    
0139C:  MOVLB  0
0139E:  GOTO   2C4C (RETURN)
.................... } // FIn de la funcion getNameMenusOutput 
....................  
.................... /*************************************************** 
....................    Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
01FBC:  MOVLB  1
01FBE:  CLRF   x6A
01FC0:  CLRF   x6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
01FC2:  MOVF   x6A,W
01FC4:  MULLW  10
01FC6:  MOVF   FF3,W
01FC8:  CLRF   03
01FCA:  MOVWF  x6C
01FCC:  MOVLW  0C
01FCE:  MOVWF  x73
01FD0:  MOVLB  0
01FD2:  CALL   0E80
01FD6:  MOVLW  E8
01FD8:  MOVWF  FF6
01FDA:  MOVLW  02
01FDC:  MOVWF  FF7
01FDE:  MOVLB  1
01FE0:  MOVF   x6C,W
01FE2:  ADDWF  FF6,F
01FE4:  MOVLW  00
01FE6:  ADDWFC FF7,F
01FE8:  MOVLB  0
01FEA:  CALL   0EEC
....................    showBottonMenu(); 
01FEE:  CALL   13A2
....................    while(!exit){ 
01FF2:  MOVLB  1
01FF4:  MOVF   x6B,F
01FF6:  BNZ   20A2
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01FF8:  MOVLB  0
01FFA:  CALL   1466
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01FFE:  BSF    F93.4
02000:  BTFSC  F81.4
02002:  BRA    2068
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02004:  MOVLW  02
02006:  MOVLB  1
02008:  MOVWF  x6C
0200A:  MOVLW  FA
0200C:  MOVWF  xB4
0200E:  MOVLB  0
02010:  CALL   0C2E
02014:  MOVLB  1
02016:  DECFSZ x6C,F
02018:  BRA    200A
....................          BEEP; 
0201A:  MOVLW  04
0201C:  MOVWF  x71
0201E:  MOVLW  B9
02020:  MOVWF  x70
02022:  CLRF   x73
02024:  MOVLW  14
02026:  MOVWF  x72
02028:  MOVLB  0
0202A:  RCALL  1E74
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0202C:  MOVLB  1
0202E:  INCF   x6A,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuStart){ 
02030:  MOVF   x6A,W
02032:  SUBWF  x62,W
02034:  BC    2038
....................             optSelected = 0; 
02036:  CLRF   x6A
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
02038:  MOVF   x6A,W
0203A:  MULLW  10
0203C:  MOVF   FF3,W
0203E:  CLRF   03
02040:  MOVWF  x6C
02042:  MOVLW  0C
02044:  MOVWF  x73
02046:  MOVLB  0
02048:  CALL   0E80
0204C:  MOVLW  E8
0204E:  MOVWF  FF6
02050:  MOVLW  02
02052:  MOVWF  FF7
02054:  MOVLB  1
02056:  MOVF   x6C,W
02058:  ADDWF  FF6,F
0205A:  MOVLW  00
0205C:  ADDWFC FF7,F
0205E:  MOVLB  0
02060:  CALL   0EEC
....................          showBottonMenu(); 
02064:  CALL   13A2
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
02068:  BSF    F93.5
0206A:  BTFSC  F81.5
0206C:  BRA    209E
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0206E:  MOVLW  02
02070:  MOVLB  1
02072:  MOVWF  x6C
02074:  MOVLW  FA
02076:  MOVWF  xB4
02078:  MOVLB  0
0207A:  CALL   0C2E
0207E:  MOVLB  1
02080:  DECFSZ x6C,F
02082:  BRA    2074
....................          BEEP; 
02084:  MOVLW  04
02086:  MOVWF  x71
02088:  MOVLW  B9
0208A:  MOVWF  x70
0208C:  CLRF   x73
0208E:  MOVLW  14
02090:  MOVWF  x72
02092:  MOVLB  0
02094:  RCALL  1E74
....................          // Rompe el Loop 
....................          exit = 1; 
02096:  MOVLW  01
02098:  MOVLB  1
0209A:  MOVWF  x6B
0209C:  MOVLB  0
....................       } // Fin KEY_OK 
0209E:  BRA    1FF2
020A0:  MOVLB  1
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
020A2:  MOVLW  01
020A4:  ADDWF  x6A,W
020A6:  MOVWF  01
020A8:  MOVLB  0
020AA:  GOTO   2C68 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
*
023A0:  MOVLB  1
023A2:  CLRF   x70
....................   int exit=0; 
....................   lcd_gotoxy(12,2); 
023A4:  MOVLW  0C
023A6:  MOVWF  x74
023A8:  MOVLW  02
023AA:  MOVWF  x75
023AC:  MOVLB  0
023AE:  CALL   0E5A
....................   printf(lcd_putc, "SALIR"); 
023B2:  MOVLW  08
023B4:  MOVWF  FF6
023B6:  MOVLW  04
023B8:  MOVWF  FF7
023BA:  CALL   0EEC
....................    
....................   while(exit==0){ 
023BE:  MOVLB  1
023C0:  MOVF   x70,F
023C2:  BNZ   23F0
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
023C4:  MOVLB  0
023C6:  CALL   1466
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
023CA:  BSF    F93.5
023CC:  BTFSC  F81.5
023CE:  BRA    23EC
....................            // Elimina el rebote 
....................            delay_ms(500); 
023D0:  MOVLW  02
023D2:  MOVLB  1
023D4:  MOVWF  x71
023D6:  MOVLW  FA
023D8:  MOVWF  xB4
023DA:  MOVLB  0
023DC:  CALL   0C2E
023E0:  MOVLB  1
023E2:  DECFSZ x71,F
023E4:  BRA    23D6
....................            exit=1; 
023E6:  MOVLW  01
023E8:  MOVWF  x70
023EA:  MOVLB  0
....................            //break; 
....................      } 
023EC:  BRA    23BE
023EE:  MOVLB  1
....................   } 
023F0:  MOVLB  0
023F2:  RETURN 0
.................... } // Fin de la funcion pressExit 
.................... /*************************************************** 
....................    Dibuja en la parte inferior del Display los botones de 
....................    Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
013A2:  MOVLW  01
013A4:  MOVLB  1
013A6:  MOVWF  x74
013A8:  MOVLW  02
013AA:  MOVWF  x75
013AC:  MOVLB  0
013AE:  RCALL  0E5A
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
013B0:  MOVLW  0E
013B2:  MOVWF  FF6
013B4:  MOVLW  04
013B6:  MOVWF  FF7
013B8:  RCALL  0EEC
013BA:  RETURN 0
.................... } 
....................  
.................... /*************************************************** 
....................    Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
020FE:  MOVLB  1
02100:  CLRF   x6A
02102:  CLRF   x6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\fOn -> %s",optMenuOn[optSelected]); 
02104:  MOVF   x6A,W
02106:  MULLW  0B
02108:  MOVF   FF3,W
0210A:  CLRF   03
0210C:  ADDLW  F4
0210E:  MOVWF  01
02110:  MOVLW  00
02112:  ADDWFC 03,F
02114:  MOVFF  01,16C
02118:  MOVFF  03,16D
0211C:  MOVLW  20
0211E:  MOVWF  FF6
02120:  MOVLW  04
02122:  MOVWF  FF7
02124:  MOVLW  07
02126:  MOVWF  x6E
02128:  MOVLB  0
0212A:  RCALL  20AE
0212C:  MOVFF  16D,FEA
02130:  MOVFF  16C,FE9
02134:  RCALL  20D8
....................    showBottonMenu(); 
02136:  CALL   13A2
....................     
....................    while(!exit){ 
0213A:  MOVLB  1
0213C:  MOVF   x6B,F
0213E:  BTFSS  FD8.2
02140:  BRA    2246
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02142:  MOVLB  0
02144:  CALL   1466
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
02148:  BSF    F93.4
0214A:  BTFSC  F81.4
0214C:  BRA    21B8
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0214E:  MOVLW  02
02150:  MOVLB  1
02152:  MOVWF  x6C
02154:  MOVLW  FA
02156:  MOVWF  xB4
02158:  MOVLB  0
0215A:  CALL   0C2E
0215E:  MOVLB  1
02160:  DECFSZ x6C,F
02162:  BRA    2154
....................          BEEP; 
02164:  MOVLW  04
02166:  MOVWF  x71
02168:  MOVLW  B9
0216A:  MOVWF  x70
0216C:  CLRF   x73
0216E:  MOVLW  14
02170:  MOVWF  x72
02172:  MOVLB  0
02174:  RCALL  1E74
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
02176:  MOVLB  1
02178:  INCF   x6A,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
0217A:  MOVF   x6A,W
0217C:  SUBWF  x63,W
0217E:  BC    2182
....................             optSelected = 0; 
02180:  CLRF   x6A
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\fOn -> %s",optMenuOn[optSelected]); 
02182:  MOVF   x6A,W
02184:  MULLW  0B
02186:  MOVF   FF3,W
02188:  CLRF   03
0218A:  ADDLW  F4
0218C:  MOVWF  01
0218E:  MOVLW  00
02190:  ADDWFC 03,F
02192:  MOVFF  01,16C
02196:  MOVFF  03,16D
0219A:  MOVLW  2A
0219C:  MOVWF  FF6
0219E:  MOVLW  04
021A0:  MOVWF  FF7
021A2:  MOVLW  07
021A4:  MOVWF  x6E
021A6:  MOVLB  0
021A8:  RCALL  20AE
021AA:  MOVFF  16D,FEA
021AE:  MOVFF  16C,FE9
021B2:  RCALL  20D8
....................          showBottonMenu(); 
021B4:  CALL   13A2
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
021B8:  BSF    F93.5
021BA:  BTFSC  F81.5
021BC:  BRA    2242
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
021BE:  MOVLW  02
021C0:  MOVLB  1
021C2:  MOVWF  x6C
021C4:  MOVLW  FA
021C6:  MOVWF  xB4
021C8:  MOVLB  0
021CA:  CALL   0C2E
021CE:  MOVLB  1
021D0:  DECFSZ x6C,F
021D2:  BRA    21C4
....................          BEEP; 
021D4:  MOVLW  04
021D6:  MOVWF  x71
021D8:  MOVLW  B9
021DA:  MOVWF  x70
021DC:  CLRF   x73
021DE:  MOVLW  14
021E0:  MOVWF  x72
021E2:  MOVLB  0
021E4:  RCALL  1E74
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuOn){ 
021E6:  MOVLB  1
021E8:  MOVF   x63,W
021EA:  SUBWF  x6A,W
021EC:  BNZ   21F4
....................             exit = 1; 
021EE:  MOVLW  01
021F0:  MOVWF  x6B
....................          }else{ 
021F2:  BRA    2244
....................             output_high(PIN_OUT[optSelected]); 
021F4:  BCF    FD8.0
021F6:  RLCF   x6A,W
021F8:  CLRF   03
021FA:  MOVFF  FF2,16C
021FE:  BCF    FF2.7
02200:  MOVLB  0
02202:  CALL   0096
02206:  TBLRD*+
02208:  MOVFF  FF5,03
0220C:  MOVLB  1
0220E:  BTFSC  x6C.7
02210:  BSF    FF2.7
02212:  MOVWF  x6C
02214:  MOVFF  03,16D
02218:  MOVWF  xB5
0221A:  MOVLW  01
0221C:  MOVWF  xB6
0221E:  MOVLW  0F
02220:  MOVWF  xB8
02222:  MOVLW  89
02224:  MOVWF  xB7
02226:  MOVLB  0
02228:  CALL   0BEC
0222C:  MOVFF  16C,1B5
02230:  MOVLB  1
02232:  CLRF   xB6
02234:  MOVLW  0F
02236:  MOVWF  xB8
02238:  MOVLW  92
0223A:  MOVWF  xB7
0223C:  MOVLB  0
0223E:  CALL   0BEC
02242:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
02244:  BRA    213C
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02246:  MOVLW  00
02248:  MOVWF  01
0224A:  MOVLB  0
0224C:  GOTO   2C74 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
....................    Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
02250:  MOVLB  1
02252:  CLRF   x6A
02254:  CLRF   x6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\fOff-> %s",optMenuOn[optSelected]); 
02256:  MOVF   x6A,W
02258:  MULLW  0B
0225A:  MOVF   FF3,W
0225C:  CLRF   03
0225E:  ADDLW  F4
02260:  MOVWF  01
02262:  MOVLW  00
02264:  ADDWFC 03,F
02266:  MOVFF  01,16C
0226A:  MOVFF  03,16D
0226E:  MOVLW  34
02270:  MOVWF  FF6
02272:  MOVLW  04
02274:  MOVWF  FF7
02276:  MOVLW  07
02278:  MOVWF  x6E
0227A:  MOVLB  0
0227C:  RCALL  20AE
0227E:  MOVFF  16D,FEA
02282:  MOVFF  16C,FE9
02286:  RCALL  20D8
....................    showBottonMenu(); 
02288:  CALL   13A2
....................     
....................    while(!exit){ 
0228C:  MOVLB  1
0228E:  MOVF   x6B,F
02290:  BTFSS  FD8.2
02292:  BRA    2396
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02294:  MOVLB  0
02296:  CALL   1466
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0229A:  BSF    F93.4
0229C:  BTFSC  F81.4
0229E:  BRA    230A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
022A0:  MOVLW  02
022A2:  MOVLB  1
022A4:  MOVWF  x6C
022A6:  MOVLW  FA
022A8:  MOVWF  xB4
022AA:  MOVLB  0
022AC:  CALL   0C2E
022B0:  MOVLB  1
022B2:  DECFSZ x6C,F
022B4:  BRA    22A6
....................          BEEP; 
022B6:  MOVLW  04
022B8:  MOVWF  x71
022BA:  MOVLW  B9
022BC:  MOVWF  x70
022BE:  CLRF   x73
022C0:  MOVLW  14
022C2:  MOVWF  x72
022C4:  MOVLB  0
022C6:  RCALL  1E74
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
022C8:  MOVLB  1
022CA:  INCF   x6A,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
022CC:  MOVF   x6A,W
022CE:  SUBWF  x64,W
022D0:  BC    22D4
....................             optSelected = 0; 
022D2:  CLRF   x6A
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\fOff-> %s",optMenuOn[optSelected]); 
022D4:  MOVF   x6A,W
022D6:  MULLW  0B
022D8:  MOVF   FF3,W
022DA:  CLRF   03
022DC:  ADDLW  F4
022DE:  MOVWF  01
022E0:  MOVLW  00
022E2:  ADDWFC 03,F
022E4:  MOVFF  01,16C
022E8:  MOVFF  03,16D
022EC:  MOVLW  3E
022EE:  MOVWF  FF6
022F0:  MOVLW  04
022F2:  MOVWF  FF7
022F4:  MOVLW  07
022F6:  MOVWF  x6E
022F8:  MOVLB  0
022FA:  RCALL  20AE
022FC:  MOVFF  16D,FEA
02300:  MOVFF  16C,FE9
02304:  RCALL  20D8
....................          showBottonMenu(); 
02306:  CALL   13A2
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0230A:  BSF    F93.5
0230C:  BTFSC  F81.5
0230E:  BRA    2392
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02310:  MOVLW  02
02312:  MOVLB  1
02314:  MOVWF  x6C
02316:  MOVLW  FA
02318:  MOVWF  xB4
0231A:  MOVLB  0
0231C:  CALL   0C2E
02320:  MOVLB  1
02322:  DECFSZ x6C,F
02324:  BRA    2316
....................          BEEP; 
02326:  MOVLW  04
02328:  MOVWF  x71
0232A:  MOVLW  B9
0232C:  MOVWF  x70
0232E:  CLRF   x73
02330:  MOVLW  14
02332:  MOVWF  x72
02334:  MOVLB  0
02336:  RCALL  1E74
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuOff){ 
02338:  MOVLB  1
0233A:  MOVF   x64,W
0233C:  SUBWF  x6A,W
0233E:  BNZ   2346
....................             exit = 1; 
02340:  MOVLW  01
02342:  MOVWF  x6B
....................          }else{ 
02344:  BRA    2394
....................             output_low(PIN_OUT[optSelected]); 
02346:  BCF    FD8.0
02348:  RLCF   x6A,W
0234A:  CLRF   03
0234C:  MOVFF  FF2,16C
02350:  BCF    FF2.7
02352:  MOVLB  0
02354:  CALL   0096
02358:  TBLRD*+
0235A:  MOVFF  FF5,03
0235E:  MOVLB  1
02360:  BTFSC  x6C.7
02362:  BSF    FF2.7
02364:  MOVWF  x6C
02366:  MOVFF  03,16D
0236A:  MOVWF  xB5
0236C:  CLRF   xB6
0236E:  MOVLW  0F
02370:  MOVWF  xB8
02372:  MOVLW  89
02374:  MOVWF  xB7
02376:  MOVLB  0
02378:  CALL   0BEC
0237C:  MOVFF  16C,1B5
02380:  MOVLB  1
02382:  CLRF   xB6
02384:  MOVLW  0F
02386:  MOVWF  xB8
02388:  MOVLW  92
0238A:  MOVWF  xB7
0238C:  MOVLB  0
0238E:  CALL   0BEC
02392:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
02394:  BRA    228E
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02396:  MOVLW  00
02398:  MOVWF  01
0239A:  MOVLB  0
0239C:  GOTO   2C80 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
....................    Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
*
0290E:  MOVLB  1
02910:  CLRF   x6A
02912:  CLRF   x6B
....................  
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02914:  MOVF   x6A,W
02916:  MULLW  11
02918:  MOVF   FF3,W
0291A:  CLRF   03
0291C:  MOVWF  x6C
0291E:  MOVLW  0C
02920:  MOVWF  x73
02922:  MOVLB  0
02924:  CALL   0E80
02928:  MOVLW  28
0292A:  MOVWF  FF6
0292C:  MOVLW  03
0292E:  MOVWF  FF7
02930:  MOVLB  1
02932:  MOVF   x6C,W
02934:  ADDWF  FF6,F
02936:  MOVLW  00
02938:  ADDWFC FF7,F
0293A:  MOVLB  0
0293C:  CALL   0EEC
....................    showBottonMenu(); 
02940:  CALL   13A2
....................     
....................    while(!exit){ 
02944:  MOVLB  1
02946:  MOVF   x6B,F
02948:  BTFSS  FD8.2
0294A:  BRA    2A3A
....................  
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
0294C:  MOVLB  0
0294E:  CALL   1466
....................       /********************************************/ 
....................     
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
02952:  BSF    F93.4
02954:  BTFSC  F81.4
02956:  BRA    29BE
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02958:  MOVLW  02
0295A:  MOVLB  1
0295C:  MOVWF  x6C
0295E:  MOVLW  FA
02960:  MOVWF  xB4
02962:  MOVLB  0
02964:  CALL   0C2E
02968:  MOVLB  1
0296A:  DECFSZ x6C,F
0296C:  BRA    295E
....................          BEEP; 
0296E:  MOVLW  04
02970:  MOVWF  x71
02972:  MOVLW  B9
02974:  MOVWF  x70
02976:  CLRF   x73
02978:  MOVLW  14
0297A:  MOVWF  x72
0297C:  MOVLB  0
0297E:  CALL   1E74
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
02982:  MOVLB  1
02984:  INCF   x6A,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuSetup){ 
02986:  MOVF   x6A,W
02988:  SUBWF  x65,W
0298A:  BC    298E
....................             optSelected = 0; 
0298C:  CLRF   x6A
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0298E:  MOVF   x6A,W
02990:  MULLW  11
02992:  MOVF   FF3,W
02994:  CLRF   03
02996:  MOVWF  x6C
02998:  MOVLW  0C
0299A:  MOVWF  x73
0299C:  MOVLB  0
0299E:  CALL   0E80
029A2:  MOVLW  28
029A4:  MOVWF  FF6
029A6:  MOVLW  03
029A8:  MOVWF  FF7
029AA:  MOVLB  1
029AC:  MOVF   x6C,W
029AE:  ADDWF  FF6,F
029B0:  MOVLW  00
029B2:  ADDWFC FF7,F
029B4:  MOVLB  0
029B6:  CALL   0EEC
....................          showBottonMenu(); 
029BA:  CALL   13A2
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
029BE:  BSF    F93.5
029C0:  BTFSC  F81.5
029C2:  BRA    2A36
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
029C4:  MOVLW  02
029C6:  MOVLB  1
029C8:  MOVWF  x6C
029CA:  MOVLW  FA
029CC:  MOVWF  xB4
029CE:  MOVLB  0
029D0:  CALL   0C2E
029D4:  MOVLB  1
029D6:  DECFSZ x6C,F
029D8:  BRA    29CA
....................          BEEP; 
029DA:  MOVLW  04
029DC:  MOVWF  x71
029DE:  MOVLW  B9
029E0:  MOVWF  x70
029E2:  CLRF   x73
029E4:  MOVLW  14
029E6:  MOVWF  x72
029E8:  MOVLB  0
029EA:  CALL   1E74
....................           
....................          // Si optSelected = countOptMenuSetup entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuSetup){ 
029EE:  MOVLB  1
029F0:  MOVF   x65,W
029F2:  SUBWF  x6A,W
029F4:  BNZ   29FC
....................             exit = 1; 
029F6:  MOVLW  01
029F8:  MOVWF  x6B
....................          }else{ 
029FA:  BRA    2A38
....................             executeSetup(optSelected); 
029FC:  MOVFF  16A,16C
02A00:  MOVLB  0
02A02:  BRA    2650
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02A04:  MOVLB  1
02A06:  MOVF   x6A,W
02A08:  MULLW  11
02A0A:  MOVF   FF3,W
02A0C:  CLRF   03
02A0E:  MOVWF  x6C
02A10:  MOVLW  0C
02A12:  MOVWF  x73
02A14:  MOVLB  0
02A16:  CALL   0E80
02A1A:  MOVLW  28
02A1C:  MOVWF  FF6
02A1E:  MOVLW  03
02A20:  MOVWF  FF7
02A22:  MOVLB  1
02A24:  MOVF   x6C,W
02A26:  ADDWF  FF6,F
02A28:  MOVLW  00
02A2A:  ADDWFC FF7,F
02A2C:  MOVLB  0
02A2E:  CALL   0EEC
....................             showBottonMenu(); 
02A32:  CALL   13A2
02A36:  MOVLB  1
....................          } 
....................       } // Fin KEY_OK 
02A38:  BRA    2946
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02A3A:  MOVLW  00
02A3C:  MOVWF  01
02A3E:  MOVLB  0
02A40:  GOTO   2C8A (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
....................    Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................     
....................    
....................   switch(optSelect){ 
*
02650:  MOVLB  1
02652:  MOVF   x6C,W
02654:  ADDLW  F7
02656:  BTFSC  FD8.0
02658:  BRA    28C0
0265A:  ADDLW  09
0265C:  MOVLB  0
0265E:  GOTO   28D8
....................    
....................      case OPT_SHOW_AP_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
02662:  MOVLW  48
02664:  MOVWF  FF6
02666:  MOVLW  04
02668:  MOVWF  FF7
0266A:  CALL   0C56
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
0266E:  MOVLW  05
02670:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
02672:  MOVLW  54
02674:  MOVWF  FF6
02676:  MOVLW  04
02678:  MOVWF  FF7
0267A:  CALL   0EEC
....................         waitResp(); 
0267E:  CALL   0F36
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[0]); 
02682:  MOVLW  0C
02684:  MOVLB  1
02686:  MOVWF  x73
02688:  MOVLB  0
0268A:  CALL   0E80
0268E:  CLRF   FEA
02690:  MOVLW  6B
02692:  MOVWF  FE9
02694:  RCALL  20D8
....................         flag_Resp_Get_IP_CMD = 0; 
02696:  CLRF   xBB
....................         break; 
02698:  MOVLB  1
0269A:  BRA    28C0
....................          
....................      case OPT_SHOW_STA_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
0269C:  MOVLW  62
0269E:  MOVWF  FF6
026A0:  MOVLW  04
026A2:  MOVWF  FF7
026A4:  CALL   0C56
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
026A8:  MOVLW  05
026AA:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
026AC:  MOVLW  6E
026AE:  MOVWF  FF6
026B0:  MOVLW  04
026B2:  MOVWF  FF7
026B4:  CALL   0EEC
....................         waitResp(); 
026B8:  CALL   0F36
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[1]); 
026BC:  MOVLW  0C
026BE:  MOVLB  1
026C0:  MOVWF  x73
026C2:  MOVLB  0
026C4:  CALL   0E80
026C8:  CLRF   FEA
026CA:  MOVLW  7B
026CC:  MOVWF  FE9
026CE:  RCALL  20D8
....................         flag_Resp_Get_IP_CMD = 0; 
026D0:  CLRF   xBB
....................         break; 
026D2:  MOVLB  1
026D4:  BRA    28C0
....................          
....................      case OPT_SHOW_STA_SSID: 
....................         if(modeStar!='2'){ 
026D6:  MOVF   xC1,W
026D8:  SUBLW  32
026DA:  BZ    2714
....................            fprintf(ESP8266, "AT+CWJAP?\r\n"); 
026DC:  MOVLW  7C
026DE:  MOVWF  FF6
026E0:  MOVLW  04
026E2:  MOVWF  FF7
026E4:  CALL   0C56
....................            CMD_RUN = CMD_GET_STA_INFO_FROM_MENU; 
026E8:  MOVLW  07
026EA:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
026EC:  MOVLW  88
026EE:  MOVWF  FF6
026F0:  MOVLW  04
026F2:  MOVWF  FF7
026F4:  CALL   0EEC
....................            waitResp(); 
026F8:  CALL   0F36
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[4]); 
026FC:  MOVLW  0C
026FE:  MOVLB  1
02700:  MOVWF  x73
02702:  MOVLB  0
02704:  CALL   0E80
02708:  CLRF   FEA
0270A:  MOVLW  AB
0270C:  MOVWF  FE9
0270E:  RCALL  20D8
....................            flag_Resp_Get_STA_Info_CMD=0; 
02710:  CLRF   xBF
....................         }else{ 
02712:  BRA    2720
....................            printf(lcd_putc, "\fDeshabilitado"); 
02714:  MOVLW  96
02716:  MOVWF  FF6
02718:  MOVLW  04
0271A:  MOVWF  FF7
0271C:  CALL   0EEC
....................         } 
....................         break; 
02720:  MOVLB  1
02722:  BRA    28C0
....................          
....................      case OPT_SHOW_AP_SSID: 
....................         if(modeStar!='1'){ 
02724:  MOVF   xC1,W
02726:  SUBLW  31
02728:  BZ    2762
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
0272A:  MOVLW  A6
0272C:  MOVWF  FF6
0272E:  MOVLW  04
02730:  MOVWF  FF7
02732:  CALL   0C56
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
02736:  MOVLW  06
02738:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
0273A:  MOVLW  B2
0273C:  MOVWF  FF6
0273E:  MOVLW  04
02740:  MOVWF  FF7
02742:  CALL   0EEC
....................            waitResp(); 
02746:  CALL   0F36
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[2]); 
0274A:  MOVLW  0C
0274C:  MOVLB  1
0274E:  MOVWF  x73
02750:  MOVLB  0
02752:  CALL   0E80
02756:  CLRF   FEA
02758:  MOVLW  8B
0275A:  MOVWF  FE9
0275C:  RCALL  20D8
....................            flag_Resp_Get_AP_Info_CMD=0; 
0275E:  CLRF   xBD
....................         }else{ 
02760:  BRA    276E
....................            printf(lcd_putc, "\fDeshabilitado"); 
02762:  MOVLW  C0
02764:  MOVWF  FF6
02766:  MOVLW  04
02768:  MOVWF  FF7
0276A:  CALL   0EEC
....................         } 
....................         break; 
0276E:  MOVLB  1
02770:  BRA    28C0
....................          
....................      case OPT_SHOW_AP_KEY: 
....................         if(modeStar!='1'){ 
02772:  MOVF   xC1,W
02774:  SUBLW  31
02776:  BZ    27B0
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
02778:  MOVLW  D0
0277A:  MOVWF  FF6
0277C:  MOVLW  04
0277E:  MOVWF  FF7
02780:  CALL   0C56
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
02784:  MOVLW  06
02786:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
02788:  MOVLW  DC
0278A:  MOVWF  FF6
0278C:  MOVLW  04
0278E:  MOVWF  FF7
02790:  CALL   0EEC
....................            waitResp(); 
02794:  CALL   0F36
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[3]); 
02798:  MOVLW  0C
0279A:  MOVLB  1
0279C:  MOVWF  x73
0279E:  MOVLB  0
027A0:  CALL   0E80
027A4:  CLRF   FEA
027A6:  MOVLW  9B
027A8:  MOVWF  FE9
027AA:  RCALL  20D8
....................            flag_Resp_Get_AP_Info_CMD=0; 
027AC:  CLRF   xBD
....................         }else{ 
027AE:  BRA    27BC
....................            printf(lcd_putc, "\fDeshabilitado"); 
027B0:  MOVLW  EA
027B2:  MOVWF  FF6
027B4:  MOVLW  04
027B6:  MOVWF  FF7
027B8:  CALL   0EEC
....................         } 
....................         break; 
027BC:  MOVLB  1
027BE:  BRA    28C0
....................          
....................      case OPT_RESET_ALL: 
....................          printf(lcd_putc, "\fBorrando EEEPROM"); 
027C0:  MOVLW  FA
027C2:  MOVWF  FF6
027C4:  MOVLW  04
027C6:  MOVWF  FF7
027C8:  CALL   0EEC
....................          for(int idxNC=0x00;idxNC<=0x6E;idxNC++){ 
027CC:  MOVLB  1
027CE:  CLRF   x6D
027D0:  MOVF   x6D,W
027D2:  SUBLW  6E
027D4:  BNC   2812
....................             write_eeprom(idxNC,0xFF); 
027D6:  MOVF   FF2,W
027D8:  MOVWF  00
027DA:  BCF    FF2.7
027DC:  CLRF   FAA
027DE:  MOVFF  16D,FA9
027E2:  SETF   FA8
027E4:  BCF    FA6.6
027E6:  BCF    FA6.7
027E8:  BSF    FA6.2
027EA:  MOVLB  F
027EC:  MOVLW  55
027EE:  MOVWF  FA7
027F0:  MOVLW  AA
027F2:  MOVWF  FA7
027F4:  BSF    FA6.1
027F6:  BTFSC  FA6.1
027F8:  BRA    27F6
027FA:  BCF    FA6.2
027FC:  MOVF   00,W
027FE:  IORWF  FF2,F
....................             delay_ms(10); 
02800:  MOVLW  0A
02802:  MOVLB  1
02804:  MOVWF  xB4
02806:  MOVLB  0
02808:  CALL   0C2E
0280C:  MOVLB  1
0280E:  INCF   x6D,F
02810:  BRA    27D0
....................          } 
....................          printf(lcd_putc, "\fBorrando RED"); 
02812:  MOVLW  0C
02814:  MOVWF  FF6
02816:  MOVLW  05
02818:  MOVWF  FF7
0281A:  MOVLB  0
0281C:  CALL   0EEC
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
02820:  MOVLW  1A
02822:  MOVWF  FF6
02824:  MOVLW  05
02826:  MOVWF  FF7
02828:  CALL   0C56
....................          delay_ms(1000); 
0282C:  MOVLW  04
0282E:  MOVLB  1
02830:  MOVWF  x6E
02832:  MOVLW  FA
02834:  MOVWF  xB4
02836:  MOVLB  0
02838:  CALL   0C2E
0283C:  MOVLB  1
0283E:  DECFSZ x6E,F
02840:  BRA    2832
....................          fprintf(ESP8266, "AT+RST\n\r"); 
02842:  MOVLW  26
02844:  MOVWF  FF6
02846:  MOVLW  05
02848:  MOVWF  FF7
0284A:  MOVLB  0
0284C:  CALL   0C56
....................          delay_ms(2000); 
02850:  MOVLW  08
02852:  MOVLB  1
02854:  MOVWF  x6E
02856:  MOVLW  FA
02858:  MOVWF  xB4
0285A:  MOVLB  0
0285C:  CALL   0C2E
02860:  MOVLB  1
02862:  DECFSZ x6E,F
02864:  BRA    2856
....................          fprintf(ESP8266, "AT+CWSAP_DEF=\"Kriver SmartHome\",\"kriver56106\",1,4\r\n"); 
02866:  MOVLW  30
02868:  MOVWF  FF6
0286A:  MOVLW  05
0286C:  MOVWF  FF7
0286E:  MOVLB  0
02870:  CALL   0C56
....................          delay_ms(2000); 
02874:  MOVLW  08
02876:  MOVLB  1
02878:  MOVWF  x6E
0287A:  MOVLW  FA
0287C:  MOVWF  xB4
0287E:  MOVLB  0
02880:  CALL   0C2E
02884:  MOVLB  1
02886:  DECFSZ x6E,F
02888:  BRA    287A
....................          reset_cpu(); 
0288A:  RESET
....................         break; 
0288C:  BRA    28C0
....................      
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
0288E:  BRA    23F4
....................         break; 
02890:  MOVLB  1
02892:  BRA    28C0
....................          
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
02894:  BCF    F95.3
02896:  BTG    F8C.3
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
02898:  BTFSS  F83.3
0289A:  BRA    28AA
....................            printf(lcd_putc, "\fBacklight On"); 
0289C:  MOVLW  64
0289E:  MOVWF  FF6
028A0:  MOVLW  05
028A2:  MOVWF  FF7
028A4:  CALL   0EEC
....................         }else{ 
028A8:  BRA    28B6
....................            printf(lcd_putc, "\fBacklight Off"); 
028AA:  MOVLW  72
028AC:  MOVWF  FF6
028AE:  MOVLW  05
028B0:  MOVWF  FF7
028B2:  CALL   0EEC
....................         } 
....................         break; 
028B6:  MOVLB  1
028B8:  BRA    28C0
....................          
....................      case OPT_EXIT: 
....................         break; 
028BA:  MOVLB  1
028BC:  BRA    28C0
028BE:  MOVLB  1
....................          
....................   } 
....................    
....................   if(optSelect!=OPT_EXIT && optSelect!=OPT_MODE_AP){ 
028C0:  MOVF   x6C,W
028C2:  SUBLW  08
028C4:  BZ    28D2
028C6:  MOVF   x6C,W
028C8:  SUBLW  05
028CA:  BZ    28D2
....................    pressExit(); 
028CC:  MOVLB  0
028CE:  RCALL  23A0
028D0:  MOVLB  1
....................   } 
028D2:  MOVLB  0
028D4:  GOTO   2A04 (RETURN)
.................... } 
....................    
.................... /*************************************************** 
....................    Despliega el menu MODE 
.................... ***************************************************/ 
.................... void setMenuModo(void){ 
*
023F4:  MOVLB  1
023F6:  CLRF   x6E
023F8:  CLRF   x6F
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
023FA:  MOVF   x6E,W
023FC:  MULLW  0E
023FE:  MOVF   FF3,W
02400:  CLRF   03
02402:  MOVWF  x70
02404:  MOVLW  0C
02406:  MOVWF  x73
02408:  MOVLB  0
0240A:  CALL   0E80
0240E:  MOVLW  C2
02410:  MOVWF  FF6
02412:  MOVLW  03
02414:  MOVWF  FF7
02416:  MOVLB  1
02418:  MOVF   x70,W
0241A:  ADDWF  FF6,F
0241C:  MOVLW  00
0241E:  ADDWFC FF7,F
02420:  MOVLB  0
02422:  CALL   0EEC
....................   showBottonMenu(); 
02426:  CALL   13A2
....................    
....................   while(exit==0){ 
0242A:  MOVLB  1
0242C:  MOVF   x6F,F
0242E:  BTFSS  FD8.2
02430:  BRA    261E
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02432:  MOVLB  0
02434:  CALL   1466
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
02438:  BSF    F93.4
0243A:  BTFSC  F81.4
0243C:  BRA    24A2
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
0243E:  MOVLW  02
02440:  MOVLB  1
02442:  MOVWF  x70
02444:  MOVLW  FA
02446:  MOVWF  xB4
02448:  MOVLB  0
0244A:  CALL   0C2E
0244E:  MOVLB  1
02450:  DECFSZ x70,F
02452:  BRA    2444
....................         BEEP; 
02454:  MOVLW  04
02456:  MOVWF  x71
02458:  MOVLW  B9
0245A:  MOVWF  x70
0245C:  CLRF   x73
0245E:  MOVLW  14
02460:  MOVWF  x72
02462:  MOVLB  0
02464:  RCALL  1E74
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
02466:  MOVLB  1
02468:  INCF   x6E,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
0246A:  MOVF   x6E,W
0246C:  SUBWF  x66,W
0246E:  BC    2472
....................            optSelected = 0; 
02470:  CLRF   x6E
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
02472:  MOVF   x6E,W
02474:  MULLW  0E
02476:  MOVF   FF3,W
02478:  CLRF   03
0247A:  MOVWF  x70
0247C:  MOVLW  0C
0247E:  MOVWF  x73
02480:  MOVLB  0
02482:  CALL   0E80
02486:  MOVLW  C2
02488:  MOVWF  FF6
0248A:  MOVLW  03
0248C:  MOVWF  FF7
0248E:  MOVLB  1
02490:  MOVF   x70,W
02492:  ADDWF  FF6,F
02494:  MOVLW  00
02496:  ADDWFC FF7,F
02498:  MOVLB  0
0249A:  CALL   0EEC
....................         showBottonMenu(); 
0249E:  CALL   13A2
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
024A2:  BSF    F93.5
024A4:  BTFSC  F81.5
024A6:  BRA    261A
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
024A8:  MOVLW  02
024AA:  MOVLB  1
024AC:  MOVWF  x70
024AE:  MOVLW  FA
024B0:  MOVWF  xB4
024B2:  MOVLB  0
024B4:  CALL   0C2E
024B8:  MOVLB  1
024BA:  DECFSZ x70,F
024BC:  BRA    24AE
....................         BEEP; 
024BE:  MOVLW  04
024C0:  MOVWF  x71
024C2:  MOVLW  B9
024C4:  MOVWF  x70
024C6:  CLRF   x73
024C8:  MOVLW  14
024CA:  MOVWF  x72
024CC:  MOVLB  0
024CE:  RCALL  1E74
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){          
024D0:  MOVLB  1
024D2:  MOVF   x66,W
024D4:  SUBWF  x6E,W
024D6:  BNZ   24DE
....................            exit = 1; 
024D8:  MOVLW  01
024DA:  MOVWF  x6F
....................         }else{ 
024DC:  BRA    2618
....................            switch(optSelected){ 
024DE:  MOVF   x6E,W
024E0:  ADDLW  FC
024E2:  BTFSC  FD8.0
024E4:  BRA    25EA
024E6:  ADDLW  04
024E8:  MOVLB  0
024EA:  GOTO   2624
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
024EE:  MOVLW  82
024F0:  MOVWF  FF6
024F2:  MOVLW  05
024F4:  MOVWF  FF7
024F6:  CALL   0C56
....................                  write_eeprom(0,'1'); 
024FA:  MOVF   FF2,W
024FC:  MOVWF  00
024FE:  BCF    FF2.7
02500:  CLRF   FAA
02502:  CLRF   FA9
02504:  MOVLW  31
02506:  MOVWF  FA8
02508:  BCF    FA6.6
0250A:  BCF    FA6.7
0250C:  BSF    FA6.2
0250E:  MOVLB  F
02510:  MOVLW  55
02512:  MOVWF  FA7
02514:  MOVLW  AA
02516:  MOVWF  FA7
02518:  BSF    FA6.1
0251A:  BTFSC  FA6.1
0251C:  BRA    251A
0251E:  BCF    FA6.2
02520:  MOVF   00,W
02522:  IORWF  FF2,F
....................                  delay_ms(10); 
02524:  MOVLW  0A
02526:  MOVLB  1
02528:  MOVWF  xB4
0252A:  MOVLB  0
0252C:  CALL   0C2E
....................                  printf(lcd_putc, "\fConfig Cliente"); 
02530:  MOVLW  94
02532:  MOVWF  FF6
02534:  MOVLW  05
02536:  MOVWF  FF7
02538:  CALL   0EEC
....................                  break; 
0253C:  MOVLB  1
0253E:  BRA    25EA
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
02540:  MOVLW  A4
02542:  MOVWF  FF6
02544:  MOVLW  05
02546:  MOVWF  FF7
02548:  CALL   0C56
....................                  write_eeprom(0,'2'); 
0254C:  MOVF   FF2,W
0254E:  MOVWF  00
02550:  BCF    FF2.7
02552:  CLRF   FAA
02554:  CLRF   FA9
02556:  MOVLW  32
02558:  MOVWF  FA8
0255A:  BCF    FA6.6
0255C:  BCF    FA6.7
0255E:  BSF    FA6.2
02560:  MOVLB  F
02562:  MOVLW  55
02564:  MOVWF  FA7
02566:  MOVLW  AA
02568:  MOVWF  FA7
0256A:  BSF    FA6.1
0256C:  BTFSC  FA6.1
0256E:  BRA    256C
02570:  BCF    FA6.2
02572:  MOVF   00,W
02574:  IORWF  FF2,F
....................                  delay_ms(10); 
02576:  MOVLW  0A
02578:  MOVLB  1
0257A:  MOVWF  xB4
0257C:  MOVLB  0
0257E:  CALL   0C2E
....................                  printf(lcd_putc, "\fConfig AP"); 
02582:  MOVLW  B6
02584:  MOVWF  FF6
02586:  MOVLW  05
02588:  MOVWF  FF7
0258A:  CALL   0EEC
....................                  break; 
0258E:  MOVLB  1
02590:  BRA    25EA
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
02592:  MOVLW  C2
02594:  MOVWF  FF6
02596:  MOVLW  05
02598:  MOVWF  FF7
0259A:  CALL   0C56
....................                  write_eeprom(0,'3'); 
0259E:  MOVF   FF2,W
025A0:  MOVWF  00
025A2:  BCF    FF2.7
025A4:  CLRF   FAA
025A6:  CLRF   FA9
025A8:  MOVLW  33
025AA:  MOVWF  FA8
025AC:  BCF    FA6.6
025AE:  BCF    FA6.7
025B0:  BSF    FA6.2
025B2:  MOVLB  F
025B4:  MOVLW  55
025B6:  MOVWF  FA7
025B8:  MOVLW  AA
025BA:  MOVWF  FA7
025BC:  BSF    FA6.1
025BE:  BTFSC  FA6.1
025C0:  BRA    25BE
025C2:  BCF    FA6.2
025C4:  MOVF   00,W
025C6:  IORWF  FF2,F
....................                  delay_ms(10); 
025C8:  MOVLW  0A
025CA:  MOVLB  1
025CC:  MOVWF  xB4
025CE:  MOVLB  0
025D0:  CALL   0C2E
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
025D4:  MOVLW  D4
025D6:  MOVWF  FF6
025D8:  MOVLW  05
025DA:  MOVWF  FF7
025DC:  CALL   0EEC
....................                  break; 
025E0:  MOVLB  1
025E2:  BRA    25EA
....................              case MODE_EXIT: 
....................                  break; 
025E4:  MOVLB  1
025E6:  BRA    25EA
025E8:  MOVLB  1
....................                   
....................            } 
....................             
....................            if(optSelected!=MODE_EXIT){ 
025EA:  MOVF   x6E,W
025EC:  SUBLW  03
025EE:  BZ    2618
....................               pressExit(); 
025F0:  MOVLB  0
025F2:  RCALL  23A0
....................               printf(lcd_putc, "\fReiniciando"); 
025F4:  MOVLW  E6
025F6:  MOVWF  FF6
025F8:  MOVLW  05
025FA:  MOVWF  FF7
025FC:  CALL   0EEC
....................               delay_ms(3000); 
02600:  MOVLW  0C
02602:  MOVLB  1
02604:  MOVWF  x70
02606:  MOVLW  FA
02608:  MOVWF  xB4
0260A:  MOVLB  0
0260C:  CALL   0C2E
02610:  MOVLB  1
02612:  DECFSZ x70,F
02614:  BRA    2606
....................               reset_cpu(); 
02616:  RESET
02618:  MOVLB  0
....................               // Muestra la ultima opcion del menu seleccionada 
....................               //printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
....................               //showBottonMenu(); 
....................            } 
....................         } 
....................      } // Fin KEY_OK 
0261A:  BRA    242A
0261C:  MOVLB  1
....................   } // FIN While Infinito 
0261E:  MOVLB  0
02620:  GOTO   2890 (RETURN)
.................... } // Fin funcion setMenuModo 
....................  
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
....................    se dispara cuando se detectan datos de 
....................    llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
00BBC:  BTFSS  F9E.5
00BBE:  BRA    0BBC
00BC0:  MOVFF  FAE,1BB
00BC4:  MOVLB  1
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
00BC6:  MOVFF  1BB,1BC
00BCA:  MOVLB  0
00BCC:  BRA    0AD4
00BCE:  BCF    F9E.5
00BD0:  GOTO   0054
.................... } 
....................    /************************ 
....................    ***      INIT         *** 
....................    *************************/ 
....................  
....................    void main() 
*
02A44:  CLRF   FF8
02A46:  BCF    FD0.7
02A48:  BSF    07.7
02A4A:  BSF    FB8.3
02A4C:  MOVLW  2A
02A4E:  MOVWF  FAF
02A50:  MOVLW  00
02A52:  MOVWF  FB0
02A54:  MOVLW  A6
02A56:  MOVWF  FAC
02A58:  MOVLW  90
02A5A:  MOVWF  FAB
02A5C:  BCF    F93.0
02A5E:  BSF    F8A.0
02A60:  CLRF   53
02A62:  CLRF   52
02A64:  CLRF   54
02A66:  CLRF   55
02A68:  CLRF   56
02A6A:  CLRF   57
02A6C:  CLRF   58
02A6E:  CLRF   59
02A70:  CLRF   5A
02A72:  CLRF   5B
02A74:  MOVLW  01
02A76:  MOVWF  5C
02A78:  CLRF   5D
02A7A:  MOVLW  05
02A7C:  MOVWF  5E
02A7E:  CLRF   xBB
02A80:  CLRF   xBC
02A82:  CLRF   xBD
02A84:  CLRF   xBE
02A86:  CLRF   xBF
02A88:  CLRF   xC0
02A8A:  MOVLW  02
02A8C:  MOVLB  1
02A8E:  MOVWF  x62
02A90:  MOVLW  08
02A92:  MOVWF  x63
02A94:  MOVWF  x64
02A96:  MOVWF  x65
02A98:  MOVLW  03
02A9A:  MOVWF  x66
02A9C:  CLRF   x67
02A9E:  MOVF   FC1,W
02AA0:  ANDLW  C0
02AA2:  IORLW  0F
02AA4:  MOVWF  FC1
02AA6:  MOVLW  07
02AA8:  MOVWF  FB4
02AAA:  BRA    2B46
02AAC:  DATA 02,00
02AAE:  DATA 16,00
02AB0:  DATA 00,0C
02AB2:  DATA 40,5F
02AB4:  DATA 00,07
02AB6:  DATA 80,30
02AB8:  DATA 2E,30
02ABA:  DATA 2E,30
02ABC:  DATA 2E,30
02ABE:  DATA 09,C0
02AC0:  DATA 00,07
02AC2:  DATA 80,30
02AC4:  DATA 2E,30
02AC6:  DATA 2E,30
02AC8:  DATA 2E,30
02ACA:  DATA 09,C0
02ACC:  DATA 00,0F
02ACE:  DATA C0,20
02AD0:  DATA 01,80
02AD2:  DATA 00,0F
02AD4:  DATA C0,20
02AD6:  DATA 01,80
02AD8:  DATA 00,0F
02ADA:  DATA C0,20
02ADC:  DATA 01,80
02ADE:  DATA 00,5D
02AE0:  DATA 00,F4
02AE2:  DATA 4F,75
02AE4:  DATA 74,70
02AE6:  DATA 75,74
02AE8:  DATA 20,31
02AEA:  DATA 20,20
02AEC:  DATA 00,4F
02AEE:  DATA 75,74
02AF0:  DATA 70,75
02AF2:  DATA 74,20
02AF4:  DATA 32,20
02AF6:  DATA 20,00
02AF8:  DATA 4F,75
02AFA:  DATA 74,70
02AFC:  DATA 75,74
02AFE:  DATA 20,33
02B00:  DATA 20,20
02B02:  DATA 00,4F
02B04:  DATA 75,74
02B06:  DATA 70,75
02B08:  DATA 74,20
02B0A:  DATA 34,20
02B0C:  DATA 20,00
02B0E:  DATA 4F,75
02B10:  DATA 74,70
02B12:  DATA 75,74
02B14:  DATA 20,35
02B16:  DATA 20,20
02B18:  DATA 00,4F
02B1A:  DATA 75,74
02B1C:  DATA 70,75
02B1E:  DATA 74,20
02B20:  DATA 36,20
02B22:  DATA 20,00
02B24:  DATA 4F,75
02B26:  DATA 74,70
02B28:  DATA 75,74
02B2A:  DATA 20,37
02B2C:  DATA 20,20
02B2E:  DATA 00,4F
02B30:  DATA 75,74
02B32:  DATA 70,75
02B34:  DATA 74,20
02B36:  DATA 38,20
02B38:  DATA 20,00
02B3A:  DATA 53,41
02B3C:  DATA 4C,49
02B3E:  DATA 52,05
02B40:  DATA C0,20
02B42:  DATA 0C,C0
02B44:  DATA 00,00
02B46:  MOVLW  00
02B48:  MOVWF  FF8
02B4A:  MOVLW  2A
02B4C:  MOVWF  FF7
02B4E:  MOVLW  AC
02B50:  MOVWF  FF6
02B52:  TBLRD*+
02B54:  MOVF   FF5,W
02B56:  MOVWF  00
02B58:  XORLW  00
02B5A:  BZ    2B82
02B5C:  TBLRD*+
02B5E:  MOVF   FF5,W
02B60:  MOVWF  01
02B62:  BTFSC  FE8.7
02B64:  BRA    2B70
02B66:  ANDLW  0F
02B68:  MOVWF  FEA
02B6A:  TBLRD*+
02B6C:  MOVFF  FF5,FE9
02B70:  BTFSC  01.6
02B72:  TBLRD*+
02B74:  BTFSS  01.6
02B76:  TBLRD*+
02B78:  MOVFF  FF5,FEE
02B7C:  DCFSNZ 00,F
02B7E:  BRA    2B52
02B80:  BRA    2B74
02B82:  CLRF   FF8
....................    {       
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
02B84:  BCF    FF1.7
....................       set_tris_b(0b00110010); 
02B86:  MOVLW  32
02B88:  MOVWF  F93
....................        
....................       // Configura el Estado inicial de los Puertos 
....................       output_low(CHPD_ESP8266); 
02B8A:  BCF    F93.3
02B8C:  BCF    F8A.3
....................       output_low(Speaker); 
02B8E:  BCF    F93.2
02B90:  BCF    F8A.2
....................       output_high(LCD_LIGHT_PIN); 
02B92:  BCF    F95.3
02B94:  BSF    F8C.3
....................        
....................       for(int idxOff=0;idxOff<8;idxOff++){ 
02B96:  CLRF   x68
02B98:  MOVF   x68,W
02B9A:  SUBLW  07
02B9C:  BNC   2BF0
....................          output_low(PIN_OUT[idxOff]); 
02B9E:  BCF    FD8.0
02BA0:  RLCF   x68,W
02BA2:  CLRF   03
02BA4:  MOVFF  FF2,16A
02BA8:  BCF    FF2.7
02BAA:  MOVLB  0
02BAC:  CALL   0096
02BB0:  TBLRD*+
02BB2:  MOVFF  FF5,03
02BB6:  MOVLB  1
02BB8:  BTFSC  x6A.7
02BBA:  BSF    FF2.7
02BBC:  MOVWF  x6A
02BBE:  MOVFF  03,16B
02BC2:  MOVWF  xB5
02BC4:  CLRF   xB6
02BC6:  MOVLW  0F
02BC8:  MOVWF  xB8
02BCA:  MOVLW  89
02BCC:  MOVWF  xB7
02BCE:  MOVLB  0
02BD0:  CALL   0BEC
02BD4:  MOVFF  16A,1B5
02BD8:  MOVLB  1
02BDA:  CLRF   xB6
02BDC:  MOVLW  0F
02BDE:  MOVWF  xB8
02BE0:  MOVLW  92
02BE2:  MOVWF  xB7
02BE4:  MOVLB  0
02BE6:  CALL   0BEC
02BEA:  MOVLB  1
02BEC:  INCF   x68,F
02BEE:  BRA    2B98
....................       } 
....................        
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       clear_interrupt(INT_RDA);  
....................       enable_interrupts(INT_RDA); 
02BF0:  BSF    F9D.5
....................       enable_interrupts(GLOBAL);  
02BF2:  MOVLW  C0
02BF4:  IORWF  FF2,F
....................       delay_ms(1000); 
02BF6:  MOVLW  04
02BF8:  MOVWF  x6A
02BFA:  MOVLW  FA
02BFC:  MOVWF  xB4
02BFE:  MOVLB  0
02C00:  CALL   0C2E
02C04:  MOVLB  1
02C06:  DECFSZ x6A,F
02C08:  BRA    2BFA
....................        
....................       output_high(CHPD_ESP8266); 
02C0A:  BCF    F93.3
02C0C:  BSF    F8A.3
....................       // @TODO: Usar este comando solo en produccion 
....................       //        comentarlo durante etapa de desarrollo 
....................       //        Configurar el USART a 9600bps 
....................       fprintf(ESP8266, "AT+RST\r\n"); 
02C0E:  MOVLW  D4
02C10:  MOVWF  FF6
02C12:  MOVLW  0B
02C14:  MOVWF  FF7
02C16:  MOVLB  0
02C18:  CALL   0C56
....................        
....................        
....................       // Inicializa la LCD 
....................       lcd_init(); 
02C1C:  GOTO   0DBE
....................       printf(lcd_putc, "\fIniciando..."); 
02C20:  MOVLW  DE
02C22:  MOVWF  FF6
02C24:  MOVLW  0B
02C26:  MOVWF  FF7
02C28:  CALL   0EEC
....................  
....................       delay_ms(5000); 
02C2C:  MOVLW  14
02C2E:  MOVLB  1
02C30:  MOVWF  x6A
02C32:  MOVLW  FA
02C34:  MOVWF  xB4
02C36:  MOVLB  0
02C38:  CALL   0C2E
02C3C:  MOVLB  1
02C3E:  DECFSZ x6A,F
02C40:  BRA    2C32
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
02C42:  MOVLB  0
02C44:  GOTO   10B2
....................  
....................       // Carga el nombre personalizado del puerto desde la eeprom 
....................       getNameMenusOutput(); 
02C48:  GOTO   12C6
....................        
....................       // Ciclo infinito para mantener el programa activo 
....................       int loop=1; 
02C4C:  MOVLW  01
02C4E:  MOVLB  1
02C50:  MOVWF  x69
....................       while(loop==1) 
02C52:  DECFSZ x69,W
02C54:  BRA    2C96
....................       { 
....................          switch(menuActive){ 
02C56:  MOVF   x67,W
02C58:  ADDLW  FC
02C5A:  BC    2C94
02C5C:  ADDLW  04
02C5E:  MOVLB  0
02C60:  GOTO   2C98
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
02C64:  GOTO   1FBC
02C68:  MOVFF  01,167
....................                break; 
02C6C:  MOVLB  1
02C6E:  BRA    2C94
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
02C70:  GOTO   20FE
02C74:  MOVFF  01,167
....................                break; 
02C78:  MOVLB  1
02C7A:  BRA    2C94
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
02C7C:  GOTO   2250
02C80:  MOVFF  01,167
....................                break; 
02C84:  MOVLB  1
02C86:  BRA    2C94
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
02C88:  BRA    290E
02C8A:  MOVFF  01,167
....................                break; 
02C8E:  MOVLB  1
02C90:  BRA    2C94
02C92:  MOVLB  1
....................          } // Fin del Switch(menuActive) 
02C94:  BRA    2C52
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
02C96:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
