CCS PCM C Compiler, Version 5.015, 5967               21-nov.-17 00:51

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   2207 words (27%)
                           Largest free fragment is 2048
               RAM used:   54 (15%) at main() level
                           82 (22%) worst case
               Stack used: 7 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  DATA 8C,18
0005:  DATA 39,19
0006:  DATA AE,18
0007:  DATA 36,1C
0008:  DATA 2E,18
0009:  DATA AE,18
000A:  DATA 00,00
000B:  DATA CF,25
000C:  DATA 20,38
000D:  DATA 61,39
000E:  DATA 61,10
000F:  DATA D3,20
0010:  DATA CC,24
0011:  DATA 52,00
0012:  DATA 8C,21
0013:  DATA B0,23
0014:  DATA B3,2F
0015:  DATA 55,27
0016:  DATA 45,00
0017:  DATA CF,25
0018:  DATA 20,38
0019:  DATA 61,39
001A:  DATA 61,10
001B:  DATA D3,20
001C:  DATA CC,24
001D:  DATA 52,00
001E:  DATA 8C,18
001F:  DATA B2,19
0020:  DATA B4,20
0021:  DATA FA,10
0022:  DATA 00,01
0023:  DATA CF,25
0024:  DATA 20,38
0025:  DATA 61,39
0026:  DATA 61,10
0027:  DATA D3,20
0028:  DATA CC,24
0029:  DATA 52,00
002A:  DATA 0C,22
002B:  DATA E9,39
002C:  DATA 61,31
002D:  DATA EC,32
002E:  DATA A0,26
002F:  DATA 6F,32
0030:  DATA 65,00
0031:  DATA CF,25
0032:  DATA 20,38
0033:  DATA 61,39
0034:  DATA 61,10
0035:  DATA D3,20
0036:  DATA CC,24
0037:  DATA 52,00
0038:  DATA 8C,27
0039:  DATA 4B,10
003A:  DATA F0,30
003B:  DATA F2,30
003C:  DATA A0,29
003D:  DATA 41,26
003E:  DATA 49,29
003F:  DATA 00,01
0040:  RETLW  45
0041:  RETLW  6E
0042:  RETLW  63
0043:  RETLW  65
0044:  RETLW  6E
0045:  RETLW  64
0046:  RETLW  65
0047:  RETLW  72
0048:  RETLW  20
0049:  RETLW  4D
004A:  RETLW  61
004B:  RETLW  6E
004C:  RETLW  75
004D:  RETLW  61
004E:  RETLW  6C
004F:  RETLW  00
0050:  RETLW  41
0051:  RETLW  70
0052:  RETLW  61
0053:  RETLW  67
0054:  RETLW  61
0055:  RETLW  64
0056:  RETLW  6F
0057:  RETLW  20
0058:  RETLW  4D
0059:  RETLW  61
005A:  RETLW  6E
005B:  RETLW  75
005C:  RETLW  61
005D:  RETLW  6C
005E:  RETLW  20
005F:  RETLW  00
0060:  RETLW  43
0061:  RETLW  6F
0062:  RETLW  6E
0063:  RETLW  66
0064:  RETLW  69
0065:  RETLW  67
0066:  RETLW  75
0067:  RETLW  72
0068:  RETLW  61
0069:  RETLW  63
006A:  RETLW  69
006B:  RETLW  6F
006C:  RETLW  6E
006D:  RETLW  20
006E:  RETLW  20
006F:  RETLW  00
0070:  RETLW  00
0071:  RETLW  00
0072:  RETLW  00
0073:  RETLW  00
0074:  RETLW  00
0075:  RETLW  00
0076:  RETLW  00
0077:  RETLW  00
0078:  RETLW  00
0079:  RETLW  00
007A:  RETLW  00
007B:  RETLW  00
007C:  RETLW  00
007D:  RETLW  00
007E:  RETLW  00
007F:  RETLW  00
0080:  RETLW  4F
0081:  RETLW  6E
0082:  RETLW  20
0083:  RETLW  2D
0084:  RETLW  3E
0085:  RETLW  20
0086:  RETLW  53
0087:  RETLW  61
0088:  RETLW  6C
0089:  RETLW  69
008A:  RETLW  64
008B:  RETLW  61
008C:  RETLW  20
008D:  RETLW  31
008E:  RETLW  00
008F:  RETLW  4F
0090:  RETLW  6E
0091:  RETLW  20
0092:  RETLW  2D
0093:  RETLW  3E
0094:  RETLW  20
0095:  RETLW  53
0096:  RETLW  61
0097:  RETLW  6C
0098:  RETLW  69
0099:  RETLW  64
009A:  RETLW  61
009B:  RETLW  20
009C:  RETLW  32
009D:  RETLW  00
009E:  RETLW  4F
009F:  RETLW  6E
00A0:  RETLW  20
00A1:  RETLW  2D
00A2:  RETLW  3E
00A3:  RETLW  20
00A4:  RETLW  53
00A5:  RETLW  61
00A6:  RETLW  6C
00A7:  RETLW  69
00A8:  RETLW  64
00A9:  RETLW  61
00AA:  RETLW  20
00AB:  RETLW  33
00AC:  RETLW  00
00AD:  RETLW  4F
00AE:  RETLW  6E
00AF:  RETLW  20
00B0:  RETLW  2D
00B1:  RETLW  3E
00B2:  RETLW  20
00B3:  RETLW  53
00B4:  RETLW  61
00B5:  RETLW  6C
00B6:  RETLW  69
00B7:  RETLW  64
00B8:  RETLW  61
00B9:  RETLW  20
00BA:  RETLW  34
00BB:  RETLW  00
00BC:  RETLW  4F
00BD:  RETLW  6E
00BE:  RETLW  20
00BF:  RETLW  2D
00C0:  RETLW  3E
00C1:  RETLW  20
00C2:  RETLW  53
00C3:  RETLW  61
00C4:  RETLW  6C
00C5:  RETLW  69
00C6:  RETLW  64
00C7:  RETLW  61
00C8:  RETLW  20
00C9:  RETLW  35
00CA:  RETLW  00
00CB:  RETLW  4F
00CC:  RETLW  6E
00CD:  RETLW  20
00CE:  RETLW  2D
00CF:  RETLW  3E
00D0:  RETLW  20
00D1:  RETLW  53
00D2:  RETLW  61
00D3:  RETLW  6C
00D4:  RETLW  69
00D5:  RETLW  64
00D6:  RETLW  61
00D7:  RETLW  20
00D8:  RETLW  36
00D9:  RETLW  00
00DA:  RETLW  4F
00DB:  RETLW  6E
00DC:  RETLW  20
00DD:  RETLW  2D
00DE:  RETLW  3E
00DF:  RETLW  20
00E0:  RETLW  53
00E1:  RETLW  61
00E2:  RETLW  6C
00E3:  RETLW  69
00E4:  RETLW  64
00E5:  RETLW  61
00E6:  RETLW  20
00E7:  RETLW  37
00E8:  RETLW  00
00E9:  RETLW  4F
00EA:  RETLW  6E
00EB:  RETLW  20
00EC:  RETLW  2D
00ED:  RETLW  3E
00EE:  RETLW  20
00EF:  RETLW  53
00F0:  RETLW  61
00F1:  RETLW  6C
00F2:  RETLW  69
00F3:  RETLW  64
00F4:  RETLW  61
00F5:  RETLW  20
00F6:  RETLW  38
00F7:  RETLW  00
00F8:  RETLW  53
00F9:  RETLW  41
00FA:  RETLW  4C
00FB:  RETLW  49
00FC:  RETLW  52
00FD:  RETLW  20
00FE:  RETLW  20
00FF:  RETLW  20
0100:  RETLW  20
0101:  RETLW  20
0102:  RETLW  20
0103:  RETLW  20
0104:  RETLW  20
0105:  RETLW  20
0106:  RETLW  00
0107:  RETLW  00
0108:  RETLW  00
0109:  RETLW  00
010A:  RETLW  00
010B:  RETLW  00
010C:  RETLW  00
010D:  RETLW  00
010E:  RETLW  00
010F:  RETLW  00
0110:  RETLW  00
0111:  RETLW  00
0112:  RETLW  00
0113:  RETLW  00
0114:  RETLW  00
0115:  RETLW  00
0116:  RETLW  4F
0117:  RETLW  66
0118:  RETLW  66
0119:  RETLW  20
011A:  RETLW  2D
011B:  RETLW  3E
011C:  RETLW  20
011D:  RETLW  53
011E:  RETLW  61
011F:  RETLW  6C
0120:  RETLW  69
0121:  RETLW  64
0122:  RETLW  61
0123:  RETLW  20
0124:  RETLW  31
0125:  RETLW  00
0126:  RETLW  4F
0127:  RETLW  66
0128:  RETLW  66
0129:  RETLW  20
012A:  RETLW  2D
012B:  RETLW  3E
012C:  RETLW  20
012D:  RETLW  53
012E:  RETLW  61
012F:  RETLW  6C
0130:  RETLW  69
0131:  RETLW  64
0132:  RETLW  61
0133:  RETLW  20
0134:  RETLW  32
0135:  RETLW  00
0136:  RETLW  4F
0137:  RETLW  66
0138:  RETLW  66
0139:  RETLW  20
013A:  RETLW  2D
013B:  RETLW  3E
013C:  RETLW  20
013D:  RETLW  53
013E:  RETLW  61
013F:  RETLW  6C
0140:  RETLW  69
0141:  RETLW  64
0142:  RETLW  61
0143:  RETLW  20
0144:  RETLW  33
0145:  RETLW  00
0146:  RETLW  4F
0147:  RETLW  66
0148:  RETLW  66
0149:  RETLW  20
014A:  RETLW  2D
014B:  RETLW  3E
014C:  RETLW  20
014D:  RETLW  53
014E:  RETLW  61
014F:  RETLW  6C
0150:  RETLW  69
0151:  RETLW  64
0152:  RETLW  61
0153:  RETLW  20
0154:  RETLW  34
0155:  RETLW  00
0156:  RETLW  4F
0157:  RETLW  66
0158:  RETLW  66
0159:  RETLW  20
015A:  RETLW  2D
015B:  RETLW  3E
015C:  RETLW  20
015D:  RETLW  53
015E:  RETLW  61
015F:  RETLW  6C
0160:  RETLW  69
0161:  RETLW  64
0162:  RETLW  61
0163:  RETLW  20
0164:  RETLW  35
0165:  RETLW  00
0166:  RETLW  4F
0167:  RETLW  66
0168:  RETLW  66
0169:  RETLW  20
016A:  RETLW  2D
016B:  RETLW  3E
016C:  RETLW  20
016D:  RETLW  53
016E:  RETLW  61
016F:  RETLW  6C
0170:  RETLW  69
0171:  RETLW  64
0172:  RETLW  61
0173:  RETLW  20
0174:  RETLW  36
0175:  RETLW  00
0176:  RETLW  4F
0177:  RETLW  66
0178:  RETLW  66
0179:  RETLW  20
017A:  RETLW  2D
017B:  RETLW  3E
017C:  RETLW  20
017D:  RETLW  53
017E:  RETLW  61
017F:  RETLW  6C
0180:  RETLW  69
0181:  RETLW  64
0182:  RETLW  61
0183:  RETLW  20
0184:  RETLW  37
0185:  RETLW  00
0186:  RETLW  4F
0187:  RETLW  66
0188:  RETLW  66
0189:  RETLW  20
018A:  RETLW  2D
018B:  RETLW  3E
018C:  RETLW  20
018D:  RETLW  53
018E:  RETLW  61
018F:  RETLW  6C
0190:  RETLW  69
0191:  RETLW  64
0192:  RETLW  61
0193:  RETLW  20
0194:  RETLW  38
0195:  RETLW  00
0196:  RETLW  53
0197:  RETLW  41
0198:  RETLW  4C
0199:  RETLW  49
019A:  RETLW  52
019B:  RETLW  20
019C:  RETLW  20
019D:  RETLW  20
019E:  RETLW  20
019F:  RETLW  20
01A0:  RETLW  20
01A1:  RETLW  20
01A2:  RETLW  20
01A3:  RETLW  20
01A4:  RETLW  20
01A5:  RETLW  00
01A6:  RETLW  00
01A7:  RETLW  00
01A8:  RETLW  00
01A9:  RETLW  00
01AA:  RETLW  00
01AB:  RETLW  00
01AC:  RETLW  00
01AD:  RETLW  00
01AE:  RETLW  00
01AF:  RETLW  00
01B0:  RETLW  00
01B1:  RETLW  00
01B2:  RETLW  00
01B3:  RETLW  00
01B4:  RETLW  00
01B5:  RETLW  00
01B6:  RETLW  56
01B7:  RETLW  45
01B8:  RETLW  52
01B9:  RETLW  20
01BA:  RETLW  49
01BB:  RETLW  50
01BC:  RETLW  20
01BD:  RETLW  20
01BE:  RETLW  20
01BF:  RETLW  20
01C0:  RETLW  20
01C1:  RETLW  20
01C2:  RETLW  20
01C3:  RETLW  20
01C4:  RETLW  20
01C5:  RETLW  20
01C6:  RETLW  00
01C7:  RETLW  56
01C8:  RETLW  45
01C9:  RETLW  52
01CA:  RETLW  20
01CB:  RETLW  53
01CC:  RETLW  53
01CD:  RETLW  49
01CE:  RETLW  44
01CF:  RETLW  20
01D0:  RETLW  20
01D1:  RETLW  20
01D2:  RETLW  20
01D3:  RETLW  20
01D4:  RETLW  20
01D5:  RETLW  20
01D6:  RETLW  20
01D7:  RETLW  00
01D8:  RETLW  56
01D9:  RETLW  45
01DA:  RETLW  52
01DB:  RETLW  20
01DC:  RETLW  4B
01DD:  RETLW  45
01DE:  RETLW  59
01DF:  RETLW  20
01E0:  RETLW  20
01E1:  RETLW  20
01E2:  RETLW  20
01E3:  RETLW  20
01E4:  RETLW  20
01E5:  RETLW  20
01E6:  RETLW  20
01E7:  RETLW  20
01E8:  RETLW  00
01E9:  RETLW  4D
01EA:  RETLW  6F
01EB:  RETLW  64
01EC:  RETLW  6F
01ED:  RETLW  20
01EE:  RETLW  41
01EF:  RETLW  63
01F0:  RETLW  63
01F1:  RETLW  65
01F2:  RETLW  73
01F3:  RETLW  73
01F4:  RETLW  50
01F5:  RETLW  6F
01F6:  RETLW  69
01F7:  RETLW  6E
01F8:  RETLW  74
01F9:  RETLW  00
01FA:  RETLW  4F
01FB:  RETLW  6E
01FC:  RETLW  2F
01FD:  RETLW  4F
01FE:  RETLW  66
01FF:  RETLW  66
0200:  RETLW  20
0201:  RETLW  42
0202:  RETLW  61
0203:  RETLW  63
0204:  RETLW  6B
0205:  RETLW  6C
0206:  RETLW  69
0207:  RETLW  67
0208:  RETLW  68
0209:  RETLW  74
020A:  RETLW  00
020B:  RETLW  53
020C:  RETLW  41
020D:  RETLW  4C
020E:  RETLW  49
020F:  RETLW  52
0210:  RETLW  20
0211:  RETLW  20
0212:  RETLW  20
0213:  RETLW  20
0214:  RETLW  20
0215:  RETLW  20
0216:  RETLW  20
0217:  RETLW  20
0218:  RETLW  20
0219:  RETLW  20
021A:  RETLW  20
021B:  RETLW  00
021C:  RETLW  00
021D:  RETLW  00
021E:  RETLW  00
021F:  RETLW  00
0220:  RETLW  00
0221:  RETLW  00
0222:  RETLW  00
0223:  RETLW  00
0224:  RETLW  00
0225:  RETLW  00
0226:  RETLW  00
0227:  RETLW  00
0228:  RETLW  00
0229:  RETLW  00
022A:  RETLW  00
022B:  RETLW  00
022C:  RETLW  00
*
0384:  MOVF   0B,W
0385:  MOVWF  53
0386:  BCF    0B.7
0387:  BSF    03.5
0388:  BSF    03.6
0389:  BSF    0C.7
038A:  BSF    0C.0
038B:  NOP
038C:  NOP
038D:  BCF    03.5
038E:  BCF    03.6
038F:  BTFSC  53.7
0390:  BSF    0B.7
0391:  BSF    03.6
0392:  MOVF   0C,F
0393:  BTFSC  03.2
0394:  GOTO   3AE
0395:  MOVF   0D,W
0396:  BCF    03.6
0397:  MOVWF  53
0398:  BSF    03.6
0399:  MOVF   0F,W
039A:  BCF    03.6
039B:  MOVWF  54
039C:  BSF    03.6
039D:  MOVF   0C,W
039E:  BCF    03.6
039F:  MOVWF  56
03A0:  CALL   358
03A1:  MOVF   53,W
03A2:  BSF    03.6
03A3:  MOVWF  0D
03A4:  BCF    03.6
03A5:  MOVF   54,W
03A6:  BSF    03.6
03A7:  MOVWF  0F
03A8:  INCF   0D,F
03A9:  BTFSC  03.2
03AA:  INCF   0F,F
03AB:  BCF    03.6
03AC:  GOTO   384
03AD:  BSF    03.6
03AE:  BCF    03.6
03AF:  RETURN
*
03EA:  BTFSC  03.1
03EB:  GOTO   3EF
03EC:  MOVLW  68
03ED:  MOVWF  04
03EE:  BCF    03.7
03EF:  CLRF   77
03F0:  CLRF   78
03F1:  CLRF   79
03F2:  CLRF   7A
03F3:  CLRF   68
03F4:  CLRF   69
03F5:  CLRF   6A
03F6:  CLRF   6B
03F7:  MOVF   67,W
03F8:  IORWF  66,W
03F9:  IORWF  65,W
03FA:  IORWF  64,W
03FB:  BTFSC  03.2
03FC:  GOTO   42D
03FD:  MOVLW  20
03FE:  MOVWF  6C
03FF:  BCF    03.0
0400:  RLF    60,F
0401:  RLF    61,F
0402:  RLF    62,F
0403:  RLF    63,F
0404:  RLF    68,F
0405:  RLF    69,F
0406:  RLF    6A,F
0407:  RLF    6B,F
0408:  MOVF   67,W
0409:  SUBWF  6B,W
040A:  BTFSS  03.2
040B:  GOTO   416
040C:  MOVF   66,W
040D:  SUBWF  6A,W
040E:  BTFSS  03.2
040F:  GOTO   416
0410:  MOVF   65,W
0411:  SUBWF  69,W
0412:  BTFSS  03.2
0413:  GOTO   416
0414:  MOVF   64,W
0415:  SUBWF  68,W
0416:  BTFSS  03.0
0417:  GOTO   427
0418:  MOVF   64,W
0419:  SUBWF  68,F
041A:  MOVF   65,W
041B:  BTFSS  03.0
041C:  INCFSZ 65,W
041D:  SUBWF  69,F
041E:  MOVF   66,W
041F:  BTFSS  03.0
0420:  INCFSZ 66,W
0421:  SUBWF  6A,F
0422:  MOVF   67,W
0423:  BTFSS  03.0
0424:  INCFSZ 67,W
0425:  SUBWF  6B,F
0426:  BSF    03.0
0427:  RLF    77,F
0428:  RLF    78,F
0429:  RLF    79,F
042A:  RLF    7A,F
042B:  DECFSZ 6C,F
042C:  GOTO   3FF
042D:  MOVF   68,W
042E:  MOVWF  00
042F:  INCF   04,F
0430:  MOVF   69,W
0431:  MOVWF  00
0432:  INCF   04,F
0433:  MOVF   6A,W
0434:  MOVWF  00
0435:  INCF   04,F
0436:  MOVF   6B,W
0437:  MOVWF  00
*
044D:  MOVLW  20
044E:  MOVWF  6C
044F:  CLRF   68
0450:  CLRF   69
0451:  CLRF   6A
0452:  CLRF   6B
0453:  MOVF   63,W
0454:  MOVWF  7A
0455:  MOVF   62,W
0456:  MOVWF  79
0457:  MOVF   61,W
0458:  MOVWF  78
0459:  MOVF   60,W
045A:  MOVWF  77
045B:  BCF    03.0
045C:  BTFSS  77.0
045D:  GOTO   46C
045E:  MOVF   64,W
045F:  ADDWF  68,F
0460:  MOVF   65,W
0461:  BTFSC  03.0
0462:  INCFSZ 65,W
0463:  ADDWF  69,F
0464:  MOVF   66,W
0465:  BTFSC  03.0
0466:  INCFSZ 66,W
0467:  ADDWF  6A,F
0468:  MOVF   67,W
0469:  BTFSC  03.0
046A:  INCFSZ 67,W
046B:  ADDWF  6B,F
046C:  RRF    6B,F
046D:  RRF    6A,F
046E:  RRF    69,F
046F:  RRF    68,F
0470:  RRF    7A,F
0471:  RRF    79,F
0472:  RRF    78,F
0473:  RRF    77,F
0474:  DECFSZ 6C,F
0475:  GOTO   45B
*
053F:  CLRF   77
0540:  CLRF   78
0541:  MOVF   52,W
0542:  BCF    03.0
0543:  BTFSC  53.0
0544:  ADDWF  77,F
0545:  RRF    77,F
0546:  RRF    78,F
0547:  BTFSC  53.1
0548:  ADDWF  77,F
0549:  RRF    77,F
054A:  RRF    78,F
054B:  BTFSC  53.2
054C:  ADDWF  77,F
054D:  RRF    77,F
054E:  RRF    78,F
054F:  BTFSC  53.3
0550:  ADDWF  77,F
0551:  RRF    77,F
0552:  RRF    78,F
0553:  BTFSC  53.4
0554:  ADDWF  77,F
0555:  RRF    77,F
0556:  RRF    78,F
0557:  BTFSC  53.5
0558:  ADDWF  77,F
0559:  RRF    77,F
055A:  RRF    78,F
055B:  BTFSC  53.6
055C:  ADDWF  77,F
055D:  RRF    77,F
055E:  RRF    78,F
055F:  BTFSC  53.7
0560:  ADDWF  77,F
0561:  RRF    77,F
0562:  RRF    78,F
0563:  RETURN
0564:  MOVF   54,W
0565:  ANDLW  07
0566:  MOVWF  77
0567:  RRF    54,W
0568:  MOVWF  78
0569:  RRF    78,F
056A:  RRF    78,F
056B:  MOVLW  1F
056C:  ANDWF  78,F
056D:  MOVF   78,W
056E:  ADDWF  56,W
056F:  MOVWF  04
0570:  BCF    03.7
0571:  BTFSC  57.0
0572:  BSF    03.7
0573:  CLRF   78
0574:  INCF   78,F
0575:  INCF   77,F
0576:  GOTO   578
0577:  RLF    78,F
0578:  DECFSZ 77,F
0579:  GOTO   577
057A:  MOVF   55,F
057B:  BTFSC  03.2
057C:  GOTO   580
057D:  MOVF   78,W
057E:  IORWF  00,F
057F:  GOTO   583
0580:  COMF   78,F
0581:  MOVF   78,W
0582:  ANDWF  00,F
0583:  RETURN
*
068B:  MOVF   0B,W
068C:  MOVWF  53
068D:  BCF    0B.7
068E:  BSF    03.5
068F:  BSF    03.6
0690:  BSF    0C.7
0691:  BSF    0C.0
0692:  NOP
0693:  NOP
0694:  BCF    03.5
0695:  BCF    03.6
0696:  BTFSC  53.7
0697:  BSF    0B.7
0698:  BSF    03.6
0699:  MOVF   0C,W
069A:  ANDLW  7F
069B:  BTFSC  03.2
069C:  GOTO   6DF
069D:  BCF    03.6
069E:  MOVWF  53
069F:  BSF    03.6
06A0:  MOVF   0D,W
06A1:  BCF    03.6
06A2:  MOVWF  54
06A3:  BSF    03.6
06A4:  MOVF   0F,W
06A5:  BCF    03.6
06A6:  MOVWF  55
06A7:  MOVF   53,W
06A8:  MOVWF  56
06A9:  CALL   358
06AA:  MOVF   54,W
06AB:  BSF    03.6
06AC:  MOVWF  0D
06AD:  BCF    03.6
06AE:  MOVF   55,W
06AF:  BSF    03.6
06B0:  MOVWF  0F
06B1:  BCF    03.6
06B2:  MOVF   0B,W
06B3:  MOVWF  56
06B4:  BCF    0B.7
06B5:  BSF    03.5
06B6:  BSF    03.6
06B7:  BSF    0C.7
06B8:  BSF    0C.0
06B9:  NOP
06BA:  NOP
06BB:  BCF    03.5
06BC:  BCF    03.6
06BD:  BTFSC  56.7
06BE:  BSF    0B.7
06BF:  BSF    03.6
06C0:  RLF    0C,W
06C1:  RLF    0E,W
06C2:  ANDLW  7F
06C3:  BTFSC  03.2
06C4:  GOTO   6DF
06C5:  BCF    03.6
06C6:  MOVWF  53
06C7:  BSF    03.6
06C8:  MOVF   0D,W
06C9:  BCF    03.6
06CA:  MOVWF  54
06CB:  BSF    03.6
06CC:  MOVF   0F,W
06CD:  BCF    03.6
06CE:  MOVWF  55
06CF:  MOVF   53,W
06D0:  MOVWF  56
06D1:  CALL   358
06D2:  MOVF   54,W
06D3:  BSF    03.6
06D4:  MOVWF  0D
06D5:  BCF    03.6
06D6:  MOVF   55,W
06D7:  BSF    03.6
06D8:  MOVWF  0F
06D9:  INCF   0D,F
06DA:  BTFSC  03.2
06DB:  INCF   0F,F
06DC:  BCF    03.6
06DD:  GOTO   68B
06DE:  BSF    03.6
06DF:  BCF    03.6
06E0:  RETURN
*
0765:  BSF    0A.0
0766:  BSF    0A.1
0767:  BSF    0A.2
0768:  ADDWF  02,F
0769:  GOTO   6F6
076A:  GOTO   70B
076B:  GOTO   725
076C:  GOTO   73A
076D:  GOTO   754
076E:  GOTO   762
*
08A1:  BCF    0A.0
08A2:  BCF    0A.1
08A3:  BCF    0A.2
08A4:  ADDWF  02,F
08A5:  GOTO   088
08A6:  GOTO   08E
08A7:  GOTO   094
08A8:  GOTO   09A
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20000000) 
*
022D:  MOVLW  57
022E:  MOVWF  04
022F:  BCF    03.7
0230:  MOVF   00,W
0231:  BTFSC  03.2
0232:  GOTO   240
0233:  MOVLW  06
0234:  MOVWF  78
0235:  CLRF   77
0236:  DECFSZ 77,F
0237:  GOTO   236
0238:  DECFSZ 78,F
0239:  GOTO   235
023A:  MOVLW  7B
023B:  MOVWF  77
023C:  DECFSZ 77,F
023D:  GOTO   23C
023E:  DECFSZ 00,F
023F:  GOTO   233
0240:  RETURN
*
03B0:  MOVLW  03
03B1:  SUBWF  61,F
03B2:  BTFSS  03.0
03B3:  GOTO   3BE
03B4:  MOVLW  61
03B5:  MOVWF  04
03B6:  BCF    03.7
03B7:  MOVF   00,W
03B8:  BTFSC  03.2
03B9:  GOTO   3BE
03BA:  GOTO   3BC
03BB:  GOTO   3BC
03BC:  DECFSZ 00,F
03BD:  GOTO   3BB
03BE:  RETURN
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=ESP8266) 
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
*
0824:  MOVLW  4A
0825:  BCF    03.6
0826:  MOVWF  20
0827:  CLRF   21
0828:  MOVLW  49
0829:  MOVWF  22
082A:  CLRF   23
082B:  MOVLW  48
082C:  MOVWF  24
082D:  CLRF   25
082E:  MOVLW  2C
082F:  MOVWF  26
0830:  CLRF   27
0831:  MOVLW  28
0832:  MOVWF  28
0833:  CLRF   29
0834:  MOVLW  29
0835:  MOVWF  2A
0836:  CLRF   2B
0837:  MOVLW  2A
0838:  MOVWF  2C
0839:  CLRF   2D
083A:  MOVLW  2B
083B:  MOVWF  2E
083C:  CLRF   2F
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
083D:  CLRF   30
083E:  CLRF   31
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
02AA:  BSF    08.4
....................    output_float(LCD_DATA5); 
02AB:  BSF    08.5
....................    output_float(LCD_DATA6); 
02AC:  BSF    08.6
....................    output_float(LCD_DATA7); 
02AD:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
02AE:  BCF    03.5
02AF:  BSF    08.1
02B0:  BSF    03.5
02B1:  BCF    08.1
....................    delay_cycles(1); 
02B2:  NOP
....................    lcd_output_enable(1); 
02B3:  BCF    03.5
02B4:  BSF    08.0
02B5:  BSF    03.5
02B6:  BCF    08.0
....................    delay_cycles(1); 
02B7:  NOP
....................    high = lcd_read_nibble(); 
02B8:  BCF    03.5
02B9:  CALL   271
02BA:  MOVF   78,W
02BB:  MOVWF  5E
....................        
....................    lcd_output_enable(0); 
02BC:  BCF    08.0
02BD:  BSF    03.5
02BE:  BCF    08.0
....................    delay_cycles(1); 
02BF:  NOP
....................    lcd_output_enable(1); 
02C0:  BCF    03.5
02C1:  BSF    08.0
02C2:  BSF    03.5
02C3:  BCF    08.0
....................    delay_us(1); 
02C4:  GOTO   2C5
02C5:  GOTO   2C6
02C6:  NOP
....................    low = lcd_read_nibble(); 
02C7:  BCF    03.5
02C8:  CALL   271
02C9:  MOVF   78,W
02CA:  MOVWF  5D
....................        
....................    lcd_output_enable(0); 
02CB:  BCF    08.0
02CC:  BSF    03.5
02CD:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
02CE:  BCF    08.4
....................    output_drive(LCD_DATA5); 
02CF:  BCF    08.5
....................    output_drive(LCD_DATA6); 
02D0:  BCF    08.6
....................    output_drive(LCD_DATA7); 
02D1:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
02D2:  BCF    03.5
02D3:  SWAPF  5E,W
02D4:  MOVWF  77
02D5:  MOVLW  F0
02D6:  ANDWF  77,F
02D7:  MOVF   77,W
02D8:  IORWF  5D,W
02D9:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0271:  CLRF   5F
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0272:  BSF    03.5
0273:  BSF    08.4
0274:  MOVLW  00
0275:  BCF    03.5
0276:  BTFSC  08.4
0277:  MOVLW  01
0278:  IORWF  5F,F
....................    n |= input(LCD_DATA5) << 1; 
0279:  BSF    03.5
027A:  BSF    08.5
027B:  MOVLW  00
027C:  BCF    03.5
027D:  BTFSC  08.5
027E:  MOVLW  01
027F:  MOVWF  77
0280:  BCF    03.0
0281:  RLF    77,F
0282:  MOVF   77,W
0283:  IORWF  5F,F
....................    n |= input(LCD_DATA6) << 2; 
0284:  BSF    03.5
0285:  BSF    08.6
0286:  MOVLW  00
0287:  BCF    03.5
0288:  BTFSC  08.6
0289:  MOVLW  01
028A:  MOVWF  77
028B:  RLF    77,F
028C:  RLF    77,F
028D:  MOVLW  FC
028E:  ANDWF  77,F
028F:  MOVF   77,W
0290:  IORWF  5F,F
....................    n |= input(LCD_DATA7) << 3; 
0291:  BSF    03.5
0292:  BSF    08.7
0293:  MOVLW  00
0294:  BCF    03.5
0295:  BTFSC  08.7
0296:  MOVLW  01
0297:  MOVWF  77
0298:  RLF    77,F
0299:  RLF    77,F
029A:  RLF    77,F
029B:  MOVLW  F8
029C:  ANDWF  77,F
029D:  MOVF   77,W
029E:  IORWF  5F,F
....................     
....................    return(n); 
029F:  MOVF   5F,W
02A0:  MOVWF  78
....................   #else 
02A1:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0241:  BTFSC  5E.0
0242:  GOTO   245
0243:  BCF    08.4
0244:  GOTO   246
0245:  BSF    08.4
0246:  BSF    03.5
0247:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0248:  BCF    03.5
0249:  BTFSC  5E.1
024A:  GOTO   24D
024B:  BCF    08.5
024C:  GOTO   24E
024D:  BSF    08.5
024E:  BSF    03.5
024F:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0250:  BCF    03.5
0251:  BTFSC  5E.2
0252:  GOTO   255
0253:  BCF    08.6
0254:  GOTO   256
0255:  BSF    08.6
0256:  BSF    03.5
0257:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0258:  BCF    03.5
0259:  BTFSC  5E.3
025A:  GOTO   25D
025B:  BCF    08.7
025C:  GOTO   25E
025D:  BSF    08.7
025E:  BSF    03.5
025F:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0260:  NOP
....................    lcd_output_enable(1); 
0261:  BCF    03.5
0262:  BSF    08.0
0263:  BSF    03.5
0264:  BCF    08.0
....................    delay_us(2); 
0265:  MOVLW  02
0266:  MOVWF  77
0267:  DECFSZ 77,F
0268:  GOTO   267
0269:  GOTO   26A
026A:  NOP
....................    lcd_output_enable(0); 
026B:  BCF    03.5
026C:  BCF    08.0
026D:  BSF    03.5
026E:  BCF    08.0
026F:  BCF    03.5
0270:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
02A2:  BSF    03.5
02A3:  BCF    08.0
....................    lcd_rs_tris(); 
02A4:  BCF    08.2
....................    lcd_rw_tris(); 
02A5:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
02A6:  BCF    03.5
02A7:  BCF    08.2
02A8:  BSF    03.5
02A9:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
02DA:  MOVF   78,W
02DB:  MOVWF  5D
02DC:  BTFSS  5D.7
02DD:  GOTO   2E0
02DE:  BSF    03.5
02DF:  GOTO   2AA
....................    lcd_output_rs(address); 
02E0:  MOVF   5B,F
02E1:  BTFSS  03.2
02E2:  GOTO   2E5
02E3:  BCF    08.2
02E4:  GOTO   2E6
02E5:  BSF    08.2
02E6:  BSF    03.5
02E7:  BCF    08.2
....................    delay_cycles(1); 
02E8:  NOP
....................    lcd_output_rw(0); 
02E9:  BCF    03.5
02EA:  BCF    08.1
02EB:  BSF    03.5
02EC:  BCF    08.1
....................    delay_cycles(1); 
02ED:  NOP
....................    lcd_output_enable(0); 
02EE:  BCF    03.5
02EF:  BCF    08.0
02F0:  BSF    03.5
02F1:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
02F2:  BCF    03.5
02F3:  SWAPF  5C,W
02F4:  MOVWF  5D
02F5:  MOVLW  0F
02F6:  ANDWF  5D,F
02F7:  MOVF   5D,W
02F8:  MOVWF  5E
02F9:  CALL   241
....................    lcd_send_nibble(n & 0xf); 
02FA:  MOVF   5C,W
02FB:  ANDLW  0F
02FC:  MOVWF  5D
02FD:  MOVWF  5E
02FE:  CALL   241
02FF:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0300:  MOVLW  28
0301:  MOVWF  51
0302:  MOVLW  0C
0303:  MOVWF  52
0304:  MOVLW  01
0305:  MOVWF  53
0306:  MOVLW  06
0307:  MOVWF  54
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0308:  BCF    08.0
0309:  BSF    03.5
030A:  BCF    08.0
....................    lcd_output_rs(0); 
030B:  BCF    03.5
030C:  BCF    08.2
030D:  BSF    03.5
030E:  BCF    08.2
....................    lcd_output_rw(0); 
030F:  BCF    03.5
0310:  BCF    08.1
0311:  BSF    03.5
0312:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0313:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0314:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0315:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0316:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0317:  BCF    08.0
....................    lcd_rs_tris(); 
0318:  BCF    08.2
....................    lcd_rw_tris(); 
0319:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
031A:  MOVLW  0F
031B:  BCF    03.5
031C:  MOVWF  57
031D:  CALL   22D
....................    for(i=1;i<=3;++i) 
031E:  MOVLW  01
031F:  MOVWF  50
0320:  MOVF   50,W
0321:  SUBLW  03
0322:  BTFSS  03.0
0323:  GOTO   32C
....................    { 
....................        lcd_send_nibble(3); 
0324:  MOVLW  03
0325:  MOVWF  5E
0326:  CALL   241
....................        delay_ms(5); 
0327:  MOVLW  05
0328:  MOVWF  57
0329:  CALL   22D
032A:  INCF   50,F
032B:  GOTO   320
....................    } 
....................     
....................    lcd_send_nibble(2); 
032C:  MOVLW  02
032D:  MOVWF  5E
032E:  CALL   241
....................    delay_ms(5); 
032F:  MOVLW  05
0330:  MOVWF  57
0331:  CALL   22D
....................    for(i=0;i<=3;++i) 
0332:  CLRF   50
0333:  MOVF   50,W
0334:  SUBLW  03
0335:  BTFSS  03.0
0336:  GOTO   343
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0337:  MOVLW  51
0338:  ADDWF  50,W
0339:  MOVWF  04
033A:  BCF    03.7
033B:  MOVF   00,W
033C:  MOVWF  55
033D:  CLRF   5B
033E:  MOVF   55,W
033F:  MOVWF  5C
0340:  CALL   2A2
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0341:  INCF   50,F
0342:  GOTO   333
0343:  BSF    0A.3
0344:  BCF    0A.4
0345:  GOTO   078 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0346:  DECFSZ 58,W
0347:  GOTO   349
0348:  GOTO   34C
....................       address=LCD_LINE_TWO; 
0349:  MOVLW  40
034A:  MOVWF  59
034B:  GOTO   34D
....................    else 
....................       address=0; 
034C:  CLRF   59
....................       
....................    address+=x-1; 
034D:  MOVLW  01
034E:  SUBWF  57,W
034F:  ADDWF  59,F
....................    lcd_send_byte(0,0x80|address); 
0350:  MOVF   59,W
0351:  IORLW  80
0352:  MOVWF  5A
0353:  CLRF   5B
0354:  MOVF   5A,W
0355:  MOVWF  5C
0356:  CALL   2A2
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0357:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0358:  MOVF   56,W
0359:  XORLW  07
035A:  BTFSC  03.2
035B:  GOTO   366
035C:  XORLW  0B
035D:  BTFSC  03.2
035E:  GOTO   36B
035F:  XORLW  06
0360:  BTFSC  03.2
0361:  GOTO   373
0362:  XORLW  02
0363:  BTFSC  03.2
0364:  GOTO   379
0365:  GOTO   37E
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0366:  MOVLW  01
0367:  MOVWF  57
0368:  MOVWF  58
0369:  CALL   346
036A:  GOTO   383
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
036B:  CLRF   5B
036C:  MOVLW  01
036D:  MOVWF  5C
036E:  CALL   2A2
....................                      delay_ms(2); 
036F:  MOVLW  02
0370:  MOVWF  57
0371:  CALL   22D
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0372:  GOTO   383
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0373:  MOVLW  01
0374:  MOVWF  57
0375:  MOVLW  02
0376:  MOVWF  58
0377:  CALL   346
0378:  GOTO   383
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0379:  CLRF   5B
037A:  MOVLW  10
037B:  MOVWF  5C
037C:  CALL   2A2
037D:  GOTO   383
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
037E:  MOVLW  01
037F:  MOVWF  5B
0380:  MOVF   56,W
0381:  MOVWF  5C
0382:  CALL   2A2
....................      #endif 
....................    } 
0383:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
....................  
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
*
083F:  MOVLW  B9
0840:  MOVWF  32
0841:  MOVLW  3B
0842:  MOVWF  33
0843:  MOVLW  5E
0844:  MOVWF  34
0845:  MOVLW  38
0846:  MOVWF  35
0847:  MOVLW  34
0848:  MOVWF  36
0849:  MOVLW  35
084A:  MOVWF  37
084B:  MOVLW  38
084C:  MOVWF  38
084D:  MOVLW  32
084E:  MOVWF  39
084F:  MOVLW  66
0850:  MOVWF  3A
0851:  MOVLW  2F
0852:  MOVWF  3B
0853:  MOVLW  BD
0854:  MOVWF  3C
0855:  MOVLW  2C
0856:  MOVWF  3D
0857:  MOVLW  3A
0858:  MOVWF  3E
0859:  MOVLW  2A
085A:  MOVWF  3F
085B:  MOVLW  DC
085C:  MOVWF  40
085D:  MOVLW  27
085E:  MOVWF  41
085F:  MOVLW  9F
0860:  MOVWF  42
0861:  MOVLW  25
0862:  MOVWF  43
0863:  MOVLW  82
0864:  MOVWF  44
0865:  MOVLW  23
0866:  MOVWF  45
0867:  MOVLW  84
0868:  MOVWF  46
0869:  MOVLW  21
086A:  MOVWF  47
086B:  MOVLW  A3
086C:  MOVWF  48
086D:  MOVLW  1F
086E:  MOVWF  49
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
....................  
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
03BF:  CLRF   57
03C0:  CLRF   56
03C1:  CLRF   59
03C2:  CLRF   58
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
03C3:  MOVF   53,F
03C4:  BTFSS  03.2
03C5:  GOTO   3CA
03C6:  MOVF   52,W
03C7:  SUBLW  13
03C8:  BTFSC  03.0
03C9:  GOTO   4D7
03CA:  MOVF   53,W
03CB:  SUBLW  4E
03CC:  BTFSS  03.0
03CD:  GOTO   4D7
03CE:  BTFSS  03.2
03CF:  GOTO   3D4
03D0:  MOVF   52,W
03D1:  SUBLW  20
03D2:  BTFSS  03.0
03D3:  GOTO   4D7
....................       tmp=100000; 
03D4:  CLRF   5F
03D5:  MOVLW  01
03D6:  MOVWF  5E
03D7:  MOVLW  86
03D8:  MOVWF  5D
03D9:  MOVLW  A0
03DA:  MOVWF  5C
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
03DB:  BCF    03.1
03DC:  MOVF   5F,W
03DD:  MOVWF  63
03DE:  MOVF   5E,W
03DF:  MOVWF  62
03E0:  MOVF   5D,W
03E1:  MOVWF  61
03E2:  MOVF   5C,W
03E3:  MOVWF  60
03E4:  CLRF   67
03E5:  CLRF   66
03E6:  MOVF   53,W
03E7:  MOVWF  65
03E8:  MOVF   52,W
03E9:  MOVWF  64
*
0438:  MOVF   7A,W
0439:  MOVWF  5F
043A:  MOVF   79,W
043B:  MOVWF  5E
043C:  MOVF   78,W
043D:  MOVWF  5D
043E:  MOVF   77,W
043F:  MOVWF  5C
....................       tmp*=5;    
0440:  MOVF   5F,W
0441:  MOVWF  63
0442:  MOVF   5E,W
0443:  MOVWF  62
0444:  MOVF   5D,W
0445:  MOVWF  61
0446:  MOVF   5C,W
0447:  MOVWF  60
0448:  CLRF   67
0449:  CLRF   66
044A:  CLRF   65
044B:  MOVLW  05
044C:  MOVWF  64
*
0476:  MOVF   7A,W
0477:  MOVWF  5F
0478:  MOVF   79,W
0479:  MOVWF  5E
047A:  MOVF   78,W
047B:  MOVWF  5D
047C:  MOVF   77,W
047D:  MOVWF  5C
....................       uS=tmp; 
047E:  MOVF   5D,W
047F:  MOVWF  5B
0480:  MOVF   5C,W
0481:  MOVWF  5A
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
0482:  BSF    03.5
0483:  BCF    06.2
0484:  BCF    03.5
0485:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0486:  MOVF   5B,W
0487:  MOVWF  60
0488:  INCF   60,F
0489:  DECF   60,F
048A:  BTFSC  03.2
048B:  GOTO   490
048C:  MOVLW  FF
048D:  MOVWF  61
048E:  CALL   3B0
048F:  GOTO   489
0490:  MOVF   5A,W
0491:  MOVWF  61
0492:  CALL   3B0
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
0493:  MOVF   5A,W
0494:  ADDWF  58,F
0495:  MOVF   5B,W
0496:  BTFSC  03.0
0497:  INCFSZ 5B,W
0498:  ADDWF  59,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0499:  BSF    03.5
049A:  BCF    06.2
049B:  BCF    03.5
049C:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
049D:  MOVF   5B,W
049E:  MOVWF  60
049F:  INCF   60,F
04A0:  DECF   60,F
04A1:  BTFSC  03.2
04A2:  GOTO   4A7
04A3:  MOVLW  FF
04A4:  MOVWF  61
04A5:  CALL   3B0
04A6:  GOTO   4A0
04A7:  MOVF   5A,W
04A8:  MOVWF  61
04A9:  CALL   3B0
....................          CiclosL+=(uS);          //  
04AA:  MOVF   5A,W
04AB:  ADDWF  58,F
04AC:  MOVF   5B,W
04AD:  BTFSC  03.0
04AE:  INCFSZ 5B,W
04AF:  ADDWF  59,F
....................          CiclosL+=25;            // Compensador. 
04B0:  MOVLW  19
04B1:  ADDWF  58,F
04B2:  BTFSC  03.0
04B3:  INCF   59,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
04B4:  MOVF   59,W
04B5:  SUBLW  02
04B6:  BTFSC  03.0
04B7:  GOTO   4CD
04B8:  XORLW  FF
04B9:  BTFSS  03.2
04BA:  GOTO   4BF
04BB:  MOVF   58,W
04BC:  SUBLW  E7
04BD:  BTFSC  03.0
04BE:  GOTO   4CD
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
04BF:  MOVLW  E8
04C0:  SUBWF  58,F
04C1:  MOVLW  03
04C2:  BTFSS  03.0
04C3:  MOVLW  04
04C4:  SUBWF  59,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
04C5:  INCF   56,F
04C6:  BTFSC  03.2
04C7:  INCF   57,F
....................             CiclosL+=25;         // Compensador. 
04C8:  MOVLW  19
04C9:  ADDWF  58,F
04CA:  BTFSC  03.0
04CB:  INCF   59,F
04CC:  GOTO   4B4
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
04CD:  MOVF   57,W
04CE:  SUBWF  55,W
04CF:  BTFSS  03.0
04D0:  GOTO   4D7
04D1:  BTFSS  03.2
04D2:  GOTO   482
04D3:  MOVF   54,W
04D4:  SUBWF  56,W
04D5:  BTFSS  03.0
04D6:  GOTO   482
....................                                          // tiempo indicado. 
....................    } 
04D7:  RETURN
.................... } 
....................  
.................... #include "header/func_menu_setup.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
.................... /** DIRECTIVAS **/ 
.................... #define OPT_SHOW_IP     0 
.................... #define OPT_SHOW_SSID   1 
.................... #define OPT_SHOW_KEY    2 
.................... #define OPT_MODE_AP     3 
.................... #define OPT_BACKLIGH    4 
.................... #define OPT_EXIT        5 
....................  
.................... void pressOk(void){ 
....................    while(1){ 
....................       if(input(KEY_OK)==0){ 
*
06E1:  BSF    03.5
06E2:  BSF    06.5
06E3:  BCF    03.5
06E4:  BTFSC  06.5
06E5:  GOTO   6EE
....................             // Elimina el rebote 
....................             delay_ms(500); 
06E6:  MOVLW  02
06E7:  MOVWF  53
06E8:  MOVLW  FA
06E9:  MOVWF  57
06EA:  CALL   22D
06EB:  DECFSZ 53,F
06EC:  GOTO   6E8
....................             break; 
06ED:  GOTO   6EF
....................       } 
06EE:  GOTO   6E1
....................    } 
06EF:  RETURN
.................... } 
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................    switch(optSelect){ 
06F0:  MOVF   52,W
06F1:  ADDLW  FA
06F2:  BTFSC  03.0
06F3:  GOTO   762
06F4:  ADDLW  06
06F5:  GOTO   765
....................        
....................       case OPT_SHOW_IP: 
....................          printf(lcd_putc, "\f192.168.0.1"); 
06F6:  MOVLW  04
06F7:  BSF    03.6
06F8:  MOVWF  0D
06F9:  MOVLW  00
06FA:  MOVWF  0F
06FB:  BCF    03.6
06FC:  CALL   68B
....................          lcd_gotoxy(1,2); 
06FD:  MOVLW  01
06FE:  MOVWF  57
06FF:  MOVLW  02
0700:  MOVWF  58
0701:  CALL   346
....................          printf(lcd_putc, "OK para SALIR"); 
0702:  MOVLW  0B
0703:  BSF    03.6
0704:  MOVWF  0D
0705:  MOVLW  00
0706:  MOVWF  0F
0707:  BCF    03.6
0708:  CALL   68B
....................          pressOk(); 
0709:  CALL   6E1
....................          break; 
070A:  GOTO   762
....................       case OPT_SHOW_SSID: 
....................          lcd_gotoxy(1,2); 
070B:  MOVLW  01
070C:  MOVWF  57
070D:  MOVLW  02
070E:  MOVWF  58
070F:  CALL   346
....................          printf(lcd_putc, "\fC0G3_UNE"); 
0710:  MOVLW  12
0711:  BSF    03.6
0712:  MOVWF  0D
0713:  MOVLW  00
0714:  MOVWF  0F
0715:  BCF    03.6
0716:  CALL   68B
....................          lcd_gotoxy(1,2); 
0717:  MOVLW  01
0718:  MOVWF  57
0719:  MOVLW  02
071A:  MOVWF  58
071B:  CALL   346
....................          printf(lcd_putc, "OK para SALIR"); 
071C:  MOVLW  17
071D:  BSF    03.6
071E:  MOVWF  0D
071F:  MOVLW  00
0720:  MOVWF  0F
0721:  BCF    03.6
0722:  CALL   68B
....................          pressOk();          
0723:  CALL   6E1
....................          break; 
0724:  GOTO   762
....................       case OPT_SHOW_KEY: 
....................          printf(lcd_putc, "\f1234Az!"); 
0725:  MOVLW  1E
0726:  BSF    03.6
0727:  MOVWF  0D
0728:  MOVLW  00
0729:  MOVWF  0F
072A:  BCF    03.6
072B:  CALL   68B
....................          lcd_gotoxy(1,2); 
072C:  MOVLW  01
072D:  MOVWF  57
072E:  MOVLW  02
072F:  MOVWF  58
0730:  CALL   346
....................          printf(lcd_putc, "OK para SALIR"); 
0731:  MOVLW  23
0732:  BSF    03.6
0733:  MOVWF  0D
0734:  MOVLW  00
0735:  MOVWF  0F
0736:  BCF    03.6
0737:  CALL   68B
....................          pressOk();  
0738:  CALL   6E1
....................          break; 
0739:  GOTO   762
....................       case OPT_MODE_AP: 
....................          lcd_gotoxy(1,2); 
073A:  MOVLW  01
073B:  MOVWF  57
073C:  MOVLW  02
073D:  MOVWF  58
073E:  CALL   346
....................          printf(lcd_putc, "\fDisable Mode"); 
073F:  MOVLW  2A
0740:  BSF    03.6
0741:  MOVWF  0D
0742:  MOVLW  00
0743:  MOVWF  0F
0744:  BCF    03.6
0745:  CALL   68B
....................          lcd_gotoxy(1,2); 
0746:  MOVLW  01
0747:  MOVWF  57
0748:  MOVLW  02
0749:  MOVWF  58
074A:  CALL   346
....................          printf(lcd_putc, "OK para SALIR"); 
074B:  MOVLW  31
074C:  BSF    03.6
074D:  MOVWF  0D
074E:  MOVLW  00
074F:  MOVWF  0F
0750:  BCF    03.6
0751:  CALL   68B
....................          pressOk(); 
0752:  CALL   6E1
....................          break; 
0753:  GOTO   762
....................       case OPT_BACKLIGH: 
....................          output_toggle(LCD_LIGHT_PIN); 
0754:  BSF    03.5
0755:  BCF    08.3
0756:  MOVLW  08
0757:  BCF    03.5
0758:  XORWF  08,F
....................          printf(lcd_putc, "\fOK para SALIR"); 
0759:  MOVLW  38
075A:  BSF    03.6
075B:  MOVWF  0D
075C:  MOVLW  00
075D:  MOVWF  0F
075E:  BCF    03.6
075F:  CALL   68B
....................          pressOk(); 
0760:  CALL   6E1
....................          break; 
0761:  GOTO   762
....................       case OPT_EXIT: 
....................          break; 
....................           
....................    } 
0762:  BCF    0A.3
0763:  BCF    0A.4
0764:  GOTO   7D9 (RETURN)
....................  
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuSetup  = 5; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[7][17]    =  { {"VER IP          "}, 
....................                                         {"VER SSID        "}, 
....................                                         {"VER KEY         "}, 
....................                                         {"Modo AccessPoint"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
04D8:  CLRF   50
04D9:  CLRF   51
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
04DA:  SWAPF  50,W
04DB:  MOVWF  77
04DC:  MOVLW  F0
04DD:  ANDWF  77,F
04DE:  MOVF   77,W
04DF:  MOVWF  52
04E0:  MOVLW  0C
04E1:  MOVWF  56
04E2:  CALL   358
04E3:  MOVLW  40
04E4:  BSF    03.6
04E5:  MOVWF  0D
04E6:  MOVLW  00
04E7:  MOVWF  0F
04E8:  BCF    03.6
04E9:  MOVF   52,W
04EA:  BSF    03.6
04EB:  ADDWF  0D,F
04EC:  BTFSC  03.0
04ED:  INCF   0F,F
04EE:  BCF    03.6
04EF:  CALL   384
....................  
....................    while(!exit){ 
04F0:  MOVF   51,F
04F1:  BTFSS  03.2
04F2:  GOTO   539
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
04F3:  BSF    03.5
04F4:  BSF    06.4
04F5:  BCF    03.5
04F6:  BTFSC  06.4
04F7:  GOTO   522
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
04F8:  MOVLW  02
04F9:  MOVWF  52
04FA:  MOVLW  FA
04FB:  MOVWF  57
04FC:  CALL   22D
04FD:  DECFSZ 52,F
04FE:  GOTO   4FA
....................          BEEP; 
04FF:  MOVLW  04
0500:  MOVWF  53
0501:  MOVLW  B9
0502:  MOVWF  52
0503:  CLRF   55
0504:  MOVLW  14
0505:  MOVWF  54
0506:  CALL   3BF
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0507:  INCF   50,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
0508:  MOVF   50,W
0509:  SUBWF  4A,W
050A:  BTFSS  03.0
....................             optSelected = 0; 
050B:  CLRF   50
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
050C:  SWAPF  50,W
050D:  MOVWF  77
050E:  MOVLW  F0
050F:  ANDWF  77,F
0510:  MOVF   77,W
0511:  MOVWF  52
0512:  MOVLW  0C
0513:  MOVWF  56
0514:  CALL   358
0515:  MOVLW  40
0516:  BSF    03.6
0517:  MOVWF  0D
0518:  MOVLW  00
0519:  MOVWF  0F
051A:  BCF    03.6
051B:  MOVF   52,W
051C:  BSF    03.6
051D:  ADDWF  0D,F
051E:  BTFSC  03.0
051F:  INCF   0F,F
0520:  BCF    03.6
0521:  CALL   384
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0522:  BSF    03.5
0523:  BSF    06.5
0524:  BCF    03.5
0525:  BTFSC  06.5
0526:  GOTO   538
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0527:  MOVLW  02
0528:  MOVWF  52
0529:  MOVLW  FA
052A:  MOVWF  57
052B:  CALL   22D
052C:  DECFSZ 52,F
052D:  GOTO   529
....................          BEEP; 
052E:  MOVLW  04
052F:  MOVWF  53
0530:  MOVLW  B9
0531:  MOVWF  52
0532:  CLRF   55
0533:  MOVLW  14
0534:  MOVWF  54
0535:  CALL   3BF
....................          // Rompe el Loop 
....................          exit = 1; 
0536:  MOVLW  01
0537:  MOVWF  51
....................       } // Fin KEY_OK 
0538:  GOTO   4F0
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
0539:  MOVLW  01
053A:  ADDWF  50,W
053B:  MOVWF  78
053C:  BSF    0A.3
053D:  BCF    0A.4
053E:  GOTO   08A (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
0584:  CLRF   50
0585:  CLRF   51
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0586:  MOVF   50,W
0587:  MOVWF  52
0588:  MOVLW  0F
0589:  MOVWF  53
058A:  CALL   53F
058B:  MOVF   78,W
058C:  MOVWF  52
058D:  MOVLW  0C
058E:  MOVWF  56
058F:  CALL   358
0590:  MOVLW  80
0591:  BSF    03.6
0592:  MOVWF  0D
0593:  MOVLW  00
0594:  MOVWF  0F
0595:  BCF    03.6
0596:  MOVF   52,W
0597:  BSF    03.6
0598:  ADDWF  0D,F
0599:  BTFSC  03.0
059A:  INCF   0F,F
059B:  BCF    03.6
059C:  CALL   384
....................     
....................    while(!exit){ 
059D:  MOVF   51,F
059E:  BTFSS  03.2
059F:  GOTO   604
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
05A0:  BSF    03.5
05A1:  BSF    06.4
05A2:  BCF    03.5
05A3:  BTFSC  06.4
05A4:  GOTO   5D0
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
05A5:  MOVLW  02
05A6:  MOVWF  52
05A7:  MOVLW  FA
05A8:  MOVWF  57
05A9:  CALL   22D
05AA:  DECFSZ 52,F
05AB:  GOTO   5A7
....................          BEEP; 
05AC:  MOVLW  04
05AD:  MOVWF  53
05AE:  MOVLW  B9
05AF:  MOVWF  52
05B0:  CLRF   55
05B1:  MOVLW  14
05B2:  MOVWF  54
05B3:  CALL   3BF
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
05B4:  INCF   50,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
05B5:  MOVF   50,W
05B6:  SUBWF  4C,W
05B7:  BTFSS  03.0
....................             optSelected = 0; 
05B8:  CLRF   50
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
05B9:  MOVF   50,W
05BA:  MOVWF  52
05BB:  MOVLW  0F
05BC:  MOVWF  53
05BD:  CALL   53F
05BE:  MOVF   78,W
05BF:  MOVWF  52
05C0:  MOVLW  0C
05C1:  MOVWF  56
05C2:  CALL   358
05C3:  MOVLW  80
05C4:  BSF    03.6
05C5:  MOVWF  0D
05C6:  MOVLW  00
05C7:  MOVWF  0F
05C8:  BCF    03.6
05C9:  MOVF   52,W
05CA:  BSF    03.6
05CB:  ADDWF  0D,F
05CC:  BTFSC  03.0
05CD:  INCF   0F,F
05CE:  BCF    03.6
05CF:  CALL   384
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
05D0:  BSF    03.5
05D1:  BSF    06.5
05D2:  BCF    03.5
05D3:  BTFSC  06.5
05D4:  GOTO   603
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
05D5:  MOVLW  02
05D6:  MOVWF  52
05D7:  MOVLW  FA
05D8:  MOVWF  57
05D9:  CALL   22D
05DA:  DECFSZ 52,F
05DB:  GOTO   5D7
....................          BEEP; 
05DC:  MOVLW  04
05DD:  MOVWF  53
05DE:  MOVLW  B9
05DF:  MOVWF  52
05E0:  CLRF   55
05E1:  MOVLW  14
05E2:  MOVWF  54
05E3:  CALL   3BF
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
05E4:  MOVF   4C,W
05E5:  SUBWF  50,W
05E6:  BTFSS  03.2
05E7:  GOTO   5EB
....................             exit = 1; 
05E8:  MOVLW  01
05E9:  MOVWF  51
....................          }else{ 
05EA:  GOTO   603
....................             output_high(PIN_OUT[optSelected]); 
05EB:  BCF    03.0
05EC:  RLF    50,W
05ED:  ADDLW  20
05EE:  MOVWF  04
05EF:  BCF    03.7
05F0:  INCF   04,F
05F1:  MOVF   00,W
05F2:  MOVWF  53
05F3:  DECF   04,F
05F4:  MOVF   00,W
05F5:  MOVWF  52
05F6:  MOVWF  54
05F7:  MOVLW  01
05F8:  MOVWF  55
05F9:  CLRF   57
05FA:  CLRF   56
05FB:  CALL   564
05FC:  MOVF   52,W
05FD:  MOVWF  54
05FE:  CLRF   55
05FF:  CLRF   57
0600:  MOVLW  80
0601:  MOVWF  56
0602:  CALL   564
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0603:  GOTO   59D
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0604:  MOVLW  00
0605:  MOVWF  78
0606:  BSF    0A.3
0607:  BCF    0A.4
0608:  GOTO   090 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
0609:  CLRF   50
060A:  CLRF   51
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
060B:  SWAPF  50,W
060C:  MOVWF  77
060D:  MOVLW  F0
060E:  ANDWF  77,F
060F:  MOVF   77,W
0610:  MOVWF  52
0611:  MOVLW  0C
0612:  MOVWF  56
0613:  CALL   358
0614:  MOVLW  16
0615:  BSF    03.6
0616:  MOVWF  0D
0617:  MOVLW  01
0618:  MOVWF  0F
0619:  BCF    03.6
061A:  MOVF   52,W
061B:  BSF    03.6
061C:  ADDWF  0D,F
061D:  BTFSC  03.0
061E:  INCF   0F,F
061F:  BCF    03.6
0620:  CALL   384
....................     
....................    while(!exit){ 
0621:  MOVF   51,F
0622:  BTFSS  03.2
0623:  GOTO   686
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0624:  BSF    03.5
0625:  BSF    06.4
0626:  BCF    03.5
0627:  BTFSC  06.4
0628:  GOTO   653
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0629:  MOVLW  02
062A:  MOVWF  52
062B:  MOVLW  FA
062C:  MOVWF  57
062D:  CALL   22D
062E:  DECFSZ 52,F
062F:  GOTO   62B
....................          BEEP; 
0630:  MOVLW  04
0631:  MOVWF  53
0632:  MOVLW  B9
0633:  MOVWF  52
0634:  CLRF   55
0635:  MOVLW  14
0636:  MOVWF  54
0637:  CALL   3BF
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0638:  INCF   50,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
0639:  MOVF   50,W
063A:  SUBWF  4D,W
063B:  BTFSS  03.0
....................             optSelected = 0; 
063C:  CLRF   50
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
063D:  SWAPF  50,W
063E:  MOVWF  77
063F:  MOVLW  F0
0640:  ANDWF  77,F
0641:  MOVF   77,W
0642:  MOVWF  52
0643:  MOVLW  0C
0644:  MOVWF  56
0645:  CALL   358
0646:  MOVLW  16
0647:  BSF    03.6
0648:  MOVWF  0D
0649:  MOVLW  01
064A:  MOVWF  0F
064B:  BCF    03.6
064C:  MOVF   52,W
064D:  BSF    03.6
064E:  ADDWF  0D,F
064F:  BTFSC  03.0
0650:  INCF   0F,F
0651:  BCF    03.6
0652:  CALL   384
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0653:  BSF    03.5
0654:  BSF    06.5
0655:  BCF    03.5
0656:  BTFSC  06.5
0657:  GOTO   685
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0658:  MOVLW  02
0659:  MOVWF  52
065A:  MOVLW  FA
065B:  MOVWF  57
065C:  CALL   22D
065D:  DECFSZ 52,F
065E:  GOTO   65A
....................          BEEP; 
065F:  MOVLW  04
0660:  MOVWF  53
0661:  MOVLW  B9
0662:  MOVWF  52
0663:  CLRF   55
0664:  MOVLW  14
0665:  MOVWF  54
0666:  CALL   3BF
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
0667:  MOVF   4D,W
0668:  SUBWF  50,W
0669:  BTFSS  03.2
066A:  GOTO   66E
....................             exit = 1; 
066B:  MOVLW  01
066C:  MOVWF  51
....................          }else{ 
066D:  GOTO   685
....................             output_low(PIN_OUT[optSelected]); 
066E:  BCF    03.0
066F:  RLF    50,W
0670:  ADDLW  20
0671:  MOVWF  04
0672:  BCF    03.7
0673:  INCF   04,F
0674:  MOVF   00,W
0675:  MOVWF  53
0676:  DECF   04,F
0677:  MOVF   00,W
0678:  MOVWF  52
0679:  MOVWF  54
067A:  CLRF   55
067B:  CLRF   57
067C:  CLRF   56
067D:  CALL   564
067E:  MOVF   52,W
067F:  MOVWF  54
0680:  CLRF   55
0681:  CLRF   57
0682:  MOVLW  80
0683:  MOVWF  56
0684:  CALL   564
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0685:  GOTO   621
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0686:  MOVLW  00
0687:  MOVWF  78
0688:  BSF    0A.3
0689:  BCF    0A.4
068A:  GOTO   096 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
.................... int getMenuSetup(void){ 
*
076F:  CLRF   50
0770:  CLRF   51
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0771:  MOVF   50,W
0772:  MOVWF  52
0773:  MOVLW  11
0774:  MOVWF  53
0775:  CALL   53F
0776:  MOVF   78,W
0777:  MOVWF  52
0778:  MOVLW  0C
0779:  MOVWF  56
077A:  CALL   358
077B:  MOVLW  B6
077C:  BSF    03.6
077D:  MOVWF  0D
077E:  MOVLW  01
077F:  MOVWF  0F
0780:  BCF    03.6
0781:  MOVF   52,W
0782:  BSF    03.6
0783:  ADDWF  0D,F
0784:  BTFSC  03.0
0785:  INCF   0F,F
0786:  BCF    03.6
0787:  CALL   384
....................     
....................    while(!exit){ 
0788:  MOVF   51,F
0789:  BTFSS  03.2
078A:  GOTO   7F1
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
078B:  BSF    03.5
078C:  BSF    06.4
078D:  BCF    03.5
078E:  BTFSC  06.4
078F:  GOTO   7BB
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0790:  MOVLW  02
0791:  MOVWF  52
0792:  MOVLW  FA
0793:  MOVWF  57
0794:  CALL   22D
0795:  DECFSZ 52,F
0796:  GOTO   792
....................          BEEP; 
0797:  MOVLW  04
0798:  MOVWF  53
0799:  MOVLW  B9
079A:  MOVWF  52
079B:  CLRF   55
079C:  MOVLW  14
079D:  MOVWF  54
079E:  CALL   3BF
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
079F:  INCF   50,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
07A0:  MOVF   50,W
07A1:  SUBWF  4B,W
07A2:  BTFSS  03.0
....................             optSelected = 0; 
07A3:  CLRF   50
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
07A4:  MOVF   50,W
07A5:  MOVWF  52
07A6:  MOVLW  11
07A7:  MOVWF  53
07A8:  CALL   53F
07A9:  MOVF   78,W
07AA:  MOVWF  52
07AB:  MOVLW  0C
07AC:  MOVWF  56
07AD:  CALL   358
07AE:  MOVLW  B6
07AF:  BSF    03.6
07B0:  MOVWF  0D
07B1:  MOVLW  01
07B2:  MOVWF  0F
07B3:  BCF    03.6
07B4:  MOVF   52,W
07B5:  BSF    03.6
07B6:  ADDWF  0D,F
07B7:  BTFSC  03.0
07B8:  INCF   0F,F
07B9:  BCF    03.6
07BA:  CALL   384
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
07BB:  BSF    03.5
07BC:  BSF    06.5
07BD:  BCF    03.5
07BE:  BTFSC  06.5
07BF:  GOTO   7F0
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
07C0:  MOVLW  02
07C1:  MOVWF  52
07C2:  MOVLW  FA
07C3:  MOVWF  57
07C4:  CALL   22D
07C5:  DECFSZ 52,F
07C6:  GOTO   7C2
....................          BEEP; 
07C7:  MOVLW  04
07C8:  MOVWF  53
07C9:  MOVLW  B9
07CA:  MOVWF  52
07CB:  CLRF   55
07CC:  MOVLW  14
07CD:  MOVWF  54
07CE:  CALL   3BF
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
07CF:  MOVF   4B,W
07D0:  SUBWF  50,W
07D1:  BTFSS  03.2
07D2:  GOTO   7D6
....................             exit = 1; 
07D3:  MOVLW  01
07D4:  MOVWF  51
....................          }else{ 
07D5:  GOTO   7F0
....................             executeSetup(optSelected); 
07D6:  MOVF   50,W
07D7:  MOVWF  52
07D8:  GOTO   6F0
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
07D9:  MOVF   50,W
07DA:  MOVWF  52
07DB:  MOVLW  11
07DC:  MOVWF  53
07DD:  CALL   53F
07DE:  MOVF   78,W
07DF:  MOVWF  52
07E0:  MOVLW  0C
07E1:  MOVWF  56
07E2:  CALL   358
07E3:  MOVLW  B6
07E4:  BSF    03.6
07E5:  MOVWF  0D
07E6:  MOVLW  01
07E7:  MOVWF  0F
07E8:  BCF    03.6
07E9:  MOVF   52,W
07EA:  BSF    03.6
07EB:  ADDWF  0D,F
07EC:  BTFSC  03.0
07ED:  INCF   0F,F
07EE:  BCF    03.6
07EF:  CALL   384
....................          } 
....................       } // Fin KEY_OK 
07F0:  GOTO   788
....................    } // FIN While Infinito 
....................  
....................    return 0; 
07F1:  MOVLW  00
07F2:  MOVWF  78
07F3:  BSF    0A.3
07F4:  BCF    0A.4
07F5:  GOTO   09C (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
....................  
....................  
.................... /** VARIABLES GLOBALS **/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
.................... // Flag usada para almacenar las respuestas de las opciones de menu 
.................... int optSelect  = 0; 
....................  
.................... /** INTERRUPCIONES **/ 
....................  
.................... //@hint: se dispara cuando se detectan datos de llegada al puerto serie portWF 
.................... /* 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................  
.................... }*/ 
....................  
.................... /** INIT **/ 
....................  
....................    void main() 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  BSF    03.5
0804:  BCF    06.0
0805:  BCF    03.5
0806:  BSF    06.0
0807:  BSF    03.5
0808:  BCF    06.0
0809:  BCF    03.5
080A:  BSF    06.0
080B:  MOVLW  02
080C:  MOVWF  4A
080D:  MOVLW  05
080E:  MOVWF  4B
080F:  MOVLW  08
0810:  MOVWF  4C
0811:  MOVWF  4D
0812:  CLRF   4E
0813:  CLRF   4F
0814:  BSF    03.5
0815:  BSF    03.6
0816:  MOVF   09,W
0817:  ANDLW  C0
0818:  MOVWF  09
0819:  BCF    03.6
081A:  BCF    1F.4
081B:  BCF    1F.5
081C:  MOVLW  00
081D:  BSF    03.6
081E:  MOVWF  08
081F:  BCF    03.5
0820:  CLRF   07
0821:  CLRF   08
0822:  CLRF   09
0823:  BCF    03.7
....................    { 
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
*
086F:  MOVLW  30
0870:  BSF    03.5
0871:  MOVWF  15
0872:  BCF    01.7
....................       set_tris_b(0b00110010); 
0873:  MOVLW  32
0874:  MOVWF  06
....................        
....................       // Inicializa la lcd 
....................       lcd_init(); 
0875:  BCF    0A.3
0876:  BCF    03.5
0877:  GOTO   300
0878:  BSF    0A.3
....................        
....................       //Estabiliza el inicio del programa 
....................       delay_ms(1000); 
0879:  MOVLW  04
087A:  MOVWF  50
087B:  MOVLW  FA
087C:  MOVWF  57
087D:  BCF    0A.3
087E:  CALL   22D
087F:  BSF    0A.3
0880:  DECFSZ 50,F
0881:  GOTO   07B
....................        
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
0882:  MOVF   4E,W
0883:  ADDLW  FC
0884:  BTFSC  03.0
0885:  GOTO   09F
0886:  ADDLW  04
0887:  GOTO   0A1
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
0888:  BCF    0A.3
0889:  GOTO   4D8
088A:  BSF    0A.3
088B:  MOVF   78,W
088C:  MOVWF  4E
....................                break; 
088D:  GOTO   09F
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
088E:  BCF    0A.3
088F:  GOTO   584
0890:  BSF    0A.3
0891:  MOVF   78,W
0892:  MOVWF  4E
....................                break; 
0893:  GOTO   09F
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
0894:  BCF    0A.3
0895:  GOTO   609
0896:  BSF    0A.3
0897:  MOVF   78,W
0898:  MOVWF  4E
....................                break; 
0899:  GOTO   09F
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
089A:  BCF    0A.3
089B:  GOTO   76F
089C:  BSF    0A.3
089D:  MOVF   78,W
089E:  MOVWF  4E
....................                break; 
....................          } // Fin del Switch(menuActive) 
089F:  GOTO   082
....................           
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
08A0:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
