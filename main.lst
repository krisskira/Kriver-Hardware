CCS PCM C Compiler, Version 5.015, 5967               06-dic.-17 00:41

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   4678 words (57%)
                           Largest free fragment is 2048
               RAM used:   101 (27%) at main() level
                           139 (38%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0E
0001:  MOVWF  0A
0002:  GOTO   69F
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   31B
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  43
0056:  RETLW  4D
0057:  RETLW  44
0058:  RETLW  3A
0059:  RETLW  45
005A:  RETLW  6E
005B:  RETLW  63
005C:  RETLW  65
005D:  RETLW  6E
005E:  RETLW  64
005F:  RETLW  65
0060:  RETLW  72
0061:  RETLW  20
0062:  RETLW  4D
0063:  RETLW  61
0064:  RETLW  6E
0065:  RETLW  75
0066:  RETLW  61
0067:  RETLW  6C
0068:  RETLW  00
0069:  RETLW  41
006A:  RETLW  70
006B:  RETLW  61
006C:  RETLW  67
006D:  RETLW  61
006E:  RETLW  64
006F:  RETLW  6F
0070:  RETLW  20
0071:  RETLW  4D
0072:  RETLW  61
0073:  RETLW  6E
0074:  RETLW  75
0075:  RETLW  61
0076:  RETLW  6C
0077:  RETLW  20
0078:  RETLW  00
0079:  RETLW  43
007A:  RETLW  6F
007B:  RETLW  6E
007C:  RETLW  66
007D:  RETLW  69
007E:  RETLW  67
007F:  RETLW  75
0080:  RETLW  72
0081:  RETLW  61
0082:  RETLW  63
0083:  RETLW  69
0084:  RETLW  6F
0085:  RETLW  6E
0086:  RETLW  20
0087:  RETLW  20
0088:  RETLW  00
0089:  RETLW  00
008A:  RETLW  00
008B:  RETLW  00
008C:  RETLW  00
008D:  RETLW  00
008E:  RETLW  00
008F:  RETLW  00
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  00
0094:  RETLW  00
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  00
0098:  RETLW  00
0099:  RETLW  4F
009A:  RETLW  6E
009B:  RETLW  20
009C:  RETLW  2D
009D:  RETLW  3E
009E:  RETLW  20
009F:  RETLW  53
00A0:  RETLW  61
00A1:  RETLW  6C
00A2:  RETLW  69
00A3:  RETLW  64
00A4:  RETLW  61
00A5:  RETLW  20
00A6:  RETLW  31
00A7:  RETLW  00
00A8:  RETLW  4F
00A9:  RETLW  6E
00AA:  RETLW  20
00AB:  RETLW  2D
00AC:  RETLW  3E
00AD:  RETLW  20
00AE:  RETLW  53
00AF:  RETLW  61
00B0:  RETLW  6C
00B1:  RETLW  69
00B2:  RETLW  64
00B3:  RETLW  61
00B4:  RETLW  20
00B5:  RETLW  32
00B6:  RETLW  00
00B7:  RETLW  4F
00B8:  RETLW  6E
00B9:  RETLW  20
00BA:  RETLW  2D
00BB:  RETLW  3E
00BC:  RETLW  20
00BD:  RETLW  53
00BE:  RETLW  61
00BF:  RETLW  6C
00C0:  RETLW  69
00C1:  RETLW  64
00C2:  RETLW  61
00C3:  RETLW  20
00C4:  RETLW  33
00C5:  RETLW  00
00C6:  RETLW  4F
00C7:  RETLW  6E
00C8:  RETLW  20
00C9:  RETLW  2D
00CA:  RETLW  3E
00CB:  RETLW  20
00CC:  RETLW  53
00CD:  RETLW  61
00CE:  RETLW  6C
00CF:  RETLW  69
00D0:  RETLW  64
00D1:  RETLW  61
00D2:  RETLW  20
00D3:  RETLW  34
00D4:  RETLW  00
00D5:  RETLW  4F
00D6:  RETLW  6E
00D7:  RETLW  20
00D8:  RETLW  2D
00D9:  RETLW  3E
00DA:  RETLW  20
00DB:  RETLW  53
00DC:  RETLW  61
00DD:  RETLW  6C
00DE:  RETLW  69
00DF:  RETLW  64
00E0:  RETLW  61
00E1:  RETLW  20
00E2:  RETLW  35
00E3:  RETLW  00
00E4:  RETLW  4F
00E5:  RETLW  6E
00E6:  RETLW  20
00E7:  RETLW  2D
00E8:  RETLW  3E
00E9:  RETLW  20
00EA:  RETLW  53
00EB:  RETLW  61
00EC:  RETLW  6C
00ED:  RETLW  69
00EE:  RETLW  64
00EF:  RETLW  61
00F0:  RETLW  20
00F1:  RETLW  36
00F2:  RETLW  00
00F3:  RETLW  4F
00F4:  RETLW  6E
00F5:  RETLW  20
00F6:  RETLW  2D
00F7:  RETLW  3E
00F8:  RETLW  20
00F9:  RETLW  53
00FA:  RETLW  61
00FB:  RETLW  6C
00FC:  RETLW  69
00FD:  RETLW  64
00FE:  RETLW  61
00FF:  RETLW  20
0100:  RETLW  37
0101:  RETLW  00
0102:  RETLW  4F
0103:  RETLW  6E
0104:  RETLW  20
0105:  RETLW  2D
0106:  RETLW  3E
0107:  RETLW  20
0108:  RETLW  53
0109:  RETLW  61
010A:  RETLW  6C
010B:  RETLW  69
010C:  RETLW  64
010D:  RETLW  61
010E:  RETLW  20
010F:  RETLW  38
0110:  RETLW  00
0111:  RETLW  53
0112:  RETLW  41
0113:  RETLW  4C
0114:  RETLW  49
0115:  RETLW  52
0116:  RETLW  20
0117:  RETLW  20
0118:  RETLW  20
0119:  RETLW  20
011A:  RETLW  20
011B:  RETLW  20
011C:  RETLW  20
011D:  RETLW  20
011E:  RETLW  20
011F:  RETLW  00
0120:  RETLW  00
0121:  RETLW  00
0122:  RETLW  00
0123:  RETLW  00
0124:  RETLW  00
0125:  RETLW  00
0126:  RETLW  00
0127:  RETLW  00
0128:  RETLW  00
0129:  RETLW  00
012A:  RETLW  00
012B:  RETLW  00
012C:  RETLW  00
012D:  RETLW  00
012E:  RETLW  00
012F:  RETLW  4F
0130:  RETLW  66
0131:  RETLW  66
0132:  RETLW  20
0133:  RETLW  2D
0134:  RETLW  3E
0135:  RETLW  20
0136:  RETLW  53
0137:  RETLW  61
0138:  RETLW  6C
0139:  RETLW  69
013A:  RETLW  64
013B:  RETLW  61
013C:  RETLW  20
013D:  RETLW  31
013E:  RETLW  00
013F:  RETLW  4F
0140:  RETLW  66
0141:  RETLW  66
0142:  RETLW  20
0143:  RETLW  2D
0144:  RETLW  3E
0145:  RETLW  20
0146:  RETLW  53
0147:  RETLW  61
0148:  RETLW  6C
0149:  RETLW  69
014A:  RETLW  64
014B:  RETLW  61
014C:  RETLW  20
014D:  RETLW  32
014E:  RETLW  00
014F:  RETLW  4F
0150:  RETLW  66
0151:  RETLW  66
0152:  RETLW  20
0153:  RETLW  2D
0154:  RETLW  3E
0155:  RETLW  20
0156:  RETLW  53
0157:  RETLW  61
0158:  RETLW  6C
0159:  RETLW  69
015A:  RETLW  64
015B:  RETLW  61
015C:  RETLW  20
015D:  RETLW  33
015E:  RETLW  00
015F:  RETLW  4F
0160:  RETLW  66
0161:  RETLW  66
0162:  RETLW  20
0163:  RETLW  2D
0164:  RETLW  3E
0165:  RETLW  20
0166:  RETLW  53
0167:  RETLW  61
0168:  RETLW  6C
0169:  RETLW  69
016A:  RETLW  64
016B:  RETLW  61
016C:  RETLW  20
016D:  RETLW  34
016E:  RETLW  00
016F:  RETLW  4F
0170:  RETLW  66
0171:  RETLW  66
0172:  RETLW  20
0173:  RETLW  2D
0174:  RETLW  3E
0175:  RETLW  20
0176:  RETLW  53
0177:  RETLW  61
0178:  RETLW  6C
0179:  RETLW  69
017A:  RETLW  64
017B:  RETLW  61
017C:  RETLW  20
017D:  RETLW  35
017E:  RETLW  00
017F:  RETLW  4F
0180:  RETLW  66
0181:  RETLW  66
0182:  RETLW  20
0183:  RETLW  2D
0184:  RETLW  3E
0185:  RETLW  20
0186:  RETLW  53
0187:  RETLW  61
0188:  RETLW  6C
0189:  RETLW  69
018A:  RETLW  64
018B:  RETLW  61
018C:  RETLW  20
018D:  RETLW  36
018E:  RETLW  00
018F:  RETLW  4F
0190:  RETLW  66
0191:  RETLW  66
0192:  RETLW  20
0193:  RETLW  2D
0194:  RETLW  3E
0195:  RETLW  20
0196:  RETLW  53
0197:  RETLW  61
0198:  RETLW  6C
0199:  RETLW  69
019A:  RETLW  64
019B:  RETLW  61
019C:  RETLW  20
019D:  RETLW  37
019E:  RETLW  00
019F:  RETLW  4F
01A0:  RETLW  66
01A1:  RETLW  66
01A2:  RETLW  20
01A3:  RETLW  2D
01A4:  RETLW  3E
01A5:  RETLW  20
01A6:  RETLW  53
01A7:  RETLW  61
01A8:  RETLW  6C
01A9:  RETLW  69
01AA:  RETLW  64
01AB:  RETLW  61
01AC:  RETLW  20
01AD:  RETLW  38
01AE:  RETLW  00
01AF:  RETLW  53
01B0:  RETLW  41
01B1:  RETLW  4C
01B2:  RETLW  49
01B3:  RETLW  52
01B4:  RETLW  20
01B5:  RETLW  20
01B6:  RETLW  20
01B7:  RETLW  20
01B8:  RETLW  20
01B9:  RETLW  20
01BA:  RETLW  20
01BB:  RETLW  20
01BC:  RETLW  20
01BD:  RETLW  20
01BE:  RETLW  00
01BF:  RETLW  00
01C0:  RETLW  00
01C1:  RETLW  00
01C2:  RETLW  00
01C3:  RETLW  00
01C4:  RETLW  00
01C5:  RETLW  00
01C6:  RETLW  00
01C7:  RETLW  00
01C8:  RETLW  00
01C9:  RETLW  00
01CA:  RETLW  00
01CB:  RETLW  00
01CC:  RETLW  00
01CD:  RETLW  00
01CE:  RETLW  00
01CF:  RETLW  56
01D0:  RETLW  45
01D1:  RETLW  52
01D2:  RETLW  20
01D3:  RETLW  49
01D4:  RETLW  50
01D5:  RETLW  20
01D6:  RETLW  20
01D7:  RETLW  20
01D8:  RETLW  20
01D9:  RETLW  20
01DA:  RETLW  20
01DB:  RETLW  20
01DC:  RETLW  20
01DD:  RETLW  20
01DE:  RETLW  20
01DF:  RETLW  00
01E0:  RETLW  56
01E1:  RETLW  45
01E2:  RETLW  52
01E3:  RETLW  20
01E4:  RETLW  53
01E5:  RETLW  53
01E6:  RETLW  49
01E7:  RETLW  44
01E8:  RETLW  20
01E9:  RETLW  20
01EA:  RETLW  20
01EB:  RETLW  20
01EC:  RETLW  20
01ED:  RETLW  20
01EE:  RETLW  20
01EF:  RETLW  20
01F0:  RETLW  00
01F1:  RETLW  56
01F2:  RETLW  45
01F3:  RETLW  52
01F4:  RETLW  20
01F5:  RETLW  4B
01F6:  RETLW  45
01F7:  RETLW  59
01F8:  RETLW  20
01F9:  RETLW  20
01FA:  RETLW  20
01FB:  RETLW  20
01FC:  RETLW  20
01FD:  RETLW  20
01FE:  RETLW  20
01FF:  RETLW  20
0200:  RETLW  20
0201:  RETLW  00
0202:  RETLW  43
0203:  RETLW  6F
0204:  RETLW  6E
0205:  RETLW  66
0206:  RETLW  20
0207:  RETLW  41
0208:  RETLW  63
0209:  RETLW  63
020A:  RETLW  65
020B:  RETLW  73
020C:  RETLW  73
020D:  RETLW  6F
020E:  RETLW  20
020F:  RETLW  52
0210:  RETLW  65
0211:  RETLW  64
0212:  RETLW  00
0213:  RETLW  4F
0214:  RETLW  6E
0215:  RETLW  2F
0216:  RETLW  4F
0217:  RETLW  66
0218:  RETLW  66
0219:  RETLW  20
021A:  RETLW  42
021B:  RETLW  61
021C:  RETLW  63
021D:  RETLW  6B
021E:  RETLW  6C
021F:  RETLW  69
0220:  RETLW  67
0221:  RETLW  68
0222:  RETLW  74
0223:  RETLW  00
0224:  RETLW  53
0225:  RETLW  41
0226:  RETLW  4C
0227:  RETLW  49
0228:  RETLW  52
0229:  RETLW  20
022A:  RETLW  20
022B:  RETLW  20
022C:  RETLW  20
022D:  RETLW  20
022E:  RETLW  20
022F:  RETLW  20
0230:  RETLW  20
0231:  RETLW  20
0232:  RETLW  20
0233:  RETLW  20
0234:  RETLW  00
0235:  RETLW  00
0236:  RETLW  00
0237:  RETLW  00
0238:  RETLW  00
0239:  RETLW  00
023A:  RETLW  00
023B:  RETLW  00
023C:  RETLW  00
023D:  RETLW  00
023E:  RETLW  00
023F:  RETLW  00
0240:  RETLW  00
0241:  RETLW  00
0242:  RETLW  00
0243:  RETLW  00
0244:  RETLW  00
0245:  RETLW  00
0246:  RETLW  45
0247:  RETLW  73
0248:  RETLW  74
0249:  RETLW  61
024A:  RETLW  63
024B:  RETLW  69
024C:  RETLW  6F
024D:  RETLW  6E
024E:  RETLW  20
024F:  RETLW  20
0250:  RETLW  20
0251:  RETLW  20
0252:  RETLW  20
0253:  RETLW  00
0254:  RETLW  41
0255:  RETLW  63
0256:  RETLW  63
0257:  RETLW  65
0258:  RETLW  73
0259:  RETLW  73
025A:  RETLW  20
025B:  RETLW  50
025C:  RETLW  6F
025D:  RETLW  69
025E:  RETLW  6E
025F:  RETLW  74
0260:  RETLW  20
0261:  RETLW  00
0262:  RETLW  45
0263:  RETLW  73
0264:  RETLW  74
0265:  RETLW  61
0266:  RETLW  63
0267:  RETLW  69
0268:  RETLW  6F
0269:  RETLW  6E
026A:  RETLW  20
026B:  RETLW  2B
026C:  RETLW  20
026D:  RETLW  41
026E:  RETLW  50
026F:  RETLW  00
0270:  RETLW  53
0271:  RETLW  41
0272:  RETLW  4C
0273:  RETLW  49
0274:  RETLW  52
0275:  RETLW  20
0276:  RETLW  20
0277:  RETLW  20
0278:  RETLW  20
0279:  RETLW  20
027A:  RETLW  20
027B:  RETLW  20
027C:  RETLW  20
027D:  RETLW  00
027E:  RETLW  00
027F:  RETLW  00
0280:  RETLW  00
0281:  RETLW  00
0282:  RETLW  00
0283:  RETLW  00
0284:  RETLW  00
0285:  RETLW  00
0286:  RETLW  00
0287:  RETLW  00
0288:  RETLW  00
0289:  RETLW  00
028A:  RETLW  00
028B:  RETLW  00
028C:  DATA D3,20
028D:  DATA CC,24
028E:  DATA 52,00
028F:  DATA DB,29
0290:  DATA C9,23
0291:  DATA 5D,10
0292:  DATA 20,10
0293:  DATA 20,10
0294:  DATA A0,2D
0295:  DATA 45,27
0296:  DATA D4,2E
0297:  DATA 00,00
0298:  DATA 8C,18
0299:  DATA 39,19
029A:  DATA AE,18
029B:  DATA 36,1C
029C:  DATA 2E,18
029D:  DATA AE,18
029E:  DATA 00,01
029F:  DATA 8C,21
02A0:  DATA B0,23
02A1:  DATA B3,2F
02A2:  DATA 55,27
02A3:  DATA 45,00
02A4:  DATA 8C,18
02A5:  DATA B2,19
02A6:  DATA B4,20
02A7:  DATA FA,10
02A8:  DATA 00,01
02A9:  DATA 0C,21
02AA:  DATA E1,31
02AB:  DATA 6B,36
02AC:  DATA E9,33
02AD:  DATA 68,3A
02AE:  DATA A0,27
02AF:  DATA 6E,00
02B0:  DATA 0C,21
02B1:  DATA E1,31
02B2:  DATA 6B,36
02B3:  DATA E9,33
02B4:  DATA 68,3A
02B5:  DATA A0,27
02B6:  DATA 66,33
02B7:  DATA 00,01
02B8:  DATA 41,2A
02B9:  DATA AB,21
02BA:  DATA D7,26
02BB:  DATA 4F,22
02BC:  DATA C5,2F
02BD:  DATA C4,22
02BE:  DATA C6,1E
02BF:  DATA B1,06
02C0:  DATA 0A,00
02C1:  DATA 8C,21
02C2:  DATA 6F,37
02C3:  DATA E6,34
02C4:  DATA 67,10
02C5:  DATA 43,36
02C6:  DATA E9,32
02C7:  DATA 6E,3A
02C8:  DATA 65,00
02C9:  DATA 41,2A
02CA:  DATA AB,21
02CB:  DATA D7,26
02CC:  DATA 4F,22
02CD:  DATA C5,2F
02CE:  DATA C4,22
02CF:  DATA C6,1E
02D0:  DATA B2,06
02D1:  DATA 0A,00
02D2:  DATA 8C,21
02D3:  DATA 6F,37
02D4:  DATA E6,34
02D5:  DATA 67,10
02D6:  DATA 41,28
02D7:  DATA 00,01
02D8:  DATA 41,2A
02D9:  DATA AB,21
02DA:  DATA D7,26
02DB:  DATA 4F,22
02DC:  DATA C5,2F
02DD:  DATA C4,22
02DE:  DATA C6,1E
02DF:  DATA B3,06
02E0:  DATA 0A,00
02E1:  DATA 8C,21
02E2:  DATA 6F,37
02E3:  DATA E6,34
02E4:  DATA 67,10
02E5:  DATA 43,36
02E6:  DATA E9,32
02E7:  DATA 6E,3A
02E8:  DATA E5,20
02E9:  DATA 50,00
02EA:  DATA 41,2A
02EB:  DATA 2B,29
02EC:  DATA 53,2A
02ED:  DATA 0D,05
02EE:  DATA 00,00
02EF:  DATA 41,2A
02F0:  DATA AB,21
02F1:  DATA D7,26
02F2:  DATA 4F,22
02F3:  DATA C5,1E
02F4:  DATA A5,39
02F5:  DATA 0D,05
02F6:  DATA 00,00
02F7:  DATA 41,2A
02F8:  DATA AB,21
02F9:  DATA 57,25
02FA:  DATA 41,28
02FB:  DATA BF,06
02FC:  DATA 0A,00
02FD:  DATA 41,2A
02FE:  DATA AB,21
02FF:  DATA 57,25
0300:  DATA 41,28
0301:  DATA BD,12
0302:  DATA 73,00
0303:  DATA 41,2A
0304:  DATA AB,21
0305:  DATA 49,28
0306:  DATA CD,2A
0307:  DATA D8,1E
0308:  DATA B1,06
0309:  DATA 0A,00
030A:  DATA 41,2A
030B:  DATA AB,21
030C:  DATA 49,28
030D:  DATA D3,22
030E:  DATA 52,2B
030F:  DATA 45,29
0310:  DATA BD,18
0311:  DATA 2C,1C
0312:  DATA B0,06
0313:  DATA 0A,00
0314:  DATA C3,37
0315:  DATA ED,30
0316:  DATA 6E,32
0317:  DATA 6F,1D
0318:  DATA A0,12
0319:  DATA 73,10
031A:  DATA 0A,00
*
0340:  MOVF   00,F
0341:  BTFSC  03.2
0342:  GOTO   37A
0343:  CLRF   49
0344:  MOVF   04,W
0345:  MOVWF  48
0346:  BCF    49.0
0347:  BTFSC  03.7
0348:  BSF    49.0
0349:  MOVF   00,W
034A:  MOVWF  4A
*
036D:  BSF    03.5
036E:  MOVF   48,W
036F:  MOVWF  04
0370:  BCF    03.7
0371:  BTFSC  49.0
0372:  BSF    03.7
0373:  INCF   04,F
0374:  BTFSS  03.2
0375:  GOTO   379
0376:  BCF    03.5
0377:  INCF   05,F
0378:  BSF    03.5
0379:  GOTO   340
*
0532:  MOVF   0B,W
0533:  BSF    03.5
0534:  MOVWF  29
0535:  BCF    03.5
0536:  BCF    0B.7
0537:  BSF    03.5
0538:  BSF    03.6
0539:  BSF    0C.7
053A:  BSF    0C.0
053B:  NOP
053C:  NOP
053D:  BCF    03.6
053E:  BTFSS  29.7
053F:  GOTO   543
0540:  BCF    03.5
0541:  BSF    0B.7
0542:  BSF    03.5
0543:  BCF    03.5
0544:  BSF    03.6
0545:  MOVF   0C,W
0546:  ANDLW  7F
0547:  BTFSC  03.2
0548:  GOTO   5A6
0549:  BSF    03.5
054A:  BCF    03.6
054B:  MOVWF  29
054C:  BCF    03.5
054D:  BSF    03.6
054E:  MOVF   0D,W
054F:  BSF    03.5
0550:  BCF    03.6
0551:  MOVWF  2A
0552:  BCF    03.5
0553:  BSF    03.6
0554:  MOVF   0F,W
0555:  BSF    03.5
0556:  BCF    03.6
0557:  MOVWF  2B
0558:  MOVF   29,W
0559:  BCF    03.5
055A:  BTFSS  0C.4
055B:  GOTO   55A
055C:  MOVWF  19
055D:  BSF    03.5
055E:  MOVF   2A,W
055F:  BCF    03.5
0560:  BSF    03.6
0561:  MOVWF  0D
0562:  BSF    03.5
0563:  BCF    03.6
0564:  MOVF   2B,W
0565:  BCF    03.5
0566:  BSF    03.6
0567:  MOVWF  0F
0568:  BCF    03.6
0569:  MOVF   0B,W
056A:  BSF    03.5
056B:  MOVWF  2C
056C:  BCF    03.5
056D:  BCF    0B.7
056E:  BSF    03.5
056F:  BSF    03.6
0570:  BSF    0C.7
0571:  BSF    0C.0
0572:  NOP
0573:  NOP
0574:  BCF    03.6
0575:  BTFSS  2C.7
0576:  GOTO   57A
0577:  BCF    03.5
0578:  BSF    0B.7
0579:  BSF    03.5
057A:  BCF    03.5
057B:  BSF    03.6
057C:  RLF    0C,W
057D:  RLF    0E,W
057E:  ANDLW  7F
057F:  BTFSC  03.2
0580:  GOTO   5A6
0581:  BSF    03.5
0582:  BCF    03.6
0583:  MOVWF  29
0584:  BCF    03.5
0585:  BSF    03.6
0586:  MOVF   0D,W
0587:  BSF    03.5
0588:  BCF    03.6
0589:  MOVWF  2A
058A:  BCF    03.5
058B:  BSF    03.6
058C:  MOVF   0F,W
058D:  BSF    03.5
058E:  BCF    03.6
058F:  MOVWF  2B
0590:  MOVF   29,W
0591:  BCF    03.5
0592:  BTFSS  0C.4
0593:  GOTO   592
0594:  MOVWF  19
0595:  BSF    03.5
0596:  MOVF   2A,W
0597:  BCF    03.5
0598:  BSF    03.6
0599:  MOVWF  0D
059A:  BSF    03.5
059B:  BCF    03.6
059C:  MOVF   2B,W
059D:  BCF    03.5
059E:  BSF    03.6
059F:  MOVWF  0F
05A0:  INCF   0D,F
05A1:  BTFSC  03.2
05A2:  INCF   0F,F
05A3:  BCF    03.6
05A4:  GOTO   532
05A5:  BSF    03.6
05A6:  BCF    03.6
05A7:  RETURN
*
0602:  MOVF   0B,W
0603:  BSF    03.5
0604:  MOVWF  2A
0605:  BCF    03.5
0606:  BCF    0B.7
0607:  BSF    03.5
0608:  BSF    03.6
0609:  BSF    0C.7
060A:  BSF    0C.0
060B:  NOP
060C:  NOP
060D:  BCF    03.6
060E:  BTFSS  2A.7
060F:  GOTO   613
0610:  BCF    03.5
0611:  BSF    0B.7
0612:  BSF    03.5
0613:  BCF    03.5
0614:  BSF    03.6
0615:  MOVF   0C,F
0616:  BTFSC  03.2
0617:  GOTO   63B
0618:  MOVF   0D,W
0619:  BSF    03.5
061A:  BCF    03.6
061B:  MOVWF  2A
061C:  BCF    03.5
061D:  BSF    03.6
061E:  MOVF   0F,W
061F:  BSF    03.5
0620:  BCF    03.6
0621:  MOVWF  2B
0622:  BCF    03.5
0623:  BSF    03.6
0624:  MOVF   0C,W
0625:  BSF    03.5
0626:  BCF    03.6
0627:  MOVWF  2C
0628:  BCF    03.5
0629:  CALL   5A8
062A:  BSF    03.5
062B:  MOVF   2A,W
062C:  BCF    03.5
062D:  BSF    03.6
062E:  MOVWF  0D
062F:  BSF    03.5
0630:  BCF    03.6
0631:  MOVF   2B,W
0632:  BCF    03.5
0633:  BSF    03.6
0634:  MOVWF  0F
0635:  INCF   0D,F
0636:  BTFSC  03.2
0637:  INCF   0F,F
0638:  BCF    03.6
0639:  GOTO   602
063A:  BSF    03.6
063B:  BCF    03.6
063C:  RETURN
063D:  MOVF   0B,W
063E:  BSF    03.5
063F:  MOVWF  29
0640:  BCF    03.5
0641:  BCF    0B.7
0642:  BSF    03.5
0643:  BSF    03.6
0644:  BSF    0C.7
0645:  BSF    0C.0
0646:  NOP
0647:  NOP
0648:  BCF    03.6
0649:  BTFSS  29.7
064A:  GOTO   64E
064B:  BCF    03.5
064C:  BSF    0B.7
064D:  BSF    03.5
064E:  BCF    03.5
064F:  BSF    03.6
0650:  MOVF   0C,W
0651:  ANDLW  7F
0652:  BTFSC  03.2
0653:  GOTO   6AF
0654:  BSF    03.5
0655:  BCF    03.6
0656:  MOVWF  29
0657:  BCF    03.5
0658:  BSF    03.6
0659:  MOVF   0D,W
065A:  BSF    03.5
065B:  BCF    03.6
065C:  MOVWF  2A
065D:  BCF    03.5
065E:  BSF    03.6
065F:  MOVF   0F,W
0660:  BSF    03.5
0661:  BCF    03.6
0662:  MOVWF  2B
0663:  MOVF   29,W
0664:  MOVWF  2C
0665:  BCF    03.5
0666:  CALL   5A8
0667:  BSF    03.5
0668:  MOVF   2A,W
0669:  BCF    03.5
066A:  BSF    03.6
066B:  MOVWF  0D
066C:  BSF    03.5
066D:  BCF    03.6
066E:  MOVF   2B,W
066F:  BCF    03.5
0670:  BSF    03.6
0671:  MOVWF  0F
0672:  BCF    03.6
0673:  MOVF   0B,W
0674:  BSF    03.5
0675:  MOVWF  2C
0676:  BCF    03.5
0677:  BCF    0B.7
0678:  BSF    03.5
0679:  BSF    03.6
067A:  BSF    0C.7
067B:  BSF    0C.0
067C:  NOP
067D:  NOP
067E:  BCF    03.6
067F:  BTFSS  2C.7
0680:  GOTO   684
0681:  BCF    03.5
0682:  BSF    0B.7
0683:  BSF    03.5
0684:  BCF    03.5
0685:  BSF    03.6
0686:  RLF    0C,W
0687:  RLF    0E,W
0688:  ANDLW  7F
0689:  BTFSC  03.2
068A:  GOTO   6AF
068B:  BSF    03.5
068C:  BCF    03.6
068D:  MOVWF  29
068E:  BCF    03.5
068F:  BSF    03.6
0690:  MOVF   0D,W
0691:  BSF    03.5
0692:  BCF    03.6
0693:  MOVWF  2A
0694:  BCF    03.5
0695:  BSF    03.6
0696:  MOVF   0F,W
0697:  BSF    03.5
0698:  BCF    03.6
0699:  MOVWF  2B
069A:  MOVF   29,W
069B:  MOVWF  2C
069C:  BCF    03.5
069D:  CALL   5A8
069E:  BSF    03.5
069F:  MOVF   2A,W
06A0:  BCF    03.5
06A1:  BSF    03.6
06A2:  MOVWF  0D
06A3:  BSF    03.5
06A4:  BCF    03.6
06A5:  MOVF   2B,W
06A6:  BCF    03.5
06A7:  BSF    03.6
06A8:  MOVWF  0F
06A9:  INCF   0D,F
06AA:  BTFSC  03.2
06AB:  INCF   0F,F
06AC:  BCF    03.6
06AD:  GOTO   63D
06AE:  BSF    03.6
06AF:  BCF    03.6
06B0:  RETURN
*
06DD:  BTFSC  03.1
06DE:  GOTO   6E2
06DF:  MOVLW  BF
06E0:  MOVWF  04
06E1:  BCF    03.7
06E2:  CLRF   77
06E3:  CLRF   78
06E4:  CLRF   79
06E5:  CLRF   7A
06E6:  CLRF   3F
06E7:  CLRF   40
06E8:  CLRF   41
06E9:  CLRF   42
06EA:  MOVF   3E,W
06EB:  IORWF  3D,W
06EC:  IORWF  3C,W
06ED:  IORWF  3B,W
06EE:  BTFSC  03.2
06EF:  GOTO   720
06F0:  MOVLW  20
06F1:  MOVWF  43
06F2:  BCF    03.0
06F3:  RLF    37,F
06F4:  RLF    38,F
06F5:  RLF    39,F
06F6:  RLF    3A,F
06F7:  RLF    3F,F
06F8:  RLF    40,F
06F9:  RLF    41,F
06FA:  RLF    42,F
06FB:  MOVF   3E,W
06FC:  SUBWF  42,W
06FD:  BTFSS  03.2
06FE:  GOTO   709
06FF:  MOVF   3D,W
0700:  SUBWF  41,W
0701:  BTFSS  03.2
0702:  GOTO   709
0703:  MOVF   3C,W
0704:  SUBWF  40,W
0705:  BTFSS  03.2
0706:  GOTO   709
0707:  MOVF   3B,W
0708:  SUBWF  3F,W
0709:  BTFSS  03.0
070A:  GOTO   71A
070B:  MOVF   3B,W
070C:  SUBWF  3F,F
070D:  MOVF   3C,W
070E:  BTFSS  03.0
070F:  INCFSZ 3C,W
0710:  SUBWF  40,F
0711:  MOVF   3D,W
0712:  BTFSS  03.0
0713:  INCFSZ 3D,W
0714:  SUBWF  41,F
0715:  MOVF   3E,W
0716:  BTFSS  03.0
0717:  INCFSZ 3E,W
0718:  SUBWF  42,F
0719:  BSF    03.0
071A:  RLF    77,F
071B:  RLF    78,F
071C:  RLF    79,F
071D:  RLF    7A,F
071E:  DECFSZ 43,F
071F:  GOTO   6F2
0720:  MOVF   3F,W
0721:  MOVWF  00
0722:  INCF   04,F
0723:  MOVF   40,W
0724:  MOVWF  00
0725:  INCF   04,F
0726:  MOVF   41,W
0727:  MOVWF  00
0728:  INCF   04,F
0729:  MOVF   42,W
072A:  MOVWF  00
*
0740:  MOVLW  20
0741:  MOVWF  43
0742:  CLRF   3F
0743:  CLRF   40
0744:  CLRF   41
0745:  CLRF   42
0746:  MOVF   3A,W
0747:  MOVWF  7A
0748:  MOVF   39,W
0749:  MOVWF  79
074A:  MOVF   38,W
074B:  MOVWF  78
074C:  MOVF   37,W
074D:  MOVWF  77
074E:  BCF    03.0
074F:  BTFSS  77.0
0750:  GOTO   75F
0751:  MOVF   3B,W
0752:  ADDWF  3F,F
0753:  MOVF   3C,W
0754:  BTFSC  03.0
0755:  INCFSZ 3C,W
0756:  ADDWF  40,F
0757:  MOVF   3D,W
0758:  BTFSC  03.0
0759:  INCFSZ 3D,W
075A:  ADDWF  41,F
075B:  MOVF   3E,W
075C:  BTFSC  03.0
075D:  INCFSZ 3E,W
075E:  ADDWF  42,F
075F:  RRF    42,F
0760:  RRF    41,F
0761:  RRF    40,F
0762:  RRF    3F,F
0763:  RRF    7A,F
0764:  RRF    79,F
0765:  RRF    78,F
0766:  RRF    77,F
0767:  DECFSZ 43,F
0768:  GOTO   74E
*
0812:  BCF    03.5
0813:  MOVF   0B,W
0814:  BSF    03.5
0815:  MOVWF  2A
0816:  BCF    03.5
0817:  BCF    0B.7
0818:  BSF    03.5
0819:  BSF    03.6
081A:  BSF    0C.7
081B:  BSF    0C.0
081C:  NOP
081D:  NOP
081E:  BCF    03.6
081F:  BTFSS  2A.7
0820:  GOTO   024
0821:  BCF    03.5
0822:  BSF    0B.7
0823:  BSF    03.5
0824:  BTFSC  03.0
0825:  GOTO   05E
0826:  BCF    03.5
0827:  BSF    03.6
0828:  MOVF   0C,W
0829:  ANDLW  7F
082A:  BSF    03.5
082B:  BCF    03.6
082C:  MOVWF  2A
082D:  BCF    03.5
082E:  BSF    03.6
082F:  MOVF   0D,W
0830:  BSF    03.5
0831:  BCF    03.6
0832:  MOVWF  2B
0833:  BCF    03.5
0834:  BSF    03.6
0835:  MOVF   0F,W
0836:  BSF    03.5
0837:  BCF    03.6
0838:  MOVWF  2C
0839:  MOVF   2A,W
083A:  BCF    03.5
083B:  BTFSS  0C.4
083C:  GOTO   03B
083D:  MOVWF  19
083E:  BSF    03.5
083F:  MOVF   2B,W
0840:  BCF    03.5
0841:  BSF    03.6
0842:  MOVWF  0D
0843:  BSF    03.5
0844:  BCF    03.6
0845:  MOVF   2C,W
0846:  BCF    03.5
0847:  BSF    03.6
0848:  MOVWF  0F
0849:  BCF    03.6
084A:  MOVF   0B,W
084B:  BSF    03.5
084C:  MOVWF  2D
084D:  BCF    03.5
084E:  BCF    0B.7
084F:  BSF    03.5
0850:  BSF    03.6
0851:  BSF    0C.7
0852:  BSF    0C.0
0853:  NOP
0854:  NOP
0855:  BCF    03.6
0856:  BTFSS  2D.7
0857:  GOTO   05B
0858:  BCF    03.5
0859:  BSF    0B.7
085A:  BSF    03.5
085B:  DECFSZ 29,F
085C:  GOTO   05E
085D:  GOTO   08A
085E:  BCF    03.5
085F:  BSF    03.6
0860:  RLF    0C,W
0861:  RLF    0E,W
0862:  ANDLW  7F
0863:  BSF    03.5
0864:  BCF    03.6
0865:  MOVWF  2A
0866:  BCF    03.5
0867:  BSF    03.6
0868:  MOVF   0D,W
0869:  BSF    03.5
086A:  BCF    03.6
086B:  MOVWF  2B
086C:  BCF    03.5
086D:  BSF    03.6
086E:  MOVF   0F,W
086F:  BSF    03.5
0870:  BCF    03.6
0871:  MOVWF  2C
0872:  MOVF   2A,W
0873:  BCF    03.5
0874:  BTFSS  0C.4
0875:  GOTO   074
0876:  MOVWF  19
0877:  BSF    03.5
0878:  MOVF   2B,W
0879:  BCF    03.5
087A:  BSF    03.6
087B:  MOVWF  0D
087C:  BSF    03.5
087D:  BCF    03.6
087E:  MOVF   2C,W
087F:  BCF    03.5
0880:  BSF    03.6
0881:  MOVWF  0F
0882:  INCF   0D,F
0883:  BTFSC  03.2
0884:  INCF   0F,F
0885:  BCF    03.0
0886:  BSF    03.5
0887:  BCF    03.6
0888:  DECFSZ 29,F
0889:  GOTO   012
*
088F:  MOVF   00,F
0890:  BTFSC  03.2
0891:  GOTO   0AA
0892:  CLRF   2A
0893:  MOVF   04,W
0894:  MOVWF  29
0895:  BCF    2A.0
0896:  BTFSC  03.7
0897:  BSF    2A.0
0898:  MOVF   00,W
0899:  BCF    03.5
089A:  BTFSS  0C.4
089B:  GOTO   09A
089C:  MOVWF  19
089D:  BSF    03.5
089E:  MOVF   29,W
089F:  MOVWF  04
08A0:  BCF    03.7
08A1:  BTFSC  2A.0
08A2:  BSF    03.7
08A3:  INCF   04,F
08A4:  BTFSS  03.2
08A5:  GOTO   0A9
08A6:  BCF    03.5
08A7:  INCF   05,F
08A8:  BSF    03.5
08A9:  GOTO   08F
*
08DF:  BCF    03.5
08E0:  MOVF   0B,W
08E1:  BSF    03.5
08E2:  MOVWF  2A
08E3:  BCF    03.5
08E4:  BCF    0B.7
08E5:  BSF    03.5
08E6:  BSF    03.6
08E7:  BSF    0C.7
08E8:  BSF    0C.0
08E9:  NOP
08EA:  NOP
08EB:  BCF    03.6
08EC:  BTFSS  2A.7
08ED:  GOTO   0F1
08EE:  BCF    03.5
08EF:  BSF    0B.7
08F0:  BSF    03.5
08F1:  BTFSC  03.0
08F2:  GOTO   12B
08F3:  BCF    03.5
08F4:  BSF    03.6
08F5:  MOVF   0C,W
08F6:  ANDLW  7F
08F7:  BSF    03.5
08F8:  BCF    03.6
08F9:  MOVWF  2A
08FA:  BCF    03.5
08FB:  BSF    03.6
08FC:  MOVF   0D,W
08FD:  BSF    03.5
08FE:  BCF    03.6
08FF:  MOVWF  2B
0900:  BCF    03.5
0901:  BSF    03.6
0902:  MOVF   0F,W
0903:  BSF    03.5
0904:  BCF    03.6
0905:  MOVWF  2C
0906:  MOVF   2A,W
0907:  BCF    03.5
0908:  BTFSS  0C.4
0909:  GOTO   108
090A:  MOVWF  19
090B:  BSF    03.5
090C:  MOVF   2B,W
090D:  BCF    03.5
090E:  BSF    03.6
090F:  MOVWF  0D
0910:  BSF    03.5
0911:  BCF    03.6
0912:  MOVF   2C,W
0913:  BCF    03.5
0914:  BSF    03.6
0915:  MOVWF  0F
0916:  BCF    03.6
0917:  MOVF   0B,W
0918:  BSF    03.5
0919:  MOVWF  2D
091A:  BCF    03.5
091B:  BCF    0B.7
091C:  BSF    03.5
091D:  BSF    03.6
091E:  BSF    0C.7
091F:  BSF    0C.0
0920:  NOP
0921:  NOP
0922:  BCF    03.6
0923:  BTFSS  2D.7
0924:  GOTO   128
0925:  BCF    03.5
0926:  BSF    0B.7
0927:  BSF    03.5
0928:  DECFSZ 29,F
0929:  GOTO   12B
092A:  GOTO   157
092B:  BCF    03.5
092C:  BSF    03.6
092D:  RLF    0C,W
092E:  RLF    0E,W
092F:  ANDLW  7F
0930:  BSF    03.5
0931:  BCF    03.6
0932:  MOVWF  2A
0933:  BCF    03.5
0934:  BSF    03.6
0935:  MOVF   0D,W
0936:  BSF    03.5
0937:  BCF    03.6
0938:  MOVWF  2B
0939:  BCF    03.5
093A:  BSF    03.6
093B:  MOVF   0F,W
093C:  BSF    03.5
093D:  BCF    03.6
093E:  MOVWF  2C
093F:  MOVF   2A,W
0940:  BCF    03.5
0941:  BTFSS  0C.4
0942:  GOTO   141
0943:  MOVWF  19
0944:  BSF    03.5
0945:  MOVF   2B,W
0946:  BCF    03.5
0947:  BSF    03.6
0948:  MOVWF  0D
0949:  BSF    03.5
094A:  BCF    03.6
094B:  MOVF   2C,W
094C:  BCF    03.5
094D:  BSF    03.6
094E:  MOVWF  0F
094F:  INCF   0D,F
0950:  BTFSC  03.2
0951:  INCF   0F,F
0952:  BCF    03.0
0953:  BSF    03.5
0954:  BCF    03.6
0955:  DECFSZ 29,F
0956:  GOTO   0DF
*
095C:  MOVF   00,F
095D:  BTFSC  03.2
095E:  GOTO   177
095F:  CLRF   2A
0960:  MOVF   04,W
0961:  MOVWF  29
0962:  BCF    2A.0
0963:  BTFSC  03.7
0964:  BSF    2A.0
0965:  MOVF   00,W
0966:  BCF    03.5
0967:  BTFSS  0C.4
0968:  GOTO   167
0969:  MOVWF  19
096A:  BSF    03.5
096B:  MOVF   29,W
096C:  MOVWF  04
096D:  BCF    03.7
096E:  BTFSC  2A.0
096F:  BSF    03.7
0970:  INCF   04,F
0971:  BTFSS  03.2
0972:  GOTO   176
0973:  BCF    03.5
0974:  INCF   05,F
0975:  BSF    03.5
0976:  GOTO   15C
*
0994:  BCF    03.5
0995:  MOVF   0B,W
0996:  BSF    03.5
0997:  MOVWF  2A
0998:  BCF    03.5
0999:  BCF    0B.7
099A:  BSF    03.5
099B:  BSF    03.6
099C:  BSF    0C.7
099D:  BSF    0C.0
099E:  NOP
099F:  NOP
09A0:  BCF    03.6
09A1:  BTFSS  2A.7
09A2:  GOTO   1A6
09A3:  BCF    03.5
09A4:  BSF    0B.7
09A5:  BSF    03.5
09A6:  BTFSC  03.0
09A7:  GOTO   1E0
09A8:  BCF    03.5
09A9:  BSF    03.6
09AA:  MOVF   0C,W
09AB:  ANDLW  7F
09AC:  BSF    03.5
09AD:  BCF    03.6
09AE:  MOVWF  2A
09AF:  BCF    03.5
09B0:  BSF    03.6
09B1:  MOVF   0D,W
09B2:  BSF    03.5
09B3:  BCF    03.6
09B4:  MOVWF  2B
09B5:  BCF    03.5
09B6:  BSF    03.6
09B7:  MOVF   0F,W
09B8:  BSF    03.5
09B9:  BCF    03.6
09BA:  MOVWF  2C
09BB:  MOVF   2A,W
09BC:  BCF    03.5
09BD:  BTFSS  0C.4
09BE:  GOTO   1BD
09BF:  MOVWF  19
09C0:  BSF    03.5
09C1:  MOVF   2B,W
09C2:  BCF    03.5
09C3:  BSF    03.6
09C4:  MOVWF  0D
09C5:  BSF    03.5
09C6:  BCF    03.6
09C7:  MOVF   2C,W
09C8:  BCF    03.5
09C9:  BSF    03.6
09CA:  MOVWF  0F
09CB:  BCF    03.6
09CC:  MOVF   0B,W
09CD:  BSF    03.5
09CE:  MOVWF  2D
09CF:  BCF    03.5
09D0:  BCF    0B.7
09D1:  BSF    03.5
09D2:  BSF    03.6
09D3:  BSF    0C.7
09D4:  BSF    0C.0
09D5:  NOP
09D6:  NOP
09D7:  BCF    03.6
09D8:  BTFSS  2D.7
09D9:  GOTO   1DD
09DA:  BCF    03.5
09DB:  BSF    0B.7
09DC:  BSF    03.5
09DD:  DECFSZ 29,F
09DE:  GOTO   1E0
09DF:  GOTO   20C
09E0:  BCF    03.5
09E1:  BSF    03.6
09E2:  RLF    0C,W
09E3:  RLF    0E,W
09E4:  ANDLW  7F
09E5:  BSF    03.5
09E6:  BCF    03.6
09E7:  MOVWF  2A
09E8:  BCF    03.5
09E9:  BSF    03.6
09EA:  MOVF   0D,W
09EB:  BSF    03.5
09EC:  BCF    03.6
09ED:  MOVWF  2B
09EE:  BCF    03.5
09EF:  BSF    03.6
09F0:  MOVF   0F,W
09F1:  BSF    03.5
09F2:  BCF    03.6
09F3:  MOVWF  2C
09F4:  MOVF   2A,W
09F5:  BCF    03.5
09F6:  BTFSS  0C.4
09F7:  GOTO   1F6
09F8:  MOVWF  19
09F9:  BSF    03.5
09FA:  MOVF   2B,W
09FB:  BCF    03.5
09FC:  BSF    03.6
09FD:  MOVWF  0D
09FE:  BSF    03.5
09FF:  BCF    03.6
0A00:  MOVF   2C,W
0A01:  BCF    03.5
0A02:  BSF    03.6
0A03:  MOVWF  0F
0A04:  INCF   0D,F
0A05:  BTFSC  03.2
0A06:  INCF   0F,F
0A07:  BCF    03.0
0A08:  BSF    03.5
0A09:  BCF    03.6
0A0A:  DECFSZ 29,F
0A0B:  GOTO   194
*
0A11:  MOVF   00,F
0A12:  BTFSC  03.2
0A13:  GOTO   22C
0A14:  CLRF   2A
0A15:  MOVF   04,W
0A16:  MOVWF  29
0A17:  BCF    2A.0
0A18:  BTFSC  03.7
0A19:  BSF    2A.0
0A1A:  MOVF   00,W
0A1B:  BCF    03.5
0A1C:  BTFSS  0C.4
0A1D:  GOTO   21C
0A1E:  MOVWF  19
0A1F:  BSF    03.5
0A20:  MOVF   29,W
0A21:  MOVWF  04
0A22:  BCF    03.7
0A23:  BTFSC  2A.0
0A24:  BSF    03.7
0A25:  INCF   04,F
0A26:  BTFSS  03.2
0A27:  GOTO   22B
0A28:  BCF    03.5
0A29:  INCF   05,F
0A2A:  BSF    03.5
0A2B:  GOTO   211
*
0B45:  CLRF   77
0B46:  CLRF   78
0B47:  BSF    03.5
0B48:  MOVF   29,W
0B49:  BCF    03.0
0B4A:  BTFSC  2A.0
0B4B:  ADDWF  77,F
0B4C:  RRF    77,F
0B4D:  RRF    78,F
0B4E:  BTFSC  2A.1
0B4F:  ADDWF  77,F
0B50:  RRF    77,F
0B51:  RRF    78,F
0B52:  BTFSC  2A.2
0B53:  ADDWF  77,F
0B54:  RRF    77,F
0B55:  RRF    78,F
0B56:  BTFSC  2A.3
0B57:  ADDWF  77,F
0B58:  RRF    77,F
0B59:  RRF    78,F
0B5A:  BTFSC  2A.4
0B5B:  ADDWF  77,F
0B5C:  RRF    77,F
0B5D:  RRF    78,F
0B5E:  BTFSC  2A.5
0B5F:  ADDWF  77,F
0B60:  RRF    77,F
0B61:  RRF    78,F
0B62:  BTFSC  2A.6
0B63:  ADDWF  77,F
0B64:  RRF    77,F
0B65:  RRF    78,F
0B66:  BTFSC  2A.7
0B67:  ADDWF  77,F
0B68:  RRF    77,F
0B69:  RRF    78,F
0B6A:  BCF    03.5
0B6B:  RETURN
0B6C:  BSF    03.5
0B6D:  MOVF   28,W
0B6E:  ANDLW  07
0B6F:  MOVWF  77
0B70:  RRF    28,W
0B71:  MOVWF  78
0B72:  RRF    78,F
0B73:  RRF    78,F
0B74:  MOVLW  1F
0B75:  ANDWF  78,F
0B76:  MOVF   78,W
0B77:  ADDWF  2A,W
0B78:  MOVWF  04
0B79:  BCF    03.7
0B7A:  BTFSC  2B.0
0B7B:  BSF    03.7
0B7C:  CLRF   78
0B7D:  INCF   78,F
0B7E:  INCF   77,F
0B7F:  GOTO   381
0B80:  RLF    78,F
0B81:  DECFSZ 77,F
0B82:  GOTO   380
0B83:  MOVF   29,F
0B84:  BTFSC  03.2
0B85:  GOTO   389
0B86:  MOVF   78,W
0B87:  IORWF  00,F
0B88:  GOTO   38C
0B89:  COMF   78,F
0B8A:  MOVF   78,W
0B8B:  ANDWF  00,F
0B8C:  BCF    03.5
0B8D:  RETURN
*
0F6F:  BSF    0A.0
0F70:  BSF    0A.1
0F71:  BSF    0A.2
0F72:  ADDWF  02,F
0F73:  GOTO   758
0F74:  GOTO   75D
0F75:  GOTO   762
0F76:  GOTO   767
*
12C5:  BCF    0A.0
12C6:  BSF    0A.1
12C7:  BCF    0A.2
12C8:  ADDWF  02,F
12C9:  GOTO   008
12CA:  GOTO   049
12CB:  GOTO   08A
12CC:  GOTO   0CB
12CD:  GOTO   26C
12CE:  GOTO   2BE
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20000000) 
*
039F:  MOVLW  AD
03A0:  MOVWF  04
03A1:  BCF    03.7
03A2:  MOVF   00,W
03A3:  BTFSC  03.2
03A4:  GOTO   3B2
03A5:  MOVLW  06
03A6:  MOVWF  78
03A7:  CLRF   77
03A8:  DECFSZ 77,F
03A9:  GOTO   3A8
03AA:  DECFSZ 78,F
03AB:  GOTO   3A7
03AC:  MOVLW  7B
03AD:  MOVWF  77
03AE:  DECFSZ 77,F
03AF:  GOTO   3AE
03B0:  DECFSZ 00,F
03B1:  GOTO   3A5
03B2:  RETURN
*
0781:  MOVLW  03
0782:  SUBWF  38,F
0783:  BTFSS  03.0
0784:  GOTO   78F
0785:  MOVLW  B8
0786:  MOVWF  04
0787:  BCF    03.7
0788:  MOVF   00,W
0789:  BTFSC  03.2
078A:  GOTO   78F
078B:  GOTO   78D
078C:  GOTO   78D
078D:  DECFSZ 00,F
078E:  GOTO   78C
*
0792:  MOVLW  03
0793:  SUBWF  38,F
0794:  BTFSS  03.0
0795:  GOTO   7A0
0796:  MOVLW  B8
0797:  MOVWF  04
0798:  BCF    03.7
0799:  MOVF   00,W
079A:  BTFSC  03.2
079B:  GOTO   7A0
079C:  GOTO   79E
079D:  GOTO   79E
079E:  DECFSZ 00,F
079F:  GOTO   79D
*
07B2:  MOVLW  03
07B3:  SUBWF  38,F
07B4:  BTFSS  03.0
07B5:  GOTO   7C0
07B6:  MOVLW  B8
07B7:  MOVWF  04
07B8:  BCF    03.7
07B9:  MOVF   00,W
07BA:  BTFSC  03.2
07BB:  GOTO   7C0
07BC:  GOTO   7BE
07BD:  GOTO   7BE
07BE:  DECFSZ 00,F
07BF:  GOTO   7BD
*
07C3:  MOVLW  03
07C4:  SUBWF  38,F
07C5:  BTFSS  03.0
07C6:  GOTO   7D1
07C7:  MOVLW  B8
07C8:  MOVWF  04
07C9:  BCF    03.7
07CA:  MOVF   00,W
07CB:  BTFSC  03.2
07CC:  GOTO   7D1
07CD:  GOTO   7CF
07CE:  GOTO   7CF
07CF:  DECFSZ 00,F
07D0:  GOTO   7CE
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
*
034B:  BCF    06.0
034C:  BCF    03.5
034D:  BCF    06.0
034E:  MOVLW  08
034F:  MOVWF  78
0350:  GOTO   351
0351:  NOP
0352:  BSF    78.7
0353:  GOTO   364
0354:  BCF    78.7
0355:  BSF    03.5
0356:  RRF    4A,F
0357:  BCF    03.5
0358:  BTFSC  03.0
0359:  BSF    06.0
035A:  BTFSS  03.0
035B:  BCF    06.0
035C:  BSF    78.6
035D:  GOTO   364
035E:  BCF    78.6
035F:  DECFSZ 78,F
0360:  GOTO   355
0361:  GOTO   362
0362:  NOP
0363:  BSF    06.0
0364:  MOVLW  A7
0365:  MOVWF  04
0366:  DECFSZ 04,F
0367:  GOTO   366
0368:  GOTO   369
0369:  BTFSC  78.7
036A:  GOTO   354
036B:  BTFSC  78.6
036C:  GOTO   35E
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
*
0EDF:  MOVLW  4A
0EE0:  BCF    03.6
0EE1:  MOVWF  2B
0EE2:  CLRF   2C
0EE3:  MOVLW  49
0EE4:  MOVWF  2D
0EE5:  CLRF   2E
0EE6:  MOVLW  48
0EE7:  MOVWF  2F
0EE8:  CLRF   30
0EE9:  MOVLW  2C
0EEA:  MOVWF  31
0EEB:  CLRF   32
0EEC:  MOVLW  28
0EED:  MOVWF  33
0EEE:  CLRF   34
0EEF:  MOVLW  29
0EF0:  MOVWF  35
0EF1:  CLRF   36
0EF2:  MOVLW  2A
0EF3:  MOVWF  37
0EF4:  CLRF   38
0EF5:  MOVLW  2B
0EF6:  MOVWF  39
0EF7:  CLRF   3A
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
0EF8:  CLRF   3B
0EF9:  CLRF   3C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
03F5:  BSF    08.4
....................    output_float(LCD_DATA5); 
03F6:  BSF    08.5
....................    output_float(LCD_DATA6); 
03F7:  BSF    08.6
....................    output_float(LCD_DATA7); 
03F8:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
03F9:  BCF    03.5
03FA:  BSF    08.1
03FB:  BSF    03.5
03FC:  BCF    08.1
....................    delay_cycles(1); 
03FD:  NOP
....................    lcd_output_enable(1); 
03FE:  BCF    03.5
03FF:  BSF    08.0
0400:  BSF    03.5
0401:  BCF    08.0
....................    delay_cycles(1); 
0402:  NOP
....................    high = lcd_read_nibble(); 
*
0433:  MOVF   78,W
0434:  MOVWF  34
....................        
....................    lcd_output_enable(0); 
0435:  BCF    03.5
0436:  BCF    08.0
0437:  BSF    03.5
0438:  BCF    08.0
....................    delay_cycles(1); 
0439:  NOP
....................    lcd_output_enable(1); 
043A:  BCF    03.5
043B:  BSF    08.0
043C:  BSF    03.5
043D:  BCF    08.0
....................    delay_us(1); 
043E:  GOTO   43F
043F:  GOTO   440
0440:  NOP
....................    low = lcd_read_nibble(); 
*
0471:  MOVF   78,W
0472:  MOVWF  33
....................        
....................    lcd_output_enable(0); 
0473:  BCF    03.5
0474:  BCF    08.0
0475:  BSF    03.5
0476:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0477:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0478:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0479:  BCF    08.6
....................    output_drive(LCD_DATA7); 
047A:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
047B:  SWAPF  34,W
047C:  MOVWF  77
047D:  MOVLW  F0
047E:  ANDWF  77,F
047F:  MOVF   77,W
0480:  IORWF  33,W
0481:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0403:  CLRF   35
*
0441:  CLRF   35
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
0404:  BSF    08.4
0405:  MOVLW  00
0406:  BCF    03.5
0407:  BTFSC  08.4
0408:  MOVLW  01
0409:  BSF    03.5
040A:  IORWF  35,F
*
0442:  BSF    08.4
0443:  MOVLW  00
0444:  BCF    03.5
0445:  BTFSC  08.4
0446:  MOVLW  01
0447:  BSF    03.5
0448:  IORWF  35,F
....................    n |= input(LCD_DATA5) << 1; 
*
040B:  BSF    08.5
040C:  MOVLW  00
040D:  BCF    03.5
040E:  BTFSC  08.5
040F:  MOVLW  01
0410:  MOVWF  77
0411:  BCF    03.0
0412:  RLF    77,F
0413:  MOVF   77,W
0414:  BSF    03.5
0415:  IORWF  35,F
*
0449:  BSF    08.5
044A:  MOVLW  00
044B:  BCF    03.5
044C:  BTFSC  08.5
044D:  MOVLW  01
044E:  MOVWF  77
044F:  BCF    03.0
0450:  RLF    77,F
0451:  MOVF   77,W
0452:  BSF    03.5
0453:  IORWF  35,F
....................    n |= input(LCD_DATA6) << 2; 
*
0416:  BSF    08.6
0417:  MOVLW  00
0418:  BCF    03.5
0419:  BTFSC  08.6
041A:  MOVLW  01
041B:  MOVWF  77
041C:  RLF    77,F
041D:  RLF    77,F
041E:  MOVLW  FC
041F:  ANDWF  77,F
0420:  MOVF   77,W
0421:  BSF    03.5
0422:  IORWF  35,F
*
0454:  BSF    08.6
0455:  MOVLW  00
0456:  BCF    03.5
0457:  BTFSC  08.6
0458:  MOVLW  01
0459:  MOVWF  77
045A:  RLF    77,F
045B:  RLF    77,F
045C:  MOVLW  FC
045D:  ANDWF  77,F
045E:  MOVF   77,W
045F:  BSF    03.5
0460:  IORWF  35,F
....................    n |= input(LCD_DATA7) << 3; 
*
0423:  BSF    08.7
0424:  MOVLW  00
0425:  BCF    03.5
0426:  BTFSC  08.7
0427:  MOVLW  01
0428:  MOVWF  77
0429:  RLF    77,F
042A:  RLF    77,F
042B:  RLF    77,F
042C:  MOVLW  F8
042D:  ANDWF  77,F
042E:  MOVF   77,W
042F:  BSF    03.5
0430:  IORWF  35,F
*
0461:  BSF    08.7
0462:  MOVLW  00
0463:  BCF    03.5
0464:  BTFSC  08.7
0465:  MOVLW  01
0466:  MOVWF  77
0467:  RLF    77,F
0468:  RLF    77,F
0469:  RLF    77,F
046A:  MOVLW  F8
046B:  ANDWF  77,F
046C:  MOVF   77,W
046D:  BSF    03.5
046E:  IORWF  35,F
....................     
....................    return(n); 
*
0431:  MOVF   35,W
0432:  MOVWF  78
*
046F:  MOVF   35,W
0470:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
03B3:  BSF    03.5
03B4:  BTFSC  34.0
03B5:  GOTO   3BA
03B6:  BCF    03.5
03B7:  BCF    08.4
03B8:  GOTO   3BC
03B9:  BSF    03.5
03BA:  BCF    03.5
03BB:  BSF    08.4
03BC:  BSF    03.5
03BD:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
03BE:  BTFSC  34.1
03BF:  GOTO   3C4
03C0:  BCF    03.5
03C1:  BCF    08.5
03C2:  GOTO   3C6
03C3:  BSF    03.5
03C4:  BCF    03.5
03C5:  BSF    08.5
03C6:  BSF    03.5
03C7:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
03C8:  BTFSC  34.2
03C9:  GOTO   3CE
03CA:  BCF    03.5
03CB:  BCF    08.6
03CC:  GOTO   3D0
03CD:  BSF    03.5
03CE:  BCF    03.5
03CF:  BSF    08.6
03D0:  BSF    03.5
03D1:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
03D2:  BTFSC  34.3
03D3:  GOTO   3D8
03D4:  BCF    03.5
03D5:  BCF    08.7
03D6:  GOTO   3DA
03D7:  BSF    03.5
03D8:  BCF    03.5
03D9:  BSF    08.7
03DA:  BSF    03.5
03DB:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
03DC:  NOP
....................    lcd_output_enable(1); 
03DD:  BCF    03.5
03DE:  BSF    08.0
03DF:  BSF    03.5
03E0:  BCF    08.0
....................    delay_us(2); 
03E1:  MOVLW  02
03E2:  MOVWF  77
03E3:  DECFSZ 77,F
03E4:  GOTO   3E3
03E5:  GOTO   3E6
03E6:  NOP
....................    lcd_output_enable(0); 
03E7:  BCF    03.5
03E8:  BCF    08.0
03E9:  BSF    03.5
03EA:  BCF    08.0
03EB:  BCF    03.5
03EC:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
03ED:  BSF    03.5
03EE:  BCF    08.0
....................    lcd_rs_tris(); 
03EF:  BCF    08.2
....................    lcd_rw_tris(); 
03F0:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
03F1:  BCF    03.5
03F2:  BCF    08.2
03F3:  BSF    03.5
03F4:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0482:  MOVF   78,W
0483:  MOVWF  33
0484:  BTFSC  33.7
0485:  GOTO   3F5
....................    lcd_output_rs(address); 
0486:  MOVF   31,F
0487:  BTFSS  03.2
0488:  GOTO   48D
0489:  BCF    03.5
048A:  BCF    08.2
048B:  GOTO   48F
048C:  BSF    03.5
048D:  BCF    03.5
048E:  BSF    08.2
048F:  BSF    03.5
0490:  BCF    08.2
....................    delay_cycles(1); 
0491:  NOP
....................    lcd_output_rw(0); 
0492:  BCF    03.5
0493:  BCF    08.1
0494:  BSF    03.5
0495:  BCF    08.1
....................    delay_cycles(1); 
0496:  NOP
....................    lcd_output_enable(0); 
0497:  BCF    03.5
0498:  BCF    08.0
0499:  BSF    03.5
049A:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
049B:  SWAPF  32,W
049C:  MOVWF  33
049D:  MOVLW  0F
049E:  ANDWF  33,F
049F:  MOVF   33,W
04A0:  MOVWF  34
04A1:  BCF    03.5
04A2:  CALL   3B3
....................    lcd_send_nibble(n & 0xf); 
04A3:  BSF    03.5
04A4:  MOVF   32,W
04A5:  ANDLW  0F
04A6:  MOVWF  33
04A7:  MOVWF  34
04A8:  BCF    03.5
04A9:  CALL   3B3
04AA:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
04AB:  MOVLW  28
04AC:  BSF    03.5
04AD:  MOVWF  25
04AE:  MOVLW  0C
04AF:  MOVWF  26
04B0:  MOVLW  01
04B1:  MOVWF  27
04B2:  MOVLW  06
04B3:  MOVWF  28
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
04B4:  BCF    03.5
04B5:  BCF    08.0
04B6:  BSF    03.5
04B7:  BCF    08.0
....................    lcd_output_rs(0); 
04B8:  BCF    03.5
04B9:  BCF    08.2
04BA:  BSF    03.5
04BB:  BCF    08.2
....................    lcd_output_rw(0); 
04BC:  BCF    03.5
04BD:  BCF    08.1
04BE:  BSF    03.5
04BF:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
04C0:  BCF    08.4
....................    output_drive(LCD_DATA5); 
04C1:  BCF    08.5
....................    output_drive(LCD_DATA6); 
04C2:  BCF    08.6
....................    output_drive(LCD_DATA7); 
04C3:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
04C4:  BCF    08.0
....................    lcd_rs_tris(); 
04C5:  BCF    08.2
....................    lcd_rw_tris(); 
04C6:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
04C7:  MOVLW  0F
04C8:  MOVWF  2D
04C9:  BCF    03.5
04CA:  CALL   39F
....................    for(i=1;i<=3;++i) 
04CB:  MOVLW  01
04CC:  BSF    03.5
04CD:  MOVWF  24
04CE:  MOVF   24,W
04CF:  SUBLW  03
04D0:  BTFSS  03.0
04D1:  GOTO   4DE
....................    { 
....................        lcd_send_nibble(3); 
04D2:  MOVLW  03
04D3:  MOVWF  34
04D4:  BCF    03.5
04D5:  CALL   3B3
....................        delay_ms(5); 
04D6:  MOVLW  05
04D7:  BSF    03.5
04D8:  MOVWF  2D
04D9:  BCF    03.5
04DA:  CALL   39F
04DB:  BSF    03.5
04DC:  INCF   24,F
04DD:  GOTO   4CE
....................    } 
....................     
....................    lcd_send_nibble(2); 
04DE:  MOVLW  02
04DF:  MOVWF  34
04E0:  BCF    03.5
04E1:  CALL   3B3
....................    delay_ms(5); 
04E2:  MOVLW  05
04E3:  BSF    03.5
04E4:  MOVWF  2D
04E5:  BCF    03.5
04E6:  CALL   39F
....................    for(i=0;i<=3;++i) 
04E7:  BSF    03.5
04E8:  CLRF   24
04E9:  MOVF   24,W
04EA:  SUBLW  03
04EB:  BTFSS  03.0
04EC:  GOTO   4FB
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
04ED:  MOVLW  A5
04EE:  ADDWF  24,W
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  MOVF   00,W
04F2:  MOVWF  29
04F3:  CLRF   31
04F4:  MOVF   29,W
04F5:  MOVWF  32
04F6:  BCF    03.5
04F7:  CALL   3ED
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
04F8:  BSF    03.5
04F9:  INCF   24,F
04FA:  GOTO   4E9
04FB:  BCF    03.5
04FC:  BSF    0A.3
04FD:  BCF    0A.4
04FE:  GOTO   74A (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
05BC:  DECFSZ 2E,W
05BD:  GOTO   5BF
05BE:  GOTO   5C2
*
05E0:  DECFSZ 2E,W
05E1:  GOTO   5E3
05E2:  GOTO   5E6
*
0A96:  DECFSZ 2E,W
0A97:  GOTO   299
0A98:  GOTO   29C
*
0AFF:  DECFSZ 2E,W
0B00:  GOTO   302
0B01:  GOTO   305
*
0BB6:  DECFSZ 2E,W
0BB7:  GOTO   3B9
0BB8:  GOTO   3BC
*
0C22:  DECFSZ 2E,W
0C23:  GOTO   425
0C24:  GOTO   428
*
0CAB:  DECFSZ 2E,W
0CAC:  GOTO   4AE
0CAD:  GOTO   4B1
*
0D14:  DECFSZ 2E,W
0D15:  GOTO   517
0D16:  GOTO   51A
*
0D9F:  DECFSZ 2E,W
0DA0:  GOTO   5A2
0DA1:  GOTO   5A5
*
0E0B:  DECFSZ 2E,W
0E0C:  GOTO   60E
0E0D:  GOTO   611
*
0E7A:  DECFSZ 2E,W
0E7B:  GOTO   67D
0E7C:  GOTO   680
*
1016:  DECFSZ 2E,W
1017:  GOTO   019
1018:  GOTO   01C
*
1057:  DECFSZ 2E,W
1058:  GOTO   05A
1059:  GOTO   05D
*
1098:  DECFSZ 2E,W
1099:  GOTO   09B
109A:  GOTO   09E
*
10F7:  DECFSZ 2E,W
10F8:  GOTO   0FA
10F9:  GOTO   0FD
*
1167:  DECFSZ 2E,W
1168:  GOTO   16A
1169:  GOTO   16D
*
11F1:  DECFSZ 2E,W
11F2:  GOTO   1F4
11F3:  GOTO   1F7
*
124C:  DECFSZ 2E,W
124D:  GOTO   24F
124E:  GOTO   252
*
128B:  DECFSZ 2E,W
128C:  GOTO   28E
128D:  GOTO   291
....................       address=LCD_LINE_TWO; 
*
05BF:  MOVLW  40
05C0:  MOVWF  2F
05C1:  GOTO   5C3
*
05E3:  MOVLW  40
05E4:  MOVWF  2F
05E5:  GOTO   5E7
*
0A99:  MOVLW  40
0A9A:  MOVWF  2F
0A9B:  GOTO   29D
*
0B02:  MOVLW  40
0B03:  MOVWF  2F
0B04:  GOTO   306
*
0BB9:  MOVLW  40
0BBA:  MOVWF  2F
0BBB:  GOTO   3BD
*
0C25:  MOVLW  40
0C26:  MOVWF  2F
0C27:  GOTO   429
*
0CAE:  MOVLW  40
0CAF:  MOVWF  2F
0CB0:  GOTO   4B2
*
0D17:  MOVLW  40
0D18:  MOVWF  2F
0D19:  GOTO   51B
*
0DA2:  MOVLW  40
0DA3:  MOVWF  2F
0DA4:  GOTO   5A6
*
0E0E:  MOVLW  40
0E0F:  MOVWF  2F
0E10:  GOTO   612
*
0E7D:  MOVLW  40
0E7E:  MOVWF  2F
0E7F:  GOTO   681
*
1019:  MOVLW  40
101A:  MOVWF  2F
101B:  GOTO   01D
*
105A:  MOVLW  40
105B:  MOVWF  2F
105C:  GOTO   05E
*
109B:  MOVLW  40
109C:  MOVWF  2F
109D:  GOTO   09F
*
10FA:  MOVLW  40
10FB:  MOVWF  2F
10FC:  GOTO   0FE
*
116A:  MOVLW  40
116B:  MOVWF  2F
116C:  GOTO   16E
*
11F4:  MOVLW  40
11F5:  MOVWF  2F
11F6:  GOTO   1F8
*
124F:  MOVLW  40
1250:  MOVWF  2F
1251:  GOTO   253
*
128E:  MOVLW  40
128F:  MOVWF  2F
1290:  GOTO   292
....................    else 
....................       address=0; 
*
05C2:  CLRF   2F
*
05E6:  CLRF   2F
*
0A9C:  CLRF   2F
*
0B05:  CLRF   2F
*
0BBC:  CLRF   2F
*
0C28:  CLRF   2F
*
0CB1:  CLRF   2F
*
0D1A:  CLRF   2F
*
0DA5:  CLRF   2F
*
0E11:  CLRF   2F
*
0E80:  CLRF   2F
*
101C:  CLRF   2F
*
105D:  CLRF   2F
*
109E:  CLRF   2F
*
10FD:  CLRF   2F
*
116D:  CLRF   2F
*
11F7:  CLRF   2F
*
1252:  CLRF   2F
*
1291:  CLRF   2F
....................       
....................    address+=x-1; 
*
05C3:  MOVLW  01
05C4:  SUBWF  2D,W
05C5:  ADDWF  2F,F
*
05E7:  MOVLW  01
05E8:  SUBWF  2D,W
05E9:  ADDWF  2F,F
*
0A9D:  MOVLW  01
0A9E:  SUBWF  2D,W
0A9F:  ADDWF  2F,F
*
0B06:  MOVLW  01
0B07:  SUBWF  2D,W
0B08:  ADDWF  2F,F
*
0BBD:  MOVLW  01
0BBE:  SUBWF  2D,W
0BBF:  ADDWF  2F,F
*
0C29:  MOVLW  01
0C2A:  SUBWF  2D,W
0C2B:  ADDWF  2F,F
*
0CB2:  MOVLW  01
0CB3:  SUBWF  2D,W
0CB4:  ADDWF  2F,F
*
0D1B:  MOVLW  01
0D1C:  SUBWF  2D,W
0D1D:  ADDWF  2F,F
*
0DA6:  MOVLW  01
0DA7:  SUBWF  2D,W
0DA8:  ADDWF  2F,F
*
0E12:  MOVLW  01
0E13:  SUBWF  2D,W
0E14:  ADDWF  2F,F
*
0E81:  MOVLW  01
0E82:  SUBWF  2D,W
0E83:  ADDWF  2F,F
*
101D:  MOVLW  01
101E:  SUBWF  2D,W
101F:  ADDWF  2F,F
*
105E:  MOVLW  01
105F:  SUBWF  2D,W
1060:  ADDWF  2F,F
*
109F:  MOVLW  01
10A0:  SUBWF  2D,W
10A1:  ADDWF  2F,F
*
10FE:  MOVLW  01
10FF:  SUBWF  2D,W
1100:  ADDWF  2F,F
*
116E:  MOVLW  01
116F:  SUBWF  2D,W
1170:  ADDWF  2F,F
*
11F8:  MOVLW  01
11F9:  SUBWF  2D,W
11FA:  ADDWF  2F,F
*
1253:  MOVLW  01
1254:  SUBWF  2D,W
1255:  ADDWF  2F,F
*
1292:  MOVLW  01
1293:  SUBWF  2D,W
1294:  ADDWF  2F,F
....................    lcd_send_byte(0,0x80|address); 
*
05C6:  MOVF   2F,W
05C7:  IORLW  80
05C8:  MOVWF  30
05C9:  CLRF   31
05CA:  MOVF   30,W
05CB:  MOVWF  32
05CC:  BCF    03.5
05CD:  CALL   3ED
*
05EA:  MOVF   2F,W
05EB:  IORLW  80
05EC:  MOVWF  30
05ED:  CLRF   31
05EE:  MOVF   30,W
05EF:  MOVWF  32
05F0:  BCF    03.5
05F1:  CALL   3ED
*
0AA0:  MOVF   2F,W
0AA1:  IORLW  80
0AA2:  MOVWF  30
0AA3:  CLRF   31
0AA4:  MOVF   30,W
0AA5:  MOVWF  32
0AA6:  BCF    0A.3
0AA7:  BCF    03.5
0AA8:  CALL   3ED
0AA9:  BSF    0A.3
*
0B09:  MOVF   2F,W
0B0A:  IORLW  80
0B0B:  MOVWF  30
0B0C:  CLRF   31
0B0D:  MOVF   30,W
0B0E:  MOVWF  32
0B0F:  BCF    0A.3
0B10:  BCF    03.5
0B11:  CALL   3ED
0B12:  BSF    0A.3
*
0BC0:  MOVF   2F,W
0BC1:  IORLW  80
0BC2:  MOVWF  30
0BC3:  CLRF   31
0BC4:  MOVF   30,W
0BC5:  MOVWF  32
0BC6:  BCF    0A.3
0BC7:  BCF    03.5
0BC8:  CALL   3ED
0BC9:  BSF    0A.3
*
0C2C:  MOVF   2F,W
0C2D:  IORLW  80
0C2E:  MOVWF  30
0C2F:  CLRF   31
0C30:  MOVF   30,W
0C31:  MOVWF  32
0C32:  BCF    0A.3
0C33:  BCF    03.5
0C34:  CALL   3ED
0C35:  BSF    0A.3
*
0CB5:  MOVF   2F,W
0CB6:  IORLW  80
0CB7:  MOVWF  30
0CB8:  CLRF   31
0CB9:  MOVF   30,W
0CBA:  MOVWF  32
0CBB:  BCF    0A.3
0CBC:  BCF    03.5
0CBD:  CALL   3ED
0CBE:  BSF    0A.3
*
0D1E:  MOVF   2F,W
0D1F:  IORLW  80
0D20:  MOVWF  30
0D21:  CLRF   31
0D22:  MOVF   30,W
0D23:  MOVWF  32
0D24:  BCF    0A.3
0D25:  BCF    03.5
0D26:  CALL   3ED
0D27:  BSF    0A.3
*
0DA9:  MOVF   2F,W
0DAA:  IORLW  80
0DAB:  MOVWF  30
0DAC:  CLRF   31
0DAD:  MOVF   30,W
0DAE:  MOVWF  32
0DAF:  BCF    0A.3
0DB0:  BCF    03.5
0DB1:  CALL   3ED
0DB2:  BSF    0A.3
*
0E15:  MOVF   2F,W
0E16:  IORLW  80
0E17:  MOVWF  30
0E18:  CLRF   31
0E19:  MOVF   30,W
0E1A:  MOVWF  32
0E1B:  BCF    0A.3
0E1C:  BCF    03.5
0E1D:  CALL   3ED
0E1E:  BSF    0A.3
*
0E84:  MOVF   2F,W
0E85:  IORLW  80
0E86:  MOVWF  30
0E87:  CLRF   31
0E88:  MOVF   30,W
0E89:  MOVWF  32
0E8A:  BCF    0A.3
0E8B:  BCF    03.5
0E8C:  CALL   3ED
0E8D:  BSF    0A.3
*
1020:  MOVF   2F,W
1021:  IORLW  80
1022:  MOVWF  30
1023:  CLRF   31
1024:  MOVF   30,W
1025:  MOVWF  32
1026:  BCF    0A.4
1027:  BCF    03.5
1028:  CALL   3ED
1029:  BSF    0A.4
*
1061:  MOVF   2F,W
1062:  IORLW  80
1063:  MOVWF  30
1064:  CLRF   31
1065:  MOVF   30,W
1066:  MOVWF  32
1067:  BCF    0A.4
1068:  BCF    03.5
1069:  CALL   3ED
106A:  BSF    0A.4
*
10A2:  MOVF   2F,W
10A3:  IORLW  80
10A4:  MOVWF  30
10A5:  CLRF   31
10A6:  MOVF   30,W
10A7:  MOVWF  32
10A8:  BCF    0A.4
10A9:  BCF    03.5
10AA:  CALL   3ED
10AB:  BSF    0A.4
*
1101:  MOVF   2F,W
1102:  IORLW  80
1103:  MOVWF  30
1104:  CLRF   31
1105:  MOVF   30,W
1106:  MOVWF  32
1107:  BCF    0A.4
1108:  BCF    03.5
1109:  CALL   3ED
110A:  BSF    0A.4
*
1171:  MOVF   2F,W
1172:  IORLW  80
1173:  MOVWF  30
1174:  CLRF   31
1175:  MOVF   30,W
1176:  MOVWF  32
1177:  BCF    0A.4
1178:  BCF    03.5
1179:  CALL   3ED
117A:  BSF    0A.4
*
11FB:  MOVF   2F,W
11FC:  IORLW  80
11FD:  MOVWF  30
11FE:  CLRF   31
11FF:  MOVF   30,W
1200:  MOVWF  32
1201:  BCF    0A.4
1202:  BCF    03.5
1203:  CALL   3ED
1204:  BSF    0A.4
*
1256:  MOVF   2F,W
1257:  IORLW  80
1258:  MOVWF  30
1259:  CLRF   31
125A:  MOVF   30,W
125B:  MOVWF  32
125C:  BCF    0A.4
125D:  BCF    03.5
125E:  CALL   3ED
125F:  BSF    0A.4
*
1295:  MOVF   2F,W
1296:  IORLW  80
1297:  MOVWF  30
1298:  CLRF   31
1299:  MOVF   30,W
129A:  MOVWF  32
129B:  BCF    0A.4
129C:  BCF    03.5
129D:  CALL   3ED
129E:  BSF    0A.4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
05A8:  BSF    03.5
05A9:  MOVF   2C,W
05AA:  XORLW  07
05AB:  BCF    03.5
05AC:  BTFSC  03.2
05AD:  GOTO   5B8
05AE:  XORLW  0B
05AF:  BTFSC  03.2
05B0:  GOTO   5CF
05B1:  XORLW  06
05B2:  BTFSC  03.2
05B3:  GOTO   5DB
05B4:  XORLW  02
05B5:  BTFSC  03.2
05B6:  GOTO   5F3
05B7:  GOTO   5FA
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
05B8:  MOVLW  01
05B9:  BSF    03.5
05BA:  MOVWF  2D
05BB:  MOVWF  2E
*
05CE:  GOTO   601
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
05CF:  BSF    03.5
05D0:  CLRF   31
05D1:  MOVLW  01
05D2:  MOVWF  32
05D3:  BCF    03.5
05D4:  CALL   3ED
....................                      delay_ms(2); 
05D5:  MOVLW  02
05D6:  BSF    03.5
05D7:  MOVWF  2D
05D8:  BCF    03.5
05D9:  CALL   39F
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
05DA:  GOTO   601
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
05DB:  MOVLW  01
05DC:  BSF    03.5
05DD:  MOVWF  2D
05DE:  MOVLW  02
05DF:  MOVWF  2E
*
05F2:  GOTO   601
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
05F3:  BSF    03.5
05F4:  CLRF   31
05F5:  MOVLW  10
05F6:  MOVWF  32
05F7:  BCF    03.5
05F8:  CALL   3ED
05F9:  GOTO   601
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
05FA:  MOVLW  01
05FB:  BSF    03.5
05FC:  MOVWF  31
05FD:  MOVF   2C,W
05FE:  MOVWF  32
05FF:  BCF    03.5
0600:  CALL   3ED
....................      #endif 
....................    } 
0601:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
06B1:  BSF    03.5
06B2:  CLRF   2E
06B3:  CLRF   2D
06B4:  CLRF   30
06B5:  CLRF   2F
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
06B6:  MOVF   2A,F
06B7:  BTFSS  03.2
06B8:  GOTO   6BD
06B9:  MOVF   29,W
06BA:  SUBLW  13
06BB:  BTFSC  03.0
06BC:  GOTO   7FE
06BD:  MOVF   2A,W
06BE:  SUBLW  4E
06BF:  BTFSS  03.0
06C0:  GOTO   7FE
06C1:  BTFSS  03.2
06C2:  GOTO   6C7
06C3:  MOVF   29,W
06C4:  SUBLW  20
06C5:  BTFSS  03.0
06C6:  GOTO   7FE
....................       tmp=100000; 
06C7:  CLRF   36
06C8:  MOVLW  01
06C9:  MOVWF  35
06CA:  MOVLW  86
06CB:  MOVWF  34
06CC:  MOVLW  A0
06CD:  MOVWF  33
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
06CE:  BCF    03.1
06CF:  MOVF   36,W
06D0:  MOVWF  3A
06D1:  MOVF   35,W
06D2:  MOVWF  39
06D3:  MOVF   34,W
06D4:  MOVWF  38
06D5:  MOVF   33,W
06D6:  MOVWF  37
06D7:  CLRF   3E
06D8:  CLRF   3D
06D9:  MOVF   2A,W
06DA:  MOVWF  3C
06DB:  MOVF   29,W
06DC:  MOVWF  3B
*
072B:  MOVF   7A,W
072C:  MOVWF  36
072D:  MOVF   79,W
072E:  MOVWF  35
072F:  MOVF   78,W
0730:  MOVWF  34
0731:  MOVF   77,W
0732:  MOVWF  33
....................       tmp*=5;    
0733:  MOVF   36,W
0734:  MOVWF  3A
0735:  MOVF   35,W
0736:  MOVWF  39
0737:  MOVF   34,W
0738:  MOVWF  38
0739:  MOVF   33,W
073A:  MOVWF  37
073B:  CLRF   3E
073C:  CLRF   3D
073D:  CLRF   3C
073E:  MOVLW  05
073F:  MOVWF  3B
*
0769:  MOVF   7A,W
076A:  MOVWF  36
076B:  MOVF   79,W
076C:  MOVWF  35
076D:  MOVF   78,W
076E:  MOVWF  34
076F:  MOVF   77,W
0770:  MOVWF  33
....................       uS=tmp; 
0771:  MOVF   34,W
0772:  MOVWF  32
0773:  MOVF   33,W
0774:  MOVWF  31
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
0775:  BCF    06.2
0776:  BCF    03.5
0777:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0778:  BSF    03.5
0779:  MOVF   32,W
077A:  MOVWF  37
077B:  INCF   37,F
077C:  DECF   37,F
077D:  BTFSC  03.2
077E:  GOTO   790
077F:  MOVLW  FF
0780:  MOVWF  38
*
078F:  GOTO   77C
0790:  MOVF   31,W
0791:  MOVWF  38
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
07A0:  MOVF   31,W
07A1:  ADDWF  2F,F
07A2:  MOVF   32,W
07A3:  BTFSC  03.0
07A4:  INCFSZ 32,W
07A5:  ADDWF  30,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
07A6:  BCF    06.2
07A7:  BCF    03.5
07A8:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
07A9:  BSF    03.5
07AA:  MOVF   32,W
07AB:  MOVWF  37
07AC:  INCF   37,F
07AD:  DECF   37,F
07AE:  BTFSC  03.2
07AF:  GOTO   7C1
07B0:  MOVLW  FF
07B1:  MOVWF  38
*
07C0:  GOTO   7AD
07C1:  MOVF   31,W
07C2:  MOVWF  38
....................          CiclosL+=(uS);          //  
*
07D1:  MOVF   31,W
07D2:  ADDWF  2F,F
07D3:  MOVF   32,W
07D4:  BTFSC  03.0
07D5:  INCFSZ 32,W
07D6:  ADDWF  30,F
....................          CiclosL+=25;            // Compensador. 
07D7:  MOVLW  19
07D8:  ADDWF  2F,F
07D9:  BTFSC  03.0
07DA:  INCF   30,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
07DB:  MOVF   30,W
07DC:  SUBLW  02
07DD:  BTFSC  03.0
07DE:  GOTO   7F4
07DF:  XORLW  FF
07E0:  BTFSS  03.2
07E1:  GOTO   7E6
07E2:  MOVF   2F,W
07E3:  SUBLW  E7
07E4:  BTFSC  03.0
07E5:  GOTO   7F4
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
07E6:  MOVLW  E8
07E7:  SUBWF  2F,F
07E8:  MOVLW  03
07E9:  BTFSS  03.0
07EA:  MOVLW  04
07EB:  SUBWF  30,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
07EC:  INCF   2D,F
07ED:  BTFSC  03.2
07EE:  INCF   2E,F
....................             CiclosL+=25;         // Compensador. 
07EF:  MOVLW  19
07F0:  ADDWF  2F,F
07F1:  BTFSC  03.0
07F2:  INCF   30,F
07F3:  GOTO   7DB
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
07F4:  MOVF   2E,W
07F5:  SUBWF  2C,W
07F6:  BTFSS  03.0
07F7:  GOTO   7FE
07F8:  BTFSS  03.2
07F9:  GOTO   775
07FA:  MOVF   2B,W
07FB:  SUBWF  2D,W
07FC:  BTFSS  03.0
07FD:  GOTO   775
....................                                          // tiempo indicado. 
....................    } 
07FE:  BCF    03.5
07FF:  RETURN
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/menu.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_IP     0 
....................   #define OPT_SHOW_SSID   1 
....................   #define OPT_SHOW_KEY    2 
....................   #define OPT_MODE_AP     3 
....................   #define OPT_BACKLIGH    4 
....................   #define OPT_EXIT        5 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[7][17]    =  { {"VER IP          "}, 
....................                                         {"VER SSID        "}, 
....................                                         {"VER KEY         "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacion     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 5; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
0A71:  BSF    03.5
0A72:  CLRF   24
0A73:  CLRF   25
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0A74:  SWAPF  24,W
0A75:  MOVWF  77
0A76:  MOVLW  F0
0A77:  ANDWF  77,F
0A78:  MOVF   77,W
0A79:  MOVWF  26
0A7A:  MOVLW  0C
0A7B:  MOVWF  2C
0A7C:  BCF    0A.3
0A7D:  BCF    03.5
0A7E:  CALL   5A8
0A7F:  BSF    0A.3
0A80:  MOVLW  59
0A81:  BSF    03.6
0A82:  MOVWF  0D
0A83:  MOVLW  00
0A84:  MOVWF  0F
0A85:  BSF    03.5
0A86:  BCF    03.6
0A87:  MOVF   26,W
0A88:  BCF    03.5
0A89:  BSF    03.6
0A8A:  ADDWF  0D,F
0A8B:  BTFSC  03.0
0A8C:  INCF   0F,F
0A8D:  BCF    0A.3
0A8E:  BCF    03.6
0A8F:  CALL   602
0A90:  BSF    0A.3
....................    showBottonMenu(); 
....................    while(!exit){ 
*
0AB3:  BSF    03.5
0AB4:  MOVF   25,F
0AB5:  BTFSS  03.2
0AB6:  GOTO   33E
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0AB7:  BSF    06.4
0AB8:  BCF    03.5
0AB9:  BTFSC  06.4
0ABA:  GOTO   31C
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0ABB:  MOVLW  02
0ABC:  BSF    03.5
0ABD:  MOVWF  26
0ABE:  MOVLW  FA
0ABF:  MOVWF  2D
0AC0:  BCF    0A.3
0AC1:  BCF    03.5
0AC2:  CALL   39F
0AC3:  BSF    0A.3
0AC4:  BSF    03.5
0AC5:  DECFSZ 26,F
0AC6:  GOTO   2BE
....................          BEEP; 
0AC7:  MOVLW  04
0AC8:  MOVWF  2A
0AC9:  MOVLW  B9
0ACA:  MOVWF  29
0ACB:  CLRF   2C
0ACC:  MOVLW  14
0ACD:  MOVWF  2B
0ACE:  BCF    0A.3
0ACF:  BCF    03.5
0AD0:  CALL   6B1
0AD1:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0AD2:  BSF    03.5
0AD3:  INCF   24,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
0AD4:  MOVF   24,W
0AD5:  BCF    03.5
0AD6:  SUBWF  41,W
0AD7:  BTFSC  03.0
0AD8:  GOTO   2DC
....................             optSelected = 0; 
0AD9:  BSF    03.5
0ADA:  CLRF   24
0ADB:  BCF    03.5
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0ADC:  BSF    03.5
0ADD:  SWAPF  24,W
0ADE:  MOVWF  77
0ADF:  MOVLW  F0
0AE0:  ANDWF  77,F
0AE1:  MOVF   77,W
0AE2:  MOVWF  26
0AE3:  MOVLW  0C
0AE4:  MOVWF  2C
0AE5:  BCF    0A.3
0AE6:  BCF    03.5
0AE7:  CALL   5A8
0AE8:  BSF    0A.3
0AE9:  MOVLW  59
0AEA:  BSF    03.6
0AEB:  MOVWF  0D
0AEC:  MOVLW  00
0AED:  MOVWF  0F
0AEE:  BSF    03.5
0AEF:  BCF    03.6
0AF0:  MOVF   26,W
0AF1:  BCF    03.5
0AF2:  BSF    03.6
0AF3:  ADDWF  0D,F
0AF4:  BTFSC  03.0
0AF5:  INCF   0F,F
0AF6:  BCF    0A.3
0AF7:  BCF    03.6
0AF8:  CALL   602
0AF9:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0B1C:  BSF    03.5
0B1D:  BSF    06.5
0B1E:  BCF    03.5
0B1F:  BTFSC  06.5
0B20:  GOTO   33C
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0B21:  MOVLW  02
0B22:  BSF    03.5
0B23:  MOVWF  26
0B24:  MOVLW  FA
0B25:  MOVWF  2D
0B26:  BCF    0A.3
0B27:  BCF    03.5
0B28:  CALL   39F
0B29:  BSF    0A.3
0B2A:  BSF    03.5
0B2B:  DECFSZ 26,F
0B2C:  GOTO   324
....................          BEEP; 
0B2D:  MOVLW  04
0B2E:  MOVWF  2A
0B2F:  MOVLW  B9
0B30:  MOVWF  29
0B31:  CLRF   2C
0B32:  MOVLW  14
0B33:  MOVWF  2B
0B34:  BCF    0A.3
0B35:  BCF    03.5
0B36:  CALL   6B1
0B37:  BSF    0A.3
....................          // Rompe el Loop 
....................          exit = 1; 
0B38:  MOVLW  01
0B39:  BSF    03.5
0B3A:  MOVWF  25
0B3B:  BCF    03.5
....................       } // Fin KEY_OK 
0B3C:  GOTO   2B3
0B3D:  BSF    03.5
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
0B3E:  MOVLW  01
0B3F:  ADDWF  24,W
0B40:  MOVWF  78
0B41:  BCF    03.5
0B42:  BSF    0A.3
0B43:  BCF    0A.4
0B44:  GOTO   759 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
1011:  MOVLW  0C
1012:  BSF    03.5
1013:  MOVWF  2D
1014:  MOVLW  02
1015:  MOVWF  2E
*
1052:  MOVLW  0C
1053:  BSF    03.5
1054:  MOVWF  2D
1055:  MOVLW  02
1056:  MOVWF  2E
*
1093:  MOVLW  0C
1094:  BSF    03.5
1095:  MOVWF  2D
1096:  MOVLW  02
1097:  MOVWF  2E
*
11EC:  MOVLW  0C
11ED:  BSF    03.5
11EE:  MOVWF  2D
11EF:  MOVLW  02
11F0:  MOVWF  2E
*
1286:  MOVLW  0C
1287:  BSF    03.5
1288:  MOVWF  2D
1289:  MOVLW  02
128A:  MOVWF  2E
....................   printf(lcd_putc, "SALIR"); 
*
102A:  MOVLW  8C
102B:  BSF    03.6
102C:  MOVWF  0D
102D:  MOVLW  02
102E:  MOVWF  0F
102F:  BCF    0A.4
1030:  BCF    03.6
1031:  CALL   63D
1032:  BSF    0A.4
*
106B:  MOVLW  8C
106C:  BSF    03.6
106D:  MOVWF  0D
106E:  MOVLW  02
106F:  MOVWF  0F
1070:  BCF    0A.4
1071:  BCF    03.6
1072:  CALL   63D
1073:  BSF    0A.4
*
10AC:  MOVLW  8C
10AD:  BSF    03.6
10AE:  MOVWF  0D
10AF:  MOVLW  02
10B0:  MOVWF  0F
10B1:  BCF    0A.4
10B2:  BCF    03.6
10B3:  CALL   63D
10B4:  BSF    0A.4
*
1205:  MOVLW  8C
1206:  BSF    03.6
1207:  MOVWF  0D
1208:  MOVLW  02
1209:  MOVWF  0F
120A:  BCF    0A.4
120B:  BCF    03.6
120C:  CALL   63D
120D:  BSF    0A.4
*
129F:  MOVLW  8C
12A0:  BSF    03.6
12A1:  MOVWF  0D
12A2:  MOVLW  02
12A3:  MOVWF  0F
12A4:  BCF    0A.4
12A5:  BCF    03.6
12A6:  CALL   63D
12A7:  BSF    0A.4
....................   while(1){ 
....................      if(input(KEY_OK)==0){ 
*
1033:  BSF    03.5
1034:  BSF    06.5
1035:  BCF    03.5
1036:  BTFSC  06.5
1037:  GOTO   046
*
1074:  BSF    03.5
1075:  BSF    06.5
1076:  BCF    03.5
1077:  BTFSC  06.5
1078:  GOTO   087
*
10B5:  BSF    03.5
10B6:  BSF    06.5
10B7:  BCF    03.5
10B8:  BTFSC  06.5
10B9:  GOTO   0C8
*
120E:  BSF    03.5
120F:  BSF    06.5
1210:  BCF    03.5
1211:  BTFSC  06.5
1212:  GOTO   221
*
12A8:  BSF    03.5
12A9:  BSF    06.5
12AA:  BCF    03.5
12AB:  BTFSC  06.5
12AC:  GOTO   2BB
....................            // Elimina el rebote 
....................            delay_ms(500); 
*
1038:  MOVLW  02
1039:  BSF    03.5
103A:  MOVWF  29
103B:  MOVLW  FA
103C:  MOVWF  2D
103D:  BCF    0A.4
103E:  BCF    03.5
103F:  CALL   39F
1040:  BSF    0A.4
1041:  BSF    03.5
1042:  DECFSZ 29,F
1043:  GOTO   03B
*
1079:  MOVLW  02
107A:  BSF    03.5
107B:  MOVWF  29
107C:  MOVLW  FA
107D:  MOVWF  2D
107E:  BCF    0A.4
107F:  BCF    03.5
1080:  CALL   39F
1081:  BSF    0A.4
1082:  BSF    03.5
1083:  DECFSZ 29,F
1084:  GOTO   07C
*
10BA:  MOVLW  02
10BB:  BSF    03.5
10BC:  MOVWF  29
10BD:  MOVLW  FA
10BE:  MOVWF  2D
10BF:  BCF    0A.4
10C0:  BCF    03.5
10C1:  CALL   39F
10C2:  BSF    0A.4
10C3:  BSF    03.5
10C4:  DECFSZ 29,F
10C5:  GOTO   0BD
*
1213:  MOVLW  02
1214:  BSF    03.5
1215:  MOVWF  29
1216:  MOVLW  FA
1217:  MOVWF  2D
1218:  BCF    0A.4
1219:  BCF    03.5
121A:  CALL   39F
121B:  BSF    0A.4
121C:  BSF    03.5
121D:  DECFSZ 29,F
121E:  GOTO   216
*
12AD:  MOVLW  02
12AE:  BSF    03.5
12AF:  MOVWF  29
12B0:  MOVLW  FA
12B1:  MOVWF  2D
12B2:  BCF    0A.4
12B3:  BCF    03.5
12B4:  CALL   39F
12B5:  BSF    0A.4
12B6:  BSF    03.5
12B7:  DECFSZ 29,F
12B8:  GOTO   2B0
....................            break; 
*
1044:  GOTO   048
1045:  BCF    03.5
*
1085:  GOTO   089
1086:  BCF    03.5
*
10C6:  GOTO   0CA
10C7:  BCF    03.5
*
121F:  GOTO   223
1220:  BCF    03.5
*
12B9:  GOTO   2BD
12BA:  BCF    03.5
....................      } 
*
1046:  GOTO   033
1047:  BSF    03.5
*
1087:  GOTO   074
1088:  BSF    03.5
*
10C8:  GOTO   0B5
10C9:  BSF    03.5
*
1221:  GOTO   20E
1222:  BSF    03.5
*
12BB:  GOTO   2A8
12BC:  BSF    03.5
....................   } 
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
0A91:  MOVLW  01
0A92:  BSF    03.5
0A93:  MOVWF  2D
0A94:  MOVLW  02
0A95:  MOVWF  2E
*
0AFA:  MOVLW  01
0AFB:  BSF    03.5
0AFC:  MOVWF  2D
0AFD:  MOVLW  02
0AFE:  MOVWF  2E
*
0BB1:  MOVLW  01
0BB2:  BSF    03.5
0BB3:  MOVWF  2D
0BB4:  MOVLW  02
0BB5:  MOVWF  2E
*
0C1D:  MOVLW  01
0C1E:  BSF    03.5
0C1F:  MOVWF  2D
0C20:  MOVLW  02
0C21:  MOVWF  2E
*
0CA6:  MOVLW  01
0CA7:  BSF    03.5
0CA8:  MOVWF  2D
0CA9:  MOVLW  02
0CAA:  MOVWF  2E
*
0D0F:  MOVLW  01
0D10:  BSF    03.5
0D11:  MOVWF  2D
0D12:  MOVLW  02
0D13:  MOVWF  2E
*
0D9A:  MOVLW  01
0D9B:  BSF    03.5
0D9C:  MOVWF  2D
0D9D:  MOVLW  02
0D9E:  MOVWF  2E
*
0E06:  MOVLW  01
0E07:  BSF    03.5
0E08:  MOVWF  2D
0E09:  MOVLW  02
0E0A:  MOVWF  2E
*
0E75:  MOVLW  01
0E76:  BSF    03.5
0E77:  MOVWF  2D
0E78:  MOVLW  02
0E79:  MOVWF  2E
*
10F2:  MOVLW  01
10F3:  BSF    03.5
10F4:  MOVWF  2D
10F5:  MOVLW  02
10F6:  MOVWF  2E
*
1162:  MOVLW  01
1163:  BSF    03.5
1164:  MOVWF  2D
1165:  MOVLW  02
1166:  MOVWF  2E
*
1247:  MOVLW  01
1248:  BSF    03.5
1249:  MOVWF  2D
124A:  MOVLW  02
124B:  MOVWF  2E
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
*
0AAA:  MOVLW  8F
0AAB:  BSF    03.6
0AAC:  MOVWF  0D
0AAD:  MOVLW  02
0AAE:  MOVWF  0F
0AAF:  BCF    0A.3
0AB0:  BCF    03.6
0AB1:  CALL   63D
0AB2:  BSF    0A.3
*
0B13:  MOVLW  8F
0B14:  BSF    03.6
0B15:  MOVWF  0D
0B16:  MOVLW  02
0B17:  MOVWF  0F
0B18:  BCF    0A.3
0B19:  BCF    03.6
0B1A:  CALL   63D
0B1B:  BSF    0A.3
*
0BCA:  MOVLW  8F
0BCB:  BSF    03.6
0BCC:  MOVWF  0D
0BCD:  MOVLW  02
0BCE:  MOVWF  0F
0BCF:  BCF    0A.3
0BD0:  BCF    03.6
0BD1:  CALL   63D
0BD2:  BSF    0A.3
*
0C36:  MOVLW  8F
0C37:  BSF    03.6
0C38:  MOVWF  0D
0C39:  MOVLW  02
0C3A:  MOVWF  0F
0C3B:  BCF    0A.3
0C3C:  BCF    03.6
0C3D:  CALL   63D
0C3E:  BSF    0A.3
*
0CBF:  MOVLW  8F
0CC0:  BSF    03.6
0CC1:  MOVWF  0D
0CC2:  MOVLW  02
0CC3:  MOVWF  0F
0CC4:  BCF    0A.3
0CC5:  BCF    03.6
0CC6:  CALL   63D
0CC7:  BSF    0A.3
*
0D28:  MOVLW  8F
0D29:  BSF    03.6
0D2A:  MOVWF  0D
0D2B:  MOVLW  02
0D2C:  MOVWF  0F
0D2D:  BCF    0A.3
0D2E:  BCF    03.6
0D2F:  CALL   63D
0D30:  BSF    0A.3
*
0DB3:  MOVLW  8F
0DB4:  BSF    03.6
0DB5:  MOVWF  0D
0DB6:  MOVLW  02
0DB7:  MOVWF  0F
0DB8:  BCF    0A.3
0DB9:  BCF    03.6
0DBA:  CALL   63D
0DBB:  BSF    0A.3
*
0E1F:  MOVLW  8F
0E20:  BSF    03.6
0E21:  MOVWF  0D
0E22:  MOVLW  02
0E23:  MOVWF  0F
0E24:  BCF    0A.3
0E25:  BCF    03.6
0E26:  CALL   63D
0E27:  BSF    0A.3
*
0E8E:  MOVLW  8F
0E8F:  BSF    03.6
0E90:  MOVWF  0D
0E91:  MOVLW  02
0E92:  MOVWF  0F
0E93:  BCF    0A.3
0E94:  BCF    03.6
0E95:  CALL   63D
0E96:  BSF    0A.3
0E97:  BSF    03.5
*
110B:  MOVLW  8F
110C:  BSF    03.6
110D:  MOVWF  0D
110E:  MOVLW  02
110F:  MOVWF  0F
1110:  BCF    0A.4
1111:  BCF    03.6
1112:  CALL   63D
1113:  BSF    0A.4
*
117B:  MOVLW  8F
117C:  BSF    03.6
117D:  MOVWF  0D
117E:  MOVLW  02
117F:  MOVWF  0F
1180:  BCF    0A.4
1181:  BCF    03.6
1182:  CALL   63D
1183:  BSF    0A.4
*
1260:  MOVLW  8F
1261:  BSF    03.6
1262:  MOVWF  0D
1263:  MOVLW  02
1264:  MOVWF  0F
1265:  BCF    0A.4
1266:  BCF    03.6
1267:  CALL   63D
1268:  BSF    0A.4
1269:  BSF    03.5
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
0B8E:  BSF    03.5
0B8F:  CLRF   24
0B90:  CLRF   25
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0B91:  MOVF   24,W
0B92:  MOVWF  29
0B93:  MOVLW  0F
0B94:  MOVWF  2A
0B95:  BCF    03.5
0B96:  CALL   345
0B97:  MOVF   78,W
0B98:  BSF    03.5
0B99:  MOVWF  26
0B9A:  MOVLW  0C
0B9B:  MOVWF  2C
0B9C:  BCF    0A.3
0B9D:  BCF    03.5
0B9E:  CALL   5A8
0B9F:  BSF    0A.3
0BA0:  MOVLW  99
0BA1:  BSF    03.6
0BA2:  MOVWF  0D
0BA3:  MOVLW  00
0BA4:  MOVWF  0F
0BA5:  BSF    03.5
0BA6:  BCF    03.6
0BA7:  MOVF   26,W
0BA8:  BCF    03.5
0BA9:  BSF    03.6
0BAA:  ADDWF  0D,F
0BAB:  BTFSC  03.0
0BAC:  INCF   0F,F
0BAD:  BCF    0A.3
0BAE:  BCF    03.6
0BAF:  CALL   602
0BB0:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0BD3:  BSF    03.5
0BD4:  MOVF   25,F
0BD5:  BTFSS  03.2
0BD6:  GOTO   480
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0BD7:  BSF    06.4
0BD8:  BCF    03.5
0BD9:  BTFSC  06.4
0BDA:  GOTO   43F
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0BDB:  MOVLW  02
0BDC:  BSF    03.5
0BDD:  MOVWF  26
0BDE:  MOVLW  FA
0BDF:  MOVWF  2D
0BE0:  BCF    0A.3
0BE1:  BCF    03.5
0BE2:  CALL   39F
0BE3:  BSF    0A.3
0BE4:  BSF    03.5
0BE5:  DECFSZ 26,F
0BE6:  GOTO   3DE
....................          BEEP; 
0BE7:  MOVLW  04
0BE8:  MOVWF  2A
0BE9:  MOVLW  B9
0BEA:  MOVWF  29
0BEB:  CLRF   2C
0BEC:  MOVLW  14
0BED:  MOVWF  2B
0BEE:  BCF    0A.3
0BEF:  BCF    03.5
0BF0:  CALL   6B1
0BF1:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0BF2:  BSF    03.5
0BF3:  INCF   24,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
0BF4:  MOVF   24,W
0BF5:  BCF    03.5
0BF6:  SUBWF  42,W
0BF7:  BTFSC  03.0
0BF8:  GOTO   3FC
....................             optSelected = 0; 
0BF9:  BSF    03.5
0BFA:  CLRF   24
0BFB:  BCF    03.5
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0BFC:  BSF    03.5
0BFD:  MOVF   24,W
0BFE:  MOVWF  29
0BFF:  MOVLW  0F
0C00:  MOVWF  2A
0C01:  BCF    03.5
0C02:  CALL   345
0C03:  MOVF   78,W
0C04:  BSF    03.5
0C05:  MOVWF  26
0C06:  MOVLW  0C
0C07:  MOVWF  2C
0C08:  BCF    0A.3
0C09:  BCF    03.5
0C0A:  CALL   5A8
0C0B:  BSF    0A.3
0C0C:  MOVLW  99
0C0D:  BSF    03.6
0C0E:  MOVWF  0D
0C0F:  MOVLW  00
0C10:  MOVWF  0F
0C11:  BSF    03.5
0C12:  BCF    03.6
0C13:  MOVF   26,W
0C14:  BCF    03.5
0C15:  BSF    03.6
0C16:  ADDWF  0D,F
0C17:  BTFSC  03.0
0C18:  INCF   0F,F
0C19:  BCF    0A.3
0C1A:  BCF    03.6
0C1B:  CALL   602
0C1C:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0C3F:  BSF    03.5
0C40:  BSF    06.5
0C41:  BCF    03.5
0C42:  BTFSC  06.5
0C43:  GOTO   47E
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0C44:  MOVLW  02
0C45:  BSF    03.5
0C46:  MOVWF  26
0C47:  MOVLW  FA
0C48:  MOVWF  2D
0C49:  BCF    0A.3
0C4A:  BCF    03.5
0C4B:  CALL   39F
0C4C:  BSF    0A.3
0C4D:  BSF    03.5
0C4E:  DECFSZ 26,F
0C4F:  GOTO   447
....................          BEEP; 
0C50:  MOVLW  04
0C51:  MOVWF  2A
0C52:  MOVLW  B9
0C53:  MOVWF  29
0C54:  CLRF   2C
0C55:  MOVLW  14
0C56:  MOVWF  2B
0C57:  BCF    0A.3
0C58:  BCF    03.5
0C59:  CALL   6B1
0C5A:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
0C5B:  MOVF   42,W
0C5C:  BSF    03.5
0C5D:  SUBWF  24,W
0C5E:  BTFSS  03.2
0C5F:  GOTO   463
....................             exit = 1; 
0C60:  MOVLW  01
0C61:  MOVWF  25
....................          }else{ 
0C62:  GOTO   47F
....................             output_high(PIN_OUT[optSelected]); 
0C63:  BCF    03.0
0C64:  RLF    24,W
0C65:  ADDLW  2B
0C66:  MOVWF  04
0C67:  BCF    03.7
0C68:  INCF   04,F
0C69:  MOVF   00,W
0C6A:  MOVWF  27
0C6B:  DECF   04,F
0C6C:  MOVF   00,W
0C6D:  MOVWF  26
0C6E:  MOVWF  28
0C6F:  MOVLW  01
0C70:  MOVWF  29
0C71:  CLRF   2B
0C72:  CLRF   2A
0C73:  BCF    03.5
0C74:  CALL   36C
0C75:  BSF    03.5
0C76:  MOVF   26,W
0C77:  MOVWF  28
0C78:  CLRF   29
0C79:  CLRF   2B
0C7A:  MOVLW  80
0C7B:  MOVWF  2A
0C7C:  BCF    03.5
0C7D:  CALL   36C
0C7E:  BSF    03.5
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0C7F:  GOTO   3D4
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0C80:  MOVLW  00
0C81:  MOVWF  78
0C82:  BCF    03.5
0C83:  BSF    0A.3
0C84:  BCF    0A.4
0C85:  GOTO   75E (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
0C86:  BSF    03.5
0C87:  CLRF   24
0C88:  CLRF   25
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0C89:  SWAPF  24,W
0C8A:  MOVWF  77
0C8B:  MOVLW  F0
0C8C:  ANDWF  77,F
0C8D:  MOVF   77,W
0C8E:  MOVWF  26
0C8F:  MOVLW  0C
0C90:  MOVWF  2C
0C91:  BCF    0A.3
0C92:  BCF    03.5
0C93:  CALL   5A8
0C94:  BSF    0A.3
0C95:  MOVLW  2F
0C96:  BSF    03.6
0C97:  MOVWF  0D
0C98:  MOVLW  01
0C99:  MOVWF  0F
0C9A:  BSF    03.5
0C9B:  BCF    03.6
0C9C:  MOVF   26,W
0C9D:  BCF    03.5
0C9E:  BSF    03.6
0C9F:  ADDWF  0D,F
0CA0:  BTFSC  03.0
0CA1:  INCF   0F,F
0CA2:  BCF    0A.3
0CA3:  BCF    03.6
0CA4:  CALL   602
0CA5:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0CC8:  BSF    03.5
0CC9:  MOVF   25,F
0CCA:  BTFSS  03.2
0CCB:  GOTO   571
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0CCC:  BSF    06.4
0CCD:  BCF    03.5
0CCE:  BTFSC  06.4
0CCF:  GOTO   531
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0CD0:  MOVLW  02
0CD1:  BSF    03.5
0CD2:  MOVWF  26
0CD3:  MOVLW  FA
0CD4:  MOVWF  2D
0CD5:  BCF    0A.3
0CD6:  BCF    03.5
0CD7:  CALL   39F
0CD8:  BSF    0A.3
0CD9:  BSF    03.5
0CDA:  DECFSZ 26,F
0CDB:  GOTO   4D3
....................          BEEP; 
0CDC:  MOVLW  04
0CDD:  MOVWF  2A
0CDE:  MOVLW  B9
0CDF:  MOVWF  29
0CE0:  CLRF   2C
0CE1:  MOVLW  14
0CE2:  MOVWF  2B
0CE3:  BCF    0A.3
0CE4:  BCF    03.5
0CE5:  CALL   6B1
0CE6:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0CE7:  BSF    03.5
0CE8:  INCF   24,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
0CE9:  MOVF   24,W
0CEA:  BCF    03.5
0CEB:  SUBWF  43,W
0CEC:  BTFSC  03.0
0CED:  GOTO   4F1
....................             optSelected = 0; 
0CEE:  BSF    03.5
0CEF:  CLRF   24
0CF0:  BCF    03.5
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0CF1:  BSF    03.5
0CF2:  SWAPF  24,W
0CF3:  MOVWF  77
0CF4:  MOVLW  F0
0CF5:  ANDWF  77,F
0CF6:  MOVF   77,W
0CF7:  MOVWF  26
0CF8:  MOVLW  0C
0CF9:  MOVWF  2C
0CFA:  BCF    0A.3
0CFB:  BCF    03.5
0CFC:  CALL   5A8
0CFD:  BSF    0A.3
0CFE:  MOVLW  2F
0CFF:  BSF    03.6
0D00:  MOVWF  0D
0D01:  MOVLW  01
0D02:  MOVWF  0F
0D03:  BSF    03.5
0D04:  BCF    03.6
0D05:  MOVF   26,W
0D06:  BCF    03.5
0D07:  BSF    03.6
0D08:  ADDWF  0D,F
0D09:  BTFSC  03.0
0D0A:  INCF   0F,F
0D0B:  BCF    0A.3
0D0C:  BCF    03.6
0D0D:  CALL   602
0D0E:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0D31:  BSF    03.5
0D32:  BSF    06.5
0D33:  BCF    03.5
0D34:  BTFSC  06.5
0D35:  GOTO   56F
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0D36:  MOVLW  02
0D37:  BSF    03.5
0D38:  MOVWF  26
0D39:  MOVLW  FA
0D3A:  MOVWF  2D
0D3B:  BCF    0A.3
0D3C:  BCF    03.5
0D3D:  CALL   39F
0D3E:  BSF    0A.3
0D3F:  BSF    03.5
0D40:  DECFSZ 26,F
0D41:  GOTO   539
....................          BEEP; 
0D42:  MOVLW  04
0D43:  MOVWF  2A
0D44:  MOVLW  B9
0D45:  MOVWF  29
0D46:  CLRF   2C
0D47:  MOVLW  14
0D48:  MOVWF  2B
0D49:  BCF    0A.3
0D4A:  BCF    03.5
0D4B:  CALL   6B1
0D4C:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
0D4D:  MOVF   43,W
0D4E:  BSF    03.5
0D4F:  SUBWF  24,W
0D50:  BTFSS  03.2
0D51:  GOTO   555
....................             exit = 1; 
0D52:  MOVLW  01
0D53:  MOVWF  25
....................          }else{ 
0D54:  GOTO   570
....................             output_low(PIN_OUT[optSelected]); 
0D55:  BCF    03.0
0D56:  RLF    24,W
0D57:  ADDLW  2B
0D58:  MOVWF  04
0D59:  BCF    03.7
0D5A:  INCF   04,F
0D5B:  MOVF   00,W
0D5C:  MOVWF  27
0D5D:  DECF   04,F
0D5E:  MOVF   00,W
0D5F:  MOVWF  26
0D60:  MOVWF  28
0D61:  CLRF   29
0D62:  CLRF   2B
0D63:  CLRF   2A
0D64:  BCF    03.5
0D65:  CALL   36C
0D66:  BSF    03.5
0D67:  MOVF   26,W
0D68:  MOVWF  28
0D69:  CLRF   29
0D6A:  CLRF   2B
0D6B:  MOVLW  80
0D6C:  MOVWF  2A
0D6D:  BCF    03.5
0D6E:  CALL   36C
0D6F:  BSF    03.5
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0D70:  GOTO   4C9
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0D71:  MOVLW  00
0D72:  MOVWF  78
0D73:  BCF    03.5
0D74:  BSF    0A.3
0D75:  BCF    0A.4
0D76:  GOTO   763 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
0D77:  BSF    03.5
0D78:  CLRF   24
0D79:  CLRF   25
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0D7A:  MOVF   24,W
0D7B:  MOVWF  29
0D7C:  MOVLW  11
0D7D:  MOVWF  2A
0D7E:  BCF    03.5
0D7F:  CALL   345
0D80:  MOVF   78,W
0D81:  BSF    03.5
0D82:  MOVWF  26
0D83:  MOVLW  0C
0D84:  MOVWF  2C
0D85:  BCF    0A.3
0D86:  BCF    03.5
0D87:  CALL   5A8
0D88:  BSF    0A.3
0D89:  MOVLW  CF
0D8A:  BSF    03.6
0D8B:  MOVWF  0D
0D8C:  MOVLW  01
0D8D:  MOVWF  0F
0D8E:  BSF    03.5
0D8F:  BCF    03.6
0D90:  MOVF   26,W
0D91:  BCF    03.5
0D92:  BSF    03.6
0D93:  ADDWF  0D,F
0D94:  BTFSC  03.0
0D95:  INCF   0F,F
0D96:  BCF    0A.3
0D97:  BCF    03.6
0D98:  CALL   602
0D99:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0DBC:  BSF    03.5
0DBD:  MOVF   25,F
0DBE:  BTFSS  03.2
0DBF:  GOTO   699
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0DC0:  BSF    06.4
0DC1:  BCF    03.5
0DC2:  BTFSC  06.4
0DC3:  GOTO   628
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0DC4:  MOVLW  02
0DC5:  BSF    03.5
0DC6:  MOVWF  26
0DC7:  MOVLW  FA
0DC8:  MOVWF  2D
0DC9:  BCF    0A.3
0DCA:  BCF    03.5
0DCB:  CALL   39F
0DCC:  BSF    0A.3
0DCD:  BSF    03.5
0DCE:  DECFSZ 26,F
0DCF:  GOTO   5C7
....................          BEEP; 
0DD0:  MOVLW  04
0DD1:  MOVWF  2A
0DD2:  MOVLW  B9
0DD3:  MOVWF  29
0DD4:  CLRF   2C
0DD5:  MOVLW  14
0DD6:  MOVWF  2B
0DD7:  BCF    0A.3
0DD8:  BCF    03.5
0DD9:  CALL   6B1
0DDA:  BSF    0A.3
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0DDB:  BSF    03.5
0DDC:  INCF   24,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
0DDD:  MOVF   24,W
0DDE:  BCF    03.5
0DDF:  SUBWF  44,W
0DE0:  BTFSC  03.0
0DE1:  GOTO   5E5
....................             optSelected = 0; 
0DE2:  BSF    03.5
0DE3:  CLRF   24
0DE4:  BCF    03.5
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0DE5:  BSF    03.5
0DE6:  MOVF   24,W
0DE7:  MOVWF  29
0DE8:  MOVLW  11
0DE9:  MOVWF  2A
0DEA:  BCF    03.5
0DEB:  CALL   345
0DEC:  MOVF   78,W
0DED:  BSF    03.5
0DEE:  MOVWF  26
0DEF:  MOVLW  0C
0DF0:  MOVWF  2C
0DF1:  BCF    0A.3
0DF2:  BCF    03.5
0DF3:  CALL   5A8
0DF4:  BSF    0A.3
0DF5:  MOVLW  CF
0DF6:  BSF    03.6
0DF7:  MOVWF  0D
0DF8:  MOVLW  01
0DF9:  MOVWF  0F
0DFA:  BSF    03.5
0DFB:  BCF    03.6
0DFC:  MOVF   26,W
0DFD:  BCF    03.5
0DFE:  BSF    03.6
0DFF:  ADDWF  0D,F
0E00:  BTFSC  03.0
0E01:  INCF   0F,F
0E02:  BCF    0A.3
0E03:  BCF    03.6
0E04:  CALL   602
0E05:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0E28:  BSF    03.5
0E29:  BSF    06.5
0E2A:  BCF    03.5
0E2B:  BTFSC  06.5
0E2C:  GOTO   697
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0E2D:  MOVLW  02
0E2E:  BSF    03.5
0E2F:  MOVWF  26
0E30:  MOVLW  FA
0E31:  MOVWF  2D
0E32:  BCF    0A.3
0E33:  BCF    03.5
0E34:  CALL   39F
0E35:  BSF    0A.3
0E36:  BSF    03.5
0E37:  DECFSZ 26,F
0E38:  GOTO   630
....................          BEEP; 
0E39:  MOVLW  04
0E3A:  MOVWF  2A
0E3B:  MOVLW  B9
0E3C:  MOVWF  29
0E3D:  CLRF   2C
0E3E:  MOVLW  14
0E3F:  MOVWF  2B
0E40:  BCF    0A.3
0E41:  BCF    03.5
0E42:  CALL   6B1
0E43:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
0E44:  MOVF   44,W
0E45:  BSF    03.5
0E46:  SUBWF  24,W
0E47:  BTFSS  03.2
0E48:  GOTO   64C
....................             exit = 1; 
0E49:  MOVLW  01
0E4A:  MOVWF  25
....................          }else{ 
0E4B:  GOTO   698
....................             executeSetup(optSelected); 
0E4C:  MOVF   24,W
0E4D:  MOVWF  26
0E4E:  BSF    0A.4
0E4F:  BCF    0A.3
0E50:  BCF    03.5
0E51:  GOTO   000
0E52:  BCF    0A.4
0E53:  BSF    0A.3
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0E54:  BSF    03.5
0E55:  MOVF   24,W
0E56:  MOVWF  29
0E57:  MOVLW  11
0E58:  MOVWF  2A
0E59:  BCF    03.5
0E5A:  CALL   345
0E5B:  MOVF   78,W
0E5C:  BSF    03.5
0E5D:  MOVWF  26
0E5E:  MOVLW  0C
0E5F:  MOVWF  2C
0E60:  BCF    0A.3
0E61:  BCF    03.5
0E62:  CALL   5A8
0E63:  BSF    0A.3
0E64:  MOVLW  CF
0E65:  BSF    03.6
0E66:  MOVWF  0D
0E67:  MOVLW  01
0E68:  MOVWF  0F
0E69:  BSF    03.5
0E6A:  BCF    03.6
0E6B:  MOVF   26,W
0E6C:  BCF    03.5
0E6D:  BSF    03.6
0E6E:  ADDWF  0D,F
0E6F:  BTFSC  03.0
0E70:  INCF   0F,F
0E71:  BCF    0A.3
0E72:  BCF    03.6
0E73:  CALL   602
0E74:  BSF    0A.3
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
0E98:  GOTO   5BD
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0E99:  MOVLW  00
0E9A:  MOVWF  78
0E9B:  BCF    03.5
0E9C:  BSF    0A.3
0E9D:  BCF    0A.4
0E9E:  GOTO   768 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................   switch(optSelect){ 
*
1000:  BSF    03.5
1001:  MOVF   26,W
1002:  ADDLW  FA
1003:  BTFSC  03.0
1004:  GOTO   2C1
1005:  ADDLW  06
1006:  BCF    03.5
1007:  GOTO   2C5
....................       
....................      case OPT_SHOW_IP: 
....................         printf(lcd_putc, "\f192.168.0.1"); 
1008:  MOVLW  98
1009:  BSF    03.6
100A:  MOVWF  0D
100B:  MOVLW  02
100C:  MOVWF  0F
100D:  BCF    0A.4
100E:  BCF    03.6
100F:  CALL   63D
1010:  BSF    0A.4
....................         pressExit(); 
....................         break; 
*
1048:  GOTO   2C1
....................      case OPT_SHOW_SSID: 
....................         printf(lcd_putc, "\fC0G3_UNE"); 
1049:  MOVLW  9F
104A:  BSF    03.6
104B:  MOVWF  0D
104C:  MOVLW  02
104D:  MOVWF  0F
104E:  BCF    0A.4
104F:  BCF    03.6
1050:  CALL   63D
1051:  BSF    0A.4
....................         pressExit();          
....................         break; 
*
1089:  GOTO   2C1
....................      case OPT_SHOW_KEY: 
....................         printf(lcd_putc, "\f1234Az!"); 
108A:  MOVLW  A4
108B:  BSF    03.6
108C:  MOVWF  0D
108D:  MOVLW  02
108E:  MOVWF  0F
108F:  BCF    0A.4
1090:  BCF    03.6
1091:  CALL   63D
1092:  BSF    0A.4
....................         pressExit(); 
....................         break; 
*
10CA:  GOTO   2C1
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
....................         break; 
*
126B:  GOTO   2C1
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
126C:  BSF    03.5
126D:  BCF    08.3
126E:  MOVLW  08
126F:  BCF    03.5
1270:  XORWF  08,F
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
1271:  BTFSS  08.3
1272:  GOTO   27D
....................            printf(lcd_putc, "\fBacklight On"); 
1273:  MOVLW  A9
1274:  BSF    03.6
1275:  MOVWF  0D
1276:  MOVLW  02
1277:  MOVWF  0F
1278:  BCF    0A.4
1279:  BCF    03.6
127A:  CALL   63D
127B:  BSF    0A.4
....................         }else{ 
127C:  GOTO   286
....................            printf(lcd_putc, "\fBacklight Off"); 
127D:  MOVLW  B0
127E:  BSF    03.6
127F:  MOVWF  0D
1280:  MOVLW  02
1281:  MOVWF  0F
1282:  BCF    0A.4
1283:  BCF    03.6
1284:  CALL   63D
1285:  BSF    0A.4
....................         } 
....................         pressExit(); 
....................         break; 
*
12BD:  GOTO   2C1
....................      case OPT_EXIT: 
....................         break; 
12BE:  BSF    03.5
12BF:  GOTO   2C1
12C0:  BSF    03.5
....................   } 
12C1:  BCF    03.5
12C2:  BSF    0A.3
12C3:  BCF    0A.4
12C4:  GOTO   652 (RETURN)
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
*
10CB:  BSF    03.5
10CC:  CLRF   27
10CD:  CLRF   28
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
10CE:  MOVF   27,W
10CF:  MOVWF  29
10D0:  MOVLW  0E
10D1:  MOVWF  2A
10D2:  BCF    0A.4
10D3:  BSF    0A.3
10D4:  BCF    03.5
10D5:  CALL   345
10D6:  BSF    0A.4
10D7:  BCF    0A.3
10D8:  MOVF   78,W
10D9:  BSF    03.5
10DA:  MOVWF  29
10DB:  MOVLW  0C
10DC:  MOVWF  2C
10DD:  BCF    0A.4
10DE:  BCF    03.5
10DF:  CALL   5A8
10E0:  BSF    0A.4
10E1:  MOVLW  46
10E2:  BSF    03.6
10E3:  MOVWF  0D
10E4:  MOVLW  02
10E5:  MOVWF  0F
10E6:  BSF    03.5
10E7:  BCF    03.6
10E8:  MOVF   29,W
10E9:  BCF    03.5
10EA:  BSF    03.6
10EB:  ADDWF  0D,F
10EC:  BTFSC  03.0
10ED:  INCF   0F,F
10EE:  BCF    0A.4
10EF:  BCF    03.6
10F0:  CALL   602
10F1:  BSF    0A.4
....................   showBottonMenu(); 
....................    
....................   while(!exit){ 
*
1114:  BSF    03.5
1115:  MOVF   28,F
1116:  BTFSS  03.2
1117:  GOTO   26B
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
1118:  BSF    06.4
1119:  BCF    03.5
111A:  BTFSC  06.4
111B:  GOTO   184
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
111C:  MOVLW  02
111D:  BSF    03.5
111E:  MOVWF  29
111F:  MOVLW  FA
1120:  MOVWF  2D
1121:  BCF    0A.4
1122:  BCF    03.5
1123:  CALL   39F
1124:  BSF    0A.4
1125:  BSF    03.5
1126:  DECFSZ 29,F
1127:  GOTO   11F
....................         BEEP; 
1128:  MOVLW  04
1129:  MOVWF  2A
112A:  MOVLW  B9
112B:  MOVWF  29
112C:  CLRF   2C
112D:  MOVLW  14
112E:  MOVWF  2B
112F:  BCF    0A.4
1130:  BCF    03.5
1131:  CALL   6B1
1132:  BSF    0A.4
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
1133:  BSF    03.5
1134:  INCF   27,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
1135:  MOVF   27,W
1136:  BCF    03.5
1137:  SUBWF  45,W
1138:  BTFSC  03.0
1139:  GOTO   13D
....................            optSelected = 0; 
113A:  BSF    03.5
113B:  CLRF   27
113C:  BCF    03.5
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
113D:  BSF    03.5
113E:  MOVF   27,W
113F:  MOVWF  29
1140:  MOVLW  0E
1141:  MOVWF  2A
1142:  BCF    0A.4
1143:  BSF    0A.3
1144:  BCF    03.5
1145:  CALL   345
1146:  BSF    0A.4
1147:  BCF    0A.3
1148:  MOVF   78,W
1149:  BSF    03.5
114A:  MOVWF  29
114B:  MOVLW  0C
114C:  MOVWF  2C
114D:  BCF    0A.4
114E:  BCF    03.5
114F:  CALL   5A8
1150:  BSF    0A.4
1151:  MOVLW  46
1152:  BSF    03.6
1153:  MOVWF  0D
1154:  MOVLW  02
1155:  MOVWF  0F
1156:  BSF    03.5
1157:  BCF    03.6
1158:  MOVF   29,W
1159:  BCF    03.5
115A:  BSF    03.6
115B:  ADDWF  0D,F
115C:  BTFSC  03.0
115D:  INCF   0F,F
115E:  BCF    0A.4
115F:  BCF    03.6
1160:  CALL   602
1161:  BSF    0A.4
....................         showBottonMenu(); 
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
*
1184:  BSF    03.5
1185:  BSF    06.5
1186:  BCF    03.5
1187:  BTFSC  06.5
1188:  GOTO   269
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
1189:  MOVLW  02
118A:  BSF    03.5
118B:  MOVWF  29
118C:  MOVLW  FA
118D:  MOVWF  2D
118E:  BCF    0A.4
118F:  BCF    03.5
1190:  CALL   39F
1191:  BSF    0A.4
1192:  BSF    03.5
1193:  DECFSZ 29,F
1194:  GOTO   18C
....................         BEEP; 
1195:  MOVLW  04
1196:  MOVWF  2A
1197:  MOVLW  B9
1198:  MOVWF  29
1199:  CLRF   2C
119A:  MOVLW  14
119B:  MOVWF  2B
119C:  BCF    0A.4
119D:  BCF    03.5
119E:  CALL   6B1
119F:  BSF    0A.4
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
11A0:  MOVF   45,W
11A1:  BSF    03.5
11A2:  SUBWF  27,W
11A3:  BTFSS  03.2
11A4:  GOTO   1A8
....................            exit = 1; 
11A5:  MOVLW  01
11A6:  MOVWF  28
....................         }else{ 
11A7:  GOTO   26A
....................            switch(optSelected){ 
11A8:  MOVF   27,W
11A9:  XORLW  00
11AA:  BCF    03.5
11AB:  BTFSC  03.2
11AC:  GOTO   1B4
11AD:  XORLW  01
11AE:  BTFSC  03.2
11AF:  GOTO   1C7
11B0:  XORLW  03
11B1:  BTFSC  03.2
11B2:  GOTO   1DA
11B3:  GOTO   1EC
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
11B4:  MOVLW  B8
11B5:  BSF    03.6
11B6:  MOVWF  0D
11B7:  MOVLW  02
11B8:  MOVWF  0F
11B9:  BCF    0A.4
11BA:  BCF    03.6
11BB:  CALL   532
11BC:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig Cliente"); 
11BD:  MOVLW  C1
11BE:  BSF    03.6
11BF:  MOVWF  0D
11C0:  MOVLW  02
11C1:  MOVWF  0F
11C2:  BCF    0A.4
11C3:  BCF    03.6
11C4:  CALL   63D
11C5:  BSF    0A.4
....................                  break; 
11C6:  GOTO   1EC
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
11C7:  MOVLW  C9
11C8:  BSF    03.6
11C9:  MOVWF  0D
11CA:  MOVLW  02
11CB:  MOVWF  0F
11CC:  BCF    0A.4
11CD:  BCF    03.6
11CE:  CALL   532
11CF:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig AP"); 
11D0:  MOVLW  D2
11D1:  BSF    03.6
11D2:  MOVWF  0D
11D3:  MOVLW  02
11D4:  MOVWF  0F
11D5:  BCF    0A.4
11D6:  BCF    03.6
11D7:  CALL   63D
11D8:  BSF    0A.4
....................                  break; 
11D9:  GOTO   1EC
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
11DA:  MOVLW  D8
11DB:  BSF    03.6
11DC:  MOVWF  0D
11DD:  MOVLW  02
11DE:  MOVWF  0F
11DF:  BCF    0A.4
11E0:  BCF    03.6
11E1:  CALL   532
11E2:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
11E3:  MOVLW  E1
11E4:  BSF    03.6
11E5:  MOVWF  0D
11E6:  MOVLW  02
11E7:  MOVWF  0F
11E8:  BCF    0A.4
11E9:  BCF    03.6
11EA:  CALL   63D
11EB:  BSF    0A.4
....................                  break; 
....................            } 
....................            pressExit(); 
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
*
1223:  MOVF   27,W
1224:  MOVWF  29
1225:  MOVLW  0E
1226:  MOVWF  2A
1227:  BCF    0A.4
1228:  BSF    0A.3
1229:  BCF    03.5
122A:  CALL   345
122B:  BSF    0A.4
122C:  BCF    0A.3
122D:  MOVF   78,W
122E:  BSF    03.5
122F:  MOVWF  29
1230:  MOVLW  0C
1231:  MOVWF  2C
1232:  BCF    0A.4
1233:  BCF    03.5
1234:  CALL   5A8
1235:  BSF    0A.4
1236:  MOVLW  46
1237:  BSF    03.6
1238:  MOVWF  0D
1239:  MOVLW  02
123A:  MOVWF  0F
123B:  BSF    03.5
123C:  BCF    03.6
123D:  MOVF   29,W
123E:  BCF    03.5
123F:  BSF    03.6
1240:  ADDWF  0D,F
1241:  BTFSC  03.0
1242:  INCF   0F,F
1243:  BCF    0A.4
1244:  BCF    03.6
1245:  CALL   602
1246:  BSF    0A.4
....................            showBottonMenu(); 
....................         } 
....................      } // Fin KEY_OK 
*
126A:  GOTO   115
....................   } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
.................... #include "header/esp8266.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... #define  CMD_MODE    1 
.................... #define  CMD_DO_CONN 2 
.................... #define  CMD_CONN    3 
....................  
.................... /* Constantes de Captura Respuestas */ 
.................... //const char ESP8266_RESP_START_STAIP[7]    ={'S','T','A','I','P',',','"'}; 
.................... //const char ESP8266_RESP_STOP_STAIP[3]     ={'"',0x0D,0x0A}; 
....................  
.................... /* Declaracion de Funciones de comandos */ 
.................... void reset(void); 
.................... int  setupMode(char modeVal[]); 
.................... int  doConnected(); 
.................... int  setupConn(char SSIDAndKey[]); 
.................... int  setupServer(void); 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void waitRespOK(int buffer); 
.................... void waitRespNoAp(int buffer); 
.................... void waitRespCWJAP(int buffer); 
.................... void waitRespConnected(int buffer); 
.................... void waitRespFail(int buffer); 
.................... int  waitResp(void); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int READY_RESP = 0x00; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... //int flag_Ready_Resp         = 0; 
.................... int flag_Resp_Valid         = 0; 
.................... int flag_Resp_NoAp          = 0; 
.................... int flag_Resp_CWJAP         = 0; 
.................... int flag_Resp_Connected     = 0; 
.................... int flag_Resp_Fail          = 0; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp           = 0; 
.................... int flag_Pos_Resp_NoAp      = 0; 
.................... int flag_Pos_Resp_CWJAP     = 0; 
.................... int flag_Pos_Resp_Connected = 0; 
.................... int flag_Pos_Resp_Fail      = 0; 
....................  
.................... /*@TODO: Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar[]  = "1"; 
*
0EFA:  MOVLW  31
0EFB:  MOVWF  52
0EFC:  CLRF   53
.................... char  SSIDAndKey[]= {'"','U','N','E','_','C','0','6','E','"', 
....................                      ',', 
....................                      '"','0','0','9','8','6','3','4','4','2','0','0','7','7','1','"', 
....................                      0x0D,0x0A 
....................                     }; 
0EFD:  MOVLW  22
0EFE:  MOVWF  54
0EFF:  MOVLW  55
0F00:  MOVWF  55
0F01:  MOVLW  4E
0F02:  MOVWF  56
0F03:  MOVLW  45
0F04:  MOVWF  57
0F05:  MOVLW  5F
0F06:  MOVWF  58
0F07:  MOVLW  43
0F08:  MOVWF  59
0F09:  MOVLW  30
0F0A:  MOVWF  5A
0F0B:  MOVLW  36
0F0C:  MOVWF  5B
0F0D:  MOVLW  45
0F0E:  MOVWF  5C
0F0F:  MOVLW  22
0F10:  MOVWF  5D
0F11:  MOVLW  2C
0F12:  MOVWF  5E
0F13:  MOVLW  22
0F14:  MOVWF  5F
0F15:  MOVLW  30
0F16:  MOVWF  60
0F17:  MOVWF  61
0F18:  MOVLW  39
0F19:  MOVWF  62
0F1A:  MOVLW  38
0F1B:  MOVWF  63
0F1C:  MOVLW  36
0F1D:  MOVWF  64
0F1E:  MOVLW  33
0F1F:  MOVWF  65
0F20:  MOVLW  34
0F21:  MOVWF  66
0F22:  MOVWF  67
0F23:  MOVLW  32
0F24:  MOVWF  68
0F25:  MOVLW  30
0F26:  MOVWF  69
0F27:  MOVWF  6A
0F28:  MOVLW  37
0F29:  MOVWF  6B
0F2A:  MOVWF  6C
0F2B:  MOVLW  31
0F2C:  MOVWF  6D
0F2D:  MOVLW  22
0F2E:  MOVWF  6E
0F2F:  MOVLW  0D
0F30:  MOVWF  6F
0F31:  MOVLW  0A
0F32:  MOVWF  70
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    char  modeWithoutConnect[] = "3"; 
*
0800:  MOVLW  33
0801:  BSF    03.5
0802:  MOVWF  24
0803:  CLRF   25
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    /**reset(); 
....................    delay_ms(2000);**/ 
....................  
....................    CMD_RUN =  setupMode(modeStar); 
0804:  CLRF   28
0805:  MOVLW  52
0806:  MOVWF  27
*
08B5:  MOVF   78,W
08B6:  MOVWF  46
....................    waitResp(); 
08B7:  BCF    0A.3
08B8:  CALL   4FF
08B9:  BSF    0A.3
....................  
....................    CMD_RUN =  doConnected(); 
*
08C5:  MOVF   78,W
08C6:  MOVWF  46
....................     
....................    resp = waitResp(); 
08C7:  BCF    0A.3
08C8:  CALL   4FF
08C9:  BSF    0A.3
08CA:  MOVF   78,W
08CB:  BSF    03.5
08CC:  MOVWF  26
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
08CD:  MOVF   26,W
08CE:  SUBLW  02
08CF:  BTFSS  03.2
08D0:  GOTO   23D
....................  
....................       // Lanza el comando para conectarce a la red 
....................       CMD_RUN = setupConn(SSIDAndKey); 
08D1:  CLRF   28
08D2:  MOVLW  54
08D3:  MOVWF  27
*
0979:  MOVF   78,W
097A:  BCF    03.5
097B:  MOVWF  46
....................       resp    = waitResp(); 
097C:  BCF    0A.3
097D:  CALL   4FF
097E:  BSF    0A.3
097F:  MOVF   78,W
0980:  BSF    03.5
0981:  MOVWF  26
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4){ 
0982:  MOVF   26,W
0983:  SUBLW  04
0984:  BTFSS  03.2
0985:  GOTO   23D
....................          CMD_RUN =  setupMode(modeWithoutConnect); 
0986:  CLRF   28
0987:  MOVLW  A4
0988:  MOVWF  27
*
0A37:  MOVF   78,W
0A38:  MOVWF  46
....................          waitResp(); 
0A39:  BCF    0A.3
0A3A:  CALL   4FF
0A3B:  BSF    0A.3
0A3C:  BSF    03.5
....................       } 
....................    } // Fin del if(doConnect) 
....................    
....................    /** @TODO: Rutina que se encarga de recibir datos desde ESP8266 **/ 
....................    setupServer(); 
....................    READY_RESP = 1; 
*
0A6B:  MOVLW  01
0A6C:  BCF    03.5
0A6D:  MOVWF  47
0A6E:  BSF    0A.3
0A6F:  BCF    0A.4
0A70:  GOTO   750 (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
....................             case CMD_MODE: 
....................                   waitRespOK(buffer); 
....................                   break; 
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespNoAp(buffer); 
....................                   waitRespCWJAP(buffer); 
....................                   waitRespOK(buffer); 
....................                   break; 
....................  
....................             case CMD_CONN: 
....................                   waitRespConnected(buffer); 
....................                   waitRespFail(buffer); 
....................                   waitRespOK(buffer); 
....................                   break; 
....................              
....................             default: 
....................                   CMD_RUN = 0x00; 
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /******************************************************** 
.................... Reinicia el modulo ESP8266 
.................... *********************************************************/ 
.................... void reset(void) 
.................... { 
....................    fprintf(ESP8266, "AT+RST\r\n"); 
.................... } // fin de la funcion reset() 
....................  
.................... /******************************************************** 
....................  *  Configura el modo de funcionamiento 
....................  *  1-Cliente, 2-AccessPoint, 3-AP+STA  
.................... *********************************************************/ 
.................... int setupMode(char modeVal[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWMODE=%s\r\n",modeVal ); 
*
0807:  MOVLW  EF
0808:  BCF    03.5
0809:  BSF    03.6
080A:  MOVWF  0D
080B:  MOVLW  02
080C:  MOVWF  0F
080D:  BCF    03.0
080E:  MOVLW  0A
080F:  BSF    03.5
0810:  BCF    03.6
0811:  MOVWF  29
*
088A:  MOVF   27,W
088B:  MOVWF  04
088C:  BCF    03.7
088D:  BTFSC  28.0
088E:  BSF    03.7
*
08AA:  MOVLW  0D
08AB:  BCF    03.5
08AC:  BTFSS  0C.4
08AD:  GOTO   0AC
08AE:  MOVWF  19
08AF:  MOVLW  0A
08B0:  BTFSS  0C.4
08B1:  GOTO   0B0
08B2:  MOVWF  19
*
0989:  MOVLW  EF
098A:  BCF    03.5
098B:  BSF    03.6
098C:  MOVWF  0D
098D:  MOVLW  02
098E:  MOVWF  0F
098F:  BCF    03.0
0990:  MOVLW  0A
0991:  BSF    03.5
0992:  BCF    03.6
0993:  MOVWF  29
*
0A0C:  MOVF   27,W
0A0D:  MOVWF  04
0A0E:  BCF    03.7
0A0F:  BTFSC  28.0
0A10:  BSF    03.7
*
0A2C:  MOVLW  0D
0A2D:  BCF    03.5
0A2E:  BTFSS  0C.4
0A2F:  GOTO   22E
0A30:  MOVWF  19
0A31:  MOVLW  0A
0A32:  BTFSS  0C.4
0A33:  GOTO   232
0A34:  MOVWF  19
....................    return CMD_MODE; 
*
08B3:  MOVLW  01
08B4:  MOVWF  78
*
0A35:  MOVLW  01
0A36:  MOVWF  78
.................... } // fin de la funcion setupMode() 
....................  
.................... /******************************************************** 
....................  *  lanza el comando para verificar el estado de la 
....................  *  conexion a la red wifi  
.................... *********************************************************/ 
.................... int doConnected() 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
*
08BA:  MOVLW  F7
08BB:  BSF    03.6
08BC:  MOVWF  0D
08BD:  MOVLW  02
08BE:  MOVWF  0F
08BF:  BCF    0A.3
08C0:  BCF    03.6
08C1:  CALL   532
08C2:  BSF    0A.3
....................    return CMD_DO_CONN; 
08C3:  MOVLW  02
08C4:  MOVWF  78
.................... } 
....................  
.................... /******************************************************** 
....................  *  Conecta a la red wifi 
....................  *  AT+CWJAP="UNE_C06E","00986344200771" 
.................... *********************************************************/ 
.................... int setupConn(char SSID_And_Key[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP=%s",SSID_And_Key ); 
*
08D4:  MOVLW  FD
08D5:  BCF    03.5
08D6:  BSF    03.6
08D7:  MOVWF  0D
08D8:  MOVLW  02
08D9:  MOVWF  0F
08DA:  BCF    03.0
08DB:  MOVLW  09
08DC:  BSF    03.5
08DD:  BCF    03.6
08DE:  MOVWF  29
*
0957:  MOVF   27,W
0958:  MOVWF  04
0959:  BCF    03.7
095A:  BTFSC  28.0
095B:  BSF    03.7
....................    return CMD_CONN; 
*
0977:  MOVLW  03
0978:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /******************************************************** 
....................  * Activa el modo multiconexion y modo servidor por el_ 
....................  * Puerto IP:80 
.................... *********************************************************/ 
.................... int setupServer(void) 
.................... { 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
*
0A3D:  MOVLW  03
0A3E:  BCF    03.5
0A3F:  BSF    03.6
0A40:  MOVWF  0D
0A41:  MOVLW  03
0A42:  MOVWF  0F
0A43:  BCF    0A.3
0A44:  BCF    03.6
0A45:  CALL   532
0A46:  BSF    0A.3
....................    delay_ms(1000); 
0A47:  MOVLW  04
0A48:  BSF    03.5
0A49:  MOVWF  27
0A4A:  MOVLW  FA
0A4B:  MOVWF  2D
0A4C:  BCF    0A.3
0A4D:  BCF    03.5
0A4E:  CALL   39F
0A4F:  BSF    0A.3
0A50:  BSF    03.5
0A51:  DECFSZ 27,F
0A52:  GOTO   24A
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
0A53:  MOVLW  0A
0A54:  BCF    03.5
0A55:  BSF    03.6
0A56:  MOVWF  0D
0A57:  MOVLW  03
0A58:  MOVWF  0F
0A59:  BCF    0A.3
0A5A:  BCF    03.6
0A5B:  CALL   532
0A5C:  BSF    0A.3
....................    delay_ms(1000); 
0A5D:  MOVLW  04
0A5E:  BSF    03.5
0A5F:  MOVWF  27
0A60:  MOVLW  FA
0A61:  MOVWF  2D
0A62:  BCF    0A.3
0A63:  BCF    03.5
0A64:  CALL   39F
0A65:  BSF    0A.3
0A66:  BSF    03.5
0A67:  DECFSZ 27,F
0A68:  GOTO   260
....................    return CMD_CONN; 
0A69:  MOVLW  03
0A6A:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
04FF:  BSF    03.5
0500:  CLRF   27
.................... { 
....................    int ret=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(flag_Resp_Valid==0){ 
0501:  BCF    03.5
0502:  MOVF   48,F
0503:  BTFSS  03.2
0504:  GOTO   52B
....................     
....................       if(flag_Resp_CWJAP==1){ 
0505:  DECFSZ 4A,W
0506:  GOTO   50E
....................       // Comando doConnected Conectado a la red 
....................          flag_Pos_Resp_CWJAP  = 0; 
0507:  CLRF   4F
....................          flag_Resp_CWJAP      = 0; 
0508:  CLRF   4A
....................          ret = 1; 
0509:  MOVLW  01
050A:  BSF    03.5
050B:  MOVWF  27
....................  
....................       } else if(flag_Resp_NoAp==1){ 
050C:  GOTO   529
050D:  BCF    03.5
050E:  DECFSZ 49,W
050F:  GOTO   517
....................       // Comando doConnected No se ha asignado una red 
....................          flag_Pos_Resp_NoAp  = 0; 
0510:  CLRF   4E
....................          flag_Resp_NoAp      = 0; 
0511:  CLRF   49
....................          ret = 2; 
0512:  MOVLW  02
0513:  BSF    03.5
0514:  MOVWF  27
....................  
....................       } else if (flag_Resp_Connected==1){ 
0515:  GOTO   529
0516:  BCF    03.5
0517:  DECFSZ 4B,W
0518:  GOTO   520
....................       // Comando setupConn Conexion establecida 
....................          flag_Pos_Resp_Connected = 0; 
0519:  CLRF   50
....................          flag_Resp_Connected     = 0; 
051A:  CLRF   4B
....................          ret = 3; 
051B:  MOVLW  03
051C:  BSF    03.5
051D:  MOVWF  27
....................  
....................       } else if(flag_Resp_Fail==1){ 
051E:  GOTO   529
051F:  BCF    03.5
0520:  DECFSZ 4C,W
0521:  GOTO   52A
....................       // Comando setupConn Fallo al intentar la Conexion 
....................       // Esta respuesta da como resultado un ERROR entonces 
....................       // Se rompe el ciclo de forma manual flag_Resp_Valid=1 
....................          flag_Pos_Resp_Fail   = 0; 
0522:  CLRF   51
....................          flag_Resp_Fail       = 0; 
0523:  CLRF   4C
....................          flag_Resp_Valid      = 1; 
0524:  MOVLW  01
0525:  MOVWF  48
....................          ret = 4; 
0526:  MOVLW  04
0527:  BSF    03.5
0528:  MOVWF  27
0529:  BCF    03.5
....................       } 
052A:  GOTO   502
....................    }; // Fin del loop 
....................    flag_Resp_Valid = 0; 
052B:  CLRF   48
....................    CMD_RUN = 0x00; 
052C:  CLRF   46
....................    return ret; 
052D:  BSF    03.5
052E:  MOVF   27,W
052F:  MOVWF  78
0530:  BCF    03.5
0531:  RETURN
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
....................  
.................... void waitRespOK(int buffer) 
.................... { 
....................    const char ESP8266_RESP_OK[4] ={'O','K',0x0D,0x0A}; 
....................    int lenResp = 4; 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_OK[flag_Pos_Resp]) 
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp++; 
....................        
....................       if(flag_Pos_Resp==lenResp){ 
....................          // Respuesta es valida 
....................          flag_Resp_Valid   = 1; 
....................       }else{ 
....................          // Reinicia la bandera para asegurar la integridad de la respesta 
....................          flag_Resp_Valid   = 0; 
....................       } 
....................  
....................    }else{ 
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       flag_Pos_Resp     = 0; 
....................       // Como esta funcion es el ultimo caracter recibido no es necesario mantener  
....................       // Activa la bandera flag_Resp_Valid 
....................       flag_Resp_Valid   = 0; 
....................    } 
.................... } // Fin de la funcion waitRespOK() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_NoAp (Sin conexion) 
.................... *********************************************************/ 
.................... void waitRespNoAp(int buffer) 
.................... { 
....................    const char ESP8266_RESP_NoAP[5] ={'N', 'o', ' ', 'A', 'P'}; 
....................    int lenResp = 5; 
....................     
....................    if(buffer == ESP8266_RESP_NoAp[flag_Pos_Resp_NoAp] ) 
....................    { 
....................       flag_Pos_Resp_NoAp++; 
....................        
....................       if(flag_Pos_Resp_NoAp==lenResp){ 
....................          // Respuesta es valida 
....................          flag_Resp_NoAp   = 1; 
....................       } 
....................    }else{ 
....................       // Reinicia el contador 
....................       flag_Pos_Resp_NoAp  = 0; 
....................    } 
.................... } // Fin de la funcion waitRespNoAp() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_CWJAP (Conectado) 
.................... *********************************************************/ 
.................... void waitRespCWJAP(int buffer) 
.................... { 
....................    const char ESP8266_RESP_CWJAP[7] ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
....................    int lenResp = 7; 
....................  
....................    if(buffer == ESP8266_RESP_CWJAP[flag_Pos_Resp_CWJAP] ) 
....................    { 
....................       flag_Pos_Resp_CWJAP++; 
....................        
....................       if(flag_Pos_Resp_CWJAP==lenResp){ 
....................          // Respuesta es valida 
....................          flag_Resp_CWJAP   = 1; 
....................       } 
....................    }else { 
....................       // Reinicia el contador 
....................       flag_Pos_Resp_CWJAP = 0; 
....................    } 
....................     
.................... } // Fin de la funcion waitRespCWJAP() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "setupConn" 
....................  *    ESP8266_RESP_Connected (Conectado) 
.................... *********************************************************/ 
.................... void waitRespConnected(int buffer) 
.................... { 
....................    const char ESP8266_RESP_Connected[9] ={'C','O','N','N','E','C','T','E','D'}; 
....................    int lenResp = 9; 
....................   
....................    if(buffer == ESP8266_RESP_Connected[flag_Pos_Resp_Connected] ) 
....................    { 
....................       flag_Pos_Resp_Connected++; 
....................        
....................       if(flag_Pos_Resp_Connected==lenResp){ 
....................          // Respuesta es valida 
....................          flag_Resp_Connected   = 1; 
....................       } 
....................    }else{ 
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Connected = 0; 
....................    } 
.................... } // Fin de la funcion waitRespConnected() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "setupConn" 
....................  *    ESP8266_RESP_FAIL (Fallo al intentar conectarse) 
.................... *********************************************************/ 
.................... void waitRespFail(int buffer) 
.................... { 
....................    const char ESP8266_RESP_FAIL[4] ={'F', 'A', 'I', 'L'}; 
....................    int lenResp = 4; 
....................   
....................    if(buffer == ESP8266_RESP_FAIL[flag_Pos_Resp_Fail] ) 
....................    { 
....................       flag_Pos_Resp_Fail++; 
....................        
....................       if(flag_Pos_Resp_Fail==lenResp){ 
....................          // Respuesta es valida 
....................          flag_Resp_Fail   = 1; 
....................       } 
....................    }else{ 
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Fail  = 0; 
....................    } 
.................... } // Fin de la funcion waitRespFail() 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... /******************************************\ 
.................... *   Formato de comando en la respuesta:    * 
.................... *   INICIO:COMANDO:DATOS:<-(FIN)           * 
.................... *   e.g. CMD:CMD_SSID_AND_PASS:DATA:       * 
.................... \******************************************/ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[]; 
.................... char  COMMAND[5]; 
.................... char  DATA_COMMAND[]; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio recepcion de request,  
.................... y retorna el ID de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
....................        
....................       if(buffer!=','){ 
....................           
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
....................          flag_Pos_Resp_IPD++; 
....................                    
....................       }else{ 
....................          flag_Pos_Resp_IPD       = 0x00; 
....................          flag_Resp_IPD           = 0x00; 
....................       } 
....................    }else{ 
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
....................       { 
....................          flag_Pos_Resp_IPD++; 
....................          if(flag_Pos_Resp_IPD==lenResp){ 
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
....................             flag_Pos_Resp_IPD = 0; 
....................          } 
....................       }else{ 
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio comando,  
.................... y retorna el Comando enviado, Activa la bandera 
.................... de recepcion de datos 
.................... *********************************************************/ 
....................  
.................... void ESP8266_Get_CMD(char buffer[]){ 
*
0328:  MOVLW  04
0329:  MOVWF  47
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
032A:  DECFSZ 7C,W
032B:  GOTO   385
....................        
....................       switch(buffer){ 
032C:  MOVF   45,W
032D:  MOVWF  77
032E:  MOVF   46,W
032F:  MOVWF  7A
0330:  MOVF   7A,W
0331:  BTFSS  03.2
0332:  GOTO   339
0333:  MOVLW  40
0334:  SUBWF  77,W
0335:  BCF    03.5
0336:  BTFSC  03.2
0337:  GOTO   33A
0338:  BSF    03.5
0339:  GOTO   37D
....................          case '@': 
....................             flag_Pos_Resp_CMD = 0x00; 
033A:  BSF    03.5
033B:  CLRF   20
....................             flag_Resp_CMD     = 0x00; 
033C:  CLRF   7C
....................             fprintf(console,"%s",COMMAND); 
033D:  MOVLW  72
033E:  MOVWF  04
033F:  BCF    03.7
....................             // Activa la recepcion de datos del comando 
....................             flag_Resp_StartGetData  = 1; 
*
037A:  MOVLW  01
037B:  MOVWF  7E
....................             break; 
037C:  GOTO   384
....................          default: 
....................             COMMAND[flag_Pos_Resp_CMD] = buffer; 
037D:  MOVLW  72
037E:  ADDWF  20,W
037F:  MOVWF  04
0380:  BCF    03.7
0381:  MOVF   45,W
0382:  MOVWF  00
....................             flag_Pos_Resp_CMD++; 
0383:  INCF   20,F
....................             break; 
....................       } 
....................             
....................    }else{ 
0384:  GOTO   39A
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
0385:  MOVF   20,W
0386:  BCF    03.5
0387:  CALL   051
0388:  MOVWF  78
0389:  BSF    03.5
038A:  SUBWF  45,W
038B:  BTFSS  03.2
038C:  GOTO   399
038D:  MOVF   46,F
038E:  BTFSS  03.2
038F:  GOTO   399
....................       { 
....................          flag_Pos_Resp_CMD++; 
0390:  INCF   20,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
0391:  MOVF   47,W
0392:  SUBWF  20,W
0393:  BTFSS  03.2
0394:  GOTO   398
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
0395:  MOVLW  01
0396:  MOVWF  7C
....................             flag_Pos_Resp_CMD = 0; 
0397:  CLRF   20
....................          } 
....................       }else{ 
0398:  GOTO   39A
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
0399:  CLRF   20
039A:  BCF    03.5
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion Verifica si la bandera de recepcion de datos esta 
.................... activa y almacena los datos entrantes en el arreglo 
.................... DATA_COMMAND, Finaliza la captura de caracteres cuando 
.................... encuentra el caracter ":". 
.................... Envia al ESP8266 el fin de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
....................       if(buffer!=':'){ 
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
....................          flag_Pos_Resp_Data++; 
....................       }else{ 
....................          fprintf(console,"Comando: %s \n",DATA_COMMAND); 
....................          flag_Pos_Resp_Data      = 0x00; 
....................          flag_Resp_StartGetData  = 0x00; 
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
.................... } 
....................  
.................... /******************************************** 
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
031B:  BTFSS  0C.5
031C:  GOTO   31B
031D:  MOVF   1A,W
031E:  BSF    03.5
031F:  MOVWF  44
.................... { 
....................    int buffer = getc(); 
....................    if(READY_RESP==0){ 
0320:  BCF    03.5
0321:  MOVF   47,F
0322:  BTFSC  03.2
....................       //ESP8266_PROCCESS_RESPONSE(buffer); 
....................    }else{ 
0323:  GOTO   39B
....................       //ESP8266_Get_IPD(buffer); 
....................       ESP8266_Get_CMD(buffer); 
0324:  BSF    03.5
0325:  CLRF   46
0326:  MOVF   44,W
0327:  MOVWF  45
....................       //ESP8266_Get_Data(buffer); 
....................    } 
*
039B:  BCF    0C.5
039C:  BCF    0A.3
039D:  BCF    0A.4
039E:  GOTO   02D
.................... } 
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
*
0E9F:  MOVF   03,W
0EA0:  ANDLW  1F
0EA1:  MOVWF  03
0EA2:  BSF    03.5
0EA3:  BSF    03.6
0EA4:  BSF    07.3
0EA5:  MOVLW  08
0EA6:  BCF    03.6
0EA7:  MOVWF  19
0EA8:  MOVLW  02
0EA9:  MOVWF  1A
0EAA:  MOVLW  A6
0EAB:  MOVWF  18
0EAC:  MOVLW  90
0EAD:  BCF    03.5
0EAE:  MOVWF  18
0EAF:  BSF    03.5
0EB0:  BCF    06.0
0EB1:  BCF    03.5
0EB2:  BSF    06.0
0EB3:  MOVLW  02
0EB4:  MOVWF  41
0EB5:  MOVLW  08
0EB6:  MOVWF  42
0EB7:  MOVWF  43
0EB8:  MOVLW  05
0EB9:  MOVWF  44
0EBA:  MOVLW  03
0EBB:  MOVWF  45
0EBC:  CLRF   46
0EBD:  CLRF   47
0EBE:  CLRF   48
0EBF:  CLRF   49
0EC0:  CLRF   4A
0EC1:  CLRF   4B
0EC2:  CLRF   4C
0EC3:  CLRF   4D
0EC4:  CLRF   4E
0EC5:  CLRF   4F
0EC6:  CLRF   50
0EC7:  CLRF   51
0EC8:  CLRF   7C
0EC9:  CLRF   7D
0ECA:  CLRF   7E
0ECB:  BSF    03.5
0ECC:  CLRF   20
0ECD:  CLRF   21
0ECE:  CLRF   22
0ECF:  CLRF   23
0ED0:  BSF    03.6
0ED1:  MOVF   09,W
0ED2:  ANDLW  C0
0ED3:  MOVWF  09
0ED4:  BCF    03.6
0ED5:  BCF    1F.4
0ED6:  BCF    1F.5
0ED7:  MOVLW  00
0ED8:  BSF    03.6
0ED9:  MOVWF  08
0EDA:  BCF    03.5
0EDB:  CLRF   07
0EDC:  CLRF   08
0EDD:  CLRF   09
0EDE:  BCF    03.7
....................    { 
....................        
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
*
0F33:  MOVLW  02
0F34:  BSF    03.5
0F35:  MOVWF  24
0F36:  MOVLW  FA
0F37:  MOVWF  2D
0F38:  BCF    0A.3
0F39:  BCF    03.5
0F3A:  CALL   39F
0F3B:  BSF    0A.3
0F3C:  BSF    03.5
0F3D:  DECFSZ 24,F
0F3E:  GOTO   736
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
0F3F:  MOVLW  30
0F40:  MOVWF  15
0F41:  BCF    01.7
....................       set_tris_b(0b00110010); 
0F42:  MOVLW  32
0F43:  MOVWF  06
....................       enable_interrupts(INT_RDA);  
0F44:  BSF    0C.5
....................       enable_interrupts(GLOBAL);  
0F45:  MOVLW  C0
0F46:  BCF    03.5
0F47:  IORWF  0B,F
....................  
....................       // Inicializa la LCD 
....................       lcd_init(); 
0F48:  BCF    0A.3
0F49:  GOTO   4AB
0F4A:  BSF    0A.3
....................        
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
0F4B:  BSF    03.5
0F4C:  BCF    08.3
0F4D:  BCF    03.5
0F4E:  BSF    08.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
0F4F:  GOTO   000
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
0F50:  BSF    03.5
0F51:  MOVF   23,W
0F52:  ADDLW  FC
0F53:  BTFSC  03.0
0F54:  GOTO   76D
0F55:  ADDLW  04
0F56:  BCF    03.5
0F57:  GOTO   76F
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
0F58:  GOTO   271
0F59:  MOVF   78,W
0F5A:  BSF    03.5
0F5B:  MOVWF  23
....................                break; 
0F5C:  GOTO   76D
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
0F5D:  GOTO   38E
0F5E:  MOVF   78,W
0F5F:  BSF    03.5
0F60:  MOVWF  23
....................                break; 
0F61:  GOTO   76D
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
0F62:  GOTO   486
0F63:  MOVF   78,W
0F64:  BSF    03.5
0F65:  MOVWF  23
....................                break; 
0F66:  GOTO   76D
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
0F67:  GOTO   577
0F68:  MOVF   78,W
0F69:  BSF    03.5
0F6A:  MOVWF  23
....................                break; 
0F6B:  GOTO   76D
0F6C:  BSF    03.5
....................          } // Fin del Switch(menuActive) 
0F6D:  GOTO   751
....................           
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
0F6E:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
