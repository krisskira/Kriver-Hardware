CCS PCM C Compiler, Version 5.015, 5967               10-dic.-17 16:03

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   5737 words (70%)
                           Largest free fragment is 2048
               RAM used:   173 (47%) at main() level
                           210 (57%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  16
0001:  MOVWF  0A
0002:  GOTO   671
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   3B3
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  4F
0056:  RETLW  4B
0057:  RETLW  0D
0058:  RETLW  0A
0059:  BCF    0A.0
005A:  BCF    0A.1
005B:  BCF    0A.2
005C:  ADDWF  02,F
005D:  RETLW  4E
005E:  RETLW  6F
005F:  RETLW  20
0060:  RETLW  41
0061:  RETLW  50
0062:  BCF    0A.0
0063:  BCF    0A.1
0064:  BCF    0A.2
0065:  ADDWF  02,F
0066:  RETLW  2B
0067:  RETLW  43
0068:  RETLW  57
0069:  RETLW  4A
006A:  RETLW  41
006B:  RETLW  50
006C:  RETLW  3A
006D:  BCF    0A.0
006E:  BCF    0A.1
006F:  BCF    0A.2
0070:  ADDWF  02,F
0071:  RETLW  43
0072:  RETLW  4F
0073:  RETLW  4E
0074:  RETLW  4E
0075:  RETLW  45
0076:  RETLW  43
0077:  RETLW  54
0078:  RETLW  45
0079:  RETLW  44
007A:  BCF    0A.0
007B:  BCF    0A.1
007C:  BCF    0A.2
007D:  ADDWF  02,F
007E:  RETLW  46
007F:  RETLW  41
0080:  RETLW  49
0081:  RETLW  4C
0082:  BCF    0A.0
0083:  BCF    0A.1
0084:  BCF    0A.2
0085:  ADDWF  02,F
0086:  RETLW  45
0087:  RETLW  52
0088:  RETLW  52
0089:  RETLW  4F
008A:  RETLW  52
008B:  BCF    0A.0
008C:  BCF    0A.1
008D:  BCF    0A.2
008E:  ADDWF  02,F
008F:  RETLW  2B
0090:  RETLW  49
0091:  RETLW  50
0092:  RETLW  44
0093:  RETLW  2C
0094:  BCF    0A.0
0095:  BCF    0A.1
0096:  BCF    0A.2
0097:  ADDWF  02,F
0098:  RETLW  43
0099:  RETLW  4D
009A:  RETLW  44
009B:  RETLW  3A
009C:  DATA 41,2A
009D:  DATA 2B,29
009E:  DATA 53,2A
009F:  DATA 0D,05
00A0:  DATA 00,00
00A1:  DATA 41,2A
00A2:  DATA AB,21
00A3:  DATA D7,26
00A4:  DATA 4F,22
00A5:  DATA C5,1E
00A6:  DATA A5,31
00A7:  DATA 0D,05
00A8:  DATA 00,00
00A9:  DATA 41,2A
00AA:  DATA AB,21
00AB:  DATA 57,25
00AC:  DATA 41,28
00AD:  DATA BF,06
00AE:  DATA 0A,00
00AF:  DATA 41,2A
00B0:  DATA AB,21
00B1:  DATA 57,25
00B2:  DATA 41,28
00B3:  DATA BD,12
00B4:  DATA 73,00
00B5:  DATA 41,2A
00B6:  DATA AB,21
00B7:  DATA 49,28
00B8:  DATA CD,2A
00B9:  DATA D8,1E
00BA:  DATA B1,06
00BB:  DATA 0A,00
00BC:  DATA 41,2A
00BD:  DATA AB,21
00BE:  DATA 49,28
00BF:  DATA D3,22
00C0:  DATA 52,2B
00C1:  DATA 45,29
00C2:  DATA BD,18
00C3:  DATA 2C,1C
00C4:  DATA B0,06
00C5:  DATA 0A,00
00C6:  DATA 41,2A
00C7:  DATA AB,21
00C8:  DATA 49,28
00C9:  DATA D3,22
00CA:  DATA 4E,22
00CB:  DATA BD,12
00CC:  DATA 63,16
00CD:  DATA 31,19
00CE:  DATA 0D,05
00CF:  DATA 00,01
00D0:  DATA 41,2A
00D1:  DATA AB,21
00D2:  DATA 49,28
00D3:  DATA 43,26
00D4:  DATA CF,29
00D5:  DATA C5,1E
00D6:  DATA A5,31
00D7:  DATA 0D,05
00D8:  DATA 00,01
00D9:  DATA 41,2A
00DA:  DATA AB,21
00DB:  DATA D7,28
00DC:  DATA 41,28
00DD:  DATA 8A,06
00DE:  DATA 00,01
00DF:  DATA 41,2A
00E0:  DATA AB,21
00E1:  DATA 49,28
00E2:  DATA D3,22
00E3:  DATA 4E,22
00E4:  DATA BD,12
00E5:  DATA 63,16
00E6:  DATA 31,19
00E7:  DATA 0D,05
00E8:  DATA 00,01
00E9:  DATA 41,2A
00EA:  DATA AB,21
00EB:  DATA 49,28
00EC:  DATA 43,26
00ED:  DATA CF,29
00EE:  DATA C5,1E
00EF:  DATA A5,31
00F0:  DATA 0D,05
00F1:  DATA 00,01
00F2:  DATA 41,2A
00F3:  DATA AB,21
00F4:  DATA 49,28
00F5:  DATA D3,22
00F6:  DATA 4E,22
00F7:  DATA BD,12
00F8:  DATA 63,16
00F9:  DATA 31,19
00FA:  DATA 0D,05
00FB:  DATA 00,01
00FC:  DATA 41,2A
00FD:  DATA AB,21
00FE:  DATA 49,28
00FF:  DATA 43,26
0100:  DATA CF,29
0101:  DATA C5,1E
0102:  DATA A5,31
0103:  DATA 0D,05
0104:  DATA 00,00
0105:  RETLW  45
0106:  RETLW  6E
0107:  RETLW  63
0108:  RETLW  65
0109:  RETLW  6E
010A:  RETLW  64
010B:  RETLW  65
010C:  RETLW  72
010D:  RETLW  20
010E:  RETLW  4D
010F:  RETLW  61
0110:  RETLW  6E
0111:  RETLW  75
0112:  RETLW  61
0113:  RETLW  6C
0114:  RETLW  00
0115:  RETLW  41
0116:  RETLW  70
0117:  RETLW  61
0118:  RETLW  67
0119:  RETLW  61
011A:  RETLW  64
011B:  RETLW  6F
011C:  RETLW  20
011D:  RETLW  4D
011E:  RETLW  61
011F:  RETLW  6E
0120:  RETLW  75
0121:  RETLW  61
0122:  RETLW  6C
0123:  RETLW  20
0124:  RETLW  00
0125:  RETLW  43
0126:  RETLW  6F
0127:  RETLW  6E
0128:  RETLW  66
0129:  RETLW  69
012A:  RETLW  67
012B:  RETLW  75
012C:  RETLW  72
012D:  RETLW  61
012E:  RETLW  63
012F:  RETLW  69
0130:  RETLW  6F
0131:  RETLW  6E
0132:  RETLW  20
0133:  RETLW  20
0134:  RETLW  00
0135:  RETLW  00
0136:  RETLW  00
0137:  RETLW  00
0138:  RETLW  00
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  00
013C:  RETLW  00
013D:  RETLW  00
013E:  RETLW  00
013F:  RETLW  00
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  00
0143:  RETLW  00
0144:  RETLW  00
0145:  RETLW  4F
0146:  RETLW  6E
0147:  RETLW  20
0148:  RETLW  2D
0149:  RETLW  3E
014A:  RETLW  20
014B:  RETLW  53
014C:  RETLW  61
014D:  RETLW  6C
014E:  RETLW  69
014F:  RETLW  64
0150:  RETLW  61
0151:  RETLW  20
0152:  RETLW  31
0153:  RETLW  00
0154:  RETLW  4F
0155:  RETLW  6E
0156:  RETLW  20
0157:  RETLW  2D
0158:  RETLW  3E
0159:  RETLW  20
015A:  RETLW  53
015B:  RETLW  61
015C:  RETLW  6C
015D:  RETLW  69
015E:  RETLW  64
015F:  RETLW  61
0160:  RETLW  20
0161:  RETLW  32
0162:  RETLW  00
0163:  RETLW  4F
0164:  RETLW  6E
0165:  RETLW  20
0166:  RETLW  2D
0167:  RETLW  3E
0168:  RETLW  20
0169:  RETLW  53
016A:  RETLW  61
016B:  RETLW  6C
016C:  RETLW  69
016D:  RETLW  64
016E:  RETLW  61
016F:  RETLW  20
0170:  RETLW  33
0171:  RETLW  00
0172:  RETLW  4F
0173:  RETLW  6E
0174:  RETLW  20
0175:  RETLW  2D
0176:  RETLW  3E
0177:  RETLW  20
0178:  RETLW  53
0179:  RETLW  61
017A:  RETLW  6C
017B:  RETLW  69
017C:  RETLW  64
017D:  RETLW  61
017E:  RETLW  20
017F:  RETLW  34
0180:  RETLW  00
0181:  RETLW  4F
0182:  RETLW  6E
0183:  RETLW  20
0184:  RETLW  2D
0185:  RETLW  3E
0186:  RETLW  20
0187:  RETLW  53
0188:  RETLW  61
0189:  RETLW  6C
018A:  RETLW  69
018B:  RETLW  64
018C:  RETLW  61
018D:  RETLW  20
018E:  RETLW  35
018F:  RETLW  00
0190:  RETLW  4F
0191:  RETLW  6E
0192:  RETLW  20
0193:  RETLW  2D
0194:  RETLW  3E
0195:  RETLW  20
0196:  RETLW  53
0197:  RETLW  61
0198:  RETLW  6C
0199:  RETLW  69
019A:  RETLW  64
019B:  RETLW  61
019C:  RETLW  20
019D:  RETLW  36
019E:  RETLW  00
019F:  RETLW  4F
01A0:  RETLW  6E
01A1:  RETLW  20
01A2:  RETLW  2D
01A3:  RETLW  3E
01A4:  RETLW  20
01A5:  RETLW  53
01A6:  RETLW  61
01A7:  RETLW  6C
01A8:  RETLW  69
01A9:  RETLW  64
01AA:  RETLW  61
01AB:  RETLW  20
01AC:  RETLW  37
01AD:  RETLW  00
01AE:  RETLW  4F
01AF:  RETLW  6E
01B0:  RETLW  20
01B1:  RETLW  2D
01B2:  RETLW  3E
01B3:  RETLW  20
01B4:  RETLW  53
01B5:  RETLW  61
01B6:  RETLW  6C
01B7:  RETLW  69
01B8:  RETLW  64
01B9:  RETLW  61
01BA:  RETLW  20
01BB:  RETLW  38
01BC:  RETLW  00
01BD:  RETLW  53
01BE:  RETLW  41
01BF:  RETLW  4C
01C0:  RETLW  49
01C1:  RETLW  52
01C2:  RETLW  20
01C3:  RETLW  20
01C4:  RETLW  20
01C5:  RETLW  20
01C6:  RETLW  20
01C7:  RETLW  20
01C8:  RETLW  20
01C9:  RETLW  20
01CA:  RETLW  20
01CB:  RETLW  00
01CC:  RETLW  00
01CD:  RETLW  00
01CE:  RETLW  00
01CF:  RETLW  00
01D0:  RETLW  00
01D1:  RETLW  00
01D2:  RETLW  00
01D3:  RETLW  00
01D4:  RETLW  00
01D5:  RETLW  00
01D6:  RETLW  00
01D7:  RETLW  00
01D8:  RETLW  00
01D9:  RETLW  00
01DA:  RETLW  00
01DB:  RETLW  4F
01DC:  RETLW  66
01DD:  RETLW  66
01DE:  RETLW  20
01DF:  RETLW  2D
01E0:  RETLW  3E
01E1:  RETLW  20
01E2:  RETLW  53
01E3:  RETLW  61
01E4:  RETLW  6C
01E5:  RETLW  69
01E6:  RETLW  64
01E7:  RETLW  61
01E8:  RETLW  20
01E9:  RETLW  31
01EA:  RETLW  00
01EB:  RETLW  4F
01EC:  RETLW  66
01ED:  RETLW  66
01EE:  RETLW  20
01EF:  RETLW  2D
01F0:  RETLW  3E
01F1:  RETLW  20
01F2:  RETLW  53
01F3:  RETLW  61
01F4:  RETLW  6C
01F5:  RETLW  69
01F6:  RETLW  64
01F7:  RETLW  61
01F8:  RETLW  20
01F9:  RETLW  32
01FA:  RETLW  00
01FB:  RETLW  4F
01FC:  RETLW  66
01FD:  RETLW  66
01FE:  RETLW  20
01FF:  RETLW  2D
0200:  RETLW  3E
0201:  RETLW  20
0202:  RETLW  53
0203:  RETLW  61
0204:  RETLW  6C
0205:  RETLW  69
0206:  RETLW  64
0207:  RETLW  61
0208:  RETLW  20
0209:  RETLW  33
020A:  RETLW  00
020B:  RETLW  4F
020C:  RETLW  66
020D:  RETLW  66
020E:  RETLW  20
020F:  RETLW  2D
0210:  RETLW  3E
0211:  RETLW  20
0212:  RETLW  53
0213:  RETLW  61
0214:  RETLW  6C
0215:  RETLW  69
0216:  RETLW  64
0217:  RETLW  61
0218:  RETLW  20
0219:  RETLW  34
021A:  RETLW  00
021B:  RETLW  4F
021C:  RETLW  66
021D:  RETLW  66
021E:  RETLW  20
021F:  RETLW  2D
0220:  RETLW  3E
0221:  RETLW  20
0222:  RETLW  53
0223:  RETLW  61
0224:  RETLW  6C
0225:  RETLW  69
0226:  RETLW  64
0227:  RETLW  61
0228:  RETLW  20
0229:  RETLW  35
022A:  RETLW  00
022B:  RETLW  4F
022C:  RETLW  66
022D:  RETLW  66
022E:  RETLW  20
022F:  RETLW  2D
0230:  RETLW  3E
0231:  RETLW  20
0232:  RETLW  53
0233:  RETLW  61
0234:  RETLW  6C
0235:  RETLW  69
0236:  RETLW  64
0237:  RETLW  61
0238:  RETLW  20
0239:  RETLW  36
023A:  RETLW  00
023B:  RETLW  4F
023C:  RETLW  66
023D:  RETLW  66
023E:  RETLW  20
023F:  RETLW  2D
0240:  RETLW  3E
0241:  RETLW  20
0242:  RETLW  53
0243:  RETLW  61
0244:  RETLW  6C
0245:  RETLW  69
0246:  RETLW  64
0247:  RETLW  61
0248:  RETLW  20
0249:  RETLW  37
024A:  RETLW  00
024B:  RETLW  4F
024C:  RETLW  66
024D:  RETLW  66
024E:  RETLW  20
024F:  RETLW  2D
0250:  RETLW  3E
0251:  RETLW  20
0252:  RETLW  53
0253:  RETLW  61
0254:  RETLW  6C
0255:  RETLW  69
0256:  RETLW  64
0257:  RETLW  61
0258:  RETLW  20
0259:  RETLW  38
025A:  RETLW  00
025B:  RETLW  53
025C:  RETLW  41
025D:  RETLW  4C
025E:  RETLW  49
025F:  RETLW  52
0260:  RETLW  20
0261:  RETLW  20
0262:  RETLW  20
0263:  RETLW  20
0264:  RETLW  20
0265:  RETLW  20
0266:  RETLW  20
0267:  RETLW  20
0268:  RETLW  20
0269:  RETLW  20
026A:  RETLW  00
026B:  RETLW  00
026C:  RETLW  00
026D:  RETLW  00
026E:  RETLW  00
026F:  RETLW  00
0270:  RETLW  00
0271:  RETLW  00
0272:  RETLW  00
0273:  RETLW  00
0274:  RETLW  00
0275:  RETLW  00
0276:  RETLW  00
0277:  RETLW  00
0278:  RETLW  00
0279:  RETLW  00
027A:  RETLW  00
027B:  RETLW  56
027C:  RETLW  45
027D:  RETLW  52
027E:  RETLW  20
027F:  RETLW  49
0280:  RETLW  50
0281:  RETLW  20
0282:  RETLW  20
0283:  RETLW  20
0284:  RETLW  20
0285:  RETLW  20
0286:  RETLW  20
0287:  RETLW  20
0288:  RETLW  20
0289:  RETLW  20
028A:  RETLW  20
028B:  RETLW  00
028C:  RETLW  56
028D:  RETLW  45
028E:  RETLW  52
028F:  RETLW  20
0290:  RETLW  53
0291:  RETLW  53
0292:  RETLW  49
0293:  RETLW  44
0294:  RETLW  20
0295:  RETLW  20
0296:  RETLW  20
0297:  RETLW  20
0298:  RETLW  20
0299:  RETLW  20
029A:  RETLW  20
029B:  RETLW  20
029C:  RETLW  00
029D:  RETLW  56
029E:  RETLW  45
029F:  RETLW  52
02A0:  RETLW  20
02A1:  RETLW  4B
02A2:  RETLW  45
02A3:  RETLW  59
02A4:  RETLW  20
02A5:  RETLW  20
02A6:  RETLW  20
02A7:  RETLW  20
02A8:  RETLW  20
02A9:  RETLW  20
02AA:  RETLW  20
02AB:  RETLW  20
02AC:  RETLW  20
02AD:  RETLW  00
02AE:  RETLW  43
02AF:  RETLW  6F
02B0:  RETLW  6E
02B1:  RETLW  66
02B2:  RETLW  20
02B3:  RETLW  41
02B4:  RETLW  63
02B5:  RETLW  63
02B6:  RETLW  65
02B7:  RETLW  73
02B8:  RETLW  73
02B9:  RETLW  6F
02BA:  RETLW  20
02BB:  RETLW  52
02BC:  RETLW  65
02BD:  RETLW  64
02BE:  RETLW  00
02BF:  RETLW  4F
02C0:  RETLW  6E
02C1:  RETLW  2F
02C2:  RETLW  4F
02C3:  RETLW  66
02C4:  RETLW  66
02C5:  RETLW  20
02C6:  RETLW  42
02C7:  RETLW  61
02C8:  RETLW  63
02C9:  RETLW  6B
02CA:  RETLW  6C
02CB:  RETLW  69
02CC:  RETLW  67
02CD:  RETLW  68
02CE:  RETLW  74
02CF:  RETLW  00
02D0:  RETLW  53
02D1:  RETLW  41
02D2:  RETLW  4C
02D3:  RETLW  49
02D4:  RETLW  52
02D5:  RETLW  20
02D6:  RETLW  20
02D7:  RETLW  20
02D8:  RETLW  20
02D9:  RETLW  20
02DA:  RETLW  20
02DB:  RETLW  20
02DC:  RETLW  20
02DD:  RETLW  20
02DE:  RETLW  20
02DF:  RETLW  20
02E0:  RETLW  00
02E1:  RETLW  00
02E2:  RETLW  00
02E3:  RETLW  00
02E4:  RETLW  00
02E5:  RETLW  00
02E6:  RETLW  00
02E7:  RETLW  00
02E8:  RETLW  00
02E9:  RETLW  00
02EA:  RETLW  00
02EB:  RETLW  00
02EC:  RETLW  00
02ED:  RETLW  00
02EE:  RETLW  00
02EF:  RETLW  00
02F0:  RETLW  00
02F1:  RETLW  00
02F2:  RETLW  45
02F3:  RETLW  73
02F4:  RETLW  74
02F5:  RETLW  61
02F6:  RETLW  63
02F7:  RETLW  69
02F8:  RETLW  6F
02F9:  RETLW  6E
02FA:  RETLW  20
02FB:  RETLW  20
02FC:  RETLW  20
02FD:  RETLW  20
02FE:  RETLW  20
02FF:  RETLW  00
0300:  RETLW  41
0301:  RETLW  63
0302:  RETLW  63
0303:  RETLW  65
0304:  RETLW  73
0305:  RETLW  73
0306:  RETLW  20
0307:  RETLW  50
0308:  RETLW  6F
0309:  RETLW  69
030A:  RETLW  6E
030B:  RETLW  74
030C:  RETLW  20
030D:  RETLW  00
030E:  RETLW  45
030F:  RETLW  73
0310:  RETLW  74
0311:  RETLW  61
0312:  RETLW  63
0313:  RETLW  69
0314:  RETLW  6F
0315:  RETLW  6E
0316:  RETLW  20
0317:  RETLW  2B
0318:  RETLW  20
0319:  RETLW  41
031A:  RETLW  50
031B:  RETLW  00
031C:  RETLW  53
031D:  RETLW  41
031E:  RETLW  4C
031F:  RETLW  49
0320:  RETLW  52
0321:  RETLW  20
0322:  RETLW  20
0323:  RETLW  20
0324:  RETLW  20
0325:  RETLW  20
0326:  RETLW  20
0327:  RETLW  20
0328:  RETLW  20
0329:  RETLW  00
032A:  RETLW  00
032B:  RETLW  00
032C:  RETLW  00
032D:  RETLW  00
032E:  RETLW  00
032F:  RETLW  00
0330:  RETLW  00
0331:  RETLW  00
0332:  RETLW  00
0333:  RETLW  00
0334:  RETLW  00
0335:  RETLW  00
0336:  RETLW  00
0337:  RETLW  00
0338:  DATA D3,20
0339:  DATA CC,24
033A:  DATA 52,00
033B:  DATA DB,29
033C:  DATA C9,23
033D:  DATA 5D,10
033E:  DATA 20,10
033F:  DATA 20,10
0340:  DATA A0,2D
0341:  DATA 45,27
0342:  DATA D4,2E
0343:  DATA 00,00
0344:  DATA 8C,18
0345:  DATA 39,19
0346:  DATA AE,18
0347:  DATA 36,1C
0348:  DATA 2E,18
0349:  DATA AE,18
034A:  DATA 00,01
034B:  DATA 8C,21
034C:  DATA B0,23
034D:  DATA B3,2F
034E:  DATA 55,27
034F:  DATA 45,00
0350:  DATA 8C,18
0351:  DATA B2,19
0352:  DATA B4,20
0353:  DATA FA,10
0354:  DATA 00,01
0355:  DATA 0C,21
0356:  DATA E1,31
0357:  DATA 6B,36
0358:  DATA E9,33
0359:  DATA 68,3A
035A:  DATA A0,27
035B:  DATA 6E,00
035C:  DATA 0C,21
035D:  DATA E1,31
035E:  DATA 6B,36
035F:  DATA E9,33
0360:  DATA 68,3A
0361:  DATA A0,27
0362:  DATA 66,33
0363:  DATA 00,01
0364:  DATA 41,2A
0365:  DATA AB,21
0366:  DATA D7,26
0367:  DATA 4F,22
0368:  DATA C5,2F
0369:  DATA C4,22
036A:  DATA C6,1E
036B:  DATA B1,06
036C:  DATA 0A,00
036D:  DATA 8C,21
036E:  DATA 6F,37
036F:  DATA E6,34
0370:  DATA 67,10
0371:  DATA 43,36
0372:  DATA E9,32
0373:  DATA 6E,3A
0374:  DATA 65,00
0375:  DATA 41,2A
0376:  DATA AB,21
0377:  DATA D7,26
0378:  DATA 4F,22
0379:  DATA C5,2F
037A:  DATA C4,22
037B:  DATA C6,1E
037C:  DATA B2,06
037D:  DATA 0A,00
037E:  DATA 8C,21
037F:  DATA 6F,37
0380:  DATA E6,34
0381:  DATA 67,10
0382:  DATA 41,28
0383:  DATA 00,01
0384:  DATA 41,2A
0385:  DATA AB,21
0386:  DATA D7,26
0387:  DATA 4F,22
0388:  DATA C5,2F
0389:  DATA C4,22
038A:  DATA C6,1E
038B:  DATA B3,06
038C:  DATA 0A,00
038D:  DATA 8C,21
038E:  DATA 6F,37
038F:  DATA E6,34
0390:  DATA 67,10
0391:  DATA 43,36
0392:  DATA E9,32
0393:  DATA 6E,3A
0394:  DATA E5,20
0395:  DATA 50,00
*
0749:  MOVF   0B,W
074A:  BSF    03.6
074B:  MOVWF  59
074C:  BCF    03.6
074D:  BCF    0B.7
074E:  BSF    03.5
074F:  BSF    03.6
0750:  BSF    0C.7
0751:  BSF    0C.0
0752:  NOP
0753:  NOP
0754:  BCF    03.5
0755:  BTFSS  59.7
0756:  GOTO   75A
0757:  BCF    03.6
0758:  BSF    0B.7
0759:  BSF    03.6
075A:  BTFSC  03.0
075B:  GOTO   782
075C:  MOVF   0C,W
075D:  ANDLW  7F
075E:  MOVWF  59
075F:  MOVF   0D,W
0760:  MOVWF  5A
0761:  MOVF   0F,W
0762:  MOVWF  5B
0763:  MOVF   59,W
0764:  BCF    03.6
0765:  BTFSS  0C.4
0766:  GOTO   765
0767:  MOVWF  19
0768:  BSF    03.6
0769:  MOVF   5A,W
076A:  MOVWF  0D
076B:  MOVF   5B,W
076C:  MOVWF  0F
076D:  BCF    03.6
076E:  MOVF   0B,W
076F:  BSF    03.6
0770:  MOVWF  5C
0771:  BCF    03.6
0772:  BCF    0B.7
0773:  BSF    03.5
0774:  BSF    03.6
0775:  BSF    0C.7
0776:  BSF    0C.0
0777:  NOP
0778:  NOP
0779:  BCF    03.5
077A:  BTFSS  5C.7
077B:  GOTO   77F
077C:  BCF    03.6
077D:  BSF    0B.7
077E:  BSF    03.6
077F:  DECFSZ 58,F
0780:  GOTO   782
0781:  GOTO   79D
0782:  RLF    0C,W
0783:  RLF    0E,W
0784:  ANDLW  7F
0785:  MOVWF  59
0786:  MOVF   0D,W
0787:  MOVWF  5A
0788:  MOVF   0F,W
0789:  MOVWF  5B
078A:  MOVF   59,W
078B:  BCF    03.6
078C:  BTFSS  0C.4
078D:  GOTO   78C
078E:  MOVWF  19
078F:  BSF    03.6
0790:  MOVF   5A,W
0791:  MOVWF  0D
0792:  MOVF   5B,W
0793:  MOVWF  0F
0794:  INCF   0D,F
0795:  BTFSC  03.2
0796:  INCF   0F,F
0797:  BCF    03.0
0798:  DECFSZ 58,F
0799:  GOTO   79B
079A:  GOTO   79D
079B:  BCF    03.6
079C:  GOTO   749
079D:  BCF    03.6
079E:  RETURN
*
07DD:  BSF    03.6
07DE:  MOVF   5A,W
07DF:  ANDLW  07
07E0:  MOVWF  77
07E1:  RRF    5A,W
07E2:  MOVWF  78
07E3:  RRF    78,F
07E4:  RRF    78,F
07E5:  MOVLW  1F
07E6:  ANDWF  78,F
07E7:  MOVF   78,W
07E8:  ADDWF  5C,W
07E9:  MOVWF  04
07EA:  BCF    03.7
07EB:  BTFSC  5D.0
07EC:  BSF    03.7
07ED:  CLRF   78
07EE:  INCF   78,F
07EF:  INCF   77,F
07F0:  GOTO   7F2
07F1:  RLF    78,F
07F2:  DECFSZ 77,F
07F3:  GOTO   7F1
07F4:  MOVF   5B,F
07F5:  BTFSC  03.2
07F6:  GOTO   7FA
07F7:  MOVF   78,W
07F8:  IORWF  00,F
07F9:  GOTO   7FD
07FA:  COMF   78,F
07FB:  MOVF   78,W
07FC:  ANDWF  00,F
07FD:  BCF    03.6
07FE:  RETURN
*
0800:  MOVF   0B,W
0801:  BSF    03.6
0802:  MOVWF  58
0803:  BCF    03.6
0804:  BCF    0B.7
0805:  BSF    03.5
0806:  BSF    03.6
0807:  BSF    0C.7
0808:  BSF    0C.0
0809:  NOP
080A:  NOP
080B:  BCF    03.5
080C:  BTFSS  58.7
080D:  GOTO   011
080E:  BCF    03.6
080F:  BSF    0B.7
0810:  BSF    03.6
0811:  MOVF   0C,W
0812:  ANDLW  7F
0813:  BTFSC  03.2
0814:  GOTO   050
0815:  MOVWF  58
0816:  MOVF   0D,W
0817:  MOVWF  59
0818:  MOVF   0F,W
0819:  MOVWF  5A
081A:  MOVF   58,W
081B:  BCF    03.6
081C:  BTFSS  0C.4
081D:  GOTO   01C
081E:  MOVWF  19
081F:  BSF    03.6
0820:  MOVF   59,W
0821:  MOVWF  0D
0822:  MOVF   5A,W
0823:  MOVWF  0F
0824:  BCF    03.6
0825:  MOVF   0B,W
0826:  BSF    03.6
0827:  MOVWF  5B
0828:  BCF    03.6
0829:  BCF    0B.7
082A:  BSF    03.5
082B:  BSF    03.6
082C:  BSF    0C.7
082D:  BSF    0C.0
082E:  NOP
082F:  NOP
0830:  BCF    03.5
0831:  BTFSS  5B.7
0832:  GOTO   036
0833:  BCF    03.6
0834:  BSF    0B.7
0835:  BSF    03.6
0836:  RLF    0C,W
0837:  RLF    0E,W
0838:  ANDLW  7F
0839:  BTFSC  03.2
083A:  GOTO   050
083B:  MOVWF  58
083C:  MOVF   0D,W
083D:  MOVWF  59
083E:  MOVF   0F,W
083F:  MOVWF  5A
0840:  MOVF   58,W
0841:  BCF    03.6
0842:  BTFSS  0C.4
0843:  GOTO   042
0844:  MOVWF  19
0845:  BSF    03.6
0846:  MOVF   59,W
0847:  MOVWF  0D
0848:  MOVF   5A,W
0849:  MOVWF  0F
084A:  INCF   0D,F
084B:  BTFSC  03.2
084C:  INCF   0F,F
084D:  BCF    03.6
084E:  GOTO   000
084F:  BSF    03.6
0850:  BCF    03.6
0851:  RETURN
*
091F:  MOVF   00,F
0920:  BTFSC  03.2
0921:  GOTO   13A
0922:  CLRF   59
0923:  MOVF   04,W
0924:  MOVWF  58
0925:  BCF    59.0
0926:  BTFSC  03.7
0927:  BSF    59.0
0928:  MOVF   00,W
0929:  BCF    03.6
092A:  BTFSS  0C.4
092B:  GOTO   12A
092C:  MOVWF  19
092D:  BSF    03.6
092E:  MOVF   58,W
092F:  MOVWF  04
0930:  BCF    03.7
0931:  BTFSC  59.0
0932:  BSF    03.7
0933:  INCF   04,F
0934:  BTFSS  03.2
0935:  GOTO   139
0936:  BCF    03.6
0937:  INCF   05,F
0938:  BSF    03.6
0939:  GOTO   11F
*
0A02:  MOVF   0B,W
0A03:  BSF    03.6
0A04:  MOVWF  48
0A05:  BCF    03.6
0A06:  BCF    0B.7
0A07:  BSF    03.5
0A08:  BSF    03.6
0A09:  BSF    0C.7
0A0A:  BSF    0C.0
0A0B:  NOP
0A0C:  NOP
0A0D:  BCF    03.5
0A0E:  BTFSS  48.7
0A0F:  GOTO   213
0A10:  BCF    03.6
0A11:  BSF    0B.7
0A12:  BSF    03.6
0A13:  MOVF   0C,F
0A14:  BTFSC  03.2
0A15:  GOTO   229
0A16:  MOVF   0D,W
0A17:  MOVWF  48
0A18:  MOVF   0F,W
0A19:  MOVWF  49
0A1A:  MOVF   0C,W
0A1B:  MOVWF  4A
0A1C:  BCF    03.6
0A1D:  CALL   19C
0A1E:  BSF    03.6
0A1F:  MOVF   48,W
0A20:  MOVWF  0D
0A21:  MOVF   49,W
0A22:  MOVWF  0F
0A23:  INCF   0D,F
0A24:  BTFSC  03.2
0A25:  INCF   0F,F
0A26:  BCF    03.6
0A27:  GOTO   202
0A28:  BSF    03.6
0A29:  BCF    03.6
0A2A:  RETURN
0A2B:  MOVF   0B,W
0A2C:  BSF    03.6
0A2D:  MOVWF  47
0A2E:  BCF    03.6
0A2F:  BCF    0B.7
0A30:  BSF    03.5
0A31:  BSF    03.6
0A32:  BSF    0C.7
0A33:  BSF    0C.0
0A34:  NOP
0A35:  NOP
0A36:  BCF    03.5
0A37:  BTFSS  47.7
0A38:  GOTO   23C
0A39:  BCF    03.6
0A3A:  BSF    0B.7
0A3B:  BSF    03.6
0A3C:  MOVF   0C,W
0A3D:  ANDLW  7F
0A3E:  BTFSC  03.2
0A3F:  GOTO   279
0A40:  MOVWF  47
0A41:  MOVF   0D,W
0A42:  MOVWF  48
0A43:  MOVF   0F,W
0A44:  MOVWF  49
0A45:  MOVF   47,W
0A46:  MOVWF  4A
0A47:  BCF    03.6
0A48:  CALL   19C
0A49:  BSF    03.6
0A4A:  MOVF   48,W
0A4B:  MOVWF  0D
0A4C:  MOVF   49,W
0A4D:  MOVWF  0F
0A4E:  BCF    03.6
0A4F:  MOVF   0B,W
0A50:  BSF    03.6
0A51:  MOVWF  4A
0A52:  BCF    03.6
0A53:  BCF    0B.7
0A54:  BSF    03.5
0A55:  BSF    03.6
0A56:  BSF    0C.7
0A57:  BSF    0C.0
0A58:  NOP
0A59:  NOP
0A5A:  BCF    03.5
0A5B:  BTFSS  4A.7
0A5C:  GOTO   260
0A5D:  BCF    03.6
0A5E:  BSF    0B.7
0A5F:  BSF    03.6
0A60:  RLF    0C,W
0A61:  RLF    0E,W
0A62:  ANDLW  7F
0A63:  BTFSC  03.2
0A64:  GOTO   279
0A65:  MOVWF  47
0A66:  MOVF   0D,W
0A67:  MOVWF  48
0A68:  MOVF   0F,W
0A69:  MOVWF  49
0A6A:  MOVF   47,W
0A6B:  MOVWF  4A
0A6C:  BCF    03.6
0A6D:  CALL   19C
0A6E:  BSF    03.6
0A6F:  MOVF   48,W
0A70:  MOVWF  0D
0A71:  MOVF   49,W
0A72:  MOVWF  0F
0A73:  INCF   0D,F
0A74:  BTFSC  03.2
0A75:  INCF   0F,F
0A76:  BCF    03.6
0A77:  GOTO   22B
0A78:  BSF    03.6
0A79:  BCF    03.6
0A7A:  RETURN
*
0BA7:  MOVF   00,F
0BA8:  BTFSC  03.2
0BA9:  GOTO   3C4
0BAA:  BSF    03.6
0BAB:  CLRF   59
0BAC:  MOVF   04,W
0BAD:  MOVWF  58
0BAE:  BCF    59.0
0BAF:  BTFSC  03.7
0BB0:  BSF    59.0
0BB1:  MOVF   00,W
0BB2:  BCF    03.6
0BB3:  BTFSS  0C.4
0BB4:  GOTO   3B3
0BB5:  MOVWF  19
0BB6:  BSF    03.6
0BB7:  MOVF   58,W
0BB8:  MOVWF  04
0BB9:  BCF    03.7
0BBA:  BTFSC  59.0
0BBB:  BSF    03.7
0BBC:  INCF   04,F
0BBD:  BTFSS  03.2
0BBE:  GOTO   3C2
0BBF:  BCF    03.6
0BC0:  INCF   05,F
0BC1:  BSF    03.6
0BC2:  BCF    03.6
0BC3:  GOTO   3A7
*
0C4F:  MOVF   00,F
0C50:  BTFSC  03.2
0C51:  GOTO   46C
0C52:  BSF    03.6
0C53:  CLRF   59
0C54:  MOVF   04,W
0C55:  MOVWF  58
0C56:  BCF    59.0
0C57:  BTFSC  03.7
0C58:  BSF    59.0
0C59:  MOVF   00,W
0C5A:  BCF    03.6
0C5B:  BTFSS  0C.4
0C5C:  GOTO   45B
0C5D:  MOVWF  19
0C5E:  BSF    03.6
0C5F:  MOVF   58,W
0C60:  MOVWF  04
0C61:  BCF    03.7
0C62:  BTFSC  59.0
0C63:  BSF    03.7
0C64:  INCF   04,F
0C65:  BTFSS  03.2
0C66:  GOTO   46A
0C67:  BCF    03.6
0C68:  INCF   05,F
0C69:  BSF    03.6
0C6A:  BCF    03.6
0C6B:  GOTO   44F
*
0CBE:  MOVF   00,F
0CBF:  BTFSC  03.2
0CC0:  GOTO   4DB
0CC1:  BSF    03.6
0CC2:  CLRF   59
0CC3:  MOVF   04,W
0CC4:  MOVWF  58
0CC5:  BCF    59.0
0CC6:  BTFSC  03.7
0CC7:  BSF    59.0
0CC8:  MOVF   00,W
0CC9:  BCF    03.6
0CCA:  BTFSS  0C.4
0CCB:  GOTO   4CA
0CCC:  MOVWF  19
0CCD:  BSF    03.6
0CCE:  MOVF   58,W
0CCF:  MOVWF  04
0CD0:  BCF    03.7
0CD1:  BTFSC  59.0
0CD2:  BSF    03.7
0CD3:  INCF   04,F
0CD4:  BTFSS  03.2
0CD5:  GOTO   4D9
0CD6:  BCF    03.6
0CD7:  INCF   05,F
0CD8:  BSF    03.6
0CD9:  BCF    03.6
0CDA:  GOTO   4BE
*
0D46:  BTFSC  03.1
0D47:  GOTO   54B
0D48:  MOVLW  5D
0D49:  MOVWF  04
0D4A:  BSF    03.7
0D4B:  CLRF   77
0D4C:  CLRF   78
0D4D:  CLRF   79
0D4E:  CLRF   7A
0D4F:  CLRF   5D
0D50:  CLRF   5E
0D51:  CLRF   5F
0D52:  CLRF   60
0D53:  MOVF   5C,W
0D54:  IORWF  5B,W
0D55:  IORWF  5A,W
0D56:  IORWF  59,W
0D57:  BTFSC  03.2
0D58:  GOTO   589
0D59:  MOVLW  20
0D5A:  MOVWF  61
0D5B:  BCF    03.0
0D5C:  RLF    55,F
0D5D:  RLF    56,F
0D5E:  RLF    57,F
0D5F:  RLF    58,F
0D60:  RLF    5D,F
0D61:  RLF    5E,F
0D62:  RLF    5F,F
0D63:  RLF    60,F
0D64:  MOVF   5C,W
0D65:  SUBWF  60,W
0D66:  BTFSS  03.2
0D67:  GOTO   572
0D68:  MOVF   5B,W
0D69:  SUBWF  5F,W
0D6A:  BTFSS  03.2
0D6B:  GOTO   572
0D6C:  MOVF   5A,W
0D6D:  SUBWF  5E,W
0D6E:  BTFSS  03.2
0D6F:  GOTO   572
0D70:  MOVF   59,W
0D71:  SUBWF  5D,W
0D72:  BTFSS  03.0
0D73:  GOTO   583
0D74:  MOVF   59,W
0D75:  SUBWF  5D,F
0D76:  MOVF   5A,W
0D77:  BTFSS  03.0
0D78:  INCFSZ 5A,W
0D79:  SUBWF  5E,F
0D7A:  MOVF   5B,W
0D7B:  BTFSS  03.0
0D7C:  INCFSZ 5B,W
0D7D:  SUBWF  5F,F
0D7E:  MOVF   5C,W
0D7F:  BTFSS  03.0
0D80:  INCFSZ 5C,W
0D81:  SUBWF  60,F
0D82:  BSF    03.0
0D83:  RLF    77,F
0D84:  RLF    78,F
0D85:  RLF    79,F
0D86:  RLF    7A,F
0D87:  DECFSZ 61,F
0D88:  GOTO   55B
0D89:  MOVF   5D,W
0D8A:  MOVWF  00
0D8B:  INCF   04,F
0D8C:  MOVF   5E,W
0D8D:  MOVWF  00
0D8E:  INCF   04,F
0D8F:  MOVF   5F,W
0D90:  MOVWF  00
0D91:  INCF   04,F
0D92:  MOVF   60,W
0D93:  MOVWF  00
*
0DA9:  MOVLW  20
0DAA:  MOVWF  61
0DAB:  CLRF   5D
0DAC:  CLRF   5E
0DAD:  CLRF   5F
0DAE:  CLRF   60
0DAF:  MOVF   58,W
0DB0:  MOVWF  7A
0DB1:  MOVF   57,W
0DB2:  MOVWF  79
0DB3:  MOVF   56,W
0DB4:  MOVWF  78
0DB5:  MOVF   55,W
0DB6:  MOVWF  77
0DB7:  BCF    03.0
0DB8:  BTFSS  77.0
0DB9:  GOTO   5C8
0DBA:  MOVF   59,W
0DBB:  ADDWF  5D,F
0DBC:  MOVF   5A,W
0DBD:  BTFSC  03.0
0DBE:  INCFSZ 5A,W
0DBF:  ADDWF  5E,F
0DC0:  MOVF   5B,W
0DC1:  BTFSC  03.0
0DC2:  INCFSZ 5B,W
0DC3:  ADDWF  5F,F
0DC4:  MOVF   5C,W
0DC5:  BTFSC  03.0
0DC6:  INCFSZ 5C,W
0DC7:  ADDWF  60,F
0DC8:  RRF    60,F
0DC9:  RRF    5F,F
0DCA:  RRF    5E,F
0DCB:  RRF    5D,F
0DCC:  RRF    7A,F
0DCD:  RRF    79,F
0DCE:  RRF    78,F
0DCF:  RRF    77,F
0DD0:  DECFSZ 61,F
0DD1:  GOTO   5B7
*
0F2C:  CLRF   77
0F2D:  CLRF   78
0F2E:  BSF    03.6
0F2F:  MOVF   47,W
0F30:  BCF    03.0
0F31:  BTFSC  48.0
0F32:  ADDWF  77,F
0F33:  RRF    77,F
0F34:  RRF    78,F
0F35:  BTFSC  48.1
0F36:  ADDWF  77,F
0F37:  RRF    77,F
0F38:  RRF    78,F
0F39:  BTFSC  48.2
0F3A:  ADDWF  77,F
0F3B:  RRF    77,F
0F3C:  RRF    78,F
0F3D:  BTFSC  48.3
0F3E:  ADDWF  77,F
0F3F:  RRF    77,F
0F40:  RRF    78,F
0F41:  BTFSC  48.4
0F42:  ADDWF  77,F
0F43:  RRF    77,F
0F44:  RRF    78,F
0F45:  BTFSC  48.5
0F46:  ADDWF  77,F
0F47:  RRF    77,F
0F48:  RRF    78,F
0F49:  BTFSC  48.6
0F4A:  ADDWF  77,F
0F4B:  RRF    77,F
0F4C:  RRF    78,F
0F4D:  BTFSC  48.7
0F4E:  ADDWF  77,F
0F4F:  RRF    77,F
0F50:  RRF    78,F
0F51:  BCF    03.6
0F52:  RETURN
*
1526:  BSF    0A.0
1527:  BCF    0A.1
1528:  BSF    0A.2
1529:  ADDWF  02,F
152A:  GOTO   21F
152B:  GOTO   269
152C:  GOTO   2B3
152D:  GOTO   2FD
152E:  GOTO   4C2
152F:  GOTO   51F
*
170F:  BSF    0A.0
1710:  BSF    0A.1
1711:  BSF    0A.2
1712:  ADDWF  02,F
1713:  GOTO   6FA
1714:  GOTO   702
1715:  GOTO   706
1716:  GOTO   70A
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20000000) 
*
0515:  MOVLW  59
0516:  MOVWF  04
0517:  BSF    03.7
0518:  MOVF   00,W
0519:  BTFSC  03.2
051A:  GOTO   528
051B:  MOVLW  06
051C:  MOVWF  78
051D:  CLRF   77
051E:  DECFSZ 77,F
051F:  GOTO   51E
0520:  DECFSZ 78,F
0521:  GOTO   51D
0522:  MOVLW  7B
0523:  MOVWF  77
0524:  DECFSZ 77,F
0525:  GOTO   524
0526:  DECFSZ 00,F
0527:  GOTO   51B
0528:  RETURN
*
0DEC:  MOVLW  03
0DED:  SUBWF  56,F
0DEE:  BTFSS  03.0
0DEF:  GOTO   5FA
0DF0:  MOVLW  56
0DF1:  MOVWF  04
0DF2:  BSF    03.7
0DF3:  MOVF   00,W
0DF4:  BTFSC  03.2
0DF5:  GOTO   5FA
0DF6:  GOTO   5F8
0DF7:  GOTO   5F8
0DF8:  DECFSZ 00,F
0DF9:  GOTO   5F7
*
0DFD:  MOVLW  03
0DFE:  SUBWF  56,F
0DFF:  BTFSS  03.0
0E00:  GOTO   60B
0E01:  MOVLW  56
0E02:  MOVWF  04
0E03:  BSF    03.7
0E04:  MOVF   00,W
0E05:  BTFSC  03.2
0E06:  GOTO   60B
0E07:  GOTO   609
0E08:  GOTO   609
0E09:  DECFSZ 00,F
0E0A:  GOTO   608
*
0E1F:  MOVLW  03
0E20:  SUBWF  56,F
0E21:  BTFSS  03.0
0E22:  GOTO   62D
0E23:  MOVLW  56
0E24:  MOVWF  04
0E25:  BSF    03.7
0E26:  MOVF   00,W
0E27:  BTFSC  03.2
0E28:  GOTO   62D
0E29:  GOTO   62B
0E2A:  GOTO   62B
0E2B:  DECFSZ 00,F
0E2C:  GOTO   62A
*
0E30:  MOVLW  03
0E31:  SUBWF  56,F
0E32:  BTFSS  03.0
0E33:  GOTO   63E
0E34:  MOVLW  56
0E35:  MOVWF  04
0E36:  BSF    03.7
0E37:  MOVF   00,W
0E38:  BTFSC  03.2
0E39:  GOTO   63E
0E3A:  GOTO   63C
0E3B:  GOTO   63C
0E3C:  DECFSZ 00,F
0E3D:  GOTO   63B
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
*
16B6:  MOVLW  4A
16B7:  BCF    03.6
16B8:  MOVWF  2B
16B9:  CLRF   2C
16BA:  MOVLW  49
16BB:  MOVWF  2D
16BC:  CLRF   2E
16BD:  MOVLW  48
16BE:  MOVWF  2F
16BF:  CLRF   30
16C0:  MOVLW  2C
16C1:  MOVWF  31
16C2:  CLRF   32
16C3:  MOVLW  28
16C4:  MOVWF  33
16C5:  CLRF   34
16C6:  MOVLW  29
16C7:  MOVWF  35
16C8:  CLRF   36
16C9:  MOVLW  2A
16CA:  MOVWF  37
16CB:  CLRF   38
16CC:  MOVLW  2B
16CD:  MOVWF  39
16CE:  CLRF   3A
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
16CF:  CLRF   3B
16D0:  CLRF   3C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0531:  BSF    08.4
....................    output_float(LCD_DATA5); 
0532:  BSF    08.5
....................    output_float(LCD_DATA6); 
0533:  BSF    08.6
....................    output_float(LCD_DATA7); 
0534:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0535:  BCF    03.5
0536:  BSF    08.1
0537:  BSF    03.5
0538:  BCF    08.1
....................    delay_cycles(1); 
0539:  NOP
....................    lcd_output_enable(1); 
053A:  BCF    03.5
053B:  BSF    08.0
053C:  BSF    03.5
053D:  BCF    08.0
....................    delay_cycles(1); 
053E:  NOP
....................    high = lcd_read_nibble(); 
*
0579:  MOVF   78,W
057A:  MOVWF  52
....................        
....................    lcd_output_enable(0); 
057B:  BCF    03.6
057C:  BCF    08.0
057D:  BSF    03.5
057E:  BCF    08.0
....................    delay_cycles(1); 
057F:  NOP
....................    lcd_output_enable(1); 
0580:  BCF    03.5
0581:  BSF    08.0
0582:  BSF    03.5
0583:  BCF    08.0
....................    delay_us(1); 
0584:  GOTO   585
0585:  GOTO   586
0586:  NOP
....................    low = lcd_read_nibble(); 
*
05C1:  MOVF   78,W
05C2:  MOVWF  51
....................        
....................    lcd_output_enable(0); 
05C3:  BCF    03.6
05C4:  BCF    08.0
05C5:  BSF    03.5
05C6:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
05C7:  BCF    08.4
....................    output_drive(LCD_DATA5); 
05C8:  BCF    08.5
....................    output_drive(LCD_DATA6); 
05C9:  BCF    08.6
....................    output_drive(LCD_DATA7); 
05CA:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
05CB:  BCF    03.5
05CC:  BSF    03.6
05CD:  SWAPF  52,W
05CE:  MOVWF  77
05CF:  MOVLW  F0
05D0:  ANDWF  77,F
05D1:  MOVF   77,W
05D2:  IORWF  51,W
05D3:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
053F:  BCF    03.5
0540:  BSF    03.6
0541:  CLRF   53
*
0587:  BCF    03.5
0588:  BSF    03.6
0589:  CLRF   53
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
0542:  BSF    03.5
0543:  BCF    03.6
0544:  BSF    08.4
0545:  MOVLW  00
0546:  BCF    03.5
0547:  BTFSC  08.4
0548:  MOVLW  01
0549:  BSF    03.6
054A:  IORWF  53,F
*
058A:  BSF    03.5
058B:  BCF    03.6
058C:  BSF    08.4
058D:  MOVLW  00
058E:  BCF    03.5
058F:  BTFSC  08.4
0590:  MOVLW  01
0591:  BSF    03.6
0592:  IORWF  53,F
....................    n |= input(LCD_DATA5) << 1; 
*
054B:  BSF    03.5
054C:  BCF    03.6
054D:  BSF    08.5
054E:  MOVLW  00
054F:  BCF    03.5
0550:  BTFSC  08.5
0551:  MOVLW  01
0552:  MOVWF  77
0553:  BCF    03.0
0554:  RLF    77,F
0555:  MOVF   77,W
0556:  BSF    03.6
0557:  IORWF  53,F
*
0593:  BSF    03.5
0594:  BCF    03.6
0595:  BSF    08.5
0596:  MOVLW  00
0597:  BCF    03.5
0598:  BTFSC  08.5
0599:  MOVLW  01
059A:  MOVWF  77
059B:  BCF    03.0
059C:  RLF    77,F
059D:  MOVF   77,W
059E:  BSF    03.6
059F:  IORWF  53,F
....................    n |= input(LCD_DATA6) << 2; 
*
0558:  BSF    03.5
0559:  BCF    03.6
055A:  BSF    08.6
055B:  MOVLW  00
055C:  BCF    03.5
055D:  BTFSC  08.6
055E:  MOVLW  01
055F:  MOVWF  77
0560:  RLF    77,F
0561:  RLF    77,F
0562:  MOVLW  FC
0563:  ANDWF  77,F
0564:  MOVF   77,W
0565:  BSF    03.6
0566:  IORWF  53,F
*
05A0:  BSF    03.5
05A1:  BCF    03.6
05A2:  BSF    08.6
05A3:  MOVLW  00
05A4:  BCF    03.5
05A5:  BTFSC  08.6
05A6:  MOVLW  01
05A7:  MOVWF  77
05A8:  RLF    77,F
05A9:  RLF    77,F
05AA:  MOVLW  FC
05AB:  ANDWF  77,F
05AC:  MOVF   77,W
05AD:  BSF    03.6
05AE:  IORWF  53,F
....................    n |= input(LCD_DATA7) << 3; 
*
0567:  BSF    03.5
0568:  BCF    03.6
0569:  BSF    08.7
056A:  MOVLW  00
056B:  BCF    03.5
056C:  BTFSC  08.7
056D:  MOVLW  01
056E:  MOVWF  77
056F:  RLF    77,F
0570:  RLF    77,F
0571:  RLF    77,F
0572:  MOVLW  F8
0573:  ANDWF  77,F
0574:  MOVF   77,W
0575:  BSF    03.6
0576:  IORWF  53,F
*
05AF:  BSF    03.5
05B0:  BCF    03.6
05B1:  BSF    08.7
05B2:  MOVLW  00
05B3:  BCF    03.5
05B4:  BTFSC  08.7
05B5:  MOVLW  01
05B6:  MOVWF  77
05B7:  RLF    77,F
05B8:  RLF    77,F
05B9:  RLF    77,F
05BA:  MOVLW  F8
05BB:  ANDWF  77,F
05BC:  MOVF   77,W
05BD:  BSF    03.6
05BE:  IORWF  53,F
....................     
....................    return(n); 
*
0577:  MOVF   53,W
0578:  MOVWF  78
*
05BF:  MOVF   53,W
05C0:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
05F8:  BTFSC  52.0
05F9:  GOTO   5FE
05FA:  BCF    03.6
05FB:  BCF    08.4
05FC:  GOTO   600
05FD:  BSF    03.6
05FE:  BCF    03.6
05FF:  BSF    08.4
0600:  BSF    03.5
0601:  BCF    08.4
*
063C:  BTFSC  52.0
063D:  GOTO   642
063E:  BCF    03.6
063F:  BCF    08.4
0640:  GOTO   644
0641:  BSF    03.6
0642:  BCF    03.6
0643:  BSF    08.4
0644:  BSF    03.5
0645:  BCF    08.4
*
06A6:  BTFSC  52.0
06A7:  GOTO   6AC
06A8:  BCF    03.6
06A9:  BCF    08.4
06AA:  GOTO   6AE
06AB:  BSF    03.6
06AC:  BCF    03.6
06AD:  BSF    08.4
06AE:  BSF    03.5
06AF:  BCF    08.4
*
06EE:  BTFSC  52.0
06EF:  GOTO   6F4
06F0:  BCF    03.6
06F1:  BCF    08.4
06F2:  GOTO   6F6
06F3:  BSF    03.6
06F4:  BCF    03.6
06F5:  BSF    08.4
06F6:  BSF    03.5
06F7:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
*
0602:  BCF    03.5
0603:  BSF    03.6
0604:  BTFSC  52.1
0605:  GOTO   60A
0606:  BCF    03.6
0607:  BCF    08.5
0608:  GOTO   60C
0609:  BSF    03.6
060A:  BCF    03.6
060B:  BSF    08.5
060C:  BSF    03.5
060D:  BCF    08.5
*
0646:  BCF    03.5
0647:  BSF    03.6
0648:  BTFSC  52.1
0649:  GOTO   64E
064A:  BCF    03.6
064B:  BCF    08.5
064C:  GOTO   650
064D:  BSF    03.6
064E:  BCF    03.6
064F:  BSF    08.5
0650:  BSF    03.5
0651:  BCF    08.5
*
06B0:  BCF    03.5
06B1:  BSF    03.6
06B2:  BTFSC  52.1
06B3:  GOTO   6B8
06B4:  BCF    03.6
06B5:  BCF    08.5
06B6:  GOTO   6BA
06B7:  BSF    03.6
06B8:  BCF    03.6
06B9:  BSF    08.5
06BA:  BSF    03.5
06BB:  BCF    08.5
*
06F8:  BCF    03.5
06F9:  BSF    03.6
06FA:  BTFSC  52.1
06FB:  GOTO   700
06FC:  BCF    03.6
06FD:  BCF    08.5
06FE:  GOTO   702
06FF:  BSF    03.6
0700:  BCF    03.6
0701:  BSF    08.5
0702:  BSF    03.5
0703:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
*
060E:  BCF    03.5
060F:  BSF    03.6
0610:  BTFSC  52.2
0611:  GOTO   616
0612:  BCF    03.6
0613:  BCF    08.6
0614:  GOTO   618
0615:  BSF    03.6
0616:  BCF    03.6
0617:  BSF    08.6
0618:  BSF    03.5
0619:  BCF    08.6
*
0652:  BCF    03.5
0653:  BSF    03.6
0654:  BTFSC  52.2
0655:  GOTO   65A
0656:  BCF    03.6
0657:  BCF    08.6
0658:  GOTO   65C
0659:  BSF    03.6
065A:  BCF    03.6
065B:  BSF    08.6
065C:  BSF    03.5
065D:  BCF    08.6
*
06BC:  BCF    03.5
06BD:  BSF    03.6
06BE:  BTFSC  52.2
06BF:  GOTO   6C4
06C0:  BCF    03.6
06C1:  BCF    08.6
06C2:  GOTO   6C6
06C3:  BSF    03.6
06C4:  BCF    03.6
06C5:  BSF    08.6
06C6:  BSF    03.5
06C7:  BCF    08.6
*
0704:  BCF    03.5
0705:  BSF    03.6
0706:  BTFSC  52.2
0707:  GOTO   70C
0708:  BCF    03.6
0709:  BCF    08.6
070A:  GOTO   70E
070B:  BSF    03.6
070C:  BCF    03.6
070D:  BSF    08.6
070E:  BSF    03.5
070F:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
*
061A:  BCF    03.5
061B:  BSF    03.6
061C:  BTFSC  52.3
061D:  GOTO   622
061E:  BCF    03.6
061F:  BCF    08.7
0620:  GOTO   624
0621:  BSF    03.6
0622:  BCF    03.6
0623:  BSF    08.7
0624:  BSF    03.5
0625:  BCF    08.7
*
065E:  BCF    03.5
065F:  BSF    03.6
0660:  BTFSC  52.3
0661:  GOTO   666
0662:  BCF    03.6
0663:  BCF    08.7
0664:  GOTO   668
0665:  BSF    03.6
0666:  BCF    03.6
0667:  BSF    08.7
0668:  BSF    03.5
0669:  BCF    08.7
*
06C8:  BCF    03.5
06C9:  BSF    03.6
06CA:  BTFSC  52.3
06CB:  GOTO   6D0
06CC:  BCF    03.6
06CD:  BCF    08.7
06CE:  GOTO   6D2
06CF:  BSF    03.6
06D0:  BCF    03.6
06D1:  BSF    08.7
06D2:  BSF    03.5
06D3:  BCF    08.7
*
0710:  BCF    03.5
0711:  BSF    03.6
0712:  BTFSC  52.3
0713:  GOTO   718
0714:  BCF    03.6
0715:  BCF    08.7
0716:  GOTO   71A
0717:  BSF    03.6
0718:  BCF    03.6
0719:  BSF    08.7
071A:  BSF    03.5
071B:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
*
0626:  NOP
*
066A:  NOP
*
06D4:  NOP
*
071C:  NOP
....................    lcd_output_enable(1); 
*
0627:  BCF    03.5
0628:  BSF    08.0
0629:  BSF    03.5
062A:  BCF    08.0
*
066B:  BCF    03.5
066C:  BSF    08.0
066D:  BSF    03.5
066E:  BCF    08.0
*
06D5:  BCF    03.5
06D6:  BSF    08.0
06D7:  BSF    03.5
06D8:  BCF    08.0
*
071D:  BCF    03.5
071E:  BSF    08.0
071F:  BSF    03.5
0720:  BCF    08.0
....................    delay_us(2); 
*
062B:  MOVLW  02
062C:  MOVWF  77
062D:  DECFSZ 77,F
062E:  GOTO   62D
062F:  GOTO   630
0630:  NOP
*
066F:  MOVLW  02
0670:  MOVWF  77
0671:  DECFSZ 77,F
0672:  GOTO   671
0673:  GOTO   674
0674:  NOP
*
06D9:  MOVLW  02
06DA:  MOVWF  77
06DB:  DECFSZ 77,F
06DC:  GOTO   6DB
06DD:  GOTO   6DE
06DE:  NOP
*
0721:  MOVLW  02
0722:  MOVWF  77
0723:  DECFSZ 77,F
0724:  GOTO   723
0725:  GOTO   726
0726:  NOP
....................    lcd_output_enable(0); 
*
0631:  BCF    03.5
0632:  BCF    08.0
0633:  BSF    03.5
0634:  BCF    08.0
*
0675:  BCF    03.5
0676:  BCF    08.0
0677:  BSF    03.5
0678:  BCF    08.0
*
06DF:  BCF    03.5
06E0:  BCF    08.0
06E1:  BSF    03.5
06E2:  BCF    08.0
*
0727:  BCF    03.5
0728:  BCF    08.0
0729:  BSF    03.5
072A:  BCF    08.0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0529:  BSF    03.5
052A:  BCF    08.0
....................    lcd_rs_tris(); 
052B:  BCF    08.2
....................    lcd_rw_tris(); 
052C:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
052D:  BCF    03.5
052E:  BCF    08.2
052F:  BSF    03.5
0530:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
05D4:  MOVF   78,W
05D5:  MOVWF  51
05D6:  BTFSS  51.7
05D7:  GOTO   5DB
05D8:  BSF    03.5
05D9:  BCF    03.6
05DA:  GOTO   531
....................    lcd_output_rs(address); 
05DB:  MOVF   4F,F
05DC:  BTFSS  03.2
05DD:  GOTO   5E2
05DE:  BCF    03.6
05DF:  BCF    08.2
05E0:  GOTO   5E4
05E1:  BSF    03.6
05E2:  BCF    03.6
05E3:  BSF    08.2
05E4:  BSF    03.5
05E5:  BCF    08.2
....................    delay_cycles(1); 
05E6:  NOP
....................    lcd_output_rw(0); 
05E7:  BCF    03.5
05E8:  BCF    08.1
05E9:  BSF    03.5
05EA:  BCF    08.1
....................    delay_cycles(1); 
05EB:  NOP
....................    lcd_output_enable(0); 
05EC:  BCF    03.5
05ED:  BCF    08.0
05EE:  BSF    03.5
05EF:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
05F0:  BCF    03.5
05F1:  BSF    03.6
05F2:  SWAPF  50,W
05F3:  MOVWF  51
05F4:  MOVLW  0F
05F5:  ANDWF  51,F
05F6:  MOVF   51,W
05F7:  MOVWF  52
....................    lcd_send_nibble(n & 0xf); 
*
0635:  BCF    03.5
0636:  BSF    03.6
0637:  MOVF   50,W
0638:  ANDLW  0F
0639:  MOVWF  51
063A:  MOVF   51,W
063B:  MOVWF  52
*
0679:  BCF    03.5
067A:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
067B:  MOVLW  28
067C:  BSF    03.6
067D:  MOVWF  43
067E:  MOVLW  0C
067F:  MOVWF  44
0680:  MOVLW  01
0681:  MOVWF  45
0682:  MOVLW  06
0683:  MOVWF  46
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0684:  BCF    03.6
0685:  BCF    08.0
0686:  BSF    03.5
0687:  BCF    08.0
....................    lcd_output_rs(0); 
0688:  BCF    03.5
0689:  BCF    08.2
068A:  BSF    03.5
068B:  BCF    08.2
....................    lcd_output_rw(0); 
068C:  BCF    03.5
068D:  BCF    08.1
068E:  BSF    03.5
068F:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0690:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0691:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0692:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0693:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0694:  BCF    08.0
....................    lcd_rs_tris(); 
0695:  BCF    08.2
....................    lcd_rw_tris(); 
0696:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
0697:  MOVLW  0F
0698:  BCF    03.5
0699:  BSF    03.6
069A:  MOVWF  59
069B:  BCF    03.6
069C:  CALL   515
....................    for(i=1;i<=3;++i) 
069D:  MOVLW  01
069E:  BSF    03.6
069F:  MOVWF  42
06A0:  MOVF   42,W
06A1:  SUBLW  03
06A2:  BTFSS  03.0
06A3:  GOTO   6EC
....................    { 
....................        lcd_send_nibble(3); 
06A4:  MOVLW  03
06A5:  MOVWF  52
....................        delay_ms(5); 
*
06E3:  MOVLW  05
06E4:  BCF    03.5
06E5:  BSF    03.6
06E6:  MOVWF  59
06E7:  BCF    03.6
06E8:  CALL   515
06E9:  BSF    03.6
06EA:  INCF   42,F
06EB:  GOTO   6A0
....................    } 
....................     
....................    lcd_send_nibble(2); 
06EC:  MOVLW  02
06ED:  MOVWF  52
....................    delay_ms(5); 
*
072B:  MOVLW  05
072C:  BCF    03.5
072D:  BSF    03.6
072E:  MOVWF  59
072F:  BCF    03.6
0730:  CALL   515
....................    for(i=0;i<=3;++i) 
0731:  BSF    03.6
0732:  CLRF   42
0733:  MOVF   42,W
0734:  SUBLW  03
0735:  BTFSS  03.0
0736:  GOTO   745
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0737:  MOVLW  43
0738:  ADDWF  42,W
0739:  MOVWF  04
073A:  BSF    03.7
073B:  MOVF   00,W
073C:  MOVWF  47
073D:  CLRF   4F
073E:  MOVF   47,W
073F:  MOVWF  50
0740:  BCF    03.6
0741:  CALL   529
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0742:  BSF    03.6
0743:  INCF   42,F
0744:  GOTO   733
0745:  BCF    03.6
0746:  BCF    0A.3
0747:  BSF    0A.4
0748:  GOTO   6EA (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
09B0:  DECFSZ 4C,W
09B1:  GOTO   1B3
09B2:  GOTO   1B6
*
09DA:  DECFSZ 4C,W
09DB:  GOTO   1DD
09DC:  GOTO   1E0
*
0E8A:  DECFSZ 4C,W
0E8B:  GOTO   68D
0E8C:  GOTO   690
*
0EEA:  DECFSZ 4C,W
0EEB:  GOTO   6ED
0EEC:  GOTO   6F0
*
102C:  DECFSZ 4C,W
102D:  GOTO   02F
102E:  GOTO   032
*
10A7:  DECFSZ 4C,W
10A8:  GOTO   0AA
10A9:  GOTO   0AD
*
1138:  DECFSZ 4C,W
1139:  GOTO   13B
113A:  GOTO   13E
*
11AC:  DECFSZ 4C,W
11AD:  GOTO   1AF
11AE:  GOTO   1B2
*
122F:  DECFSZ 4C,W
1230:  GOTO   232
1231:  GOTO   235
*
1279:  DECFSZ 4C,W
127A:  GOTO   27C
127B:  GOTO   27F
*
12C3:  DECFSZ 4C,W
12C4:  GOTO   2C6
12C5:  GOTO   2C9
*
1329:  DECFSZ 4C,W
132A:  GOTO   32C
132B:  GOTO   32F
*
13A4:  DECFSZ 4C,W
13A5:  GOTO   3A7
13A6:  GOTO   3AA
*
143E:  DECFSZ 4C,W
143F:  GOTO   441
1440:  GOTO   444
*
14A0:  DECFSZ 4C,W
14A1:  GOTO   4A3
14A2:  GOTO   4A6
*
14E5:  DECFSZ 4C,W
14E6:  GOTO   4E8
14E7:  GOTO   4EB
*
1561:  DECFSZ 4C,W
1562:  GOTO   564
1563:  GOTO   567
*
15D7:  DECFSZ 4C,W
15D8:  GOTO   5DA
15D9:  GOTO   5DD
*
164A:  DECFSZ 4C,W
164B:  GOTO   64D
164C:  GOTO   650
....................       address=LCD_LINE_TWO; 
*
09B3:  MOVLW  40
09B4:  MOVWF  4D
09B5:  GOTO   1B7
*
09DD:  MOVLW  40
09DE:  MOVWF  4D
09DF:  GOTO   1E1
*
0E8D:  MOVLW  40
0E8E:  MOVWF  4D
0E8F:  GOTO   691
*
0EED:  MOVLW  40
0EEE:  MOVWF  4D
0EEF:  GOTO   6F1
*
102F:  MOVLW  40
1030:  MOVWF  4D
1031:  GOTO   033
*
10AA:  MOVLW  40
10AB:  MOVWF  4D
10AC:  GOTO   0AE
*
113B:  MOVLW  40
113C:  MOVWF  4D
113D:  GOTO   13F
*
11AF:  MOVLW  40
11B0:  MOVWF  4D
11B1:  GOTO   1B3
*
1232:  MOVLW  40
1233:  MOVWF  4D
1234:  GOTO   236
*
127C:  MOVLW  40
127D:  MOVWF  4D
127E:  GOTO   280
*
12C6:  MOVLW  40
12C7:  MOVWF  4D
12C8:  GOTO   2CA
*
132C:  MOVLW  40
132D:  MOVWF  4D
132E:  GOTO   330
*
13A7:  MOVLW  40
13A8:  MOVWF  4D
13A9:  GOTO   3AB
*
1441:  MOVLW  40
1442:  MOVWF  4D
1443:  GOTO   445
*
14A3:  MOVLW  40
14A4:  MOVWF  4D
14A5:  GOTO   4A7
*
14E8:  MOVLW  40
14E9:  MOVWF  4D
14EA:  GOTO   4EC
*
1564:  MOVLW  40
1565:  MOVWF  4D
1566:  GOTO   568
*
15DA:  MOVLW  40
15DB:  MOVWF  4D
15DC:  GOTO   5DE
*
164D:  MOVLW  40
164E:  MOVWF  4D
164F:  GOTO   651
....................    else 
....................       address=0; 
*
09B6:  CLRF   4D
*
09E0:  CLRF   4D
*
0E90:  CLRF   4D
*
0EF0:  CLRF   4D
*
1032:  CLRF   4D
*
10AD:  CLRF   4D
*
113E:  CLRF   4D
*
11B2:  CLRF   4D
*
1235:  CLRF   4D
*
127F:  CLRF   4D
*
12C9:  CLRF   4D
*
132F:  CLRF   4D
*
13AA:  CLRF   4D
*
1444:  CLRF   4D
*
14A6:  CLRF   4D
*
14EB:  CLRF   4D
*
1567:  CLRF   4D
*
15DD:  CLRF   4D
*
1650:  CLRF   4D
....................       
....................    address+=x-1; 
*
09B7:  MOVLW  01
09B8:  SUBWF  4B,W
09B9:  ADDWF  4D,F
*
09E1:  MOVLW  01
09E2:  SUBWF  4B,W
09E3:  ADDWF  4D,F
*
0E91:  MOVLW  01
0E92:  SUBWF  4B,W
0E93:  ADDWF  4D,F
*
0EF1:  MOVLW  01
0EF2:  SUBWF  4B,W
0EF3:  ADDWF  4D,F
*
1033:  MOVLW  01
1034:  SUBWF  4B,W
1035:  ADDWF  4D,F
*
10AE:  MOVLW  01
10AF:  SUBWF  4B,W
10B0:  ADDWF  4D,F
*
113F:  MOVLW  01
1140:  SUBWF  4B,W
1141:  ADDWF  4D,F
*
11B3:  MOVLW  01
11B4:  SUBWF  4B,W
11B5:  ADDWF  4D,F
*
1236:  MOVLW  01
1237:  SUBWF  4B,W
1238:  ADDWF  4D,F
*
1280:  MOVLW  01
1281:  SUBWF  4B,W
1282:  ADDWF  4D,F
*
12CA:  MOVLW  01
12CB:  SUBWF  4B,W
12CC:  ADDWF  4D,F
*
1330:  MOVLW  01
1331:  SUBWF  4B,W
1332:  ADDWF  4D,F
*
13AB:  MOVLW  01
13AC:  SUBWF  4B,W
13AD:  ADDWF  4D,F
*
1445:  MOVLW  01
1446:  SUBWF  4B,W
1447:  ADDWF  4D,F
*
14A7:  MOVLW  01
14A8:  SUBWF  4B,W
14A9:  ADDWF  4D,F
*
14EC:  MOVLW  01
14ED:  SUBWF  4B,W
14EE:  ADDWF  4D,F
*
1568:  MOVLW  01
1569:  SUBWF  4B,W
156A:  ADDWF  4D,F
*
15DE:  MOVLW  01
15DF:  SUBWF  4B,W
15E0:  ADDWF  4D,F
*
1651:  MOVLW  01
1652:  SUBWF  4B,W
1653:  ADDWF  4D,F
....................    lcd_send_byte(0,0x80|address); 
*
09BA:  MOVF   4D,W
09BB:  IORLW  80
09BC:  MOVWF  4E
09BD:  CLRF   4F
09BE:  MOVF   4E,W
09BF:  MOVWF  50
09C0:  BCF    0A.3
09C1:  BCF    03.6
09C2:  CALL   529
09C3:  BSF    0A.3
*
09E4:  MOVF   4D,W
09E5:  IORLW  80
09E6:  MOVWF  4E
09E7:  CLRF   4F
09E8:  MOVF   4E,W
09E9:  MOVWF  50
09EA:  BCF    0A.3
09EB:  BCF    03.6
09EC:  CALL   529
09ED:  BSF    0A.3
*
0E94:  MOVF   4D,W
0E95:  IORLW  80
0E96:  MOVWF  4E
0E97:  CLRF   4F
0E98:  MOVF   4E,W
0E99:  MOVWF  50
0E9A:  BCF    0A.3
0E9B:  BCF    03.6
0E9C:  CALL   529
0E9D:  BSF    0A.3
*
0EF4:  MOVF   4D,W
0EF5:  IORLW  80
0EF6:  MOVWF  4E
0EF7:  CLRF   4F
0EF8:  MOVF   4E,W
0EF9:  MOVWF  50
0EFA:  BCF    0A.3
0EFB:  BCF    03.6
0EFC:  CALL   529
0EFD:  BSF    0A.3
*
1036:  MOVF   4D,W
1037:  IORLW  80
1038:  MOVWF  4E
1039:  CLRF   4F
103A:  MOVF   4E,W
103B:  MOVWF  50
103C:  BCF    0A.4
103D:  BCF    03.6
103E:  CALL   529
103F:  BSF    0A.4
*
10B1:  MOVF   4D,W
10B2:  IORLW  80
10B3:  MOVWF  4E
10B4:  CLRF   4F
10B5:  MOVF   4E,W
10B6:  MOVWF  50
10B7:  BCF    0A.4
10B8:  BCF    03.6
10B9:  CALL   529
10BA:  BSF    0A.4
*
1142:  MOVF   4D,W
1143:  IORLW  80
1144:  MOVWF  4E
1145:  CLRF   4F
1146:  MOVF   4E,W
1147:  MOVWF  50
1148:  BCF    0A.4
1149:  BCF    03.6
114A:  CALL   529
114B:  BSF    0A.4
*
11B6:  MOVF   4D,W
11B7:  IORLW  80
11B8:  MOVWF  4E
11B9:  CLRF   4F
11BA:  MOVF   4E,W
11BB:  MOVWF  50
11BC:  BCF    0A.4
11BD:  BCF    03.6
11BE:  CALL   529
11BF:  BSF    0A.4
*
1239:  MOVF   4D,W
123A:  IORLW  80
123B:  MOVWF  4E
123C:  CLRF   4F
123D:  MOVF   4E,W
123E:  MOVWF  50
123F:  BCF    0A.4
1240:  BCF    03.6
1241:  CALL   529
1242:  BSF    0A.4
*
1283:  MOVF   4D,W
1284:  IORLW  80
1285:  MOVWF  4E
1286:  CLRF   4F
1287:  MOVF   4E,W
1288:  MOVWF  50
1289:  BCF    0A.4
128A:  BCF    03.6
128B:  CALL   529
128C:  BSF    0A.4
*
12CD:  MOVF   4D,W
12CE:  IORLW  80
12CF:  MOVWF  4E
12D0:  CLRF   4F
12D1:  MOVF   4E,W
12D2:  MOVWF  50
12D3:  BCF    0A.4
12D4:  BCF    03.6
12D5:  CALL   529
12D6:  BSF    0A.4
*
1333:  MOVF   4D,W
1334:  IORLW  80
1335:  MOVWF  4E
1336:  CLRF   4F
1337:  MOVF   4E,W
1338:  MOVWF  50
1339:  BCF    0A.4
133A:  BCF    03.6
133B:  CALL   529
133C:  BSF    0A.4
*
13AE:  MOVF   4D,W
13AF:  IORLW  80
13B0:  MOVWF  4E
13B1:  CLRF   4F
13B2:  MOVF   4E,W
13B3:  MOVWF  50
13B4:  BCF    0A.4
13B5:  BCF    03.6
13B6:  CALL   529
13B7:  BSF    0A.4
*
1448:  MOVF   4D,W
1449:  IORLW  80
144A:  MOVWF  4E
144B:  CLRF   4F
144C:  MOVF   4E,W
144D:  MOVWF  50
144E:  BCF    0A.4
144F:  BCF    03.6
1450:  CALL   529
1451:  BSF    0A.4
*
14AA:  MOVF   4D,W
14AB:  IORLW  80
14AC:  MOVWF  4E
14AD:  CLRF   4F
14AE:  MOVF   4E,W
14AF:  MOVWF  50
14B0:  BCF    0A.4
14B1:  BCF    03.6
14B2:  CALL   529
14B3:  BSF    0A.4
*
14EF:  MOVF   4D,W
14F0:  IORLW  80
14F1:  MOVWF  4E
14F2:  CLRF   4F
14F3:  MOVF   4E,W
14F4:  MOVWF  50
14F5:  BCF    0A.4
14F6:  BCF    03.6
14F7:  CALL   529
14F8:  BSF    0A.4
*
156B:  MOVF   4D,W
156C:  IORLW  80
156D:  MOVWF  4E
156E:  CLRF   4F
156F:  MOVF   4E,W
1570:  MOVWF  50
1571:  BCF    0A.4
1572:  BCF    03.6
1573:  CALL   529
1574:  BSF    0A.4
*
15E1:  MOVF   4D,W
15E2:  IORLW  80
15E3:  MOVWF  4E
15E4:  CLRF   4F
15E5:  MOVF   4E,W
15E6:  MOVWF  50
15E7:  BCF    0A.4
15E8:  BCF    03.6
15E9:  CALL   529
15EA:  BSF    0A.4
*
1654:  MOVF   4D,W
1655:  IORLW  80
1656:  MOVWF  4E
1657:  CLRF   4F
1658:  MOVF   4E,W
1659:  MOVWF  50
165A:  BCF    0A.4
165B:  BCF    03.6
165C:  CALL   529
165D:  BSF    0A.4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
099C:  BSF    03.6
099D:  MOVF   4A,W
099E:  XORLW  07
099F:  BCF    03.6
09A0:  BTFSC  03.2
09A1:  GOTO   1AC
09A2:  XORLW  0B
09A3:  BTFSC  03.2
09A4:  GOTO   1C5
09A5:  XORLW  06
09A6:  BTFSC  03.2
09A7:  GOTO   1D5
09A8:  XORLW  02
09A9:  BTFSC  03.2
09AA:  GOTO   1EF
09AB:  GOTO   1F8
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
09AC:  MOVLW  01
09AD:  BSF    03.6
09AE:  MOVWF  4B
09AF:  MOVWF  4C
*
09C4:  GOTO   201
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
09C5:  BSF    03.6
09C6:  CLRF   4F
09C7:  MOVLW  01
09C8:  MOVWF  50
09C9:  BCF    0A.3
09CA:  BCF    03.6
09CB:  CALL   529
09CC:  BSF    0A.3
....................                      delay_ms(2); 
09CD:  MOVLW  02
09CE:  BSF    03.6
09CF:  MOVWF  59
09D0:  BCF    0A.3
09D1:  BCF    03.6
09D2:  CALL   515
09D3:  BSF    0A.3
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
09D4:  GOTO   201
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
09D5:  MOVLW  01
09D6:  BSF    03.6
09D7:  MOVWF  4B
09D8:  MOVLW  02
09D9:  MOVWF  4C
*
09EE:  GOTO   201
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
09EF:  BSF    03.6
09F0:  CLRF   4F
09F1:  MOVLW  10
09F2:  MOVWF  50
09F3:  BCF    0A.3
09F4:  BCF    03.6
09F5:  CALL   529
09F6:  BSF    0A.3
09F7:  GOTO   201
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
09F8:  MOVLW  01
09F9:  BSF    03.6
09FA:  MOVWF  4F
09FB:  MOVF   4A,W
09FC:  MOVWF  50
09FD:  BCF    0A.3
09FE:  BCF    03.6
09FF:  CALL   529
0A00:  BSF    0A.3
....................      #endif 
....................    } 
0A01:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
0D1A:  BSF    03.6
0D1B:  CLRF   4C
0D1C:  CLRF   4B
0D1D:  CLRF   4E
0D1E:  CLRF   4D
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
0D1F:  MOVF   48,F
0D20:  BTFSS  03.2
0D21:  GOTO   526
0D22:  MOVF   47,W
0D23:  SUBLW  13
0D24:  BTFSC  03.0
0D25:  GOTO   66B
0D26:  MOVF   48,W
0D27:  SUBLW  4E
0D28:  BTFSS  03.0
0D29:  GOTO   66B
0D2A:  BTFSS  03.2
0D2B:  GOTO   530
0D2C:  MOVF   47,W
0D2D:  SUBLW  20
0D2E:  BTFSS  03.0
0D2F:  GOTO   66B
....................       tmp=100000; 
0D30:  CLRF   54
0D31:  MOVLW  01
0D32:  MOVWF  53
0D33:  MOVLW  86
0D34:  MOVWF  52
0D35:  MOVLW  A0
0D36:  MOVWF  51
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
0D37:  BCF    03.1
0D38:  MOVF   54,W
0D39:  MOVWF  58
0D3A:  MOVF   53,W
0D3B:  MOVWF  57
0D3C:  MOVF   52,W
0D3D:  MOVWF  56
0D3E:  MOVF   51,W
0D3F:  MOVWF  55
0D40:  CLRF   5C
0D41:  CLRF   5B
0D42:  MOVF   48,W
0D43:  MOVWF  5A
0D44:  MOVF   47,W
0D45:  MOVWF  59
*
0D94:  MOVF   7A,W
0D95:  MOVWF  54
0D96:  MOVF   79,W
0D97:  MOVWF  53
0D98:  MOVF   78,W
0D99:  MOVWF  52
0D9A:  MOVF   77,W
0D9B:  MOVWF  51
....................       tmp*=5;    
0D9C:  MOVF   54,W
0D9D:  MOVWF  58
0D9E:  MOVF   53,W
0D9F:  MOVWF  57
0DA0:  MOVF   52,W
0DA1:  MOVWF  56
0DA2:  MOVF   51,W
0DA3:  MOVWF  55
0DA4:  CLRF   5C
0DA5:  CLRF   5B
0DA6:  CLRF   5A
0DA7:  MOVLW  05
0DA8:  MOVWF  59
*
0DD2:  MOVF   7A,W
0DD3:  MOVWF  54
0DD4:  MOVF   79,W
0DD5:  MOVWF  53
0DD6:  MOVF   78,W
0DD7:  MOVWF  52
0DD8:  MOVF   77,W
0DD9:  MOVWF  51
....................       uS=tmp; 
0DDA:  MOVF   52,W
0DDB:  MOVWF  50
0DDC:  MOVF   51,W
0DDD:  MOVWF  4F
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
0DDE:  BSF    03.5
0DDF:  BCF    03.6
0DE0:  BCF    06.2
0DE1:  BCF    03.5
0DE2:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0DE3:  BSF    03.6
0DE4:  MOVF   50,W
0DE5:  MOVWF  55
0DE6:  INCF   55,F
0DE7:  DECF   55,F
0DE8:  BTFSC  03.2
0DE9:  GOTO   5FB
0DEA:  MOVLW  FF
0DEB:  MOVWF  56
*
0DFA:  GOTO   5E7
0DFB:  MOVF   4F,W
0DFC:  MOVWF  56
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
0E0B:  MOVF   4F,W
0E0C:  ADDWF  4D,F
0E0D:  MOVF   50,W
0E0E:  BTFSC  03.0
0E0F:  INCFSZ 50,W
0E10:  ADDWF  4E,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0E11:  BSF    03.5
0E12:  BCF    03.6
0E13:  BCF    06.2
0E14:  BCF    03.5
0E15:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
0E16:  BSF    03.6
0E17:  MOVF   50,W
0E18:  MOVWF  55
0E19:  INCF   55,F
0E1A:  DECF   55,F
0E1B:  BTFSC  03.2
0E1C:  GOTO   62E
0E1D:  MOVLW  FF
0E1E:  MOVWF  56
*
0E2D:  GOTO   61A
0E2E:  MOVF   4F,W
0E2F:  MOVWF  56
....................          CiclosL+=(uS);          //  
*
0E3E:  MOVF   4F,W
0E3F:  ADDWF  4D,F
0E40:  MOVF   50,W
0E41:  BTFSC  03.0
0E42:  INCFSZ 50,W
0E43:  ADDWF  4E,F
....................          CiclosL+=25;            // Compensador. 
0E44:  MOVLW  19
0E45:  ADDWF  4D,F
0E46:  BTFSC  03.0
0E47:  INCF   4E,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
0E48:  MOVF   4E,W
0E49:  SUBLW  02
0E4A:  BTFSC  03.0
0E4B:  GOTO   661
0E4C:  XORLW  FF
0E4D:  BTFSS  03.2
0E4E:  GOTO   653
0E4F:  MOVF   4D,W
0E50:  SUBLW  E7
0E51:  BTFSC  03.0
0E52:  GOTO   661
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0E53:  MOVLW  E8
0E54:  SUBWF  4D,F
0E55:  MOVLW  03
0E56:  BTFSS  03.0
0E57:  MOVLW  04
0E58:  SUBWF  4E,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0E59:  INCF   4B,F
0E5A:  BTFSC  03.2
0E5B:  INCF   4C,F
....................             CiclosL+=25;         // Compensador. 
0E5C:  MOVLW  19
0E5D:  ADDWF  4D,F
0E5E:  BTFSC  03.0
0E5F:  INCF   4E,F
0E60:  GOTO   648
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
0E61:  MOVF   4C,W
0E62:  SUBWF  4A,W
0E63:  BTFSS  03.0
0E64:  GOTO   66B
0E65:  BTFSS  03.2
0E66:  GOTO   5DE
0E67:  MOVF   49,W
0E68:  SUBWF  4B,W
0E69:  BTFSS  03.0
0E6A:  GOTO   5DE
....................                                          // tiempo indicado. 
....................    } 
0E6B:  BCF    03.6
0E6C:  RETURN
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/esp8266.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... #define  CMD_MODE    1 
.................... #define  CMD_DO_CONN 2 
.................... #define  CMD_CONN    3 
....................  
.................... /* Constantes de Captura Respuestas */ 
.................... //const char ESP8266_RESP_START_STAIP[7]    ={'S','T','A','I','P',',','"'}; 
.................... //const char ESP8266_RESP_STOP_STAIP[3]     ={'"',0x0D,0x0A}; 
....................  
.................... /* Declaracion de Funciones de comandos */ 
.................... void reset(void); 
.................... int  setupMode(char modeVal); 
.................... int  doConnected(); 
.................... int  setupConn(char SSIDAndKey[]); 
.................... int  setupServer(void); 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void waitRespOK(int buffer); 
.................... void waitRespNoAp(int buffer); 
.................... void waitRespCWJAP(int buffer); 
.................... void waitRespConnected(int buffer); 
.................... void waitRespFail(int buffer); 
.................... void waitRespError(int buffer); 
.................... int  waitResp(void); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int READY_RESP = 0x00; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... //int flag_Ready_Resp         = 0; 
.................... int flag_Resp_Valid         = 0; 
.................... int flag_Resp_NoAp          = 0; 
.................... int flag_Resp_CWJAP         = 0; 
.................... int flag_Resp_Connected     = 0; 
.................... int flag_Resp_Fail          = 0; 
.................... int flag_Resp_Error         = 0; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp           = 0; 
.................... int flag_Pos_Resp_NoAp      = 0; 
.................... int flag_Pos_Resp_CWJAP     = 0; 
.................... int flag_Pos_Resp_Connected = 0; 
.................... int flag_Pos_Resp_Fail      = 0; 
.................... int flag_Pos_Resp_Error     = 0; 
....................  
.................... /*@TODO: Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
*
0852:  MOVLW  33
0853:  BSF    03.6
0854:  MOVWF  42
.................... { 
....................    char  modeWithoutConnect = '3'; 
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    /**reset(); 
....................    delay_ms(2000);**/ 
....................     
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
0855:  CLRF   0D
0856:  BSF    03.5
0857:  BCF    0C.7
0858:  BSF    0C.0
0859:  BCF    03.5
085A:  MOVF   0C,W
085B:  BCF    03.6
085C:  MOVWF  4F
....................    delay_ms(10); 
085D:  MOVLW  0A
085E:  BSF    03.6
085F:  MOVWF  59
0860:  BCF    0A.3
0861:  BCF    03.6
0862:  CALL   515
0863:  BSF    0A.3
....................    switch(modeStar){ 
0864:  MOVF   4F,W
0865:  XORLW  01
0866:  BTFSC  03.2
0867:  GOTO   078
0868:  XORLW  30
0869:  BTFSC  03.2
086A:  GOTO   078
086B:  XORLW  33
086C:  BTFSC  03.2
086D:  GOTO   07B
086E:  XORLW  30
086F:  BTFSC  03.2
0870:  GOTO   07B
0871:  XORLW  31
0872:  BTFSC  03.2
0873:  GOTO   07E
0874:  XORLW  30
0875:  BTFSC  03.2
0876:  GOTO   07E
0877:  GOTO   07E
....................        
....................       case 1: 
....................       case '1': 
....................          modeStar = '1'; 
0878:  MOVLW  31
0879:  MOVWF  4F
....................          break; 
087A:  GOTO   09D
....................        
....................       case 2: 
....................       case '2': 
....................          modeStar = '2'; 
087B:  MOVLW  32
087C:  MOVWF  4F
....................          break; 
087D:  GOTO   09D
....................        
....................       case 3: 
....................       case '3': 
....................       default: 
....................          write_eeprom(0x00,'3'); 
087E:  MOVF   0B,W
087F:  MOVWF  77
0880:  BCF    0B.7
0881:  BSF    03.6
0882:  CLRF   0D
0883:  MOVLW  33
0884:  MOVWF  0C
0885:  BSF    03.5
0886:  BCF    0C.7
0887:  BSF    0C.2
0888:  MOVLW  55
0889:  MOVWF  0D
088A:  MOVLW  AA
088B:  MOVWF  0D
088C:  BSF    0C.1
088D:  BTFSC  0C.1
088E:  GOTO   08D
088F:  BCF    0C.2
0890:  MOVF   77,W
0891:  BCF    03.5
0892:  BCF    03.6
0893:  IORWF  0B,F
....................          delay_ms(10); 
0894:  MOVLW  0A
0895:  BSF    03.6
0896:  MOVWF  59
0897:  BCF    0A.3
0898:  BCF    03.6
0899:  CALL   515
089A:  BSF    0A.3
....................          modeStar = '3'; 
089B:  MOVLW  33
089C:  MOVWF  4F
....................          break; 
....................    } 
....................    
....................    CMD_RUN =  setupMode(modeStar); 
089D:  MOVF   4F,W
089E:  BSF    03.6
089F:  MOVWF  45
*
08BB:  MOVF   78,W
08BC:  MOVWF  41
....................    waitResp(); 
08BD:  BCF    0A.3
08BE:  CALL   79F
08BF:  BSF    0A.3
....................  
....................    CMD_RUN =  doConnected(); 
*
08C9:  MOVF   78,W
08CA:  MOVWF  41
....................     
....................    resp = waitResp(); 
08CB:  BCF    0A.3
08CC:  CALL   79F
08CD:  BSF    0A.3
08CE:  MOVF   78,W
08CF:  BSF    03.6
08D0:  MOVWF  43
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
08D1:  MOVF   43,W
08D2:  SUBLW  02
08D3:  BTFSS  03.2
08D4:  GOTO   170
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
08D5:  CLRF   44
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
08D6:  MOVLW  A0
08D7:  ADDWF  44,W
08D8:  MOVWF  04
08D9:  BCF    03.7
08DA:  MOVF   00,W
08DB:  SUBLW  0A
08DC:  BTFSC  03.2
08DD:  GOTO   107
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
08DE:  MOVLW  A0
08DF:  ADDWF  44,W
08E0:  MOVWF  04
08E1:  BCF    03.7
08E2:  MOVLW  01
08E3:  ADDWF  44,W
08E4:  MOVWF  47
08E5:  MOVF   47,W
08E6:  MOVWF  0D
08E7:  BSF    03.5
08E8:  BCF    0C.7
08E9:  BSF    0C.0
08EA:  BCF    03.5
08EB:  MOVF   0C,W
08EC:  MOVWF  00
....................          delay_ms(10); 
08ED:  MOVLW  0A
08EE:  MOVWF  59
08EF:  BCF    0A.3
08F0:  BCF    03.6
08F1:  CALL   515
08F2:  BSF    0A.3
....................          if(SSIDAndKey[idxRE]==0xFF){ 
08F3:  MOVLW  A0
08F4:  BSF    03.6
08F5:  ADDWF  44,W
08F6:  MOVWF  04
08F7:  BCF    03.7
08F8:  INCFSZ 00,W
08F9:  GOTO   0FD
....................             resp = 5; 
08FA:  MOVLW  05
08FB:  MOVWF  43
....................             break; 
08FC:  GOTO   107
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
08FD:  MOVLW  A0
08FE:  ADDWF  44,W
08FF:  MOVWF  04
0900:  BCF    03.7
0901:  MOVF   00,W
0902:  SUBLW  0A
0903:  BTFSC  03.2
....................             break; 
0904:  GOTO   107
....................          } 
....................          idxRE++; 
0905:  INCF   44,F
0906:  GOTO   0D6
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
0907:  MOVF   43,W
0908:  SUBLW  05
0909:  BTFSC  03.2
090A:  GOTO   145
....................          CMD_RUN = setupConn(SSIDAndKey); 
090B:  CLRF   46
090C:  MOVLW  A0
090D:  MOVWF  45
*
093C:  MOVF   78,W
093D:  BCF    03.6
093E:  MOVWF  41
....................          resp    = waitResp(); 
093F:  BCF    0A.3
0940:  CALL   79F
0941:  BSF    0A.3
0942:  MOVF   78,W
0943:  BSF    03.6
0944:  MOVWF  43
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
0945:  MOVF   43,W
0946:  SUBLW  04
0947:  BTFSC  03.2
0948:  GOTO   14D
0949:  MOVF   43,W
094A:  SUBLW  05
094B:  BTFSS  03.2
094C:  GOTO   170
....................          CMD_RUN =  setupMode(modeWithoutConnect); 
094D:  MOVF   42,W
094E:  MOVWF  45
*
096A:  MOVF   78,W
096B:  MOVWF  41
....................          waitResp(); 
096C:  BCF    0A.3
096D:  CALL   79F
096E:  BSF    0A.3
096F:  BSF    03.6
....................       } 
....................    } // Fin del if(doConnect) 
....................    
....................    /** @TODO: Rutina que se encarga de recibir datos desde ESP8266 **/ 
....................    setupServer(); 
....................    READY_RESP = 1; 
*
0996:  MOVLW  01
0997:  BCF    03.6
0998:  MOVWF  42
0999:  BCF    0A.3
099A:  BSF    0A.4
099B:  GOTO   6F2 (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
03BF:  BCF    03.6
03C0:  MOVF   41,W
03C1:  XORLW  01
03C2:  BTFSC  03.2
03C3:  GOTO   3CB
03C4:  XORLW  03
03C5:  BTFSC  03.2
03C6:  GOTO   3D1
03C7:  XORLW  01
03C8:  BTFSC  03.2
03C9:  GOTO   40D
03CA:  GOTO   464
....................             case CMD_MODE: 
....................                   waitRespOK(buffer); 
03CB:  BSF    03.6
03CC:  MOVF   63,W
03CD:  MOVWF  64
03CE:  BCF    03.6
03CF:  CALL   396
....................                   break; 
03D0:  GOTO   465
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespNoAp(buffer); 
03D1:  BSF    03.6
03D2:  MOVF   63,W
03D3:  MOVWF  64
....................                   waitRespCWJAP(buffer); 
*
03EC:  BSF    03.6
03ED:  MOVF   63,W
03EE:  MOVWF  64
....................                   waitRespOK(buffer); 
*
0407:  BSF    03.6
0408:  MOVF   63,W
0409:  MOVWF  64
040A:  BCF    03.6
040B:  CALL   396
....................                   break; 
040C:  GOTO   465
....................  
....................             case CMD_CONN: 
....................                   waitRespConnected(buffer); 
040D:  BSF    03.6
040E:  MOVF   63,W
040F:  MOVWF  64
....................                   waitRespFail(buffer); 
*
0428:  BSF    03.6
0429:  MOVF   63,W
042A:  MOVWF  64
....................                   waitRespError(buffer); 
*
0443:  BSF    03.6
0444:  MOVF   63,W
0445:  MOVWF  64
....................                   waitRespOK(buffer); 
*
045E:  BSF    03.6
045F:  MOVF   63,W
0460:  MOVWF  64
0461:  BCF    03.6
0462:  CALL   396
....................                   break; 
0463:  GOTO   465
....................              
....................             default: 
....................                   CMD_RUN = 0x00; 
0464:  CLRF   41
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /******************************************************** 
.................... Reinicia el modulo ESP8266 
.................... *********************************************************/ 
.................... void reset(void) 
.................... { 
....................    fprintf(ESP8266, "AT+RST\r\n"); 
.................... } // fin de la funcion reset() 
....................  
.................... /******************************************************** 
....................  *  Configura el modo de funcionamiento 
....................  *  1-Cliente, 2-AccessPoint, 3-AP+STA  
.................... *********************************************************/ 
.................... int setupMode(char modeVal) 
.................... { 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeVal ); 
*
08A0:  MOVLW  A1
08A1:  MOVWF  0D
08A2:  MOVLW  00
08A3:  MOVWF  0F
08A4:  BCF    03.0
08A5:  MOVLW  0A
08A6:  MOVWF  58
08A7:  BCF    0A.3
08A8:  BCF    03.6
08A9:  CALL   749
08AA:  BSF    0A.3
08AB:  BSF    03.6
08AC:  MOVF   45,W
08AD:  BCF    03.6
08AE:  BTFSS  0C.4
08AF:  GOTO   0AE
08B0:  MOVWF  19
08B1:  MOVLW  0D
08B2:  BTFSS  0C.4
08B3:  GOTO   0B2
08B4:  MOVWF  19
08B5:  MOVLW  0A
08B6:  BTFSS  0C.4
08B7:  GOTO   0B6
08B8:  MOVWF  19
*
094F:  MOVLW  A1
0950:  MOVWF  0D
0951:  MOVLW  00
0952:  MOVWF  0F
0953:  BCF    03.0
0954:  MOVLW  0A
0955:  MOVWF  58
0956:  BCF    0A.3
0957:  BCF    03.6
0958:  CALL   749
0959:  BSF    0A.3
095A:  BSF    03.6
095B:  MOVF   45,W
095C:  BCF    03.6
095D:  BTFSS  0C.4
095E:  GOTO   15D
095F:  MOVWF  19
0960:  MOVLW  0D
0961:  BTFSS  0C.4
0962:  GOTO   161
0963:  MOVWF  19
0964:  MOVLW  0A
0965:  BTFSS  0C.4
0966:  GOTO   165
0967:  MOVWF  19
....................    return CMD_MODE; 
*
08B9:  MOVLW  01
08BA:  MOVWF  78
*
0968:  MOVLW  01
0969:  MOVWF  78
.................... } // fin de la funcion setupMode() 
....................  
.................... /******************************************************** 
....................  *  lanza el comando para verificar el estado de la 
....................  *  conexion a la red wifi  
.................... *********************************************************/ 
.................... int doConnected() 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
*
08C0:  MOVLW  A9
08C1:  BSF    03.6
08C2:  MOVWF  0D
08C3:  MOVLW  00
08C4:  MOVWF  0F
08C5:  BCF    03.6
08C6:  CALL   000
....................    return CMD_DO_CONN; 
08C7:  MOVLW  02
08C8:  MOVWF  78
.................... } 
....................  
.................... /******************************************************** 
....................  *  Conecta a la red wifi 
....................  *  AT+CWJAP="UNE_C06E","00986344200771" 
.................... *********************************************************/ 
.................... int setupConn(char SSID_And_Key[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP=%s",SSID_And_Key ); 
*
090E:  MOVLW  AF
090F:  MOVWF  0D
0910:  MOVLW  00
0911:  MOVWF  0F
0912:  BCF    03.0
0913:  MOVLW  09
0914:  MOVWF  58
0915:  BCF    0A.3
0916:  BCF    03.6
0917:  CALL   749
0918:  BSF    0A.3
0919:  BSF    03.6
091A:  MOVF   45,W
091B:  MOVWF  04
091C:  BCF    03.7
091D:  BTFSC  46.0
091E:  BSF    03.7
....................    return CMD_CONN; 
*
093A:  MOVLW  03
093B:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /******************************************************** 
....................  * Activa el modo multiconexion y modo servidor por el_ 
....................  * Puerto IP:80 
.................... *********************************************************/ 
.................... int setupServer(void) 
.................... { 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
*
0970:  MOVLW  B5
0971:  MOVWF  0D
0972:  MOVLW  00
0973:  MOVWF  0F
0974:  BCF    03.6
0975:  CALL   000
....................    delay_ms(1000); 
0976:  MOVLW  04
0977:  BSF    03.6
0978:  MOVWF  45
0979:  MOVLW  FA
097A:  MOVWF  59
097B:  BCF    0A.3
097C:  BCF    03.6
097D:  CALL   515
097E:  BSF    0A.3
097F:  BSF    03.6
0980:  DECFSZ 45,F
0981:  GOTO   179
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
0982:  MOVLW  BC
0983:  MOVWF  0D
0984:  MOVLW  00
0985:  MOVWF  0F
0986:  BCF    03.6
0987:  CALL   000
....................    delay_ms(1000); 
0988:  MOVLW  04
0989:  BSF    03.6
098A:  MOVWF  45
098B:  MOVLW  FA
098C:  MOVWF  59
098D:  BCF    0A.3
098E:  BCF    03.6
098F:  CALL   515
0990:  BSF    0A.3
0991:  BSF    03.6
0992:  DECFSZ 45,F
0993:  GOTO   18B
....................    return CMD_CONN; 
0994:  MOVLW  03
0995:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
079F:  BSF    03.6
07A0:  CLRF   45
.................... { 
....................    int ret=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(flag_Resp_Valid==0){ 
07A1:  BCF    03.6
07A2:  MOVF   43,F
07A3:  BTFSS  03.2
07A4:  GOTO   7D6
....................     
....................       if(flag_Resp_CWJAP==1){ 
07A5:  DECFSZ 45,W
07A6:  GOTO   7AE
....................       // Comando doConnected Conectado a la red 
....................          flag_Pos_Resp_CWJAP  = 0; 
07A7:  CLRF   4B
....................          flag_Resp_CWJAP      = 0; 
07A8:  CLRF   45
....................          ret = 1; 
07A9:  MOVLW  01
07AA:  BSF    03.6
07AB:  MOVWF  45
....................  
....................       } else if(flag_Resp_NoAp==1){ 
07AC:  GOTO   7D4
07AD:  BCF    03.6
07AE:  DECFSZ 44,W
07AF:  GOTO   7B7
....................       // Comando doConnected No se ha asignado una red 
....................          flag_Pos_Resp_NoAp  = 0; 
07B0:  CLRF   4A
....................          flag_Resp_NoAp      = 0; 
07B1:  CLRF   44
....................          ret = 2; 
07B2:  MOVLW  02
07B3:  BSF    03.6
07B4:  MOVWF  45
....................  
....................       } else if (flag_Resp_Connected==1){ 
07B5:  GOTO   7D4
07B6:  BCF    03.6
07B7:  DECFSZ 46,W
07B8:  GOTO   7C0
....................       // Comando setupConn Conexion establecida 
....................          flag_Pos_Resp_Connected = 0; 
07B9:  CLRF   4C
....................          flag_Resp_Connected     = 0; 
07BA:  CLRF   46
....................          ret = 3; 
07BB:  MOVLW  03
07BC:  BSF    03.6
07BD:  MOVWF  45
....................  
....................       } else if(flag_Resp_Fail==1){ 
07BE:  GOTO   7D4
07BF:  BCF    03.6
07C0:  DECFSZ 47,W
07C1:  GOTO   7CB
....................       // Comando setupConn Fallo al intentar la Conexion 
....................       // Esta respuesta da como resultado un ERROR entonces 
....................       // Se rompe el ciclo de forma manual flag_Resp_Valid=1 
....................          flag_Pos_Resp_Fail   = 0; 
07C2:  CLRF   4D
....................          flag_Resp_Fail       = 0; 
07C3:  CLRF   47
....................          flag_Resp_Valid      = 1; 
07C4:  MOVLW  01
07C5:  MOVWF  43
....................          ret = 4; 
07C6:  MOVLW  04
07C7:  BSF    03.6
07C8:  MOVWF  45
....................       } else if(flag_Resp_Error==1){ 
07C9:  GOTO   7D4
07CA:  BCF    03.6
07CB:  DECFSZ 48,W
07CC:  GOTO   7D5
....................       // Comando Fallo 
....................       // Esta respuesta da como resultado un ERROR entonces 
....................       // Se rompe el ciclo de forma manual flag_Resp_Valid=1 
....................          flag_Pos_Resp_Error  = 0; 
07CD:  CLRF   4E
....................          flag_Resp_Error      = 0; 
07CE:  CLRF   48
....................          flag_Resp_Valid      = 1; 
07CF:  MOVLW  01
07D0:  MOVWF  43
....................          ret = 5; 
07D1:  MOVLW  05
07D2:  BSF    03.6
07D3:  MOVWF  45
07D4:  BCF    03.6
....................       } 
07D5:  GOTO   7A2
....................    }; // Fin del loop 
....................    flag_Resp_Valid = 0; 
07D6:  CLRF   43
....................    CMD_RUN = 0x00; 
07D7:  CLRF   41
....................    return ret; 
07D8:  BSF    03.6
07D9:  MOVF   45,W
07DA:  MOVWF  78
07DB:  BCF    03.6
07DC:  RETURN
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
....................  
.................... void waitRespOK(int buffer) 
*
0396:  MOVLW  04
0397:  BSF    03.6
0398:  MOVWF  65
.................... { 
....................    const char ESP8266_RESP_OK[4] ={'O','K',0x0D,0x0A}; 
....................    int lenResp = 4; 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_OK[flag_Pos_Resp]) 
0399:  BCF    03.6
039A:  MOVF   49,W
039B:  CALL   051
039C:  MOVWF  78
039D:  BSF    03.6
039E:  SUBWF  64,W
039F:  BTFSS  03.2
03A0:  GOTO   3AF
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp++; 
03A1:  BCF    03.6
03A2:  INCF   49,F
....................        
....................       if(flag_Pos_Resp==lenResp){ 
03A3:  BSF    03.6
03A4:  MOVF   65,W
03A5:  BCF    03.6
03A6:  SUBWF  49,W
03A7:  BTFSS  03.2
03A8:  GOTO   3AC
....................          // Respuesta es valida 
....................          flag_Resp_Valid   = 1; 
03A9:  MOVLW  01
03AA:  MOVWF  43
....................       }else{ 
03AB:  GOTO   3AD
....................          // Reinicia la bandera para asegurar la integridad de la respesta 
....................          flag_Resp_Valid   = 0; 
03AC:  CLRF   43
....................       } 
....................  
....................    }else{ 
03AD:  GOTO   3B2
03AE:  BSF    03.6
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       flag_Pos_Resp     = 0; 
03AF:  BCF    03.6
03B0:  CLRF   49
....................       // Como esta funcion es el ultimo caracter recibido no es necesario mantener  
....................       // Activa la bandera flag_Resp_Valid 
....................       flag_Resp_Valid   = 0; 
03B1:  CLRF   43
....................    } 
03B2:  RETURN
.................... } // Fin de la funcion waitRespOK() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_NoAp (Sin conexion) 
.................... *********************************************************/ 
.................... void waitRespNoAp(int buffer) 
*
03D4:  MOVLW  05
03D5:  MOVWF  65
.................... { 
....................    const char ESP8266_RESP_NoAP[5] ={'N', 'o', ' ', 'A', 'P'}; 
....................    int lenResp = 5; 
....................     
....................    if(buffer == ESP8266_RESP_NoAp[flag_Pos_Resp_NoAp] ) 
03D6:  BCF    03.6
03D7:  MOVF   4A,W
03D8:  CALL   059
03D9:  MOVWF  78
03DA:  BSF    03.6
03DB:  SUBWF  64,W
03DC:  BTFSS  03.2
03DD:  GOTO   3EA
....................    { 
....................       flag_Pos_Resp_NoAp++; 
03DE:  BCF    03.6
03DF:  INCF   4A,F
....................        
....................       if(flag_Pos_Resp_NoAp==lenResp){ 
03E0:  BSF    03.6
03E1:  MOVF   65,W
03E2:  BCF    03.6
03E3:  SUBWF  4A,W
03E4:  BTFSS  03.2
03E5:  GOTO   3E8
....................          // Respuesta es valida 
....................          flag_Resp_NoAp   = 1; 
03E6:  MOVLW  01
03E7:  MOVWF  44
....................       } 
....................    }else{ 
03E8:  GOTO   3EC
03E9:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_NoAp  = 0; 
03EA:  BCF    03.6
03EB:  CLRF   4A
....................    } 
.................... } // Fin de la funcion waitRespNoAp() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_CWJAP (Conectado) 
.................... *********************************************************/ 
.................... void waitRespCWJAP(int buffer) 
*
03EF:  MOVLW  07
03F0:  MOVWF  65
.................... { 
....................    const char ESP8266_RESP_CWJAP[7] ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
....................    int lenResp = 7; 
....................  
....................    if(buffer == ESP8266_RESP_CWJAP[flag_Pos_Resp_CWJAP] ) 
03F1:  BCF    03.6
03F2:  MOVF   4B,W
03F3:  CALL   062
03F4:  MOVWF  78
03F5:  BSF    03.6
03F6:  SUBWF  64,W
03F7:  BTFSS  03.2
03F8:  GOTO   405
....................    { 
....................       flag_Pos_Resp_CWJAP++; 
03F9:  BCF    03.6
03FA:  INCF   4B,F
....................        
....................       if(flag_Pos_Resp_CWJAP==lenResp){ 
03FB:  BSF    03.6
03FC:  MOVF   65,W
03FD:  BCF    03.6
03FE:  SUBWF  4B,W
03FF:  BTFSS  03.2
0400:  GOTO   403
....................          // Respuesta es valida 
....................          flag_Resp_CWJAP   = 1; 
0401:  MOVLW  01
0402:  MOVWF  45
....................       } 
....................    }else { 
0403:  GOTO   407
0404:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_CWJAP = 0; 
0405:  BCF    03.6
0406:  CLRF   4B
....................    } 
....................     
.................... } // Fin de la funcion waitRespCWJAP() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "setupConn" 
....................  *    ESP8266_RESP_Connected (Conectado) 
.................... *********************************************************/ 
.................... void waitRespConnected(int buffer) 
*
0410:  MOVLW  09
0411:  MOVWF  65
.................... { 
....................    const char ESP8266_RESP_Connected[9] ={'C','O','N','N','E','C','T','E','D'}; 
....................    int lenResp = 9; 
....................   
....................    if(buffer == ESP8266_RESP_Connected[flag_Pos_Resp_Connected] ) 
0412:  BCF    03.6
0413:  MOVF   4C,W
0414:  CALL   06D
0415:  MOVWF  78
0416:  BSF    03.6
0417:  SUBWF  64,W
0418:  BTFSS  03.2
0419:  GOTO   426
....................    { 
....................       flag_Pos_Resp_Connected++; 
041A:  BCF    03.6
041B:  INCF   4C,F
....................        
....................       if(flag_Pos_Resp_Connected==lenResp){ 
041C:  BSF    03.6
041D:  MOVF   65,W
041E:  BCF    03.6
041F:  SUBWF  4C,W
0420:  BTFSS  03.2
0421:  GOTO   424
....................          // Respuesta es valida 
....................          flag_Resp_Connected   = 1; 
0422:  MOVLW  01
0423:  MOVWF  46
....................       } 
....................    }else{ 
0424:  GOTO   428
0425:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Connected = 0; 
0426:  BCF    03.6
0427:  CLRF   4C
....................    } 
.................... } // Fin de la funcion waitRespConnected() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "setupConn" 
....................  *    ESP8266_RESP_FAIL (Fallo al intentar conectarse) 
.................... *********************************************************/ 
.................... void waitRespFail(int buffer) 
*
042B:  MOVLW  04
042C:  MOVWF  65
.................... { 
....................    const char ESP8266_RESP_FAIL[4] ={'F', 'A', 'I', 'L'}; 
....................    int lenResp = 4; 
....................   
....................    if(buffer == ESP8266_RESP_FAIL[flag_Pos_Resp_Fail] ) 
042D:  BCF    03.6
042E:  MOVF   4D,W
042F:  CALL   07A
0430:  MOVWF  78
0431:  BSF    03.6
0432:  SUBWF  64,W
0433:  BTFSS  03.2
0434:  GOTO   441
....................    { 
....................       flag_Pos_Resp_Fail++; 
0435:  BCF    03.6
0436:  INCF   4D,F
....................        
....................       if(flag_Pos_Resp_Fail==lenResp){ 
0437:  BSF    03.6
0438:  MOVF   65,W
0439:  BCF    03.6
043A:  SUBWF  4D,W
043B:  BTFSS  03.2
043C:  GOTO   43F
....................          // Respuesta es valida 
....................          flag_Resp_Fail   = 1; 
043D:  MOVLW  01
043E:  MOVWF  47
....................       } 
....................    }else{ 
043F:  GOTO   443
0440:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Fail  = 0; 
0441:  BCF    03.6
0442:  CLRF   4D
....................    } 
.................... } // Fin de la funcion waitRespFail() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta "ERROR" 
....................  *    ESP8266_RESP_ERROR (Fallo al lanzar el comando) 
.................... *********************************************************/ 
.................... void waitRespError(int buffer) 
*
0446:  MOVLW  05
0447:  MOVWF  65
.................... { 
....................    const char ESP8266_RESP_ERROR[5] ={'E', 'R', 'R', 'O', 'R'}; 
....................    int lenResp = 5; 
....................   
....................    if(buffer == ESP8266_RESP_ERROR[flag_Pos_Resp_Error] ) 
0448:  BCF    03.6
0449:  MOVF   4E,W
044A:  CALL   082
044B:  MOVWF  78
044C:  BSF    03.6
044D:  SUBWF  64,W
044E:  BTFSS  03.2
044F:  GOTO   45C
....................    { 
....................       flag_Pos_Resp_Error++; 
0450:  BCF    03.6
0451:  INCF   4E,F
....................        
....................       if(flag_Pos_Resp_Error==lenResp){ 
0452:  BSF    03.6
0453:  MOVF   65,W
0454:  BCF    03.6
0455:  SUBWF  4E,W
0456:  BTFSS  03.2
0457:  GOTO   45A
....................          // Respuesta es valida 
....................          flag_Resp_Error   = 1; 
0458:  MOVLW  01
0459:  MOVWF  48
....................       } 
....................    }else{ 
045A:  GOTO   45E
045B:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Error  = 0; 
045C:  BCF    03.6
045D:  CLRF   4E
....................    } 
.................... } // Fin de la funcion waitRespError() 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /***************************************************************** 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... ****************************************************************** 
....................  
.................... ******************************************** 
.................... *   Formato de comando en la respuesta:    * 
.................... *   INICIO:COMANDO:DATOS:<-(FIN)           * 
.................... *   e.g. CMD:CMD_SSID_AND_PASS,DATA:       * 
.................... ******************************************** 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:OP,[op][port]:                 | 
.................... |-----------------------------------------------| 
.................... |> Realiaza Operaciones en el Puerto de Salida  | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,[1|0][0-7]:                       | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      op:    1   -> Encender                   | 
.................... |             0   -> Apagar                     | 
.................... |      port:  0-7 -> No. del puerto.            | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,10:  Enciende el PORT 0        | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NC,"SSID","KEY":               | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el SSID y Key de la    | 
.................... |  Red donde se conectara.                      | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NC,"SSID","KEY":                     | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      SSID:  "Nombre de la Red."               | 
.................... |                                               | 
.................... |      KEY:   "Clave."                          | 
.................... |                                               | 
.................... |** @e.g. CMD:NC,"myRed","12345678":            | 
.................... | Intentara conectarse y almacenar en la eeprom | 
.................... | al nombre de la red con key pasados como      | 
.................... | parametro.                                    | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NM,[ModeConection]:            | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el modo de la conexion | 
.................... |                                               | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NM,[1|2|3]:                          | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      ModeConection:  "1" -> STA               | 
.................... |                      "2" -> AP                | 
.................... |                      "3" -> STA/AP            | 
.................... |                                               | 
.................... |** @e.g. CMD:NM,3:                             | 
.................... |                                               | 
.................... +-----------------------------------------------+ 
.................... */ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio recepcion de request,  
.................... y retorna el ID de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
046A:  MOVLW  05
046B:  MOVWF  65
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
046C:  BCF    03.6
046D:  DECFSZ 57,W
046E:  GOTO   487
....................        
....................       if(buffer!=','){ 
046F:  BSF    03.6
0470:  MOVF   63,W
0471:  SUBLW  2C
0472:  BTFSS  03.2
0473:  GOTO   477
0474:  MOVF   64,F
0475:  BTFSC  03.2
0476:  GOTO   483
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
0477:  MOVLW  50
0478:  BCF    03.6
0479:  ADDWF  5B,W
047A:  MOVWF  04
047B:  BCF    03.7
047C:  BSF    03.6
047D:  MOVF   63,W
047E:  MOVWF  00
....................          flag_Pos_Resp_IPD++; 
047F:  BCF    03.6
0480:  INCF   5B,F
....................       }else{ 
0481:  GOTO   486
0482:  BSF    03.6
....................          flag_Pos_Resp_IPD       = 0x00; 
0483:  BCF    03.6
0484:  CLRF   5B
....................          flag_Resp_IPD           = 0x00; 
0485:  CLRF   57
....................       } 
....................    }else{ 
0486:  GOTO   4A0
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
0487:  MOVF   5B,W
0488:  CALL   08B
0489:  MOVWF  78
048A:  BSF    03.6
048B:  SUBWF  63,W
048C:  BTFSS  03.2
048D:  GOTO   49E
048E:  MOVF   64,F
048F:  BTFSS  03.2
0490:  GOTO   49E
....................       { 
....................          flag_Pos_Resp_IPD++; 
0491:  BCF    03.6
0492:  INCF   5B,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
0493:  BSF    03.6
0494:  MOVF   65,W
0495:  BCF    03.6
0496:  SUBWF  5B,W
0497:  BTFSS  03.2
0498:  GOTO   49C
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
0499:  MOVLW  01
049A:  MOVWF  57
....................             flag_Pos_Resp_IPD = 0; 
049B:  CLRF   5B
....................          } 
....................       }else{ 
049C:  GOTO   4A0
049D:  BSF    03.6
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
049E:  BCF    03.6
049F:  CLRF   5B
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio comando,  
.................... y retorna el Comando enviado, Activa la bandera 
.................... de recepcion de datos 
.................... *********************************************************/ 
....................  
.................... void ESP8266_Get_CMD(char buffer[]){ 
*
04A4:  MOVLW  04
04A5:  MOVWF  65
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
04A6:  BCF    03.6
04A7:  DECFSZ 56,W
04A8:  GOTO   4C3
....................     
....................       if(buffer!=','){ 
04A9:  BSF    03.6
04AA:  MOVF   63,W
04AB:  SUBLW  2C
04AC:  BTFSS  03.2
04AD:  GOTO   4B1
04AE:  MOVF   64,F
04AF:  BTFSC  03.2
04B0:  GOTO   4BD
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
04B1:  MOVLW  52
04B2:  BCF    03.6
04B3:  ADDWF  5A,W
04B4:  MOVWF  04
04B5:  BCF    03.7
04B6:  BSF    03.6
04B7:  MOVF   63,W
04B8:  MOVWF  00
....................          flag_Pos_Resp_CMD++; 
04B9:  BCF    03.6
04BA:  INCF   5A,F
....................       }else{         
04BB:  GOTO   4C2
04BC:  BSF    03.6
....................          flag_Pos_Resp_CMD = 0x00; 
04BD:  BCF    03.6
04BE:  CLRF   5A
....................          flag_Resp_CMD     = 0x00; 
04BF:  CLRF   56
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
04C0:  MOVLW  01
04C1:  MOVWF  58
....................       } 
....................        
....................    }else{ 
04C2:  GOTO   4DC
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
04C3:  MOVF   5A,W
04C4:  CALL   094
04C5:  MOVWF  78
04C6:  BSF    03.6
04C7:  SUBWF  63,W
04C8:  BTFSS  03.2
04C9:  GOTO   4DA
04CA:  MOVF   64,F
04CB:  BTFSS  03.2
04CC:  GOTO   4DA
....................       { 
....................          flag_Pos_Resp_CMD++; 
04CD:  BCF    03.6
04CE:  INCF   5A,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
04CF:  BSF    03.6
04D0:  MOVF   65,W
04D1:  BCF    03.6
04D2:  SUBWF  5A,W
04D3:  BTFSS  03.2
04D4:  GOTO   4D8
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
04D5:  MOVLW  01
04D6:  MOVWF  56
....................             flag_Pos_Resp_CMD = 0; 
04D7:  CLRF   5A
....................          } 
....................       }else{ 
04D8:  GOTO   4DC
04D9:  BSF    03.6
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
04DA:  BCF    03.6
04DB:  CLRF   5A
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion Verifica si la bandera de recepcion de datos esta 
.................... activa y almacena los datos entrantes en el arreglo 
.................... DATA_COMMAND, Finaliza la captura de caracteres cuando 
.................... encuentra el caracter ":". 
.................... Envia al ESP8266 el fin de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
*
04E0:  BCF    03.6
04E1:  DECFSZ 58,W
04E2:  GOTO   511
....................       if(buffer!=':'){ 
04E3:  BSF    03.6
04E4:  MOVF   63,W
04E5:  SUBLW  3A
04E6:  BTFSS  03.2
04E7:  GOTO   4EB
04E8:  MOVF   64,F
04E9:  BTFSC  03.2
04EA:  GOTO   50C
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
04EB:  MOVLW  10
04EC:  BCF    03.6
04ED:  ADDWF  5C,W
04EE:  MOVWF  04
04EF:  BSF    03.7
04F0:  BSF    03.6
04F1:  MOVF   63,W
04F2:  MOVWF  00
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
04F3:  BCF    03.6
04F4:  CLRF   55
04F5:  MOVF   5C,W
04F6:  MOVWF  54
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
04F7:  MOVF   5C,F
04F8:  BTFSS  03.2
04F9:  GOTO   509
04FA:  BSF    03.6
04FB:  MOVF   63,W
04FC:  SUBLW  2C
04FD:  BTFSC  03.2
04FE:  GOTO   501
04FF:  BCF    03.6
0500:  GOTO   509
0501:  MOVF   64,F
0502:  BTFSC  03.2
0503:  GOTO   506
0504:  BCF    03.6
0505:  GOTO   509
....................             flag_Pos_Resp_Data=0; 
0506:  BCF    03.6
0507:  CLRF   5C
....................          }else{ 
0508:  GOTO   50A
....................             flag_Pos_Resp_Data++; 
0509:  INCF   5C,F
....................          } 
....................           
....................       }else{ 
050A:  GOTO   511
050B:  BSF    03.6
....................          flag_Pos_Resp_Data      = 0x00; 
050C:  BCF    03.6
050D:  CLRF   5C
....................          flag_Resp_StartGetData  = 0x00; 
050E:  CLRF   58
....................          flag_Resp_Ready         = 1; 
050F:  MOVLW  01
0510:  MOVWF  59
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
.................... } 
....................  
.................... int run_command_wifi(void){ 
*
0A7B:  BSF    03.6
0A7C:  CLRF   47
0A7D:  CLRF   48
....................    int8 ret = 0, optSelected = 0; 
....................    char ESP8266_Resp[13] = {'{','"','c','m','d','"',':','"','o','k','"','}'}; 
0A7E:  MOVLW  7B
0A7F:  MOVWF  49
0A80:  MOVLW  22
0A81:  MOVWF  4A
0A82:  MOVLW  63
0A83:  MOVWF  4B
0A84:  MOVLW  6D
0A85:  MOVWF  4C
0A86:  MOVLW  64
0A87:  MOVWF  4D
0A88:  MOVLW  22
0A89:  MOVWF  4E
0A8A:  MOVLW  3A
0A8B:  MOVWF  4F
0A8C:  MOVLW  22
0A8D:  MOVWF  50
0A8E:  MOVLW  6F
0A8F:  MOVWF  51
0A90:  MOVLW  6B
0A91:  MOVWF  52
0A92:  MOVLW  22
0A93:  MOVWF  53
0A94:  MOVLW  7D
0A95:  MOVWF  54
0A96:  CLRF   55
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
0A97:  BCF    03.6
0A98:  DECFSZ 59,W
0A99:  GOTO   515
....................        
....................       /************************** 
....................       *** Accede a las Salidas ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
0A9A:  MOVF   52,W
0A9B:  SUBLW  4F
0A9C:  BTFSS  03.2
0A9D:  GOTO   2F3
0A9E:  MOVF   53,W
0A9F:  SUBLW  50
0AA0:  BTFSS  03.2
0AA1:  GOTO   2F3
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
0AA2:  MOVLW  30
0AA3:  BSF    03.6
0AA4:  SUBWF  11,W
0AA5:  MOVWF  48
....................           
....................          switch(DATA_COMMAND[0]){ 
0AA6:  MOVF   10,W
0AA7:  XORLW  30
0AA8:  BCF    03.6
0AA9:  BTFSC  03.2
0AAA:  GOTO   2AF
0AAB:  XORLW  01
0AAC:  BTFSC  03.2
0AAD:  GOTO   2CF
0AAE:  GOTO   2EF
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
0AAF:  BCF    03.0
0AB0:  BSF    03.6
0AB1:  RLF    48,W
0AB2:  ADDLW  2B
0AB3:  MOVWF  04
0AB4:  BCF    03.7
0AB5:  INCF   04,F
0AB6:  MOVF   00,W
0AB7:  MOVWF  59
0AB8:  DECF   04,F
0AB9:  MOVF   00,W
0ABA:  MOVWF  58
0ABB:  MOVWF  5A
0ABC:  CLRF   5B
0ABD:  CLRF   5D
0ABE:  CLRF   5C
0ABF:  BCF    0A.3
0AC0:  BCF    03.6
0AC1:  CALL   7DD
0AC2:  BSF    0A.3
0AC3:  BSF    03.6
0AC4:  MOVF   58,W
0AC5:  MOVWF  5A
0AC6:  CLRF   5B
0AC7:  CLRF   5D
0AC8:  MOVLW  80
0AC9:  MOVWF  5C
0ACA:  BCF    0A.3
0ACB:  BCF    03.6
0ACC:  CALL   7DD
0ACD:  BSF    0A.3
....................                break; 
0ACE:  GOTO   2EF
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
0ACF:  BCF    03.0
0AD0:  BSF    03.6
0AD1:  RLF    48,W
0AD2:  ADDLW  2B
0AD3:  MOVWF  04
0AD4:  BCF    03.7
0AD5:  INCF   04,F
0AD6:  MOVF   00,W
0AD7:  MOVWF  59
0AD8:  DECF   04,F
0AD9:  MOVF   00,W
0ADA:  MOVWF  58
0ADB:  MOVWF  5A
0ADC:  MOVLW  01
0ADD:  MOVWF  5B
0ADE:  CLRF   5D
0ADF:  CLRF   5C
0AE0:  BCF    0A.3
0AE1:  BCF    03.6
0AE2:  CALL   7DD
0AE3:  BSF    0A.3
0AE4:  BSF    03.6
0AE5:  MOVF   58,W
0AE6:  MOVWF  5A
0AE7:  CLRF   5B
0AE8:  CLRF   5D
0AE9:  MOVLW  80
0AEA:  MOVWF  5C
0AEB:  BCF    0A.3
0AEC:  BCF    03.6
0AED:  CALL   7DD
0AEE:  BSF    0A.3
....................                break; 
....................          } 
....................           
....................          ret = 1; 
0AEF:  MOVLW  01
0AF0:  BSF    03.6
0AF1:  MOVWF  47
0AF2:  BCF    03.6
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
0AF3:  MOVF   52,W
0AF4:  SUBLW  4E
0AF5:  BTFSS  03.2
0AF6:  GOTO   3FD
0AF7:  MOVF   53,W
0AF8:  SUBLW  43
0AF9:  BTFSS  03.2
0AFA:  GOTO   3FD
....................       { 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
0AFB:  BSF    03.6
0AFC:  CLRF   56
0AFD:  BCF    03.6
0AFE:  MOVF   55,F
0AFF:  BTFSS  03.2
0B00:  GOTO   307
0B01:  BSF    03.6
0B02:  MOVF   56,W
0B03:  BCF    03.6
0B04:  SUBWF  54,W
0B05:  BTFSS  03.0
0B06:  GOTO   334
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
0B07:  MOVLW  01
0B08:  BSF    03.6
0B09:  ADDWF  56,W
0B0A:  MOVWF  58
0B0B:  MOVLW  10
0B0C:  ADDWF  56,W
0B0D:  MOVWF  04
0B0E:  BSF    03.7
0B0F:  MOVF   00,W
0B10:  MOVWF  59
0B11:  BCF    03.6
0B12:  MOVF   0B,W
0B13:  MOVWF  77
0B14:  BCF    0B.7
0B15:  BSF    03.6
0B16:  MOVF   58,W
0B17:  MOVWF  0D
0B18:  MOVF   59,W
0B19:  MOVWF  0C
0B1A:  BSF    03.5
0B1B:  BCF    0C.7
0B1C:  BSF    0C.2
0B1D:  MOVLW  55
0B1E:  MOVWF  0D
0B1F:  MOVLW  AA
0B20:  MOVWF  0D
0B21:  BSF    0C.1
0B22:  BTFSC  0C.1
0B23:  GOTO   322
0B24:  BCF    0C.2
0B25:  MOVF   77,W
0B26:  BCF    03.5
0B27:  BCF    03.6
0B28:  IORWF  0B,F
....................             delay_ms(10); 
0B29:  MOVLW  0A
0B2A:  BSF    03.6
0B2B:  MOVWF  59
0B2C:  BCF    0A.3
0B2D:  BCF    03.6
0B2E:  CALL   515
0B2F:  BSF    0A.3
0B30:  BSF    03.6
0B31:  INCF   56,F
0B32:  GOTO   2FD
0B33:  BCF    03.6
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
0B34:  MOVLW  01
0B35:  BSF    03.6
0B36:  ADDWF  56,W
0B37:  MOVWF  58
0B38:  BCF    03.6
0B39:  MOVF   0B,W
0B3A:  MOVWF  77
0B3B:  BCF    0B.7
0B3C:  BSF    03.6
0B3D:  MOVF   58,W
0B3E:  MOVWF  0D
0B3F:  MOVLW  0D
0B40:  MOVWF  0C
0B41:  BSF    03.5
0B42:  BCF    0C.7
0B43:  BSF    0C.2
0B44:  MOVLW  55
0B45:  MOVWF  0D
0B46:  MOVLW  AA
0B47:  MOVWF  0D
0B48:  BSF    0C.1
0B49:  BTFSC  0C.1
0B4A:  GOTO   349
0B4B:  BCF    0C.2
0B4C:  MOVF   77,W
0B4D:  BCF    03.5
0B4E:  BCF    03.6
0B4F:  IORWF  0B,F
....................          delay_ms(10); 
0B50:  MOVLW  0A
0B51:  BSF    03.6
0B52:  MOVWF  59
0B53:  BCF    0A.3
0B54:  BCF    03.6
0B55:  CALL   515
0B56:  BSF    0A.3
....................          write_eeprom(idxNC+2,0x0A); 
0B57:  MOVLW  02
0B58:  BSF    03.6
0B59:  ADDWF  56,W
0B5A:  MOVWF  58
0B5B:  BCF    03.6
0B5C:  MOVF   0B,W
0B5D:  MOVWF  77
0B5E:  BCF    0B.7
0B5F:  BSF    03.6
0B60:  MOVF   58,W
0B61:  MOVWF  0D
0B62:  MOVLW  0A
0B63:  MOVWF  0C
0B64:  BSF    03.5
0B65:  BCF    0C.7
0B66:  BSF    0C.2
0B67:  MOVLW  55
0B68:  MOVWF  0D
0B69:  MOVLW  AA
0B6A:  MOVWF  0D
0B6B:  BSF    0C.1
0B6C:  BTFSC  0C.1
0B6D:  GOTO   36C
0B6E:  BCF    0C.2
0B6F:  MOVF   77,W
0B70:  BCF    03.5
0B71:  BCF    03.6
0B72:  IORWF  0B,F
....................          delay_ms(10); 
0B73:  MOVLW  0A
0B74:  BSF    03.6
0B75:  MOVWF  59
0B76:  BCF    0A.3
0B77:  BCF    03.6
0B78:  CALL   515
0B79:  BSF    0A.3
....................  
....................          // Responde la solicitud 
....................          delay_ms(20); 
0B7A:  MOVLW  14
0B7B:  BSF    03.6
0B7C:  MOVWF  59
0B7D:  BCF    0A.3
0B7E:  BCF    03.6
0B7F:  CALL   515
0B80:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0B81:  MOVLW  C6
0B82:  BSF    03.6
0B83:  MOVWF  0D
0B84:  MOVLW  00
0B85:  MOVWF  0F
0B86:  BCF    03.0
0B87:  MOVLW  0B
0B88:  MOVWF  58
0B89:  BCF    0A.3
0B8A:  BCF    03.6
0B8B:  CALL   749
0B8C:  BSF    0A.3
0B8D:  MOVF   50,W
0B8E:  BTFSS  0C.4
0B8F:  GOTO   38E
0B90:  MOVWF  19
0B91:  MOVLW  CC
0B92:  BSF    03.6
0B93:  MOVWF  0D
0B94:  MOVLW  00
0B95:  MOVWF  0F
0B96:  BSF    03.0
0B97:  MOVLW  05
0B98:  MOVWF  58
0B99:  BCF    0A.3
0B9A:  BCF    03.6
0B9B:  CALL   749
0B9C:  BSF    0A.3
....................          delay_ms(50); 
0B9D:  MOVLW  32
0B9E:  BSF    03.6
0B9F:  MOVWF  59
0BA0:  BCF    0A.3
0BA1:  BCF    03.6
0BA2:  CALL   515
0BA3:  BSF    0A.3
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
0BA4:  MOVLW  49
0BA5:  MOVWF  04
0BA6:  BSF    03.7
....................          delay_ms(100); 
*
0BC4:  MOVLW  64
0BC5:  BSF    03.6
0BC6:  MOVWF  59
0BC7:  BCF    0A.3
0BC8:  BCF    03.6
0BC9:  CALL   515
0BCA:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0BCB:  MOVLW  D0
0BCC:  BSF    03.6
0BCD:  MOVWF  0D
0BCE:  MOVLW  00
0BCF:  MOVWF  0F
0BD0:  BCF    03.0
0BD1:  MOVLW  0C
0BD2:  MOVWF  58
0BD3:  BCF    0A.3
0BD4:  BCF    03.6
0BD5:  CALL   749
0BD6:  BSF    0A.3
0BD7:  MOVF   50,W
0BD8:  BTFSS  0C.4
0BD9:  GOTO   3D8
0BDA:  MOVWF  19
0BDB:  MOVLW  0D
0BDC:  BTFSS  0C.4
0BDD:  GOTO   3DC
0BDE:  MOVWF  19
0BDF:  MOVLW  0A
0BE0:  BTFSS  0C.4
0BE1:  GOTO   3E0
0BE2:  MOVWF  19
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
0BE3:  MOVLW  D9
0BE4:  BSF    03.6
0BE5:  MOVWF  0D
0BE6:  MOVLW  00
0BE7:  MOVWF  0F
0BE8:  BCF    03.6
0BE9:  CALL   000
....................          delay_ms(1000); 
0BEA:  MOVLW  04
0BEB:  BSF    03.6
0BEC:  MOVWF  58
0BED:  MOVLW  FA
0BEE:  MOVWF  59
0BEF:  BCF    0A.3
0BF0:  BCF    03.6
0BF1:  CALL   515
0BF2:  BSF    0A.3
0BF3:  BSF    03.6
0BF4:  DECFSZ 58,F
0BF5:  GOTO   3ED
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
0BF6:  CLRF   0A
0BF7:  BCF    03.6
0BF8:  GOTO   000
....................          ret = 1; 
0BF9:  MOVLW  01
0BFA:  BSF    03.6
0BFB:  MOVWF  47
0BFC:  BCF    03.6
....................       } // Fin comando NC 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
0BFD:  MOVF   52,W
0BFE:  SUBLW  4E
0BFF:  BTFSS  03.2
0C00:  GOTO   491
0C01:  MOVF   53,W
0C02:  SUBLW  4D
0C03:  BTFSS  03.2
0C04:  GOTO   491
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
0C05:  MOVF   0B,W
0C06:  MOVWF  77
0C07:  BCF    0B.7
0C08:  BSF    03.6
0C09:  CLRF   0D
0C0A:  MOVF   10,W
0C0B:  MOVWF  0C
0C0C:  BSF    03.5
0C0D:  BCF    0C.7
0C0E:  BSF    0C.2
0C0F:  MOVLW  55
0C10:  MOVWF  0D
0C11:  MOVLW  AA
0C12:  MOVWF  0D
0C13:  BSF    0C.1
0C14:  BTFSC  0C.1
0C15:  GOTO   414
0C16:  BCF    0C.2
0C17:  MOVF   77,W
0C18:  BCF    03.5
0C19:  BCF    03.6
0C1A:  IORWF  0B,F
....................          delay_ms(10); 
0C1B:  MOVLW  0A
0C1C:  BSF    03.6
0C1D:  MOVWF  59
0C1E:  BCF    0A.3
0C1F:  BCF    03.6
0C20:  CALL   515
0C21:  BSF    0A.3
....................           
....................          // Responde la solicitud 
....................          delay_ms(20); 
0C22:  MOVLW  14
0C23:  BSF    03.6
0C24:  MOVWF  59
0C25:  BCF    0A.3
0C26:  BCF    03.6
0C27:  CALL   515
0C28:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0C29:  MOVLW  DF
0C2A:  BSF    03.6
0C2B:  MOVWF  0D
0C2C:  MOVLW  00
0C2D:  MOVWF  0F
0C2E:  BCF    03.0
0C2F:  MOVLW  0B
0C30:  MOVWF  58
0C31:  BCF    0A.3
0C32:  BCF    03.6
0C33:  CALL   749
0C34:  BSF    0A.3
0C35:  MOVF   50,W
0C36:  BTFSS  0C.4
0C37:  GOTO   436
0C38:  MOVWF  19
0C39:  MOVLW  E5
0C3A:  BSF    03.6
0C3B:  MOVWF  0D
0C3C:  MOVLW  00
0C3D:  MOVWF  0F
0C3E:  BSF    03.0
0C3F:  MOVLW  05
0C40:  MOVWF  58
0C41:  BCF    0A.3
0C42:  BCF    03.6
0C43:  CALL   749
0C44:  BSF    0A.3
....................          delay_ms(50); 
0C45:  MOVLW  32
0C46:  BSF    03.6
0C47:  MOVWF  59
0C48:  BCF    0A.3
0C49:  BCF    03.6
0C4A:  CALL   515
0C4B:  BSF    0A.3
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
0C4C:  MOVLW  49
0C4D:  MOVWF  04
0C4E:  BSF    03.7
....................          delay_ms(100); 
*
0C6C:  MOVLW  64
0C6D:  BSF    03.6
0C6E:  MOVWF  59
0C6F:  BCF    0A.3
0C70:  BCF    03.6
0C71:  CALL   515
0C72:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0C73:  MOVLW  E9
0C74:  BSF    03.6
0C75:  MOVWF  0D
0C76:  MOVLW  00
0C77:  MOVWF  0F
0C78:  BCF    03.0
0C79:  MOVLW  0C
0C7A:  MOVWF  58
0C7B:  BCF    0A.3
0C7C:  BCF    03.6
0C7D:  CALL   749
0C7E:  BSF    0A.3
0C7F:  MOVF   50,W
0C80:  BTFSS  0C.4
0C81:  GOTO   480
0C82:  MOVWF  19
0C83:  MOVLW  0D
0C84:  BTFSS  0C.4
0C85:  GOTO   484
0C86:  MOVWF  19
0C87:  MOVLW  0A
0C88:  BTFSS  0C.4
0C89:  GOTO   488
0C8A:  MOVWF  19
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
0C8B:  CLRF   0A
0C8C:  GOTO   000
....................           
....................          ret = 1; 
0C8D:  MOVLW  01
0C8E:  BSF    03.6
0C8F:  MOVWF  47
0C90:  BCF    03.6
....................       } // Fin comando OP 
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................        
....................       // Responde la solicitud 
....................       delay_ms(20); 
0C91:  MOVLW  14
0C92:  BSF    03.6
0C93:  MOVWF  59
0C94:  BCF    0A.3
0C95:  BCF    03.6
0C96:  CALL   515
0C97:  BSF    0A.3
....................       fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0C98:  MOVLW  F2
0C99:  BSF    03.6
0C9A:  MOVWF  0D
0C9B:  MOVLW  00
0C9C:  MOVWF  0F
0C9D:  BCF    03.0
0C9E:  MOVLW  0B
0C9F:  MOVWF  58
0CA0:  BCF    0A.3
0CA1:  BCF    03.6
0CA2:  CALL   749
0CA3:  BSF    0A.3
0CA4:  MOVF   50,W
0CA5:  BTFSS  0C.4
0CA6:  GOTO   4A5
0CA7:  MOVWF  19
0CA8:  MOVLW  F8
0CA9:  BSF    03.6
0CAA:  MOVWF  0D
0CAB:  MOVLW  00
0CAC:  MOVWF  0F
0CAD:  BSF    03.0
0CAE:  MOVLW  05
0CAF:  MOVWF  58
0CB0:  BCF    0A.3
0CB1:  BCF    03.6
0CB2:  CALL   749
0CB3:  BSF    0A.3
....................       delay_ms(50); 
0CB4:  MOVLW  32
0CB5:  BSF    03.6
0CB6:  MOVWF  59
0CB7:  BCF    0A.3
0CB8:  BCF    03.6
0CB9:  CALL   515
0CBA:  BSF    0A.3
....................       fprintf(ESP8266, "%s",ESP8266_Resp); 
0CBB:  MOVLW  49
0CBC:  MOVWF  04
0CBD:  BSF    03.7
....................       delay_ms(100); 
*
0CDB:  MOVLW  64
0CDC:  BSF    03.6
0CDD:  MOVWF  59
0CDE:  BCF    0A.3
0CDF:  BCF    03.6
0CE0:  CALL   515
0CE1:  BSF    0A.3
....................       fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0CE2:  MOVLW  FC
0CE3:  BSF    03.6
0CE4:  MOVWF  0D
0CE5:  MOVLW  00
0CE6:  MOVWF  0F
0CE7:  BCF    03.0
0CE8:  MOVLW  0C
0CE9:  MOVWF  58
0CEA:  BCF    0A.3
0CEB:  BCF    03.6
0CEC:  CALL   749
0CED:  BSF    0A.3
0CEE:  MOVF   50,W
0CEF:  BTFSS  0C.4
0CF0:  GOTO   4EF
0CF1:  MOVWF  19
0CF2:  MOVLW  0D
0CF3:  BTFSS  0C.4
0CF4:  GOTO   4F3
0CF5:  MOVWF  19
0CF6:  MOVLW  0A
0CF7:  BTFSS  0C.4
0CF8:  GOTO   4F7
0CF9:  MOVWF  19
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
0CFA:  BSF    03.6
0CFB:  CLRF   57
0CFC:  BCF    03.6
0CFD:  MOVF   55,F
0CFE:  BTFSS  03.2
0CFF:  GOTO   506
0D00:  BSF    03.6
0D01:  MOVF   57,W
0D02:  BCF    03.6
0D03:  SUBWF  54,W
0D04:  BTFSS  03.0
0D05:  GOTO   50F
....................          DATA_COMMAND[idxCb] = 0x00; 
0D06:  MOVLW  10
0D07:  BSF    03.6
0D08:  ADDWF  57,W
0D09:  MOVWF  04
0D0A:  BSF    03.7
0D0B:  CLRF   00
0D0C:  INCF   57,F
0D0D:  GOTO   4FC
0D0E:  BCF    03.6
....................       } 
....................       COMMAND[0]       = 0x00; 
0D0F:  CLRF   52
....................       COMMAND[1]       = 0x00; 
0D10:  CLRF   53
....................       ID_CONNETION[0]  = 0x00; 
0D11:  CLRF   50
....................        
....................       // Reinicia el buffer 
....................       flag_Resp_Ready  = 0x00; 
0D12:  CLRF   59
....................       LEN_DATA_COMMAND = 0x00; 
0D13:  CLRF   55
0D14:  CLRF   54
....................        
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return ret; 
0D15:  BSF    03.6
0D16:  MOVF   47,W
0D17:  MOVWF  78
0D18:  BCF    03.6
0D19:  RETURN
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_IP     0 
....................   #define OPT_SHOW_SSID   1 
....................   #define OPT_SHOW_KEY    2 
....................   #define OPT_MODE_AP     3 
....................   #define OPT_BACKLIGH    4 
....................   #define OPT_EXIT        5 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[7][17]    =  { {"VER IP          "}, 
....................                                         {"VER SSID        "}, 
....................                                         {"VER KEY         "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacion     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 5; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
0E6D:  BSF    03.6
0E6E:  CLRF   42
0E6F:  CLRF   43
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0E70:  SWAPF  42,W
0E71:  MOVWF  77
0E72:  MOVLW  F0
0E73:  ANDWF  77,F
0E74:  MOVF   77,W
0E75:  MOVWF  44
0E76:  MOVLW  0C
0E77:  MOVWF  4A
0E78:  BCF    03.6
0E79:  CALL   19C
0E7A:  MOVLW  05
0E7B:  BSF    03.6
0E7C:  MOVWF  0D
0E7D:  MOVLW  01
0E7E:  MOVWF  0F
0E7F:  MOVF   44,W
0E80:  ADDWF  0D,F
0E81:  BTFSC  03.0
0E82:  INCF   0F,F
0E83:  BCF    03.6
0E84:  CALL   202
....................    showBottonMenu(); 
....................    while(!exit){ 
*
0EA5:  BSF    03.6
0EA6:  MOVF   43,F
0EA7:  BTFSS  03.2
0EA8:  GOTO   725
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
0EA9:  BCF    03.6
0EAA:  CALL   27B
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0EAB:  BSF    03.5
0EAC:  BSF    06.4
0EAD:  BCF    03.5
0EAE:  BTFSC  06.4
0EAF:  GOTO   705
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0EB0:  MOVLW  02
0EB1:  BSF    03.6
0EB2:  MOVWF  44
0EB3:  MOVLW  FA
0EB4:  MOVWF  59
0EB5:  BCF    0A.3
0EB6:  BCF    03.6
0EB7:  CALL   515
0EB8:  BSF    0A.3
0EB9:  BSF    03.6
0EBA:  DECFSZ 44,F
0EBB:  GOTO   6B3
....................          BEEP; 
0EBC:  MOVLW  04
0EBD:  MOVWF  48
0EBE:  MOVLW  B9
0EBF:  MOVWF  47
0EC0:  CLRF   4A
0EC1:  MOVLW  14
0EC2:  MOVWF  49
0EC3:  BCF    03.6
0EC4:  CALL   51A
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0EC5:  BSF    03.6
0EC6:  INCF   42,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
0EC7:  MOVF   42,W
0EC8:  BCF    03.6
0EC9:  SUBWF  5D,W
0ECA:  BTFSC  03.0
0ECB:  GOTO   6CF
....................             optSelected = 0; 
0ECC:  BSF    03.6
0ECD:  CLRF   42
0ECE:  BCF    03.6
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0ECF:  BSF    03.6
0ED0:  SWAPF  42,W
0ED1:  MOVWF  77
0ED2:  MOVLW  F0
0ED3:  ANDWF  77,F
0ED4:  MOVF   77,W
0ED5:  MOVWF  44
0ED6:  MOVLW  0C
0ED7:  MOVWF  4A
0ED8:  BCF    03.6
0ED9:  CALL   19C
0EDA:  MOVLW  05
0EDB:  BSF    03.6
0EDC:  MOVWF  0D
0EDD:  MOVLW  01
0EDE:  MOVWF  0F
0EDF:  MOVF   44,W
0EE0:  ADDWF  0D,F
0EE1:  BTFSC  03.0
0EE2:  INCF   0F,F
0EE3:  BCF    03.6
0EE4:  CALL   202
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0F05:  BSF    03.5
0F06:  BSF    06.5
0F07:  BCF    03.5
0F08:  BTFSC  06.5
0F09:  GOTO   723
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0F0A:  MOVLW  02
0F0B:  BSF    03.6
0F0C:  MOVWF  44
0F0D:  MOVLW  FA
0F0E:  MOVWF  59
0F0F:  BCF    0A.3
0F10:  BCF    03.6
0F11:  CALL   515
0F12:  BSF    0A.3
0F13:  BSF    03.6
0F14:  DECFSZ 44,F
0F15:  GOTO   70D
....................          BEEP; 
0F16:  MOVLW  04
0F17:  MOVWF  48
0F18:  MOVLW  B9
0F19:  MOVWF  47
0F1A:  CLRF   4A
0F1B:  MOVLW  14
0F1C:  MOVWF  49
0F1D:  BCF    03.6
0F1E:  CALL   51A
....................          // Rompe el Loop 
....................          exit = 1; 
0F1F:  MOVLW  01
0F20:  BSF    03.6
0F21:  MOVWF  43
0F22:  BCF    03.6
....................       } // Fin KEY_OK 
0F23:  GOTO   6A5
0F24:  BSF    03.6
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
0F25:  MOVLW  01
0F26:  ADDWF  42,W
0F27:  MOVWF  78
0F28:  BCF    03.6
0F29:  BCF    0A.3
0F2A:  BSF    0A.4
0F2B:  GOTO   6FD (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
122A:  MOVLW  0C
122B:  BSF    03.6
122C:  MOVWF  4B
122D:  MOVLW  02
122E:  MOVWF  4C
*
1274:  MOVLW  0C
1275:  BSF    03.6
1276:  MOVWF  4B
1277:  MOVLW  02
1278:  MOVWF  4C
*
12BE:  MOVLW  0C
12BF:  BSF    03.6
12C0:  MOVWF  4B
12C1:  MOVLW  02
12C2:  MOVWF  4C
*
1439:  MOVLW  0C
143A:  BSF    03.6
143B:  MOVWF  4B
143C:  MOVLW  02
143D:  MOVWF  4C
*
14E0:  MOVLW  0C
14E1:  BSF    03.6
14E2:  MOVWF  4B
14E3:  MOVLW  02
14E4:  MOVWF  4C
....................   printf(lcd_putc, "SALIR"); 
*
1243:  MOVLW  38
1244:  BSF    03.6
1245:  MOVWF  0D
1246:  MOVLW  03
1247:  MOVWF  0F
1248:  BCF    0A.4
1249:  BSF    0A.3
124A:  BCF    03.6
124B:  CALL   22B
124C:  BSF    0A.4
124D:  BCF    0A.3
*
128D:  MOVLW  38
128E:  BSF    03.6
128F:  MOVWF  0D
1290:  MOVLW  03
1291:  MOVWF  0F
1292:  BCF    0A.4
1293:  BSF    0A.3
1294:  BCF    03.6
1295:  CALL   22B
1296:  BSF    0A.4
1297:  BCF    0A.3
*
12D7:  MOVLW  38
12D8:  BSF    03.6
12D9:  MOVWF  0D
12DA:  MOVLW  03
12DB:  MOVWF  0F
12DC:  BCF    0A.4
12DD:  BSF    0A.3
12DE:  BCF    03.6
12DF:  CALL   22B
12E0:  BSF    0A.4
12E1:  BCF    0A.3
*
1452:  MOVLW  38
1453:  BSF    03.6
1454:  MOVWF  0D
1455:  MOVLW  03
1456:  MOVWF  0F
1457:  BCF    0A.4
1458:  BSF    0A.3
1459:  BCF    03.6
145A:  CALL   22B
145B:  BSF    0A.4
145C:  BCF    0A.3
*
14F9:  MOVLW  38
14FA:  BSF    03.6
14FB:  MOVWF  0D
14FC:  MOVLW  03
14FD:  MOVWF  0F
14FE:  BCF    0A.4
14FF:  BSF    0A.3
1500:  BCF    03.6
1501:  CALL   22B
1502:  BSF    0A.4
1503:  BCF    0A.3
....................    
....................   while(1){ 
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
*
124E:  BCF    0A.4
124F:  BSF    0A.3
1250:  CALL   27B
1251:  BSF    0A.4
1252:  BCF    0A.3
*
1298:  BCF    0A.4
1299:  BSF    0A.3
129A:  CALL   27B
129B:  BSF    0A.4
129C:  BCF    0A.3
*
12E2:  BCF    0A.4
12E3:  BSF    0A.3
12E4:  CALL   27B
12E5:  BSF    0A.4
12E6:  BCF    0A.3
*
145D:  BCF    0A.4
145E:  BSF    0A.3
145F:  CALL   27B
1460:  BSF    0A.4
1461:  BCF    0A.3
*
1504:  BCF    0A.4
1505:  BSF    0A.3
1506:  CALL   27B
1507:  BSF    0A.4
1508:  BCF    0A.3
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
*
1253:  BSF    03.5
1254:  BSF    06.5
1255:  BCF    03.5
1256:  BTFSC  06.5
1257:  GOTO   266
*
129D:  BSF    03.5
129E:  BSF    06.5
129F:  BCF    03.5
12A0:  BTFSC  06.5
12A1:  GOTO   2B0
*
12E7:  BSF    03.5
12E8:  BSF    06.5
12E9:  BCF    03.5
12EA:  BTFSC  06.5
12EB:  GOTO   2FA
*
1462:  BSF    03.5
1463:  BSF    06.5
1464:  BCF    03.5
1465:  BTFSC  06.5
1466:  GOTO   475
*
1509:  BSF    03.5
150A:  BSF    06.5
150B:  BCF    03.5
150C:  BTFSC  06.5
150D:  GOTO   51C
....................            // Elimina el rebote 
....................            delay_ms(500); 
*
1258:  MOVLW  02
1259:  BSF    03.6
125A:  MOVWF  47
125B:  MOVLW  FA
125C:  MOVWF  59
125D:  BCF    0A.4
125E:  BCF    03.6
125F:  CALL   515
1260:  BSF    0A.4
1261:  BSF    03.6
1262:  DECFSZ 47,F
1263:  GOTO   25B
*
12A2:  MOVLW  02
12A3:  BSF    03.6
12A4:  MOVWF  47
12A5:  MOVLW  FA
12A6:  MOVWF  59
12A7:  BCF    0A.4
12A8:  BCF    03.6
12A9:  CALL   515
12AA:  BSF    0A.4
12AB:  BSF    03.6
12AC:  DECFSZ 47,F
12AD:  GOTO   2A5
*
12EC:  MOVLW  02
12ED:  BSF    03.6
12EE:  MOVWF  47
12EF:  MOVLW  FA
12F0:  MOVWF  59
12F1:  BCF    0A.4
12F2:  BCF    03.6
12F3:  CALL   515
12F4:  BSF    0A.4
12F5:  BSF    03.6
12F6:  DECFSZ 47,F
12F7:  GOTO   2EF
*
1467:  MOVLW  02
1468:  BSF    03.6
1469:  MOVWF  47
146A:  MOVLW  FA
146B:  MOVWF  59
146C:  BCF    0A.4
146D:  BCF    03.6
146E:  CALL   515
146F:  BSF    0A.4
1470:  BSF    03.6
1471:  DECFSZ 47,F
1472:  GOTO   46A
*
150E:  MOVLW  02
150F:  BSF    03.6
1510:  MOVWF  47
1511:  MOVLW  FA
1512:  MOVWF  59
1513:  BCF    0A.4
1514:  BCF    03.6
1515:  CALL   515
1516:  BSF    0A.4
1517:  BSF    03.6
1518:  DECFSZ 47,F
1519:  GOTO   511
....................            break; 
*
1264:  GOTO   268
1265:  BCF    03.6
*
12AE:  GOTO   2B2
12AF:  BCF    03.6
*
12F8:  GOTO   2FC
12F9:  BCF    03.6
*
1473:  GOTO   477
1474:  BCF    03.6
*
151A:  GOTO   51E
151B:  BCF    03.6
....................      } 
*
1266:  GOTO   24E
1267:  BSF    03.6
*
12B0:  GOTO   298
12B1:  BSF    03.6
*
12FA:  GOTO   2E2
12FB:  BSF    03.6
*
1475:  GOTO   45D
1476:  BSF    03.6
*
151C:  GOTO   504
151D:  BSF    03.6
....................   } 
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
0E85:  MOVLW  01
0E86:  BSF    03.6
0E87:  MOVWF  4B
0E88:  MOVLW  02
0E89:  MOVWF  4C
*
0EE5:  MOVLW  01
0EE6:  BSF    03.6
0EE7:  MOVWF  4B
0EE8:  MOVLW  02
0EE9:  MOVWF  4C
*
1027:  MOVLW  01
1028:  BSF    03.6
1029:  MOVWF  4B
102A:  MOVLW  02
102B:  MOVWF  4C
*
10A2:  MOVLW  01
10A3:  BSF    03.6
10A4:  MOVWF  4B
10A5:  MOVLW  02
10A6:  MOVWF  4C
*
1133:  MOVLW  01
1134:  BSF    03.6
1135:  MOVWF  4B
1136:  MOVLW  02
1137:  MOVWF  4C
*
11A7:  MOVLW  01
11A8:  BSF    03.6
11A9:  MOVWF  4B
11AA:  MOVLW  02
11AB:  MOVWF  4C
*
1324:  MOVLW  01
1325:  BSF    03.6
1326:  MOVWF  4B
1327:  MOVLW  02
1328:  MOVWF  4C
*
139F:  MOVLW  01
13A0:  BSF    03.6
13A1:  MOVWF  4B
13A2:  MOVLW  02
13A3:  MOVWF  4C
*
149B:  MOVLW  01
149C:  BSF    03.6
149D:  MOVWF  4B
149E:  MOVLW  02
149F:  MOVWF  4C
*
155C:  MOVLW  01
155D:  BSF    03.6
155E:  MOVWF  4B
155F:  MOVLW  02
1560:  MOVWF  4C
*
15D2:  MOVLW  01
15D3:  BSF    03.6
15D4:  MOVWF  4B
15D5:  MOVLW  02
15D6:  MOVWF  4C
*
1645:  MOVLW  01
1646:  BSF    03.6
1647:  MOVWF  4B
1648:  MOVLW  02
1649:  MOVWF  4C
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
*
0E9E:  MOVLW  3B
0E9F:  BSF    03.6
0EA0:  MOVWF  0D
0EA1:  MOVLW  03
0EA2:  MOVWF  0F
0EA3:  BCF    03.6
0EA4:  CALL   22B
*
0EFE:  MOVLW  3B
0EFF:  BSF    03.6
0F00:  MOVWF  0D
0F01:  MOVLW  03
0F02:  MOVWF  0F
0F03:  BCF    03.6
0F04:  CALL   22B
*
1040:  MOVLW  3B
1041:  BSF    03.6
1042:  MOVWF  0D
1043:  MOVLW  03
1044:  MOVWF  0F
1045:  BCF    0A.4
1046:  BSF    0A.3
1047:  BCF    03.6
1048:  CALL   22B
1049:  BSF    0A.4
104A:  BCF    0A.3
*
10BB:  MOVLW  3B
10BC:  BSF    03.6
10BD:  MOVWF  0D
10BE:  MOVLW  03
10BF:  MOVWF  0F
10C0:  BCF    0A.4
10C1:  BSF    0A.3
10C2:  BCF    03.6
10C3:  CALL   22B
10C4:  BSF    0A.4
10C5:  BCF    0A.3
*
114C:  MOVLW  3B
114D:  BSF    03.6
114E:  MOVWF  0D
114F:  MOVLW  03
1150:  MOVWF  0F
1151:  BCF    0A.4
1152:  BSF    0A.3
1153:  BCF    03.6
1154:  CALL   22B
1155:  BSF    0A.4
1156:  BCF    0A.3
*
11C0:  MOVLW  3B
11C1:  BSF    03.6
11C2:  MOVWF  0D
11C3:  MOVLW  03
11C4:  MOVWF  0F
11C5:  BCF    0A.4
11C6:  BSF    0A.3
11C7:  BCF    03.6
11C8:  CALL   22B
11C9:  BSF    0A.4
11CA:  BCF    0A.3
*
133D:  MOVLW  3B
133E:  BSF    03.6
133F:  MOVWF  0D
1340:  MOVLW  03
1341:  MOVWF  0F
1342:  BCF    0A.4
1343:  BSF    0A.3
1344:  BCF    03.6
1345:  CALL   22B
1346:  BSF    0A.4
1347:  BCF    0A.3
*
13B8:  MOVLW  3B
13B9:  BSF    03.6
13BA:  MOVWF  0D
13BB:  MOVLW  03
13BC:  MOVWF  0F
13BD:  BCF    0A.4
13BE:  BSF    0A.3
13BF:  BCF    03.6
13C0:  CALL   22B
13C1:  BSF    0A.4
13C2:  BCF    0A.3
*
14B4:  MOVLW  3B
14B5:  BSF    03.6
14B6:  MOVWF  0D
14B7:  MOVLW  03
14B8:  MOVWF  0F
14B9:  BCF    0A.4
14BA:  BSF    0A.3
14BB:  BCF    03.6
14BC:  CALL   22B
14BD:  BSF    0A.4
14BE:  BCF    0A.3
14BF:  BSF    03.6
*
1575:  MOVLW  3B
1576:  BSF    03.6
1577:  MOVWF  0D
1578:  MOVLW  03
1579:  MOVWF  0F
157A:  BCF    0A.4
157B:  BSF    0A.3
157C:  BCF    03.6
157D:  CALL   22B
157E:  BSF    0A.4
157F:  BCF    0A.3
*
15EB:  MOVLW  3B
15EC:  BSF    03.6
15ED:  MOVWF  0D
15EE:  MOVLW  03
15EF:  MOVWF  0F
15F0:  BCF    0A.4
15F1:  BSF    0A.3
15F2:  BCF    03.6
15F3:  CALL   22B
15F4:  BSF    0A.4
15F5:  BCF    0A.3
*
165E:  MOVLW  3B
165F:  BSF    03.6
1660:  MOVWF  0D
1661:  MOVLW  03
1662:  MOVWF  0F
1663:  BCF    0A.4
1664:  BSF    0A.3
1665:  BCF    03.6
1666:  CALL   22B
1667:  BSF    0A.4
1668:  BCF    0A.3
1669:  BSF    03.6
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
1000:  BSF    03.6
1001:  CLRF   42
1002:  CLRF   43
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
1003:  MOVF   42,W
1004:  MOVWF  47
1005:  MOVLW  0F
1006:  MOVWF  48
1007:  BCF    0A.4
1008:  BSF    0A.3
1009:  BCF    03.6
100A:  CALL   72C
100B:  BSF    0A.4
100C:  BCF    0A.3
100D:  MOVF   78,W
100E:  BSF    03.6
100F:  MOVWF  44
1010:  MOVLW  0C
1011:  MOVWF  4A
1012:  BCF    0A.4
1013:  BSF    0A.3
1014:  BCF    03.6
1015:  CALL   19C
1016:  BSF    0A.4
1017:  BCF    0A.3
1018:  MOVLW  45
1019:  BSF    03.6
101A:  MOVWF  0D
101B:  MOVLW  01
101C:  MOVWF  0F
101D:  MOVF   44,W
101E:  ADDWF  0D,F
101F:  BTFSC  03.0
1020:  INCF   0F,F
1021:  BCF    0A.4
1022:  BSF    0A.3
1023:  BCF    03.6
1024:  CALL   202
1025:  BSF    0A.4
1026:  BCF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
104B:  BSF    03.6
104C:  MOVF   43,F
104D:  BTFSS  03.2
104E:  GOTO   10D
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
104F:  BCF    0A.4
1050:  BSF    0A.3
1051:  BCF    03.6
1052:  CALL   27B
1053:  BSF    0A.4
1054:  BCF    0A.3
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
1055:  BSF    03.5
1056:  BSF    06.4
1057:  BCF    03.5
1058:  BTFSC  06.4
1059:  GOTO   0C6
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
105A:  MOVLW  02
105B:  BSF    03.6
105C:  MOVWF  44
105D:  MOVLW  FA
105E:  MOVWF  59
105F:  BCF    0A.4
1060:  BCF    03.6
1061:  CALL   515
1062:  BSF    0A.4
1063:  BSF    03.6
1064:  DECFSZ 44,F
1065:  GOTO   05D
....................          BEEP; 
1066:  MOVLW  04
1067:  MOVWF  48
1068:  MOVLW  B9
1069:  MOVWF  47
106A:  CLRF   4A
106B:  MOVLW  14
106C:  MOVWF  49
106D:  BCF    0A.4
106E:  BSF    0A.3
106F:  BCF    03.6
1070:  CALL   51A
1071:  BSF    0A.4
1072:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
1073:  BSF    03.6
1074:  INCF   42,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
1075:  MOVF   42,W
1076:  BCF    03.6
1077:  SUBWF  5E,W
1078:  BTFSC  03.0
1079:  GOTO   07D
....................             optSelected = 0; 
107A:  BSF    03.6
107B:  CLRF   42
107C:  BCF    03.6
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
107D:  BSF    03.6
107E:  MOVF   42,W
107F:  MOVWF  47
1080:  MOVLW  0F
1081:  MOVWF  48
1082:  BCF    0A.4
1083:  BSF    0A.3
1084:  BCF    03.6
1085:  CALL   72C
1086:  BSF    0A.4
1087:  BCF    0A.3
1088:  MOVF   78,W
1089:  BSF    03.6
108A:  MOVWF  44
108B:  MOVLW  0C
108C:  MOVWF  4A
108D:  BCF    0A.4
108E:  BSF    0A.3
108F:  BCF    03.6
1090:  CALL   19C
1091:  BSF    0A.4
1092:  BCF    0A.3
1093:  MOVLW  45
1094:  BSF    03.6
1095:  MOVWF  0D
1096:  MOVLW  01
1097:  MOVWF  0F
1098:  MOVF   44,W
1099:  ADDWF  0D,F
109A:  BTFSC  03.0
109B:  INCF   0F,F
109C:  BCF    0A.4
109D:  BSF    0A.3
109E:  BCF    03.6
109F:  CALL   202
10A0:  BSF    0A.4
10A1:  BCF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
10C6:  BSF    03.5
10C7:  BSF    06.5
10C8:  BCF    03.5
10C9:  BTFSC  06.5
10CA:  GOTO   10B
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
10CB:  MOVLW  02
10CC:  BSF    03.6
10CD:  MOVWF  44
10CE:  MOVLW  FA
10CF:  MOVWF  59
10D0:  BCF    0A.4
10D1:  BCF    03.6
10D2:  CALL   515
10D3:  BSF    0A.4
10D4:  BSF    03.6
10D5:  DECFSZ 44,F
10D6:  GOTO   0CE
....................          BEEP; 
10D7:  MOVLW  04
10D8:  MOVWF  48
10D9:  MOVLW  B9
10DA:  MOVWF  47
10DB:  CLRF   4A
10DC:  MOVLW  14
10DD:  MOVWF  49
10DE:  BCF    0A.4
10DF:  BSF    0A.3
10E0:  BCF    03.6
10E1:  CALL   51A
10E2:  BSF    0A.4
10E3:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
10E4:  MOVF   5E,W
10E5:  BSF    03.6
10E6:  SUBWF  42,W
10E7:  BTFSS  03.2
10E8:  GOTO   0EC
....................             exit = 1; 
10E9:  MOVLW  01
10EA:  MOVWF  43
....................          }else{ 
10EB:  GOTO   10C
....................             output_high(PIN_OUT[optSelected]); 
10EC:  BCF    03.0
10ED:  RLF    42,W
10EE:  ADDLW  2B
10EF:  MOVWF  04
10F0:  BCF    03.7
10F1:  INCF   04,F
10F2:  MOVF   00,W
10F3:  MOVWF  45
10F4:  DECF   04,F
10F5:  MOVF   00,W
10F6:  MOVWF  44
10F7:  MOVWF  5A
10F8:  MOVLW  01
10F9:  MOVWF  5B
10FA:  CLRF   5D
10FB:  CLRF   5C
10FC:  BCF    0A.4
10FD:  BCF    03.6
10FE:  CALL   7DD
10FF:  BSF    0A.4
1100:  BSF    03.6
1101:  MOVF   44,W
1102:  MOVWF  5A
1103:  CLRF   5B
1104:  CLRF   5D
1105:  MOVLW  80
1106:  MOVWF  5C
1107:  BCF    0A.4
1108:  BCF    03.6
1109:  CALL   7DD
110A:  BSF    0A.4
110B:  BSF    03.6
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
110C:  GOTO   04C
....................    } // FIN While Infinito 
....................  
....................    return 0; 
110D:  MOVLW  00
110E:  MOVWF  78
110F:  BCF    03.6
1110:  BCF    0A.3
1111:  BSF    0A.4
1112:  GOTO   703 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
1113:  BSF    03.6
1114:  CLRF   42
1115:  CLRF   43
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
1116:  SWAPF  42,W
1117:  MOVWF  77
1118:  MOVLW  F0
1119:  ANDWF  77,F
111A:  MOVF   77,W
111B:  MOVWF  44
111C:  MOVLW  0C
111D:  MOVWF  4A
111E:  BCF    0A.4
111F:  BSF    0A.3
1120:  BCF    03.6
1121:  CALL   19C
1122:  BSF    0A.4
1123:  BCF    0A.3
1124:  MOVLW  DB
1125:  BSF    03.6
1126:  MOVWF  0D
1127:  MOVLW  01
1128:  MOVWF  0F
1129:  MOVF   44,W
112A:  ADDWF  0D,F
112B:  BTFSC  03.0
112C:  INCF   0F,F
112D:  BCF    0A.4
112E:  BSF    0A.3
112F:  BCF    03.6
1130:  CALL   202
1131:  BSF    0A.4
1132:  BCF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1157:  BSF    03.6
1158:  MOVF   43,F
1159:  BTFSS  03.2
115A:  GOTO   211
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
115B:  BCF    0A.4
115C:  BSF    0A.3
115D:  BCF    03.6
115E:  CALL   27B
115F:  BSF    0A.4
1160:  BCF    0A.3
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
1161:  BSF    03.5
1162:  BSF    06.4
1163:  BCF    03.5
1164:  BTFSC  06.4
1165:  GOTO   1CB
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1166:  MOVLW  02
1167:  BSF    03.6
1168:  MOVWF  44
1169:  MOVLW  FA
116A:  MOVWF  59
116B:  BCF    0A.4
116C:  BCF    03.6
116D:  CALL   515
116E:  BSF    0A.4
116F:  BSF    03.6
1170:  DECFSZ 44,F
1171:  GOTO   169
....................          BEEP; 
1172:  MOVLW  04
1173:  MOVWF  48
1174:  MOVLW  B9
1175:  MOVWF  47
1176:  CLRF   4A
1177:  MOVLW  14
1178:  MOVWF  49
1179:  BCF    0A.4
117A:  BSF    0A.3
117B:  BCF    03.6
117C:  CALL   51A
117D:  BSF    0A.4
117E:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
117F:  BSF    03.6
1180:  INCF   42,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
1181:  MOVF   42,W
1182:  BCF    03.6
1183:  SUBWF  5F,W
1184:  BTFSC  03.0
1185:  GOTO   189
....................             optSelected = 0; 
1186:  BSF    03.6
1187:  CLRF   42
1188:  BCF    03.6
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
1189:  BSF    03.6
118A:  SWAPF  42,W
118B:  MOVWF  77
118C:  MOVLW  F0
118D:  ANDWF  77,F
118E:  MOVF   77,W
118F:  MOVWF  44
1190:  MOVLW  0C
1191:  MOVWF  4A
1192:  BCF    0A.4
1193:  BSF    0A.3
1194:  BCF    03.6
1195:  CALL   19C
1196:  BSF    0A.4
1197:  BCF    0A.3
1198:  MOVLW  DB
1199:  BSF    03.6
119A:  MOVWF  0D
119B:  MOVLW  01
119C:  MOVWF  0F
119D:  MOVF   44,W
119E:  ADDWF  0D,F
119F:  BTFSC  03.0
11A0:  INCF   0F,F
11A1:  BCF    0A.4
11A2:  BSF    0A.3
11A3:  BCF    03.6
11A4:  CALL   202
11A5:  BSF    0A.4
11A6:  BCF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
11CB:  BSF    03.5
11CC:  BSF    06.5
11CD:  BCF    03.5
11CE:  BTFSC  06.5
11CF:  GOTO   20F
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
11D0:  MOVLW  02
11D1:  BSF    03.6
11D2:  MOVWF  44
11D3:  MOVLW  FA
11D4:  MOVWF  59
11D5:  BCF    0A.4
11D6:  BCF    03.6
11D7:  CALL   515
11D8:  BSF    0A.4
11D9:  BSF    03.6
11DA:  DECFSZ 44,F
11DB:  GOTO   1D3
....................          BEEP; 
11DC:  MOVLW  04
11DD:  MOVWF  48
11DE:  MOVLW  B9
11DF:  MOVWF  47
11E0:  CLRF   4A
11E1:  MOVLW  14
11E2:  MOVWF  49
11E3:  BCF    0A.4
11E4:  BSF    0A.3
11E5:  BCF    03.6
11E6:  CALL   51A
11E7:  BSF    0A.4
11E8:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
11E9:  MOVF   5F,W
11EA:  BSF    03.6
11EB:  SUBWF  42,W
11EC:  BTFSS  03.2
11ED:  GOTO   1F1
....................             exit = 1; 
11EE:  MOVLW  01
11EF:  MOVWF  43
....................          }else{ 
11F0:  GOTO   210
....................             output_low(PIN_OUT[optSelected]); 
11F1:  BCF    03.0
11F2:  RLF    42,W
11F3:  ADDLW  2B
11F4:  MOVWF  04
11F5:  BCF    03.7
11F6:  INCF   04,F
11F7:  MOVF   00,W
11F8:  MOVWF  45
11F9:  DECF   04,F
11FA:  MOVF   00,W
11FB:  MOVWF  44
11FC:  MOVWF  5A
11FD:  CLRF   5B
11FE:  CLRF   5D
11FF:  CLRF   5C
1200:  BCF    0A.4
1201:  BCF    03.6
1202:  CALL   7DD
1203:  BSF    0A.4
1204:  BSF    03.6
1205:  MOVF   44,W
1206:  MOVWF  5A
1207:  CLRF   5B
1208:  CLRF   5D
1209:  MOVLW  80
120A:  MOVWF  5C
120B:  BCF    0A.4
120C:  BCF    03.6
120D:  CALL   7DD
120E:  BSF    0A.4
120F:  BSF    03.6
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
1210:  GOTO   158
....................    } // FIN While Infinito 
....................  
....................    return 0; 
1211:  MOVLW  00
1212:  MOVWF  78
1213:  BCF    03.6
1214:  BCF    0A.3
1215:  BSF    0A.4
1216:  GOTO   707 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
....................  
....................    /******************************************** 
....................    *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................    *********************************************/ 
....................    run_command_wifi(); 
*
1530:  BCF    0A.4
1531:  BSF    0A.3
1532:  CALL   27B
1533:  BSF    0A.4
1534:  BCF    0A.3
....................    /********************************************/ 
....................     
....................    int optSelected = 0; 
....................    int exit = 0; 
1535:  BSF    03.6
1536:  CLRF   42
1537:  CLRF   43
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
1538:  MOVF   42,W
1539:  MOVWF  47
153A:  MOVLW  11
153B:  MOVWF  48
153C:  BCF    0A.4
153D:  BSF    0A.3
153E:  BCF    03.6
153F:  CALL   72C
1540:  BSF    0A.4
1541:  BCF    0A.3
1542:  MOVF   78,W
1543:  BSF    03.6
1544:  MOVWF  44
1545:  MOVLW  0C
1546:  MOVWF  4A
1547:  BCF    0A.4
1548:  BSF    0A.3
1549:  BCF    03.6
154A:  CALL   19C
154B:  BSF    0A.4
154C:  BCF    0A.3
154D:  MOVLW  7B
154E:  BSF    03.6
154F:  MOVWF  0D
1550:  MOVLW  02
1551:  MOVWF  0F
1552:  MOVF   44,W
1553:  ADDWF  0D,F
1554:  BTFSC  03.0
1555:  INCF   0F,F
1556:  BCF    0A.4
1557:  BSF    0A.3
1558:  BCF    03.6
1559:  CALL   202
155A:  BSF    0A.4
155B:  BCF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1580:  BSF    03.6
1581:  MOVF   43,F
1582:  BTFSS  03.2
1583:  GOTO   66B
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
1584:  BSF    03.5
1585:  BCF    03.6
1586:  BSF    06.4
1587:  BCF    03.5
1588:  BTFSC  06.4
1589:  GOTO   5F6
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
158A:  MOVLW  02
158B:  BSF    03.6
158C:  MOVWF  44
158D:  MOVLW  FA
158E:  MOVWF  59
158F:  BCF    0A.4
1590:  BCF    03.6
1591:  CALL   515
1592:  BSF    0A.4
1593:  BSF    03.6
1594:  DECFSZ 44,F
1595:  GOTO   58D
....................          BEEP; 
1596:  MOVLW  04
1597:  MOVWF  48
1598:  MOVLW  B9
1599:  MOVWF  47
159A:  CLRF   4A
159B:  MOVLW  14
159C:  MOVWF  49
159D:  BCF    0A.4
159E:  BSF    0A.3
159F:  BCF    03.6
15A0:  CALL   51A
15A1:  BSF    0A.4
15A2:  BCF    0A.3
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
15A3:  BSF    03.6
15A4:  INCF   42,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
15A5:  MOVF   42,W
15A6:  BCF    03.6
15A7:  SUBWF  60,W
15A8:  BTFSC  03.0
15A9:  GOTO   5AD
....................             optSelected = 0; 
15AA:  BSF    03.6
15AB:  CLRF   42
15AC:  BCF    03.6
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
15AD:  BSF    03.6
15AE:  MOVF   42,W
15AF:  MOVWF  47
15B0:  MOVLW  11
15B1:  MOVWF  48
15B2:  BCF    0A.4
15B3:  BSF    0A.3
15B4:  BCF    03.6
15B5:  CALL   72C
15B6:  BSF    0A.4
15B7:  BCF    0A.3
15B8:  MOVF   78,W
15B9:  BSF    03.6
15BA:  MOVWF  44
15BB:  MOVLW  0C
15BC:  MOVWF  4A
15BD:  BCF    0A.4
15BE:  BSF    0A.3
15BF:  BCF    03.6
15C0:  CALL   19C
15C1:  BSF    0A.4
15C2:  BCF    0A.3
15C3:  MOVLW  7B
15C4:  BSF    03.6
15C5:  MOVWF  0D
15C6:  MOVLW  02
15C7:  MOVWF  0F
15C8:  MOVF   44,W
15C9:  ADDWF  0D,F
15CA:  BTFSC  03.0
15CB:  INCF   0F,F
15CC:  BCF    0A.4
15CD:  BSF    0A.3
15CE:  BCF    03.6
15CF:  CALL   202
15D0:  BSF    0A.4
15D1:  BCF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
15F6:  BSF    03.5
15F7:  BSF    06.5
15F8:  BCF    03.5
15F9:  BTFSC  06.5
15FA:  GOTO   669
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
15FB:  MOVLW  02
15FC:  BSF    03.6
15FD:  MOVWF  44
15FE:  MOVLW  FA
15FF:  MOVWF  59
1600:  BCF    0A.4
1601:  BCF    03.6
1602:  CALL   515
1603:  BSF    0A.4
1604:  BSF    03.6
1605:  DECFSZ 44,F
1606:  GOTO   5FE
....................          BEEP; 
1607:  MOVLW  04
1608:  MOVWF  48
1609:  MOVLW  B9
160A:  MOVWF  47
160B:  CLRF   4A
160C:  MOVLW  14
160D:  MOVWF  49
160E:  BCF    0A.4
160F:  BSF    0A.3
1610:  BCF    03.6
1611:  CALL   51A
1612:  BSF    0A.4
1613:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
1614:  MOVF   60,W
1615:  BSF    03.6
1616:  SUBWF  42,W
1617:  BTFSS  03.2
1618:  GOTO   61C
....................             exit = 1; 
1619:  MOVLW  01
161A:  MOVWF  43
....................          }else{ 
161B:  GOTO   66A
....................             executeSetup(optSelected); 
161C:  MOVF   42,W
161D:  MOVWF  44
161E:  BCF    03.6
161F:  GOTO   217
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
1620:  BSF    03.6
1621:  MOVF   42,W
1622:  MOVWF  47
1623:  MOVLW  11
1624:  MOVWF  48
1625:  BCF    0A.4
1626:  BSF    0A.3
1627:  BCF    03.6
1628:  CALL   72C
1629:  BSF    0A.4
162A:  BCF    0A.3
162B:  MOVF   78,W
162C:  BSF    03.6
162D:  MOVWF  44
162E:  MOVLW  0C
162F:  MOVWF  4A
1630:  BCF    0A.4
1631:  BSF    0A.3
1632:  BCF    03.6
1633:  CALL   19C
1634:  BSF    0A.4
1635:  BCF    0A.3
1636:  MOVLW  7B
1637:  BSF    03.6
1638:  MOVWF  0D
1639:  MOVLW  02
163A:  MOVWF  0F
163B:  MOVF   44,W
163C:  ADDWF  0D,F
163D:  BTFSC  03.0
163E:  INCF   0F,F
163F:  BCF    0A.4
1640:  BSF    0A.3
1641:  BCF    03.6
1642:  CALL   202
1643:  BSF    0A.4
1644:  BCF    0A.3
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
166A:  GOTO   581
....................    } // FIN While Infinito 
....................  
....................    return 0; 
166B:  MOVLW  00
166C:  MOVWF  78
166D:  BCF    03.6
166E:  BCF    0A.3
166F:  BSF    0A.4
1670:  GOTO   70B (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................   switch(optSelect){ 
*
1217:  BSF    03.6
1218:  MOVF   44,W
1219:  ADDLW  FA
121A:  BTFSC  03.0
121B:  GOTO   522
121C:  ADDLW  06
121D:  BCF    03.6
121E:  GOTO   526
....................       
....................      case OPT_SHOW_IP: 
....................         printf(lcd_putc, "\f192.168.0.1"); 
121F:  MOVLW  44
1220:  BSF    03.6
1221:  MOVWF  0D
1222:  MOVLW  03
1223:  MOVWF  0F
1224:  BCF    0A.4
1225:  BSF    0A.3
1226:  BCF    03.6
1227:  CALL   22B
1228:  BSF    0A.4
1229:  BCF    0A.3
....................         pressExit(); 
....................         break; 
*
1268:  GOTO   522
....................      case OPT_SHOW_SSID: 
....................         printf(lcd_putc, "\fC0G3_UNE"); 
1269:  MOVLW  4B
126A:  BSF    03.6
126B:  MOVWF  0D
126C:  MOVLW  03
126D:  MOVWF  0F
126E:  BCF    0A.4
126F:  BSF    0A.3
1270:  BCF    03.6
1271:  CALL   22B
1272:  BSF    0A.4
1273:  BCF    0A.3
....................         pressExit();          
....................         break; 
*
12B2:  GOTO   522
....................      case OPT_SHOW_KEY: 
....................         printf(lcd_putc, "\f1234Az!"); 
12B3:  MOVLW  50
12B4:  BSF    03.6
12B5:  MOVWF  0D
12B6:  MOVLW  03
12B7:  MOVWF  0F
12B8:  BCF    0A.4
12B9:  BSF    0A.3
12BA:  BCF    03.6
12BB:  CALL   22B
12BC:  BSF    0A.4
12BD:  BCF    0A.3
....................         pressExit(); 
....................         break; 
*
12FC:  GOTO   522
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
....................         break; 
*
14C1:  GOTO   522
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
14C2:  BSF    03.5
14C3:  BCF    08.3
14C4:  MOVLW  08
14C5:  BCF    03.5
14C6:  XORWF  08,F
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
14C7:  BTFSS  08.3
14C8:  GOTO   4D5
....................            printf(lcd_putc, "\fBacklight On"); 
14C9:  MOVLW  55
14CA:  BSF    03.6
14CB:  MOVWF  0D
14CC:  MOVLW  03
14CD:  MOVWF  0F
14CE:  BCF    0A.4
14CF:  BSF    0A.3
14D0:  BCF    03.6
14D1:  CALL   22B
14D2:  BSF    0A.4
14D3:  BCF    0A.3
....................         }else{ 
14D4:  GOTO   4E0
....................            printf(lcd_putc, "\fBacklight Off"); 
14D5:  MOVLW  5C
14D6:  BSF    03.6
14D7:  MOVWF  0D
14D8:  MOVLW  03
14D9:  MOVWF  0F
14DA:  BCF    0A.4
14DB:  BSF    0A.3
14DC:  BCF    03.6
14DD:  CALL   22B
14DE:  BSF    0A.4
14DF:  BCF    0A.3
....................         } 
....................         pressExit(); 
....................         break; 
*
151E:  GOTO   522
....................      case OPT_EXIT: 
....................         break; 
151F:  BSF    03.6
1520:  GOTO   522
1521:  BSF    03.6
....................   } 
1522:  BCF    03.6
1523:  BCF    0A.3
1524:  BSF    0A.4
1525:  GOTO   620 (RETURN)
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
*
12FD:  BSF    03.6
12FE:  CLRF   45
12FF:  CLRF   46
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
1300:  MOVF   45,W
1301:  MOVWF  47
1302:  MOVLW  0E
1303:  MOVWF  48
1304:  BCF    0A.4
1305:  BSF    0A.3
1306:  BCF    03.6
1307:  CALL   72C
1308:  BSF    0A.4
1309:  BCF    0A.3
130A:  MOVF   78,W
130B:  BSF    03.6
130C:  MOVWF  47
130D:  MOVLW  0C
130E:  MOVWF  4A
130F:  BCF    0A.4
1310:  BSF    0A.3
1311:  BCF    03.6
1312:  CALL   19C
1313:  BSF    0A.4
1314:  BCF    0A.3
1315:  MOVLW  F2
1316:  BSF    03.6
1317:  MOVWF  0D
1318:  MOVLW  02
1319:  MOVWF  0F
131A:  MOVF   47,W
131B:  ADDWF  0D,F
131C:  BTFSC  03.0
131D:  INCF   0F,F
131E:  BCF    0A.4
131F:  BSF    0A.3
1320:  BCF    03.6
1321:  CALL   202
1322:  BSF    0A.4
1323:  BCF    0A.3
....................   showBottonMenu(); 
....................    
....................   while(!exit){ 
*
1348:  BSF    03.6
1349:  MOVF   46,F
134A:  BTFSS  03.2
134B:  GOTO   4C1
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
134C:  BCF    0A.4
134D:  BSF    0A.3
134E:  BCF    03.6
134F:  CALL   27B
1350:  BSF    0A.4
1351:  BCF    0A.3
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
1352:  BSF    03.5
1353:  BSF    06.4
1354:  BCF    03.5
1355:  BTFSC  06.4
1356:  GOTO   3C3
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
1357:  MOVLW  02
1358:  BSF    03.6
1359:  MOVWF  47
135A:  MOVLW  FA
135B:  MOVWF  59
135C:  BCF    0A.4
135D:  BCF    03.6
135E:  CALL   515
135F:  BSF    0A.4
1360:  BSF    03.6
1361:  DECFSZ 47,F
1362:  GOTO   35A
....................         BEEP; 
1363:  MOVLW  04
1364:  MOVWF  48
1365:  MOVLW  B9
1366:  MOVWF  47
1367:  CLRF   4A
1368:  MOVLW  14
1369:  MOVWF  49
136A:  BCF    0A.4
136B:  BSF    0A.3
136C:  BCF    03.6
136D:  CALL   51A
136E:  BSF    0A.4
136F:  BCF    0A.3
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
1370:  BSF    03.6
1371:  INCF   45,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
1372:  MOVF   45,W
1373:  BCF    03.6
1374:  SUBWF  61,W
1375:  BTFSC  03.0
1376:  GOTO   37A
....................            optSelected = 0; 
1377:  BSF    03.6
1378:  CLRF   45
1379:  BCF    03.6
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
137A:  BSF    03.6
137B:  MOVF   45,W
137C:  MOVWF  47
137D:  MOVLW  0E
137E:  MOVWF  48
137F:  BCF    0A.4
1380:  BSF    0A.3
1381:  BCF    03.6
1382:  CALL   72C
1383:  BSF    0A.4
1384:  BCF    0A.3
1385:  MOVF   78,W
1386:  BSF    03.6
1387:  MOVWF  47
1388:  MOVLW  0C
1389:  MOVWF  4A
138A:  BCF    0A.4
138B:  BSF    0A.3
138C:  BCF    03.6
138D:  CALL   19C
138E:  BSF    0A.4
138F:  BCF    0A.3
1390:  MOVLW  F2
1391:  BSF    03.6
1392:  MOVWF  0D
1393:  MOVLW  02
1394:  MOVWF  0F
1395:  MOVF   47,W
1396:  ADDWF  0D,F
1397:  BTFSC  03.0
1398:  INCF   0F,F
1399:  BCF    0A.4
139A:  BSF    0A.3
139B:  BCF    03.6
139C:  CALL   202
139D:  BSF    0A.4
139E:  BCF    0A.3
....................         showBottonMenu(); 
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
*
13C3:  BSF    03.5
13C4:  BSF    06.5
13C5:  BCF    03.5
13C6:  BTFSC  06.5
13C7:  GOTO   4BF
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
13C8:  MOVLW  02
13C9:  BSF    03.6
13CA:  MOVWF  47
13CB:  MOVLW  FA
13CC:  MOVWF  59
13CD:  BCF    0A.4
13CE:  BCF    03.6
13CF:  CALL   515
13D0:  BSF    0A.4
13D1:  BSF    03.6
13D2:  DECFSZ 47,F
13D3:  GOTO   3CB
....................         BEEP; 
13D4:  MOVLW  04
13D5:  MOVWF  48
13D6:  MOVLW  B9
13D7:  MOVWF  47
13D8:  CLRF   4A
13D9:  MOVLW  14
13DA:  MOVWF  49
13DB:  BCF    0A.4
13DC:  BSF    0A.3
13DD:  BCF    03.6
13DE:  CALL   51A
13DF:  BSF    0A.4
13E0:  BCF    0A.3
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
13E1:  MOVF   61,W
13E2:  BSF    03.6
13E3:  SUBWF  45,W
13E4:  BTFSS  03.2
13E5:  GOTO   3E9
....................            exit = 1; 
13E6:  MOVLW  01
13E7:  MOVWF  46
....................         }else{ 
13E8:  GOTO   4C0
....................            switch(optSelected){ 
13E9:  MOVF   45,W
13EA:  XORLW  00
13EB:  BCF    03.6
13EC:  BTFSC  03.2
13ED:  GOTO   3F5
13EE:  XORLW  01
13EF:  BTFSC  03.2
13F0:  GOTO   40C
13F1:  XORLW  03
13F2:  BTFSC  03.2
13F3:  GOTO   423
13F4:  GOTO   439
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
13F5:  MOVLW  64
13F6:  BSF    03.6
13F7:  MOVWF  0D
13F8:  MOVLW  03
13F9:  MOVWF  0F
13FA:  BCF    0A.4
13FB:  BSF    0A.3
13FC:  BCF    03.6
13FD:  CALL   000
13FE:  BSF    0A.4
13FF:  BCF    0A.3
....................                  printf(lcd_putc, "\fConfig Cliente"); 
1400:  MOVLW  6D
1401:  BSF    03.6
1402:  MOVWF  0D
1403:  MOVLW  03
1404:  MOVWF  0F
1405:  BCF    0A.4
1406:  BSF    0A.3
1407:  BCF    03.6
1408:  CALL   22B
1409:  BSF    0A.4
140A:  BCF    0A.3
....................                  break; 
140B:  GOTO   439
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
140C:  MOVLW  75
140D:  BSF    03.6
140E:  MOVWF  0D
140F:  MOVLW  03
1410:  MOVWF  0F
1411:  BCF    0A.4
1412:  BSF    0A.3
1413:  BCF    03.6
1414:  CALL   000
1415:  BSF    0A.4
1416:  BCF    0A.3
....................                  printf(lcd_putc, "\fConfig AP"); 
1417:  MOVLW  7E
1418:  BSF    03.6
1419:  MOVWF  0D
141A:  MOVLW  03
141B:  MOVWF  0F
141C:  BCF    0A.4
141D:  BSF    0A.3
141E:  BCF    03.6
141F:  CALL   22B
1420:  BSF    0A.4
1421:  BCF    0A.3
....................                  break; 
1422:  GOTO   439
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
1423:  MOVLW  84
1424:  BSF    03.6
1425:  MOVWF  0D
1426:  MOVLW  03
1427:  MOVWF  0F
1428:  BCF    0A.4
1429:  BSF    0A.3
142A:  BCF    03.6
142B:  CALL   000
142C:  BSF    0A.4
142D:  BCF    0A.3
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
142E:  MOVLW  8D
142F:  BSF    03.6
1430:  MOVWF  0D
1431:  MOVLW  03
1432:  MOVWF  0F
1433:  BCF    0A.4
1434:  BSF    0A.3
1435:  BCF    03.6
1436:  CALL   22B
1437:  BSF    0A.4
1438:  BCF    0A.3
....................                  break; 
....................            } 
....................            pressExit(); 
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
*
1477:  MOVF   45,W
1478:  MOVWF  47
1479:  MOVLW  0E
147A:  MOVWF  48
147B:  BCF    0A.4
147C:  BSF    0A.3
147D:  BCF    03.6
147E:  CALL   72C
147F:  BSF    0A.4
1480:  BCF    0A.3
1481:  MOVF   78,W
1482:  BSF    03.6
1483:  MOVWF  47
1484:  MOVLW  0C
1485:  MOVWF  4A
1486:  BCF    0A.4
1487:  BSF    0A.3
1488:  BCF    03.6
1489:  CALL   19C
148A:  BSF    0A.4
148B:  BCF    0A.3
148C:  MOVLW  F2
148D:  BSF    03.6
148E:  MOVWF  0D
148F:  MOVLW  02
1490:  MOVWF  0F
1491:  MOVF   47,W
1492:  ADDWF  0D,F
1493:  BTFSC  03.0
1494:  INCF   0F,F
1495:  BCF    0A.4
1496:  BSF    0A.3
1497:  BCF    03.6
1498:  CALL   202
1499:  BSF    0A.4
149A:  BCF    0A.3
....................            showBottonMenu(); 
....................         } 
....................      } // Fin KEY_OK 
*
14C0:  GOTO   349
....................   } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
....................  
.................... /******************************************** 
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
03B3:  BTFSS  0C.5
03B4:  GOTO   3B3
03B5:  MOVF   1A,W
03B6:  BSF    03.6
03B7:  MOVWF  62
.................... { 
....................    int buffer = getc(); 
....................    if(READY_RESP==0){ 
03B8:  BCF    03.6
03B9:  MOVF   42,F
03BA:  BTFSS  03.2
03BB:  GOTO   466
....................       ESP8266_PROCCESS_RESPONSE(buffer); 
03BC:  BSF    03.6
03BD:  MOVF   62,W
03BE:  MOVWF  63
....................    }else{ 
*
0465:  GOTO   511
....................       ESP8266_Get_IPD(buffer); 
0466:  BSF    03.6
0467:  CLRF   64
0468:  MOVF   62,W
0469:  MOVWF  63
....................       ESP8266_Get_CMD(buffer); 
*
04A0:  BSF    03.6
04A1:  CLRF   64
04A2:  MOVF   62,W
04A3:  MOVWF  63
....................       ESP8266_Get_Data(buffer); 
*
04DC:  BSF    03.6
04DD:  CLRF   64
04DE:  MOVF   62,W
04DF:  MOVWF  63
....................    } 
*
0511:  BCF    0C.5
0512:  BCF    0A.3
0513:  BCF    0A.4
0514:  GOTO   02D
.................... } 
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
*
1671:  MOVF   03,W
1672:  ANDLW  1F
1673:  MOVWF  03
1674:  BSF    03.5
1675:  BSF    03.6
1676:  BSF    07.3
1677:  MOVLW  08
1678:  BCF    03.6
1679:  MOVWF  19
167A:  MOVLW  02
167B:  MOVWF  1A
167C:  MOVLW  A6
167D:  MOVWF  18
167E:  MOVLW  90
167F:  BCF    03.5
1680:  MOVWF  18
1681:  BSF    03.5
1682:  BCF    06.0
1683:  BCF    03.5
1684:  BSF    06.0
1685:  CLRF   41
1686:  CLRF   42
1687:  CLRF   43
1688:  CLRF   44
1689:  CLRF   45
168A:  CLRF   46
168B:  CLRF   47
168C:  CLRF   48
168D:  CLRF   49
168E:  CLRF   4A
168F:  CLRF   4B
1690:  CLRF   4C
1691:  CLRF   4D
1692:  CLRF   4E
1693:  CLRF   55
1694:  CLRF   54
1695:  CLRF   56
1696:  CLRF   57
1697:  CLRF   58
1698:  CLRF   59
1699:  CLRF   5A
169A:  CLRF   5B
169B:  CLRF   5C
169C:  MOVLW  02
169D:  MOVWF  5D
169E:  MOVLW  08
169F:  MOVWF  5E
16A0:  MOVWF  5F
16A1:  MOVLW  05
16A2:  MOVWF  60
16A3:  MOVLW  03
16A4:  MOVWF  61
16A5:  CLRF   62
16A6:  BSF    03.5
16A7:  BSF    03.6
16A8:  MOVF   09,W
16A9:  ANDLW  C0
16AA:  MOVWF  09
16AB:  BCF    03.6
16AC:  BCF    1F.4
16AD:  BCF    1F.5
16AE:  MOVLW  00
16AF:  BSF    03.6
16B0:  MOVWF  08
16B1:  BCF    03.5
16B2:  CLRF   07
16B3:  CLRF   08
16B4:  CLRF   09
16B5:  BCF    03.7
....................    {       
....................       /*for(int idxNC=0;idxNC<=255;idxNC++){ 
....................          write_eeprom(idxNC,0xFF); 
....................          delay_ms(10); 
....................       }*/ 
....................           
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
*
16D1:  MOVLW  02
16D2:  BSF    03.6
16D3:  MOVWF  42
16D4:  MOVLW  FA
16D5:  MOVWF  59
16D6:  BCF    0A.4
16D7:  BCF    03.6
16D8:  CALL   515
16D9:  BSF    0A.4
16DA:  BSF    03.6
16DB:  DECFSZ 42,F
16DC:  GOTO   6D4
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
16DD:  MOVLW  30
16DE:  BSF    03.5
16DF:  BCF    03.6
16E0:  MOVWF  15
16E1:  BCF    01.7
....................       set_tris_b(0b00110010); 
16E2:  MOVLW  32
16E3:  MOVWF  06
....................       enable_interrupts(INT_RDA);  
16E4:  BSF    0C.5
....................       enable_interrupts(GLOBAL);  
16E5:  MOVLW  C0
16E6:  BCF    03.5
16E7:  IORWF  0B,F
....................  
....................       // Inicializa la LCD 
....................       lcd_init(); 
16E8:  BCF    0A.4
16E9:  GOTO   67B
16EA:  BSF    0A.4
....................        
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
16EB:  BSF    03.5
16EC:  BCF    08.3
16ED:  BCF    03.5
16EE:  BSF    08.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
16EF:  BCF    0A.4
16F0:  BSF    0A.3
16F1:  GOTO   052
16F2:  BSF    0A.4
16F3:  BCF    0A.3
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
16F4:  MOVF   62,W
16F5:  ADDLW  FC
16F6:  BTFSC  03.0
16F7:  GOTO   70D
16F8:  ADDLW  04
16F9:  GOTO   70F
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
16FA:  BCF    0A.4
16FB:  BSF    0A.3
16FC:  GOTO   66D
16FD:  BSF    0A.4
16FE:  BCF    0A.3
16FF:  MOVF   78,W
1700:  MOVWF  62
....................                break; 
1701:  GOTO   70D
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
1702:  GOTO   000
1703:  MOVF   78,W
1704:  MOVWF  62
....................                break; 
1705:  GOTO   70D
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
1706:  GOTO   113
1707:  MOVF   78,W
1708:  MOVWF  62
....................                break; 
1709:  GOTO   70D
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
170A:  GOTO   530
170B:  MOVF   78,W
170C:  MOVWF  62
....................                break; 
....................          } // Fin del Switch(menuActive) 
170D:  GOTO   6F4
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
170E:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
