CCS PCM C Compiler, Version 5.015, 5967               12-dic.-17 20:22

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   5895 words (72%)
                           Largest free fragment is 2048
               RAM used:   172 (47%) at main() level
                           211 (57%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  16
0001:  MOVWF  0A
0002:  GOTO   683
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   3F3
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  2B
0056:  RETLW  49
0057:  RETLW  50
0058:  RETLW  44
0059:  RETLW  2C
005A:  BCF    0A.0
005B:  BCF    0A.1
005C:  BCF    0A.2
005D:  ADDWF  02,F
005E:  RETLW  43
005F:  RETLW  4D
0060:  RETLW  44
0061:  RETLW  3A
0062:  BCF    0A.0
0063:  BCF    0A.1
0064:  BCF    0A.2
0065:  ADDWF  02,F
0066:  RETLW  4F
0067:  RETLW  4B
0068:  RETLW  0D
0069:  RETLW  0A
006A:  BCF    0A.0
006B:  BCF    0A.1
006C:  BCF    0A.2
006D:  ADDWF  02,F
006E:  RETLW  4E
006F:  RETLW  6F
0070:  RETLW  20
0071:  RETLW  41
0072:  RETLW  50
0073:  BCF    0A.0
0074:  BCF    0A.1
0075:  BCF    0A.2
0076:  ADDWF  02,F
0077:  RETLW  2B
0078:  RETLW  43
0079:  RETLW  57
007A:  RETLW  4A
007B:  RETLW  41
007C:  RETLW  50
007D:  RETLW  3A
007E:  BCF    0A.0
007F:  BCF    0A.1
0080:  BCF    0A.2
0081:  ADDWF  02,F
0082:  RETLW  43
0083:  RETLW  4F
0084:  RETLW  4E
0085:  RETLW  4E
0086:  RETLW  45
0087:  RETLW  43
0088:  RETLW  54
0089:  RETLW  45
008A:  RETLW  44
008B:  BCF    0A.0
008C:  BCF    0A.1
008D:  BCF    0A.2
008E:  ADDWF  02,F
008F:  RETLW  46
0090:  RETLW  41
0091:  RETLW  49
0092:  RETLW  4C
0093:  DATA 41,2A
0094:  DATA AB,21
0095:  DATA 49,28
0096:  DATA D3,22
0097:  DATA 4E,22
0098:  DATA BD,12
0099:  DATA 63,16
009A:  DATA 31,19
009B:  DATA 0D,05
009C:  DATA 00,00
009D:  DATA 41,2A
009E:  DATA AB,21
009F:  DATA 49,28
00A0:  DATA 43,26
00A1:  DATA CF,29
00A2:  DATA C5,1E
00A3:  DATA A5,31
00A4:  DATA 0D,05
00A5:  DATA 00,01
00A6:  DATA 41,2A
00A7:  DATA AB,21
00A8:  DATA D7,28
00A9:  DATA 41,28
00AA:  DATA 8A,06
00AB:  DATA 00,00
00AC:  DATA 41,2A
00AD:  DATA AB,21
00AE:  DATA 49,28
00AF:  DATA D3,22
00B0:  DATA 4E,22
00B1:  DATA BD,12
00B2:  DATA 63,16
00B3:  DATA 31,19
00B4:  DATA 0D,05
00B5:  DATA 00,01
00B6:  DATA 41,2A
00B7:  DATA AB,21
00B8:  DATA 49,28
00B9:  DATA 43,26
00BA:  DATA CF,29
00BB:  DATA C5,1E
00BC:  DATA A5,31
00BD:  DATA 0D,05
00BE:  DATA 00,01
00BF:  DATA 41,2A
00C0:  DATA AB,21
00C1:  DATA 49,28
00C2:  DATA D3,22
00C3:  DATA 4E,22
00C4:  DATA BD,12
00C5:  DATA 63,16
00C6:  DATA 31,19
00C7:  DATA 0D,05
00C8:  DATA 00,01
00C9:  DATA 41,2A
00CA:  DATA AB,21
00CB:  DATA 49,28
00CC:  DATA 43,26
00CD:  DATA CF,29
00CE:  DATA C5,1E
00CF:  DATA A5,31
00D0:  DATA 0D,05
00D1:  DATA 00,00
00D2:  DATA 41,2A
00D3:  DATA AB,21
00D4:  DATA D7,26
00D5:  DATA 4F,22
00D6:  DATA C5,1E
00D7:  DATA A5,31
00D8:  DATA 0D,05
00D9:  DATA 00,01
00DA:  DATA 41,2A
00DB:  DATA AB,21
00DC:  DATA 57,25
00DD:  DATA 41,28
00DE:  DATA BF,06
00DF:  DATA 0A,00
00E0:  DATA 41,2A
00E1:  DATA AB,21
00E2:  DATA 57,25
00E3:  DATA 41,28
00E4:  DATA BD,12
00E5:  DATA 73,00
00E6:  DATA 41,2A
00E7:  DATA AB,21
00E8:  DATA D7,26
00E9:  DATA 4F,22
00EA:  DATA C5,1E
00EB:  DATA A5,31
00EC:  DATA 0D,05
00ED:  DATA 00,01
00EE:  DATA 41,2A
00EF:  DATA AB,21
00F0:  DATA 49,28
00F1:  DATA CD,2A
00F2:  DATA D8,1E
00F3:  DATA B1,06
00F4:  DATA 0A,00
00F5:  DATA 41,2A
00F6:  DATA AB,21
00F7:  DATA 49,28
00F8:  DATA D3,22
00F9:  DATA 52,2B
00FA:  DATA 45,29
00FB:  DATA BD,18
00FC:  DATA 2C,1C
00FD:  DATA B0,06
00FE:  DATA 0A,00
00FF:  RETLW  45
0100:  RETLW  6E
0101:  RETLW  63
0102:  RETLW  65
0103:  RETLW  6E
0104:  RETLW  64
0105:  RETLW  65
0106:  RETLW  72
0107:  RETLW  20
0108:  RETLW  4D
0109:  RETLW  61
010A:  RETLW  6E
010B:  RETLW  75
010C:  RETLW  61
010D:  RETLW  6C
010E:  RETLW  00
010F:  RETLW  41
0110:  RETLW  70
0111:  RETLW  61
0112:  RETLW  67
0113:  RETLW  61
0114:  RETLW  64
0115:  RETLW  6F
0116:  RETLW  20
0117:  RETLW  4D
0118:  RETLW  61
0119:  RETLW  6E
011A:  RETLW  75
011B:  RETLW  61
011C:  RETLW  6C
011D:  RETLW  20
011E:  RETLW  00
011F:  RETLW  43
0120:  RETLW  6F
0121:  RETLW  6E
0122:  RETLW  66
0123:  RETLW  69
0124:  RETLW  67
0125:  RETLW  75
0126:  RETLW  72
0127:  RETLW  61
0128:  RETLW  63
0129:  RETLW  69
012A:  RETLW  6F
012B:  RETLW  6E
012C:  RETLW  20
012D:  RETLW  20
012E:  RETLW  00
012F:  RETLW  00
0130:  RETLW  00
0131:  RETLW  00
0132:  RETLW  00
0133:  RETLW  00
0134:  RETLW  00
0135:  RETLW  00
0136:  RETLW  00
0137:  RETLW  00
0138:  RETLW  00
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  00
013C:  RETLW  00
013D:  RETLW  00
013E:  RETLW  00
013F:  RETLW  4F
0140:  RETLW  6E
0141:  RETLW  20
0142:  RETLW  2D
0143:  RETLW  3E
0144:  RETLW  20
0145:  RETLW  53
0146:  RETLW  61
0147:  RETLW  6C
0148:  RETLW  69
0149:  RETLW  64
014A:  RETLW  61
014B:  RETLW  20
014C:  RETLW  31
014D:  RETLW  00
014E:  RETLW  4F
014F:  RETLW  6E
0150:  RETLW  20
0151:  RETLW  2D
0152:  RETLW  3E
0153:  RETLW  20
0154:  RETLW  53
0155:  RETLW  61
0156:  RETLW  6C
0157:  RETLW  69
0158:  RETLW  64
0159:  RETLW  61
015A:  RETLW  20
015B:  RETLW  32
015C:  RETLW  00
015D:  RETLW  4F
015E:  RETLW  6E
015F:  RETLW  20
0160:  RETLW  2D
0161:  RETLW  3E
0162:  RETLW  20
0163:  RETLW  53
0164:  RETLW  61
0165:  RETLW  6C
0166:  RETLW  69
0167:  RETLW  64
0168:  RETLW  61
0169:  RETLW  20
016A:  RETLW  33
016B:  RETLW  00
016C:  RETLW  4F
016D:  RETLW  6E
016E:  RETLW  20
016F:  RETLW  2D
0170:  RETLW  3E
0171:  RETLW  20
0172:  RETLW  53
0173:  RETLW  61
0174:  RETLW  6C
0175:  RETLW  69
0176:  RETLW  64
0177:  RETLW  61
0178:  RETLW  20
0179:  RETLW  34
017A:  RETLW  00
017B:  RETLW  4F
017C:  RETLW  6E
017D:  RETLW  20
017E:  RETLW  2D
017F:  RETLW  3E
0180:  RETLW  20
0181:  RETLW  53
0182:  RETLW  61
0183:  RETLW  6C
0184:  RETLW  69
0185:  RETLW  64
0186:  RETLW  61
0187:  RETLW  20
0188:  RETLW  35
0189:  RETLW  00
018A:  RETLW  4F
018B:  RETLW  6E
018C:  RETLW  20
018D:  RETLW  2D
018E:  RETLW  3E
018F:  RETLW  20
0190:  RETLW  53
0191:  RETLW  61
0192:  RETLW  6C
0193:  RETLW  69
0194:  RETLW  64
0195:  RETLW  61
0196:  RETLW  20
0197:  RETLW  36
0198:  RETLW  00
0199:  RETLW  4F
019A:  RETLW  6E
019B:  RETLW  20
019C:  RETLW  2D
019D:  RETLW  3E
019E:  RETLW  20
019F:  RETLW  53
01A0:  RETLW  61
01A1:  RETLW  6C
01A2:  RETLW  69
01A3:  RETLW  64
01A4:  RETLW  61
01A5:  RETLW  20
01A6:  RETLW  37
01A7:  RETLW  00
01A8:  RETLW  4F
01A9:  RETLW  6E
01AA:  RETLW  20
01AB:  RETLW  2D
01AC:  RETLW  3E
01AD:  RETLW  20
01AE:  RETLW  53
01AF:  RETLW  61
01B0:  RETLW  6C
01B1:  RETLW  69
01B2:  RETLW  64
01B3:  RETLW  61
01B4:  RETLW  20
01B5:  RETLW  38
01B6:  RETLW  00
01B7:  RETLW  53
01B8:  RETLW  41
01B9:  RETLW  4C
01BA:  RETLW  49
01BB:  RETLW  52
01BC:  RETLW  20
01BD:  RETLW  20
01BE:  RETLW  20
01BF:  RETLW  20
01C0:  RETLW  20
01C1:  RETLW  20
01C2:  RETLW  20
01C3:  RETLW  20
01C4:  RETLW  20
01C5:  RETLW  00
01C6:  RETLW  00
01C7:  RETLW  00
01C8:  RETLW  00
01C9:  RETLW  00
01CA:  RETLW  00
01CB:  RETLW  00
01CC:  RETLW  00
01CD:  RETLW  00
01CE:  RETLW  00
01CF:  RETLW  00
01D0:  RETLW  00
01D1:  RETLW  00
01D2:  RETLW  00
01D3:  RETLW  00
01D4:  RETLW  00
01D5:  RETLW  4F
01D6:  RETLW  66
01D7:  RETLW  66
01D8:  RETLW  20
01D9:  RETLW  2D
01DA:  RETLW  3E
01DB:  RETLW  20
01DC:  RETLW  53
01DD:  RETLW  61
01DE:  RETLW  6C
01DF:  RETLW  69
01E0:  RETLW  64
01E1:  RETLW  61
01E2:  RETLW  20
01E3:  RETLW  31
01E4:  RETLW  00
01E5:  RETLW  4F
01E6:  RETLW  66
01E7:  RETLW  66
01E8:  RETLW  20
01E9:  RETLW  2D
01EA:  RETLW  3E
01EB:  RETLW  20
01EC:  RETLW  53
01ED:  RETLW  61
01EE:  RETLW  6C
01EF:  RETLW  69
01F0:  RETLW  64
01F1:  RETLW  61
01F2:  RETLW  20
01F3:  RETLW  32
01F4:  RETLW  00
01F5:  RETLW  4F
01F6:  RETLW  66
01F7:  RETLW  66
01F8:  RETLW  20
01F9:  RETLW  2D
01FA:  RETLW  3E
01FB:  RETLW  20
01FC:  RETLW  53
01FD:  RETLW  61
01FE:  RETLW  6C
01FF:  RETLW  69
0200:  RETLW  64
0201:  RETLW  61
0202:  RETLW  20
0203:  RETLW  33
0204:  RETLW  00
0205:  RETLW  4F
0206:  RETLW  66
0207:  RETLW  66
0208:  RETLW  20
0209:  RETLW  2D
020A:  RETLW  3E
020B:  RETLW  20
020C:  RETLW  53
020D:  RETLW  61
020E:  RETLW  6C
020F:  RETLW  69
0210:  RETLW  64
0211:  RETLW  61
0212:  RETLW  20
0213:  RETLW  34
0214:  RETLW  00
0215:  RETLW  4F
0216:  RETLW  66
0217:  RETLW  66
0218:  RETLW  20
0219:  RETLW  2D
021A:  RETLW  3E
021B:  RETLW  20
021C:  RETLW  53
021D:  RETLW  61
021E:  RETLW  6C
021F:  RETLW  69
0220:  RETLW  64
0221:  RETLW  61
0222:  RETLW  20
0223:  RETLW  35
0224:  RETLW  00
0225:  RETLW  4F
0226:  RETLW  66
0227:  RETLW  66
0228:  RETLW  20
0229:  RETLW  2D
022A:  RETLW  3E
022B:  RETLW  20
022C:  RETLW  53
022D:  RETLW  61
022E:  RETLW  6C
022F:  RETLW  69
0230:  RETLW  64
0231:  RETLW  61
0232:  RETLW  20
0233:  RETLW  36
0234:  RETLW  00
0235:  RETLW  4F
0236:  RETLW  66
0237:  RETLW  66
0238:  RETLW  20
0239:  RETLW  2D
023A:  RETLW  3E
023B:  RETLW  20
023C:  RETLW  53
023D:  RETLW  61
023E:  RETLW  6C
023F:  RETLW  69
0240:  RETLW  64
0241:  RETLW  61
0242:  RETLW  20
0243:  RETLW  37
0244:  RETLW  00
0245:  RETLW  4F
0246:  RETLW  66
0247:  RETLW  66
0248:  RETLW  20
0249:  RETLW  2D
024A:  RETLW  3E
024B:  RETLW  20
024C:  RETLW  53
024D:  RETLW  61
024E:  RETLW  6C
024F:  RETLW  69
0250:  RETLW  64
0251:  RETLW  61
0252:  RETLW  20
0253:  RETLW  38
0254:  RETLW  00
0255:  RETLW  53
0256:  RETLW  41
0257:  RETLW  4C
0258:  RETLW  49
0259:  RETLW  52
025A:  RETLW  20
025B:  RETLW  20
025C:  RETLW  20
025D:  RETLW  20
025E:  RETLW  20
025F:  RETLW  20
0260:  RETLW  20
0261:  RETLW  20
0262:  RETLW  20
0263:  RETLW  20
0264:  RETLW  00
0265:  RETLW  00
0266:  RETLW  00
0267:  RETLW  00
0268:  RETLW  00
0269:  RETLW  00
026A:  RETLW  00
026B:  RETLW  00
026C:  RETLW  00
026D:  RETLW  00
026E:  RETLW  00
026F:  RETLW  00
0270:  RETLW  00
0271:  RETLW  00
0272:  RETLW  00
0273:  RETLW  00
0274:  RETLW  00
0275:  RETLW  45
0276:  RETLW  53
0277:  RETLW  54
0278:  RETLW  41
0279:  RETLW  43
027A:  RETLW  49
027B:  RETLW  4F
027C:  RETLW  4E
027D:  RETLW  20
027E:  RETLW  49
027F:  RETLW  50
0280:  RETLW  20
0281:  RETLW  20
0282:  RETLW  20
0283:  RETLW  20
0284:  RETLW  20
0285:  RETLW  00
0286:  RETLW  45
0287:  RETLW  53
0288:  RETLW  54
0289:  RETLW  41
028A:  RETLW  43
028B:  RETLW  49
028C:  RETLW  4F
028D:  RETLW  4E
028E:  RETLW  20
028F:  RETLW  53
0290:  RETLW  53
0291:  RETLW  49
0292:  RETLW  44
0293:  RETLW  20
0294:  RETLW  20
0295:  RETLW  20
0296:  RETLW  00
0297:  RETLW  41
0298:  RETLW  50
0299:  RETLW  20
029A:  RETLW  53
029B:  RETLW  53
029C:  RETLW  49
029D:  RETLW  44
029E:  RETLW  20
029F:  RETLW  20
02A0:  RETLW  20
02A1:  RETLW  20
02A2:  RETLW  20
02A3:  RETLW  20
02A4:  RETLW  20
02A5:  RETLW  20
02A6:  RETLW  20
02A7:  RETLW  00
02A8:  RETLW  41
02A9:  RETLW  50
02AA:  RETLW  20
02AB:  RETLW  4B
02AC:  RETLW  45
02AD:  RETLW  59
02AE:  RETLW  20
02AF:  RETLW  20
02B0:  RETLW  20
02B1:  RETLW  20
02B2:  RETLW  20
02B3:  RETLW  20
02B4:  RETLW  20
02B5:  RETLW  20
02B6:  RETLW  20
02B7:  RETLW  20
02B8:  RETLW  00
02B9:  RETLW  41
02BA:  RETLW  50
02BB:  RETLW  20
02BC:  RETLW  49
02BD:  RETLW  50
02BE:  RETLW  20
02BF:  RETLW  20
02C0:  RETLW  20
02C1:  RETLW  20
02C2:  RETLW  20
02C3:  RETLW  20
02C4:  RETLW  20
02C5:  RETLW  20
02C6:  RETLW  20
02C7:  RETLW  20
02C8:  RETLW  20
02C9:  RETLW  00
02CA:  RETLW  43
02CB:  RETLW  6F
02CC:  RETLW  6E
02CD:  RETLW  66
02CE:  RETLW  20
02CF:  RETLW  41
02D0:  RETLW  63
02D1:  RETLW  63
02D2:  RETLW  65
02D3:  RETLW  73
02D4:  RETLW  73
02D5:  RETLW  6F
02D6:  RETLW  20
02D7:  RETLW  52
02D8:  RETLW  65
02D9:  RETLW  64
02DA:  RETLW  00
02DB:  RETLW  4F
02DC:  RETLW  6E
02DD:  RETLW  2F
02DE:  RETLW  4F
02DF:  RETLW  66
02E0:  RETLW  66
02E1:  RETLW  20
02E2:  RETLW  42
02E3:  RETLW  61
02E4:  RETLW  63
02E5:  RETLW  6B
02E6:  RETLW  6C
02E7:  RETLW  69
02E8:  RETLW  67
02E9:  RETLW  68
02EA:  RETLW  74
02EB:  RETLW  00
02EC:  RETLW  53
02ED:  RETLW  41
02EE:  RETLW  4C
02EF:  RETLW  49
02F0:  RETLW  52
02F1:  RETLW  20
02F2:  RETLW  20
02F3:  RETLW  20
02F4:  RETLW  20
02F5:  RETLW  20
02F6:  RETLW  20
02F7:  RETLW  20
02F8:  RETLW  20
02F9:  RETLW  20
02FA:  RETLW  20
02FB:  RETLW  20
02FC:  RETLW  00
02FD:  RETLW  00
02FE:  RETLW  00
02FF:  RETLW  00
0300:  RETLW  00
0301:  RETLW  00
0302:  RETLW  00
0303:  RETLW  00
0304:  RETLW  00
0305:  RETLW  00
0306:  RETLW  00
0307:  RETLW  00
0308:  RETLW  00
0309:  RETLW  00
030A:  RETLW  00
030B:  RETLW  00
030C:  RETLW  00
030D:  RETLW  00
030E:  RETLW  45
030F:  RETLW  73
0310:  RETLW  74
0311:  RETLW  61
0312:  RETLW  63
0313:  RETLW  69
0314:  RETLW  F3
0315:  RETLW  6E
0316:  RETLW  20
0317:  RETLW  20
0318:  RETLW  20
0319:  RETLW  20
031A:  RETLW  20
031B:  RETLW  00
031C:  RETLW  41
031D:  RETLW  63
031E:  RETLW  63
031F:  RETLW  65
0320:  RETLW  73
0321:  RETLW  73
0322:  RETLW  20
0323:  RETLW  50
0324:  RETLW  6F
0325:  RETLW  69
0326:  RETLW  6E
0327:  RETLW  74
0328:  RETLW  20
0329:  RETLW  00
032A:  RETLW  45
032B:  RETLW  73
032C:  RETLW  74
032D:  RETLW  61
032E:  RETLW  63
032F:  RETLW  69
0330:  RETLW  6F
0331:  RETLW  6E
0332:  RETLW  20
0333:  RETLW  2B
0334:  RETLW  20
0335:  RETLW  41
0336:  RETLW  50
0337:  RETLW  00
0338:  RETLW  53
0339:  RETLW  41
033A:  RETLW  4C
033B:  RETLW  49
033C:  RETLW  52
033D:  RETLW  20
033E:  RETLW  20
033F:  RETLW  20
0340:  RETLW  20
0341:  RETLW  20
0342:  RETLW  20
0343:  RETLW  20
0344:  RETLW  20
0345:  RETLW  00
0346:  RETLW  00
0347:  RETLW  00
0348:  RETLW  00
0349:  RETLW  00
034A:  RETLW  00
034B:  RETLW  00
034C:  RETLW  00
034D:  RETLW  00
034E:  RETLW  00
034F:  RETLW  00
0350:  RETLW  00
0351:  RETLW  00
0352:  RETLW  00
0353:  RETLW  00
0354:  DATA D3,20
0355:  DATA CC,24
0356:  DATA 52,00
0357:  DATA DB,29
0358:  DATA C9,23
0359:  DATA 5D,10
035A:  DATA 20,10
035B:  DATA 20,10
035C:  DATA A0,2D
035D:  DATA 45,27
035E:  DATA D4,2E
035F:  DATA 00,00
0360:  DATA 8C,27
0361:  DATA 50,2A
0362:  DATA DF,29
0363:  DATA C8,27
0364:  DATA D7,2F
0365:  DATA 53,2A
0366:  DATA C1,2F
0367:  DATA 49,28
0368:  DATA 00,01
0369:  DATA 8C,27
036A:  DATA 50,2A
036B:  DATA DF,29
036C:  DATA C8,27
036D:  DATA D7,2F
036E:  DATA 53,2A
036F:  DATA C1,2F
0370:  DATA D3,29
0371:  DATA 49,22
0372:  DATA 00,01
0373:  DATA 8C,27
0374:  DATA 50,2A
0375:  DATA DF,29
0376:  DATA C8,27
0377:  DATA D7,2F
0378:  DATA 41,28
0379:  DATA DF,29
037A:  DATA D3,24
037B:  DATA 44,00
037C:  DATA 8C,27
037D:  DATA 50,2A
037E:  DATA DF,29
037F:  DATA C8,27
0380:  DATA D7,2F
0381:  DATA 41,28
0382:  DATA DF,25
0383:  DATA C5,2C
0384:  DATA 00,01
0385:  DATA 8C,27
0386:  DATA 50,2A
0387:  DATA DF,29
0388:  DATA C8,27
0389:  DATA D7,2F
038A:  DATA 41,28
038B:  DATA DF,24
038C:  DATA 50,00
038D:  DATA 0C,21
038E:  DATA E1,31
038F:  DATA 6B,36
0390:  DATA E9,33
0391:  DATA 68,3A
0392:  DATA A0,27
0393:  DATA 6E,00
0394:  DATA 0C,21
0395:  DATA E1,31
0396:  DATA 6B,36
0397:  DATA E9,33
0398:  DATA 68,3A
0399:  DATA A0,27
039A:  DATA 66,33
039B:  DATA 00,01
039C:  DATA 41,2A
039D:  DATA AB,21
039E:  DATA D7,26
039F:  DATA 4F,22
03A0:  DATA C5,2F
03A1:  DATA C4,22
03A2:  DATA C6,1E
03A3:  DATA B1,06
03A4:  DATA 0A,00
03A5:  DATA 8C,21
03A6:  DATA 6F,37
03A7:  DATA E6,34
03A8:  DATA 67,10
03A9:  DATA 43,36
03AA:  DATA E9,32
03AB:  DATA 6E,3A
03AC:  DATA 65,00
03AD:  DATA 41,2A
03AE:  DATA AB,21
03AF:  DATA D7,26
03B0:  DATA 4F,22
03B1:  DATA C5,2F
03B2:  DATA C4,22
03B3:  DATA C6,1E
03B4:  DATA B2,06
03B5:  DATA 0A,00
03B6:  DATA 8C,21
03B7:  DATA 6F,37
03B8:  DATA E6,34
03B9:  DATA 67,10
03BA:  DATA 41,28
03BB:  DATA 00,01
03BC:  DATA 41,2A
03BD:  DATA AB,21
03BE:  DATA D7,26
03BF:  DATA 4F,22
03C0:  DATA C5,2F
03C1:  DATA C4,22
03C2:  DATA C6,1E
03C3:  DATA B3,06
03C4:  DATA 0A,00
03C5:  DATA 8C,21
03C6:  DATA 6F,37
03C7:  DATA E6,34
03C8:  DATA 67,10
03C9:  DATA 43,36
03CA:  DATA E9,32
03CB:  DATA 6E,3A
03CC:  DATA E5,20
03CD:  DATA 50,00
*
0581:  DATA 8C,21
0582:  DATA 6F,37
0583:  DATA E6,34
0584:  DATA E7,3A
0585:  DATA F2,30
0586:  DATA 6E,32
0587:  DATA 6F,17
0588:  DATA 2E,17
0589:  DATA 00,01
*
0866:  MOVF   0B,W
0867:  BSF    03.6
0868:  MOVWF  10
0869:  BCF    03.6
086A:  BCF    0B.7
086B:  BSF    03.5
086C:  BSF    03.6
086D:  BSF    0C.7
086E:  BSF    0C.0
086F:  NOP
0870:  NOP
0871:  BCF    03.5
0872:  BTFSS  10.7
0873:  GOTO   077
0874:  BCF    03.6
0875:  BSF    0B.7
0876:  BSF    03.6
0877:  MOVF   0C,W
0878:  ANDLW  7F
0879:  BTFSC  03.2
087A:  GOTO   0B4
087B:  MOVWF  10
087C:  MOVF   0D,W
087D:  MOVWF  11
087E:  MOVF   0F,W
087F:  MOVWF  12
0880:  MOVF   10,W
0881:  MOVWF  13
0882:  BCF    03.6
0883:  CALL   000
0884:  BSF    03.6
0885:  MOVF   11,W
0886:  MOVWF  0D
0887:  MOVF   12,W
0888:  MOVWF  0F
0889:  BCF    03.6
088A:  MOVF   0B,W
088B:  BSF    03.6
088C:  MOVWF  13
088D:  BCF    03.6
088E:  BCF    0B.7
088F:  BSF    03.5
0890:  BSF    03.6
0891:  BSF    0C.7
0892:  BSF    0C.0
0893:  NOP
0894:  NOP
0895:  BCF    03.5
0896:  BTFSS  13.7
0897:  GOTO   09B
0898:  BCF    03.6
0899:  BSF    0B.7
089A:  BSF    03.6
089B:  RLF    0C,W
089C:  RLF    0E,W
089D:  ANDLW  7F
089E:  BTFSC  03.2
089F:  GOTO   0B4
08A0:  MOVWF  10
08A1:  MOVF   0D,W
08A2:  MOVWF  11
08A3:  MOVF   0F,W
08A4:  MOVWF  12
08A5:  MOVF   10,W
08A6:  MOVWF  13
08A7:  BCF    03.6
08A8:  CALL   000
08A9:  BSF    03.6
08AA:  MOVF   11,W
08AB:  MOVWF  0D
08AC:  MOVF   12,W
08AD:  MOVWF  0F
08AE:  INCF   0D,F
08AF:  BTFSC  03.2
08B0:  INCF   0F,F
08B1:  BCF    03.6
08B2:  GOTO   066
08B3:  BSF    03.6
08B4:  BCF    03.6
08B5:  RETURN
08B6:  MOVF   0B,W
08B7:  BSF    03.6
08B8:  MOVWF  22
08B9:  BCF    03.6
08BA:  BCF    0B.7
08BB:  BSF    03.5
08BC:  BSF    03.6
08BD:  BSF    0C.7
08BE:  BSF    0C.0
08BF:  NOP
08C0:  NOP
08C1:  BCF    03.5
08C2:  BTFSS  22.7
08C3:  GOTO   0C7
08C4:  BCF    03.6
08C5:  BSF    0B.7
08C6:  BSF    03.6
08C7:  BTFSC  03.0
08C8:  GOTO   0EF
08C9:  MOVF   0C,W
08CA:  ANDLW  7F
08CB:  MOVWF  22
08CC:  MOVF   0D,W
08CD:  MOVWF  23
08CE:  MOVF   0F,W
08CF:  MOVWF  24
08D0:  MOVF   22,W
08D1:  BCF    03.6
08D2:  BTFSS  0C.4
08D3:  GOTO   0D2
08D4:  MOVWF  19
08D5:  BSF    03.6
08D6:  MOVF   23,W
08D7:  MOVWF  0D
08D8:  MOVF   24,W
08D9:  MOVWF  0F
08DA:  BCF    03.6
08DB:  MOVF   0B,W
08DC:  BSF    03.6
08DD:  MOVWF  25
08DE:  BCF    03.6
08DF:  BCF    0B.7
08E0:  BSF    03.5
08E1:  BSF    03.6
08E2:  BSF    0C.7
08E3:  BSF    0C.0
08E4:  NOP
08E5:  NOP
08E6:  BCF    03.5
08E7:  BTFSS  25.7
08E8:  GOTO   0EC
08E9:  BCF    03.6
08EA:  BSF    0B.7
08EB:  BSF    03.6
08EC:  DECFSZ 21,F
08ED:  GOTO   0EF
08EE:  GOTO   10A
08EF:  RLF    0C,W
08F0:  RLF    0E,W
08F1:  ANDLW  7F
08F2:  MOVWF  22
08F3:  MOVF   0D,W
08F4:  MOVWF  23
08F5:  MOVF   0F,W
08F6:  MOVWF  24
08F7:  MOVF   22,W
08F8:  BCF    03.6
08F9:  BTFSS  0C.4
08FA:  GOTO   0F9
08FB:  MOVWF  19
08FC:  BSF    03.6
08FD:  MOVF   23,W
08FE:  MOVWF  0D
08FF:  MOVF   24,W
0900:  MOVWF  0F
0901:  INCF   0D,F
0902:  BTFSC  03.2
0903:  INCF   0F,F
0904:  BCF    03.0
0905:  DECFSZ 21,F
0906:  GOTO   108
0907:  GOTO   10A
0908:  BCF    03.6
0909:  GOTO   0B6
090A:  BCF    03.6
090B:  RETURN
090C:  MOVF   0B,W
090D:  BSF    03.6
090E:  MOVWF  21
090F:  BCF    03.6
0910:  BCF    0B.7
0911:  BSF    03.5
0912:  BSF    03.6
0913:  BSF    0C.7
0914:  BSF    0C.0
0915:  NOP
0916:  NOP
0917:  BCF    03.5
0918:  BTFSS  21.7
0919:  GOTO   11D
091A:  BCF    03.6
091B:  BSF    0B.7
091C:  BSF    03.6
091D:  MOVF   0C,W
091E:  ANDLW  7F
091F:  BTFSC  03.2
0920:  GOTO   15C
0921:  MOVWF  21
0922:  MOVF   0D,W
0923:  MOVWF  22
0924:  MOVF   0F,W
0925:  MOVWF  23
0926:  MOVF   21,W
0927:  BCF    03.6
0928:  BTFSS  0C.4
0929:  GOTO   128
092A:  MOVWF  19
092B:  BSF    03.6
092C:  MOVF   22,W
092D:  MOVWF  0D
092E:  MOVF   23,W
092F:  MOVWF  0F
0930:  BCF    03.6
0931:  MOVF   0B,W
0932:  BSF    03.6
0933:  MOVWF  24
0934:  BCF    03.6
0935:  BCF    0B.7
0936:  BSF    03.5
0937:  BSF    03.6
0938:  BSF    0C.7
0939:  BSF    0C.0
093A:  NOP
093B:  NOP
093C:  BCF    03.5
093D:  BTFSS  24.7
093E:  GOTO   142
093F:  BCF    03.6
0940:  BSF    0B.7
0941:  BSF    03.6
0942:  RLF    0C,W
0943:  RLF    0E,W
0944:  ANDLW  7F
0945:  BTFSC  03.2
0946:  GOTO   15C
0947:  MOVWF  21
0948:  MOVF   0D,W
0949:  MOVWF  22
094A:  MOVF   0F,W
094B:  MOVWF  23
094C:  MOVF   21,W
094D:  BCF    03.6
094E:  BTFSS  0C.4
094F:  GOTO   14E
0950:  MOVWF  19
0951:  BSF    03.6
0952:  MOVF   22,W
0953:  MOVWF  0D
0954:  MOVF   23,W
0955:  MOVWF  0F
0956:  INCF   0D,F
0957:  BTFSC  03.2
0958:  INCF   0F,F
0959:  BCF    03.6
095A:  GOTO   10C
095B:  BSF    03.6
095C:  BCF    03.6
095D:  RETURN
*
0A1C:  MOVF   00,F
0A1D:  BTFSC  03.2
0A1E:  GOTO   239
0A1F:  BSF    03.6
0A20:  CLRF   22
0A21:  MOVF   04,W
0A22:  MOVWF  21
0A23:  BCF    22.0
0A24:  BTFSC  03.7
0A25:  BSF    22.0
0A26:  MOVF   00,W
0A27:  BCF    03.6
0A28:  BTFSS  0C.4
0A29:  GOTO   228
0A2A:  MOVWF  19
0A2B:  BSF    03.6
0A2C:  MOVF   21,W
0A2D:  MOVWF  04
0A2E:  BCF    03.7
0A2F:  BTFSC  22.0
0A30:  BSF    03.7
0A31:  INCF   04,F
0A32:  BTFSS  03.2
0A33:  GOTO   237
0A34:  BCF    03.6
0A35:  INCF   05,F
0A36:  BSF    03.6
0A37:  BCF    03.6
0A38:  GOTO   21C
*
0A9B:  MOVF   0B,W
0A9C:  BSF    03.6
0A9D:  MOVWF  11
0A9E:  BCF    03.6
0A9F:  BCF    0B.7
0AA0:  BSF    03.5
0AA1:  BSF    03.6
0AA2:  BSF    0C.7
0AA3:  BSF    0C.0
0AA4:  NOP
0AA5:  NOP
0AA6:  BCF    03.5
0AA7:  BTFSS  11.7
0AA8:  GOTO   2AC
0AA9:  BCF    03.6
0AAA:  BSF    0B.7
0AAB:  BSF    03.6
0AAC:  MOVF   0C,F
0AAD:  BTFSC  03.2
0AAE:  GOTO   2C2
0AAF:  MOVF   0D,W
0AB0:  MOVWF  11
0AB1:  MOVF   0F,W
0AB2:  MOVWF  12
0AB3:  MOVF   0C,W
0AB4:  MOVWF  13
0AB5:  BCF    03.6
0AB6:  CALL   000
0AB7:  BSF    03.6
0AB8:  MOVF   11,W
0AB9:  MOVWF  0D
0ABA:  MOVF   12,W
0ABB:  MOVWF  0F
0ABC:  INCF   0D,F
0ABD:  BTFSC  03.2
0ABE:  INCF   0F,F
0ABF:  BCF    03.6
0AC0:  GOTO   29B
0AC1:  BSF    03.6
0AC2:  BCF    03.6
0AC3:  RETURN
0AC4:  BSF    03.6
0AC5:  MOVF   23,W
0AC6:  ANDLW  07
0AC7:  MOVWF  77
0AC8:  RRF    23,W
0AC9:  MOVWF  78
0ACA:  RRF    78,F
0ACB:  RRF    78,F
0ACC:  MOVLW  1F
0ACD:  ANDWF  78,F
0ACE:  MOVF   78,W
0ACF:  ADDWF  25,W
0AD0:  MOVWF  04
0AD1:  BCF    03.7
0AD2:  BTFSC  26.0
0AD3:  BSF    03.7
0AD4:  CLRF   78
0AD5:  INCF   78,F
0AD6:  INCF   77,F
0AD7:  GOTO   2D9
0AD8:  RLF    78,F
0AD9:  DECFSZ 77,F
0ADA:  GOTO   2D8
0ADB:  MOVF   24,F
0ADC:  BTFSC  03.2
0ADD:  GOTO   2E1
0ADE:  MOVF   78,W
0ADF:  IORWF  00,F
0AE0:  GOTO   2E4
0AE1:  COMF   78,F
0AE2:  MOVF   78,W
0AE3:  ANDWF  00,F
0AE4:  BCF    03.6
0AE5:  RETURN
*
0BFB:  MOVF   00,F
0BFC:  BTFSC  03.2
0BFD:  GOTO   418
0BFE:  BSF    03.6
0BFF:  CLRF   22
0C00:  MOVF   04,W
0C01:  MOVWF  21
0C02:  BCF    22.0
0C03:  BTFSC  03.7
0C04:  BSF    22.0
0C05:  MOVF   00,W
0C06:  BCF    03.6
0C07:  BTFSS  0C.4
0C08:  GOTO   407
0C09:  MOVWF  19
0C0A:  BSF    03.6
0C0B:  MOVF   21,W
0C0C:  MOVWF  04
0C0D:  BCF    03.7
0C0E:  BTFSC  22.0
0C0F:  BSF    03.7
0C10:  INCF   04,F
0C11:  BTFSS  03.2
0C12:  GOTO   416
0C13:  BCF    03.6
0C14:  INCF   05,F
0C15:  BSF    03.6
0C16:  BCF    03.6
0C17:  GOTO   3FB
*
0C9F:  MOVF   00,F
0CA0:  BTFSC  03.2
0CA1:  GOTO   4BC
0CA2:  BSF    03.6
0CA3:  CLRF   22
0CA4:  MOVF   04,W
0CA5:  MOVWF  21
0CA6:  BCF    22.0
0CA7:  BTFSC  03.7
0CA8:  BSF    22.0
0CA9:  MOVF   00,W
0CAA:  BCF    03.6
0CAB:  BTFSS  0C.4
0CAC:  GOTO   4AB
0CAD:  MOVWF  19
0CAE:  BSF    03.6
0CAF:  MOVF   21,W
0CB0:  MOVWF  04
0CB1:  BCF    03.7
0CB2:  BTFSC  22.0
0CB3:  BSF    03.7
0CB4:  INCF   04,F
0CB5:  BTFSS  03.2
0CB6:  GOTO   4BA
0CB7:  BCF    03.6
0CB8:  INCF   05,F
0CB9:  BSF    03.6
0CBA:  BCF    03.6
0CBB:  GOTO   49F
*
0D08:  MOVF   00,F
0D09:  BTFSC  03.2
0D0A:  GOTO   525
0D0B:  BSF    03.6
0D0C:  CLRF   22
0D0D:  MOVF   04,W
0D0E:  MOVWF  21
0D0F:  BCF    22.0
0D10:  BTFSC  03.7
0D11:  BSF    22.0
0D12:  MOVF   00,W
0D13:  BCF    03.6
0D14:  BTFSS  0C.4
0D15:  GOTO   514
0D16:  MOVWF  19
0D17:  BSF    03.6
0D18:  MOVF   21,W
0D19:  MOVWF  04
0D1A:  BCF    03.7
0D1B:  BTFSC  22.0
0D1C:  BSF    03.7
0D1D:  INCF   04,F
0D1E:  BTFSS  03.2
0D1F:  GOTO   523
0D20:  BCF    03.6
0D21:  INCF   05,F
0D22:  BSF    03.6
0D23:  BCF    03.6
0D24:  GOTO   508
*
0D8C:  BTFSC  03.1
0D8D:  GOTO   591
0D8E:  MOVLW  26
0D8F:  MOVWF  04
0D90:  BSF    03.7
0D91:  CLRF   77
0D92:  CLRF   78
0D93:  CLRF   79
0D94:  CLRF   7A
0D95:  CLRF   26
0D96:  CLRF   27
0D97:  CLRF   28
0D98:  CLRF   29
0D99:  MOVF   25,W
0D9A:  IORWF  24,W
0D9B:  IORWF  23,W
0D9C:  IORWF  22,W
0D9D:  BTFSC  03.2
0D9E:  GOTO   5CF
0D9F:  MOVLW  20
0DA0:  MOVWF  2A
0DA1:  BCF    03.0
0DA2:  RLF    1E,F
0DA3:  RLF    1F,F
0DA4:  RLF    20,F
0DA5:  RLF    21,F
0DA6:  RLF    26,F
0DA7:  RLF    27,F
0DA8:  RLF    28,F
0DA9:  RLF    29,F
0DAA:  MOVF   25,W
0DAB:  SUBWF  29,W
0DAC:  BTFSS  03.2
0DAD:  GOTO   5B8
0DAE:  MOVF   24,W
0DAF:  SUBWF  28,W
0DB0:  BTFSS  03.2
0DB1:  GOTO   5B8
0DB2:  MOVF   23,W
0DB3:  SUBWF  27,W
0DB4:  BTFSS  03.2
0DB5:  GOTO   5B8
0DB6:  MOVF   22,W
0DB7:  SUBWF  26,W
0DB8:  BTFSS  03.0
0DB9:  GOTO   5C9
0DBA:  MOVF   22,W
0DBB:  SUBWF  26,F
0DBC:  MOVF   23,W
0DBD:  BTFSS  03.0
0DBE:  INCFSZ 23,W
0DBF:  SUBWF  27,F
0DC0:  MOVF   24,W
0DC1:  BTFSS  03.0
0DC2:  INCFSZ 24,W
0DC3:  SUBWF  28,F
0DC4:  MOVF   25,W
0DC5:  BTFSS  03.0
0DC6:  INCFSZ 25,W
0DC7:  SUBWF  29,F
0DC8:  BSF    03.0
0DC9:  RLF    77,F
0DCA:  RLF    78,F
0DCB:  RLF    79,F
0DCC:  RLF    7A,F
0DCD:  DECFSZ 2A,F
0DCE:  GOTO   5A1
0DCF:  MOVF   26,W
0DD0:  MOVWF  00
0DD1:  INCF   04,F
0DD2:  MOVF   27,W
0DD3:  MOVWF  00
0DD4:  INCF   04,F
0DD5:  MOVF   28,W
0DD6:  MOVWF  00
0DD7:  INCF   04,F
0DD8:  MOVF   29,W
0DD9:  MOVWF  00
*
0DEF:  MOVLW  20
0DF0:  MOVWF  2A
0DF1:  CLRF   26
0DF2:  CLRF   27
0DF3:  CLRF   28
0DF4:  CLRF   29
0DF5:  MOVF   21,W
0DF6:  MOVWF  7A
0DF7:  MOVF   20,W
0DF8:  MOVWF  79
0DF9:  MOVF   1F,W
0DFA:  MOVWF  78
0DFB:  MOVF   1E,W
0DFC:  MOVWF  77
0DFD:  BCF    03.0
0DFE:  BTFSS  77.0
0DFF:  GOTO   60E
0E00:  MOVF   22,W
0E01:  ADDWF  26,F
0E02:  MOVF   23,W
0E03:  BTFSC  03.0
0E04:  INCFSZ 23,W
0E05:  ADDWF  27,F
0E06:  MOVF   24,W
0E07:  BTFSC  03.0
0E08:  INCFSZ 24,W
0E09:  ADDWF  28,F
0E0A:  MOVF   25,W
0E0B:  BTFSC  03.0
0E0C:  INCFSZ 25,W
0E0D:  ADDWF  29,F
0E0E:  RRF    29,F
0E0F:  RRF    28,F
0E10:  RRF    27,F
0E11:  RRF    26,F
0E12:  RRF    7A,F
0E13:  RRF    79,F
0E14:  RRF    78,F
0E15:  RRF    77,F
0E16:  DECFSZ 2A,F
0E17:  GOTO   5FD
*
0F81:  CLRF   77
0F82:  CLRF   78
0F83:  BSF    03.6
0F84:  MOVF   10,W
0F85:  BCF    03.0
0F86:  BTFSC  11.0
0F87:  ADDWF  77,F
0F88:  RRF    77,F
0F89:  RRF    78,F
0F8A:  BTFSC  11.1
0F8B:  ADDWF  77,F
0F8C:  RRF    77,F
0F8D:  RRF    78,F
0F8E:  BTFSC  11.2
0F8F:  ADDWF  77,F
0F90:  RRF    77,F
0F91:  RRF    78,F
0F92:  BTFSC  11.3
0F93:  ADDWF  77,F
0F94:  RRF    77,F
0F95:  RRF    78,F
0F96:  BTFSC  11.4
0F97:  ADDWF  77,F
0F98:  RRF    77,F
0F99:  RRF    78,F
0F9A:  BTFSC  11.5
0F9B:  ADDWF  77,F
0F9C:  RRF    77,F
0F9D:  RRF    78,F
0F9E:  BTFSC  11.6
0F9F:  ADDWF  77,F
0FA0:  RRF    77,F
0FA1:  RRF    78,F
0FA2:  BTFSC  11.7
0FA3:  ADDWF  77,F
0FA4:  RRF    77,F
0FA5:  RRF    78,F
0FA6:  BCF    03.6
0FA7:  RETURN
*
151D:  BSF    0A.0
151E:  BCF    0A.1
151F:  BSF    0A.2
1520:  ADDWF  02,F
1521:  GOTO   251
1522:  GOTO   25E
1523:  GOTO   26B
1524:  GOTO   278
1525:  GOTO   285
1526:  GOTO   292
1527:  GOTO   4B1
1528:  GOTO   4D1
*
1761:  BSF    0A.0
1762:  BSF    0A.1
1763:  BSF    0A.2
1764:  ADDWF  02,F
1765:  GOTO   746
1766:  GOTO   74F
1767:  GOTO   754
1768:  GOTO   759
....................  
.................... #list 
....................  
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20M) 
*
058A:  MOVLW  22
058B:  MOVWF  04
058C:  BSF    03.7
058D:  MOVF   00,W
058E:  BTFSC  03.2
058F:  GOTO   59D
0590:  MOVLW  06
0591:  MOVWF  78
0592:  CLRF   77
0593:  DECFSZ 77,F
0594:  GOTO   593
0595:  DECFSZ 78,F
0596:  GOTO   592
0597:  MOVLW  7B
0598:  MOVWF  77
0599:  DECFSZ 77,F
059A:  GOTO   599
059B:  DECFSZ 00,F
059C:  GOTO   590
059D:  RETURN
*
0E32:  MOVLW  03
0E33:  SUBWF  1F,F
0E34:  BTFSS  03.0
0E35:  GOTO   640
0E36:  MOVLW  1F
0E37:  MOVWF  04
0E38:  BSF    03.7
0E39:  MOVF   00,W
0E3A:  BTFSC  03.2
0E3B:  GOTO   640
0E3C:  GOTO   63E
0E3D:  GOTO   63E
0E3E:  DECFSZ 00,F
0E3F:  GOTO   63D
*
0E43:  MOVLW  03
0E44:  SUBWF  1F,F
0E45:  BTFSS  03.0
0E46:  GOTO   651
0E47:  MOVLW  1F
0E48:  MOVWF  04
0E49:  BSF    03.7
0E4A:  MOVF   00,W
0E4B:  BTFSC  03.2
0E4C:  GOTO   651
0E4D:  GOTO   64F
0E4E:  GOTO   64F
0E4F:  DECFSZ 00,F
0E50:  GOTO   64E
*
0E65:  MOVLW  03
0E66:  SUBWF  1F,F
0E67:  BTFSS  03.0
0E68:  GOTO   673
0E69:  MOVLW  1F
0E6A:  MOVWF  04
0E6B:  BSF    03.7
0E6C:  MOVF   00,W
0E6D:  BTFSC  03.2
0E6E:  GOTO   673
0E6F:  GOTO   671
0E70:  GOTO   671
0E71:  DECFSZ 00,F
0E72:  GOTO   670
*
0E76:  MOVLW  03
0E77:  SUBWF  1F,F
0E78:  BTFSS  03.0
0E79:  GOTO   684
0E7A:  MOVLW  1F
0E7B:  MOVWF  04
0E7C:  BSF    03.7
0E7D:  MOVF   00,W
0E7E:  BTFSC  03.2
0E7F:  GOTO   684
0E80:  GOTO   682
0E81:  GOTO   682
0E82:  DECFSZ 00,F
0E83:  GOTO   681
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
*
16F5:  MOVLW  4A
16F6:  BCF    03.6
16F7:  MOVWF  2B
16F8:  CLRF   2C
16F9:  MOVLW  49
16FA:  MOVWF  2D
16FB:  CLRF   2E
16FC:  MOVLW  48
16FD:  MOVWF  2F
16FE:  CLRF   30
16FF:  MOVLW  2C
1700:  MOVWF  31
1701:  CLRF   32
1702:  MOVLW  28
1703:  MOVWF  33
1704:  CLRF   34
1705:  MOVLW  29
1706:  MOVWF  35
1707:  CLRF   36
1708:  MOVLW  2A
1709:  MOVWF  37
170A:  CLRF   38
170B:  MOVLW  2B
170C:  MOVWF  39
170D:  CLRF   3A
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
170E:  CLRF   3B
170F:  CLRF   3C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
05A6:  BSF    08.4
....................    output_float(LCD_DATA5); 
05A7:  BSF    08.5
....................    output_float(LCD_DATA6); 
05A8:  BSF    08.6
....................    output_float(LCD_DATA7); 
05A9:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
05AA:  BCF    03.5
05AB:  BSF    08.1
05AC:  BSF    03.5
05AD:  BCF    08.1
....................    delay_cycles(1); 
05AE:  NOP
....................    lcd_output_enable(1); 
05AF:  BCF    03.5
05B0:  BSF    08.0
05B1:  BSF    03.5
05B2:  BCF    08.0
....................    delay_cycles(1); 
05B3:  NOP
....................    high = lcd_read_nibble(); 
*
05EE:  MOVF   78,W
05EF:  MOVWF  1B
....................        
....................    lcd_output_enable(0); 
05F0:  BCF    03.6
05F1:  BCF    08.0
05F2:  BSF    03.5
05F3:  BCF    08.0
....................    delay_cycles(1); 
05F4:  NOP
....................    lcd_output_enable(1); 
05F5:  BCF    03.5
05F6:  BSF    08.0
05F7:  BSF    03.5
05F8:  BCF    08.0
....................    delay_us(1); 
05F9:  GOTO   5FA
05FA:  GOTO   5FB
05FB:  NOP
....................    low = lcd_read_nibble(); 
*
0636:  MOVF   78,W
0637:  MOVWF  1A
....................        
....................    lcd_output_enable(0); 
0638:  BCF    03.6
0639:  BCF    08.0
063A:  BSF    03.5
063B:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
063C:  BCF    08.4
....................    output_drive(LCD_DATA5); 
063D:  BCF    08.5
....................    output_drive(LCD_DATA6); 
063E:  BCF    08.6
....................    output_drive(LCD_DATA7); 
063F:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0640:  BCF    03.5
0641:  BSF    03.6
0642:  SWAPF  1B,W
0643:  MOVWF  77
0644:  MOVLW  F0
0645:  ANDWF  77,F
0646:  MOVF   77,W
0647:  IORWF  1A,W
0648:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
05B4:  BCF    03.5
05B5:  BSF    03.6
05B6:  CLRF   1C
*
05FC:  BCF    03.5
05FD:  BSF    03.6
05FE:  CLRF   1C
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
05B7:  BSF    03.5
05B8:  BCF    03.6
05B9:  BSF    08.4
05BA:  MOVLW  00
05BB:  BCF    03.5
05BC:  BTFSC  08.4
05BD:  MOVLW  01
05BE:  BSF    03.6
05BF:  IORWF  1C,F
*
05FF:  BSF    03.5
0600:  BCF    03.6
0601:  BSF    08.4
0602:  MOVLW  00
0603:  BCF    03.5
0604:  BTFSC  08.4
0605:  MOVLW  01
0606:  BSF    03.6
0607:  IORWF  1C,F
....................    n |= input(LCD_DATA5) << 1; 
*
05C0:  BSF    03.5
05C1:  BCF    03.6
05C2:  BSF    08.5
05C3:  MOVLW  00
05C4:  BCF    03.5
05C5:  BTFSC  08.5
05C6:  MOVLW  01
05C7:  MOVWF  77
05C8:  BCF    03.0
05C9:  RLF    77,F
05CA:  MOVF   77,W
05CB:  BSF    03.6
05CC:  IORWF  1C,F
*
0608:  BSF    03.5
0609:  BCF    03.6
060A:  BSF    08.5
060B:  MOVLW  00
060C:  BCF    03.5
060D:  BTFSC  08.5
060E:  MOVLW  01
060F:  MOVWF  77
0610:  BCF    03.0
0611:  RLF    77,F
0612:  MOVF   77,W
0613:  BSF    03.6
0614:  IORWF  1C,F
....................    n |= input(LCD_DATA6) << 2; 
*
05CD:  BSF    03.5
05CE:  BCF    03.6
05CF:  BSF    08.6
05D0:  MOVLW  00
05D1:  BCF    03.5
05D2:  BTFSC  08.6
05D3:  MOVLW  01
05D4:  MOVWF  77
05D5:  RLF    77,F
05D6:  RLF    77,F
05D7:  MOVLW  FC
05D8:  ANDWF  77,F
05D9:  MOVF   77,W
05DA:  BSF    03.6
05DB:  IORWF  1C,F
*
0615:  BSF    03.5
0616:  BCF    03.6
0617:  BSF    08.6
0618:  MOVLW  00
0619:  BCF    03.5
061A:  BTFSC  08.6
061B:  MOVLW  01
061C:  MOVWF  77
061D:  RLF    77,F
061E:  RLF    77,F
061F:  MOVLW  FC
0620:  ANDWF  77,F
0621:  MOVF   77,W
0622:  BSF    03.6
0623:  IORWF  1C,F
....................    n |= input(LCD_DATA7) << 3; 
*
05DC:  BSF    03.5
05DD:  BCF    03.6
05DE:  BSF    08.7
05DF:  MOVLW  00
05E0:  BCF    03.5
05E1:  BTFSC  08.7
05E2:  MOVLW  01
05E3:  MOVWF  77
05E4:  RLF    77,F
05E5:  RLF    77,F
05E6:  RLF    77,F
05E7:  MOVLW  F8
05E8:  ANDWF  77,F
05E9:  MOVF   77,W
05EA:  BSF    03.6
05EB:  IORWF  1C,F
*
0624:  BSF    03.5
0625:  BCF    03.6
0626:  BSF    08.7
0627:  MOVLW  00
0628:  BCF    03.5
0629:  BTFSC  08.7
062A:  MOVLW  01
062B:  MOVWF  77
062C:  RLF    77,F
062D:  RLF    77,F
062E:  RLF    77,F
062F:  MOVLW  F8
0630:  ANDWF  77,F
0631:  MOVF   77,W
0632:  BSF    03.6
0633:  IORWF  1C,F
....................     
....................    return(n); 
*
05EC:  MOVF   1C,W
05ED:  MOVWF  78
*
0634:  MOVF   1C,W
0635:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
066D:  BTFSC  1B.0
066E:  GOTO   673
066F:  BCF    03.6
0670:  BCF    08.4
0671:  GOTO   675
0672:  BSF    03.6
0673:  BCF    03.6
0674:  BSF    08.4
0675:  BSF    03.5
0676:  BCF    08.4
*
06B1:  BTFSC  1B.0
06B2:  GOTO   6B7
06B3:  BCF    03.6
06B4:  BCF    08.4
06B5:  GOTO   6B9
06B6:  BSF    03.6
06B7:  BCF    03.6
06B8:  BSF    08.4
06B9:  BSF    03.5
06BA:  BCF    08.4
*
071D:  BTFSC  1B.0
071E:  GOTO   723
071F:  BCF    03.6
0720:  BCF    08.4
0721:  GOTO   725
0722:  BSF    03.6
0723:  BCF    03.6
0724:  BSF    08.4
0725:  BSF    03.5
0726:  BCF    08.4
*
0767:  BTFSC  1B.0
0768:  GOTO   76D
0769:  BCF    03.6
076A:  BCF    08.4
076B:  GOTO   76F
076C:  BSF    03.6
076D:  BCF    03.6
076E:  BSF    08.4
076F:  BSF    03.5
0770:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
*
0677:  BCF    03.5
0678:  BSF    03.6
0679:  BTFSC  1B.1
067A:  GOTO   67F
067B:  BCF    03.6
067C:  BCF    08.5
067D:  GOTO   681
067E:  BSF    03.6
067F:  BCF    03.6
0680:  BSF    08.5
0681:  BSF    03.5
0682:  BCF    08.5
*
06BB:  BCF    03.5
06BC:  BSF    03.6
06BD:  BTFSC  1B.1
06BE:  GOTO   6C3
06BF:  BCF    03.6
06C0:  BCF    08.5
06C1:  GOTO   6C5
06C2:  BSF    03.6
06C3:  BCF    03.6
06C4:  BSF    08.5
06C5:  BSF    03.5
06C6:  BCF    08.5
*
0727:  BCF    03.5
0728:  BSF    03.6
0729:  BTFSC  1B.1
072A:  GOTO   72F
072B:  BCF    03.6
072C:  BCF    08.5
072D:  GOTO   731
072E:  BSF    03.6
072F:  BCF    03.6
0730:  BSF    08.5
0731:  BSF    03.5
0732:  BCF    08.5
*
0771:  BCF    03.5
0772:  BSF    03.6
0773:  BTFSC  1B.1
0774:  GOTO   779
0775:  BCF    03.6
0776:  BCF    08.5
0777:  GOTO   77B
0778:  BSF    03.6
0779:  BCF    03.6
077A:  BSF    08.5
077B:  BSF    03.5
077C:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
*
0683:  BCF    03.5
0684:  BSF    03.6
0685:  BTFSC  1B.2
0686:  GOTO   68B
0687:  BCF    03.6
0688:  BCF    08.6
0689:  GOTO   68D
068A:  BSF    03.6
068B:  BCF    03.6
068C:  BSF    08.6
068D:  BSF    03.5
068E:  BCF    08.6
*
06C7:  BCF    03.5
06C8:  BSF    03.6
06C9:  BTFSC  1B.2
06CA:  GOTO   6CF
06CB:  BCF    03.6
06CC:  BCF    08.6
06CD:  GOTO   6D1
06CE:  BSF    03.6
06CF:  BCF    03.6
06D0:  BSF    08.6
06D1:  BSF    03.5
06D2:  BCF    08.6
*
0733:  BCF    03.5
0734:  BSF    03.6
0735:  BTFSC  1B.2
0736:  GOTO   73B
0737:  BCF    03.6
0738:  BCF    08.6
0739:  GOTO   73D
073A:  BSF    03.6
073B:  BCF    03.6
073C:  BSF    08.6
073D:  BSF    03.5
073E:  BCF    08.6
*
077D:  BCF    03.5
077E:  BSF    03.6
077F:  BTFSC  1B.2
0780:  GOTO   785
0781:  BCF    03.6
0782:  BCF    08.6
0783:  GOTO   787
0784:  BSF    03.6
0785:  BCF    03.6
0786:  BSF    08.6
0787:  BSF    03.5
0788:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
*
068F:  BCF    03.5
0690:  BSF    03.6
0691:  BTFSC  1B.3
0692:  GOTO   697
0693:  BCF    03.6
0694:  BCF    08.7
0695:  GOTO   699
0696:  BSF    03.6
0697:  BCF    03.6
0698:  BSF    08.7
0699:  BSF    03.5
069A:  BCF    08.7
*
06D3:  BCF    03.5
06D4:  BSF    03.6
06D5:  BTFSC  1B.3
06D6:  GOTO   6DB
06D7:  BCF    03.6
06D8:  BCF    08.7
06D9:  GOTO   6DD
06DA:  BSF    03.6
06DB:  BCF    03.6
06DC:  BSF    08.7
06DD:  BSF    03.5
06DE:  BCF    08.7
*
073F:  BCF    03.5
0740:  BSF    03.6
0741:  BTFSC  1B.3
0742:  GOTO   747
0743:  BCF    03.6
0744:  BCF    08.7
0745:  GOTO   749
0746:  BSF    03.6
0747:  BCF    03.6
0748:  BSF    08.7
0749:  BSF    03.5
074A:  BCF    08.7
*
0789:  BCF    03.5
078A:  BSF    03.6
078B:  BTFSC  1B.3
078C:  GOTO   791
078D:  BCF    03.6
078E:  BCF    08.7
078F:  GOTO   793
0790:  BSF    03.6
0791:  BCF    03.6
0792:  BSF    08.7
0793:  BSF    03.5
0794:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
*
069B:  NOP
*
06DF:  NOP
*
074B:  NOP
*
0795:  NOP
....................    lcd_output_enable(1); 
*
069C:  BCF    03.5
069D:  BSF    08.0
069E:  BSF    03.5
069F:  BCF    08.0
*
06E0:  BCF    03.5
06E1:  BSF    08.0
06E2:  BSF    03.5
06E3:  BCF    08.0
*
074C:  BCF    03.5
074D:  BSF    08.0
074E:  BSF    03.5
074F:  BCF    08.0
*
0796:  BCF    03.5
0797:  BSF    08.0
0798:  BSF    03.5
0799:  BCF    08.0
....................    delay_us(2); 
*
06A0:  MOVLW  02
06A1:  MOVWF  77
06A2:  DECFSZ 77,F
06A3:  GOTO   6A2
06A4:  GOTO   6A5
06A5:  NOP
*
06E4:  MOVLW  02
06E5:  MOVWF  77
06E6:  DECFSZ 77,F
06E7:  GOTO   6E6
06E8:  GOTO   6E9
06E9:  NOP
*
0750:  MOVLW  02
0751:  MOVWF  77
0752:  DECFSZ 77,F
0753:  GOTO   752
0754:  GOTO   755
0755:  NOP
*
079A:  MOVLW  02
079B:  MOVWF  77
079C:  DECFSZ 77,F
079D:  GOTO   79C
079E:  GOTO   79F
079F:  NOP
....................    lcd_output_enable(0); 
*
06A6:  BCF    03.5
06A7:  BCF    08.0
06A8:  BSF    03.5
06A9:  BCF    08.0
*
06EA:  BCF    03.5
06EB:  BCF    08.0
06EC:  BSF    03.5
06ED:  BCF    08.0
*
0756:  BCF    03.5
0757:  BCF    08.0
0758:  BSF    03.5
0759:  BCF    08.0
*
07A0:  BCF    03.5
07A1:  BCF    08.0
07A2:  BSF    03.5
07A3:  BCF    08.0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
059E:  BSF    03.5
059F:  BCF    08.0
....................    lcd_rs_tris(); 
05A0:  BCF    08.2
....................    lcd_rw_tris(); 
05A1:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
05A2:  BCF    03.5
05A3:  BCF    08.2
05A4:  BSF    03.5
05A5:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0649:  MOVF   78,W
064A:  MOVWF  1A
064B:  BTFSS  1A.7
064C:  GOTO   650
064D:  BSF    03.5
064E:  BCF    03.6
064F:  GOTO   5A6
....................    lcd_output_rs(address); 
0650:  MOVF   18,F
0651:  BTFSS  03.2
0652:  GOTO   657
0653:  BCF    03.6
0654:  BCF    08.2
0655:  GOTO   659
0656:  BSF    03.6
0657:  BCF    03.6
0658:  BSF    08.2
0659:  BSF    03.5
065A:  BCF    08.2
....................    delay_cycles(1); 
065B:  NOP
....................    lcd_output_rw(0); 
065C:  BCF    03.5
065D:  BCF    08.1
065E:  BSF    03.5
065F:  BCF    08.1
....................    delay_cycles(1); 
0660:  NOP
....................    lcd_output_enable(0); 
0661:  BCF    03.5
0662:  BCF    08.0
0663:  BSF    03.5
0664:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
0665:  BCF    03.5
0666:  BSF    03.6
0667:  SWAPF  19,W
0668:  MOVWF  1A
0669:  MOVLW  0F
066A:  ANDWF  1A,F
066B:  MOVF   1A,W
066C:  MOVWF  1B
....................    lcd_send_nibble(n & 0xf); 
*
06AA:  BCF    03.5
06AB:  BSF    03.6
06AC:  MOVF   19,W
06AD:  ANDLW  0F
06AE:  MOVWF  1A
06AF:  MOVF   1A,W
06B0:  MOVWF  1B
*
06EE:  BCF    03.5
06EF:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
06F0:  MOVLW  28
06F1:  BSF    03.5
06F2:  MOVWF  6C
06F3:  MOVLW  0C
06F4:  MOVWF  6D
06F5:  MOVLW  01
06F6:  MOVWF  6E
06F7:  MOVLW  06
06F8:  MOVWF  6F
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
06F9:  BCF    03.5
06FA:  BCF    08.0
06FB:  BSF    03.5
06FC:  BCF    08.0
....................    lcd_output_rs(0); 
06FD:  BCF    03.5
06FE:  BCF    08.2
06FF:  BSF    03.5
0700:  BCF    08.2
....................    lcd_output_rw(0); 
0701:  BCF    03.5
0702:  BCF    08.1
0703:  BSF    03.5
0704:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0705:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0706:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0707:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0708:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0709:  BCF    08.0
....................    lcd_rs_tris(); 
070A:  BCF    08.2
....................    lcd_rw_tris(); 
070B:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
070C:  MOVLW  0F
070D:  BCF    03.5
070E:  BSF    03.6
070F:  MOVWF  22
0710:  BCF    03.6
0711:  CALL   58A
....................    for(i=1;i<=3;++i) 
0712:  MOVLW  01
0713:  BSF    03.5
0714:  MOVWF  6B
0715:  MOVF   6B,W
0716:  SUBLW  03
0717:  BTFSS  03.0
0718:  GOTO   763
....................    { 
....................        lcd_send_nibble(3); 
0719:  MOVLW  03
071A:  BCF    03.5
071B:  BSF    03.6
071C:  MOVWF  1B
....................        delay_ms(5); 
*
075A:  MOVLW  05
075B:  BCF    03.5
075C:  BSF    03.6
075D:  MOVWF  22
075E:  BCF    03.6
075F:  CALL   58A
0760:  BSF    03.5
0761:  INCF   6B,F
0762:  GOTO   715
....................    } 
....................     
....................    lcd_send_nibble(2); 
0763:  MOVLW  02
0764:  BCF    03.5
0765:  BSF    03.6
0766:  MOVWF  1B
....................    delay_ms(5); 
*
07A4:  MOVLW  05
07A5:  BCF    03.5
07A6:  BSF    03.6
07A7:  MOVWF  22
07A8:  BCF    03.6
07A9:  CALL   58A
....................    for(i=0;i<=3;++i) 
07AA:  BSF    03.5
07AB:  CLRF   6B
07AC:  MOVF   6B,W
07AD:  SUBLW  03
07AE:  BTFSS  03.0
07AF:  GOTO   7C0
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
07B0:  MOVLW  EC
07B1:  ADDWF  6B,W
07B2:  MOVWF  04
07B3:  BCF    03.7
07B4:  MOVF   00,W
07B5:  BCF    03.5
07B6:  BSF    03.6
07B7:  MOVWF  10
07B8:  CLRF   18
07B9:  MOVF   10,W
07BA:  MOVWF  19
07BB:  BCF    03.6
07BC:  CALL   59E
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
07BD:  BSF    03.5
07BE:  INCF   6B,F
07BF:  GOTO   7AC
07C0:  BCF    03.5
07C1:  BCF    0A.3
07C2:  BSF    0A.4
07C3:  GOTO   729 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0814:  DECFSZ 15,W
0815:  GOTO   017
0816:  GOTO   01A
*
083E:  DECFSZ 15,W
083F:  GOTO   041
0840:  GOTO   044
*
0ED6:  DECFSZ 15,W
0ED7:  GOTO   6D9
0ED8:  GOTO   6DC
*
0F3B:  DECFSZ 15,W
0F3C:  GOTO   73E
0F3D:  GOTO   741
*
1034:  DECFSZ 15,W
1035:  GOTO   037
1036:  GOTO   03A
*
10B6:  DECFSZ 15,W
10B7:  GOTO   0B9
10B8:  GOTO   0BC
*
1159:  DECFSZ 15,W
115A:  GOTO   15C
115B:  GOTO   15F
*
11D2:  DECFSZ 15,W
11D3:  GOTO   1D5
11D4:  GOTO   1D8
*
12C0:  DECFSZ 15,W
12C1:  GOTO   2C3
12C2:  GOTO   2C6
*
1338:  DECFSZ 15,W
1339:  GOTO   33B
133A:  GOTO   33E
*
1429:  DECFSZ 15,W
142A:  GOTO   42C
142B:  GOTO   42F
*
148F:  DECFSZ 15,W
1490:  GOTO   492
1491:  GOTO   495
*
14DE:  DECFSZ 15,W
14DF:  GOTO   4E1
14E0:  GOTO   4E4
*
1562:  DECFSZ 15,W
1563:  GOTO   565
1564:  GOTO   568
*
15DD:  DECFSZ 15,W
15DE:  GOTO   5E0
15DF:  GOTO   5E3
*
165C:  DECFSZ 15,W
165D:  GOTO   65F
165E:  GOTO   662
....................       address=LCD_LINE_TWO; 
*
0817:  MOVLW  40
0818:  MOVWF  16
0819:  GOTO   01B
*
0841:  MOVLW  40
0842:  MOVWF  16
0843:  GOTO   045
*
0ED9:  MOVLW  40
0EDA:  MOVWF  16
0EDB:  GOTO   6DD
*
0F3E:  MOVLW  40
0F3F:  MOVWF  16
0F40:  GOTO   742
*
1037:  MOVLW  40
1038:  MOVWF  16
1039:  GOTO   03B
*
10B9:  MOVLW  40
10BA:  MOVWF  16
10BB:  GOTO   0BD
*
115C:  MOVLW  40
115D:  MOVWF  16
115E:  GOTO   160
*
11D5:  MOVLW  40
11D6:  MOVWF  16
11D7:  GOTO   1D9
*
12C3:  MOVLW  40
12C4:  MOVWF  16
12C5:  GOTO   2C7
*
133B:  MOVLW  40
133C:  MOVWF  16
133D:  GOTO   33F
*
142C:  MOVLW  40
142D:  MOVWF  16
142E:  GOTO   430
*
1492:  MOVLW  40
1493:  MOVWF  16
1494:  GOTO   496
*
14E1:  MOVLW  40
14E2:  MOVWF  16
14E3:  GOTO   4E5
*
1565:  MOVLW  40
1566:  MOVWF  16
1567:  GOTO   569
*
15E0:  MOVLW  40
15E1:  MOVWF  16
15E2:  GOTO   5E4
*
165F:  MOVLW  40
1660:  MOVWF  16
1661:  GOTO   663
....................    else 
....................       address=0; 
*
081A:  CLRF   16
*
0844:  CLRF   16
*
0EDC:  CLRF   16
*
0F41:  CLRF   16
*
103A:  CLRF   16
*
10BC:  CLRF   16
*
115F:  CLRF   16
*
11D8:  CLRF   16
*
12C6:  CLRF   16
*
133E:  CLRF   16
*
142F:  CLRF   16
*
1495:  CLRF   16
*
14E4:  CLRF   16
*
1568:  CLRF   16
*
15E3:  CLRF   16
*
1662:  CLRF   16
....................       
....................    address+=x-1; 
*
081B:  MOVLW  01
081C:  SUBWF  14,W
081D:  ADDWF  16,F
*
0845:  MOVLW  01
0846:  SUBWF  14,W
0847:  ADDWF  16,F
*
0EDD:  MOVLW  01
0EDE:  SUBWF  14,W
0EDF:  ADDWF  16,F
*
0F42:  MOVLW  01
0F43:  SUBWF  14,W
0F44:  ADDWF  16,F
*
103B:  MOVLW  01
103C:  SUBWF  14,W
103D:  ADDWF  16,F
*
10BD:  MOVLW  01
10BE:  SUBWF  14,W
10BF:  ADDWF  16,F
*
1160:  MOVLW  01
1161:  SUBWF  14,W
1162:  ADDWF  16,F
*
11D9:  MOVLW  01
11DA:  SUBWF  14,W
11DB:  ADDWF  16,F
*
12C7:  MOVLW  01
12C8:  SUBWF  14,W
12C9:  ADDWF  16,F
*
133F:  MOVLW  01
1340:  SUBWF  14,W
1341:  ADDWF  16,F
*
1430:  MOVLW  01
1431:  SUBWF  14,W
1432:  ADDWF  16,F
*
1496:  MOVLW  01
1497:  SUBWF  14,W
1498:  ADDWF  16,F
*
14E5:  MOVLW  01
14E6:  SUBWF  14,W
14E7:  ADDWF  16,F
*
1569:  MOVLW  01
156A:  SUBWF  14,W
156B:  ADDWF  16,F
*
15E4:  MOVLW  01
15E5:  SUBWF  14,W
15E6:  ADDWF  16,F
*
1663:  MOVLW  01
1664:  SUBWF  14,W
1665:  ADDWF  16,F
....................    lcd_send_byte(0,0x80|address); 
*
081E:  MOVF   16,W
081F:  IORLW  80
0820:  MOVWF  17
0821:  CLRF   18
0822:  MOVF   17,W
0823:  MOVWF  19
0824:  BCF    0A.3
0825:  BCF    03.6
0826:  CALL   59E
0827:  BSF    0A.3
*
0848:  MOVF   16,W
0849:  IORLW  80
084A:  MOVWF  17
084B:  CLRF   18
084C:  MOVF   17,W
084D:  MOVWF  19
084E:  BCF    0A.3
084F:  BCF    03.6
0850:  CALL   59E
0851:  BSF    0A.3
*
0EE0:  MOVF   16,W
0EE1:  IORLW  80
0EE2:  MOVWF  17
0EE3:  CLRF   18
0EE4:  MOVF   17,W
0EE5:  MOVWF  19
0EE6:  BCF    0A.3
0EE7:  BCF    03.6
0EE8:  CALL   59E
0EE9:  BSF    0A.3
*
0F45:  MOVF   16,W
0F46:  IORLW  80
0F47:  MOVWF  17
0F48:  CLRF   18
0F49:  MOVF   17,W
0F4A:  MOVWF  19
0F4B:  BCF    0A.3
0F4C:  BCF    03.6
0F4D:  CALL   59E
0F4E:  BSF    0A.3
*
103E:  MOVF   16,W
103F:  IORLW  80
1040:  MOVWF  17
1041:  CLRF   18
1042:  MOVF   17,W
1043:  MOVWF  19
1044:  BCF    0A.4
1045:  BCF    03.6
1046:  CALL   59E
1047:  BSF    0A.4
*
10C0:  MOVF   16,W
10C1:  IORLW  80
10C2:  MOVWF  17
10C3:  CLRF   18
10C4:  MOVF   17,W
10C5:  MOVWF  19
10C6:  BCF    0A.4
10C7:  BCF    03.6
10C8:  CALL   59E
10C9:  BSF    0A.4
*
1163:  MOVF   16,W
1164:  IORLW  80
1165:  MOVWF  17
1166:  CLRF   18
1167:  MOVF   17,W
1168:  MOVWF  19
1169:  BCF    0A.4
116A:  BCF    03.6
116B:  CALL   59E
116C:  BSF    0A.4
*
11DC:  MOVF   16,W
11DD:  IORLW  80
11DE:  MOVWF  17
11DF:  CLRF   18
11E0:  MOVF   17,W
11E1:  MOVWF  19
11E2:  BCF    0A.4
11E3:  BCF    03.6
11E4:  CALL   59E
11E5:  BSF    0A.4
*
12CA:  MOVF   16,W
12CB:  IORLW  80
12CC:  MOVWF  17
12CD:  CLRF   18
12CE:  MOVF   17,W
12CF:  MOVWF  19
12D0:  BCF    0A.4
12D1:  BCF    03.6
12D2:  CALL   59E
12D3:  BSF    0A.4
*
1342:  MOVF   16,W
1343:  IORLW  80
1344:  MOVWF  17
1345:  CLRF   18
1346:  MOVF   17,W
1347:  MOVWF  19
1348:  BCF    0A.4
1349:  BCF    03.6
134A:  CALL   59E
134B:  BSF    0A.4
*
1433:  MOVF   16,W
1434:  IORLW  80
1435:  MOVWF  17
1436:  CLRF   18
1437:  MOVF   17,W
1438:  MOVWF  19
1439:  BCF    0A.4
143A:  BCF    03.6
143B:  CALL   59E
143C:  BSF    0A.4
*
1499:  MOVF   16,W
149A:  IORLW  80
149B:  MOVWF  17
149C:  CLRF   18
149D:  MOVF   17,W
149E:  MOVWF  19
149F:  BCF    0A.4
14A0:  BCF    03.6
14A1:  CALL   59E
14A2:  BSF    0A.4
*
14E8:  MOVF   16,W
14E9:  IORLW  80
14EA:  MOVWF  17
14EB:  CLRF   18
14EC:  MOVF   17,W
14ED:  MOVWF  19
14EE:  BCF    0A.4
14EF:  BCF    03.6
14F0:  CALL   59E
14F1:  BSF    0A.4
*
156C:  MOVF   16,W
156D:  IORLW  80
156E:  MOVWF  17
156F:  CLRF   18
1570:  MOVF   17,W
1571:  MOVWF  19
1572:  BCF    0A.4
1573:  BCF    03.6
1574:  CALL   59E
1575:  BSF    0A.4
*
15E7:  MOVF   16,W
15E8:  IORLW  80
15E9:  MOVWF  17
15EA:  CLRF   18
15EB:  MOVF   17,W
15EC:  MOVWF  19
15ED:  BCF    0A.4
15EE:  BCF    03.6
15EF:  CALL   59E
15F0:  BSF    0A.4
*
1666:  MOVF   16,W
1667:  IORLW  80
1668:  MOVWF  17
1669:  CLRF   18
166A:  MOVF   17,W
166B:  MOVWF  19
166C:  BCF    0A.4
166D:  BCF    03.6
166E:  CALL   59E
166F:  BSF    0A.4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
0800:  BSF    03.6
0801:  MOVF   13,W
0802:  XORLW  07
0803:  BCF    03.6
0804:  BTFSC  03.2
0805:  GOTO   010
0806:  XORLW  0B
0807:  BTFSC  03.2
0808:  GOTO   029
0809:  XORLW  06
080A:  BTFSC  03.2
080B:  GOTO   039
080C:  XORLW  02
080D:  BTFSC  03.2
080E:  GOTO   053
080F:  GOTO   05C
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0810:  MOVLW  01
0811:  BSF    03.6
0812:  MOVWF  14
0813:  MOVWF  15
*
0828:  GOTO   065
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0829:  BSF    03.6
082A:  CLRF   18
082B:  MOVLW  01
082C:  MOVWF  19
082D:  BCF    0A.3
082E:  BCF    03.6
082F:  CALL   59E
0830:  BSF    0A.3
....................                      delay_ms(2); 
0831:  MOVLW  02
0832:  BSF    03.6
0833:  MOVWF  22
0834:  BCF    0A.3
0835:  BCF    03.6
0836:  CALL   58A
0837:  BSF    0A.3
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0838:  GOTO   065
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0839:  MOVLW  01
083A:  BSF    03.6
083B:  MOVWF  14
083C:  MOVLW  02
083D:  MOVWF  15
*
0852:  GOTO   065
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0853:  BSF    03.6
0854:  CLRF   18
0855:  MOVLW  10
0856:  MOVWF  19
0857:  BCF    0A.3
0858:  BCF    03.6
0859:  CALL   59E
085A:  BSF    0A.3
085B:  GOTO   065
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
085C:  MOVLW  01
085D:  BSF    03.6
085E:  MOVWF  18
085F:  MOVF   13,W
0860:  MOVWF  19
0861:  BCF    0A.3
0862:  BCF    03.6
0863:  CALL   59E
0864:  BSF    0A.3
....................      #endif 
....................    } 
0865:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
0D60:  BSF    03.6
0D61:  CLRF   15
0D62:  CLRF   14
0D63:  CLRF   17
0D64:  CLRF   16
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
0D65:  MOVF   11,F
0D66:  BTFSS  03.2
0D67:  GOTO   56C
0D68:  MOVF   10,W
0D69:  SUBLW  13
0D6A:  BTFSC  03.0
0D6B:  GOTO   6B1
0D6C:  MOVF   11,W
0D6D:  SUBLW  4E
0D6E:  BTFSS  03.0
0D6F:  GOTO   6B1
0D70:  BTFSS  03.2
0D71:  GOTO   576
0D72:  MOVF   10,W
0D73:  SUBLW  20
0D74:  BTFSS  03.0
0D75:  GOTO   6B1
....................       tmp=100000; 
0D76:  CLRF   1D
0D77:  MOVLW  01
0D78:  MOVWF  1C
0D79:  MOVLW  86
0D7A:  MOVWF  1B
0D7B:  MOVLW  A0
0D7C:  MOVWF  1A
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
0D7D:  BCF    03.1
0D7E:  MOVF   1D,W
0D7F:  MOVWF  21
0D80:  MOVF   1C,W
0D81:  MOVWF  20
0D82:  MOVF   1B,W
0D83:  MOVWF  1F
0D84:  MOVF   1A,W
0D85:  MOVWF  1E
0D86:  CLRF   25
0D87:  CLRF   24
0D88:  MOVF   11,W
0D89:  MOVWF  23
0D8A:  MOVF   10,W
0D8B:  MOVWF  22
*
0DDA:  MOVF   7A,W
0DDB:  MOVWF  1D
0DDC:  MOVF   79,W
0DDD:  MOVWF  1C
0DDE:  MOVF   78,W
0DDF:  MOVWF  1B
0DE0:  MOVF   77,W
0DE1:  MOVWF  1A
....................       tmp*=5;    
0DE2:  MOVF   1D,W
0DE3:  MOVWF  21
0DE4:  MOVF   1C,W
0DE5:  MOVWF  20
0DE6:  MOVF   1B,W
0DE7:  MOVWF  1F
0DE8:  MOVF   1A,W
0DE9:  MOVWF  1E
0DEA:  CLRF   25
0DEB:  CLRF   24
0DEC:  CLRF   23
0DED:  MOVLW  05
0DEE:  MOVWF  22
*
0E18:  MOVF   7A,W
0E19:  MOVWF  1D
0E1A:  MOVF   79,W
0E1B:  MOVWF  1C
0E1C:  MOVF   78,W
0E1D:  MOVWF  1B
0E1E:  MOVF   77,W
0E1F:  MOVWF  1A
....................       uS=tmp; 
0E20:  MOVF   1B,W
0E21:  MOVWF  19
0E22:  MOVF   1A,W
0E23:  MOVWF  18
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
0E24:  BSF    03.5
0E25:  BCF    03.6
0E26:  BCF    06.2
0E27:  BCF    03.5
0E28:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0E29:  BSF    03.6
0E2A:  MOVF   19,W
0E2B:  MOVWF  1E
0E2C:  INCF   1E,F
0E2D:  DECF   1E,F
0E2E:  BTFSC  03.2
0E2F:  GOTO   641
0E30:  MOVLW  FF
0E31:  MOVWF  1F
*
0E40:  GOTO   62D
0E41:  MOVF   18,W
0E42:  MOVWF  1F
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
0E51:  MOVF   18,W
0E52:  ADDWF  16,F
0E53:  MOVF   19,W
0E54:  BTFSC  03.0
0E55:  INCFSZ 19,W
0E56:  ADDWF  17,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0E57:  BSF    03.5
0E58:  BCF    03.6
0E59:  BCF    06.2
0E5A:  BCF    03.5
0E5B:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
0E5C:  BSF    03.6
0E5D:  MOVF   19,W
0E5E:  MOVWF  1E
0E5F:  INCF   1E,F
0E60:  DECF   1E,F
0E61:  BTFSC  03.2
0E62:  GOTO   674
0E63:  MOVLW  FF
0E64:  MOVWF  1F
*
0E73:  GOTO   660
0E74:  MOVF   18,W
0E75:  MOVWF  1F
....................          CiclosL+=(uS);          //  
*
0E84:  MOVF   18,W
0E85:  ADDWF  16,F
0E86:  MOVF   19,W
0E87:  BTFSC  03.0
0E88:  INCFSZ 19,W
0E89:  ADDWF  17,F
....................          CiclosL+=25;            // Compensador. 
0E8A:  MOVLW  19
0E8B:  ADDWF  16,F
0E8C:  BTFSC  03.0
0E8D:  INCF   17,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
0E8E:  MOVF   17,W
0E8F:  SUBLW  02
0E90:  BTFSC  03.0
0E91:  GOTO   6A7
0E92:  XORLW  FF
0E93:  BTFSS  03.2
0E94:  GOTO   699
0E95:  MOVF   16,W
0E96:  SUBLW  E7
0E97:  BTFSC  03.0
0E98:  GOTO   6A7
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0E99:  MOVLW  E8
0E9A:  SUBWF  16,F
0E9B:  MOVLW  03
0E9C:  BTFSS  03.0
0E9D:  MOVLW  04
0E9E:  SUBWF  17,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0E9F:  INCF   14,F
0EA0:  BTFSC  03.2
0EA1:  INCF   15,F
....................             CiclosL+=25;         // Compensador. 
0EA2:  MOVLW  19
0EA3:  ADDWF  16,F
0EA4:  BTFSC  03.0
0EA5:  INCF   17,F
0EA6:  GOTO   68E
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
0EA7:  MOVF   15,W
0EA8:  SUBWF  13,W
0EA9:  BTFSS  03.0
0EAA:  GOTO   6B1
0EAB:  BTFSS  03.2
0EAC:  GOTO   624
0EAD:  MOVF   12,W
0EAE:  SUBWF  14,W
0EAF:  BTFSS  03.0
0EB0:  GOTO   624
....................                                          // tiempo indicado. 
....................    } 
0EB1:  BCF    03.6
0EB2:  RETURN
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /***************************************************************** 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... ****************************************************************** 
....................  
.................... ******************************************** 
.................... *   Formato de comando en la respuesta:    * 
.................... *   INICIO:COMANDO:DATOS:<-(FIN)           * 
.................... *   e.g. CMD:CMD_SSID_AND_PASS,DATA:       * 
.................... ******************************************** 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:OP,[op][port]:                 | 
.................... |-----------------------------------------------| 
.................... |> Realiaza Operaciones en el Puerto de Salida  | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,[1|0][0-7]:                       | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      op:    1   -> Encender                   | 
.................... |             0   -> Apagar                     | 
.................... |      port:  0-7 -> No. del puerto.            | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,10:  Enciende el PORT 0        | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NC,"SSID","KEY":               | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el SSID y Key de la    | 
.................... |  Red donde se conectara.                      | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NC,"SSID","KEY":                     | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      SSID:  "Nombre de la Red."               | 
.................... |                                               | 
.................... |      KEY:   "Clave."                          | 
.................... |                                               | 
.................... |** @e.g. CMD:NC,"myRed","12345678":            | 
.................... | Intentara conectarse y almacenar en la eeprom | 
.................... | al nombre de la red con key pasados como      | 
.................... | parametro.                                    | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NM,[ModeConection]:            | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el modo de la conexion | 
.................... |                                               | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NM,[1|2|3]:                          | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      ModeConection:  "1" -> STA               | 
.................... |                      "2" -> AP                | 
.................... |                      "3" -> STA/AP            | 
.................... |                                               | 
.................... |** @e.g. CMD:NM,3:                             | 
.................... |                                               | 
.................... +-----------------------------------------------+ 
.................... */ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio recepcion de request,  
.................... y retorna el ID de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
04AD:  MOVLW  05
04AE:  MOVWF  30
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
04AF:  DECFSZ 7E,W
04B0:  GOTO   4CF
....................        
....................       if(buffer!=','){ 
04B1:  MOVF   2E,W
04B2:  SUBLW  2C
04B3:  BTFSS  03.2
04B4:  GOTO   4B8
04B5:  MOVF   2F,F
04B6:  BTFSC  03.2
04B7:  GOTO   4C8
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
04B8:  MOVLW  41
04B9:  BSF    03.5
04BA:  BCF    03.6
04BB:  ADDWF  23,W
04BC:  MOVWF  04
04BD:  BCF    03.7
04BE:  BCF    03.5
04BF:  BSF    03.6
04C0:  MOVF   2E,W
04C1:  MOVWF  00
....................          flag_Pos_Resp_IPD++; 
04C2:  BSF    03.5
04C3:  BCF    03.6
04C4:  INCF   23,F
....................       }else{ 
04C5:  GOTO   4CC
04C6:  BCF    03.5
04C7:  BSF    03.6
....................          flag_Pos_Resp_IPD       = 0x00; 
04C8:  BSF    03.5
04C9:  BCF    03.6
04CA:  CLRF   23
....................          flag_Resp_IPD           = 0x00; 
04CB:  CLRF   7E
....................       } 
....................    }else{ 
04CC:  GOTO   4F0
04CD:  BCF    03.5
04CE:  BSF    03.6
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
04CF:  BSF    03.5
04D0:  BCF    03.6
04D1:  MOVF   23,W
04D2:  BCF    03.5
04D3:  CALL   051
04D4:  MOVWF  78
04D5:  BSF    03.6
04D6:  SUBWF  2E,W
04D7:  BTFSS  03.2
04D8:  GOTO   4ED
04D9:  MOVF   2F,F
04DA:  BTFSS  03.2
04DB:  GOTO   4ED
....................       { 
....................          flag_Pos_Resp_IPD++; 
04DC:  BSF    03.5
04DD:  BCF    03.6
04DE:  INCF   23,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
04DF:  BCF    03.5
04E0:  BSF    03.6
04E1:  MOVF   30,W
04E2:  BSF    03.5
04E3:  BCF    03.6
04E4:  SUBWF  23,W
04E5:  BTFSS  03.2
04E6:  GOTO   4EA
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
04E7:  MOVLW  01
04E8:  MOVWF  7E
....................             flag_Pos_Resp_IPD = 0; 
04E9:  CLRF   23
....................          } 
....................       }else{ 
04EA:  GOTO   4F0
04EB:  BCF    03.5
04EC:  BSF    03.6
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
04ED:  BSF    03.5
04EE:  BCF    03.6
04EF:  CLRF   23
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio comando,  
.................... y retorna el Comando enviado, Activa la bandera 
.................... de recepcion de datos 
.................... *********************************************************/ 
....................  
.................... void ESP8266_Get_CMD(char buffer[]){ 
*
04F5:  MOVLW  04
04F6:  MOVWF  30
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
04F7:  DECFSZ 7D,W
04F8:  GOTO   519
....................     
....................       if(buffer!=','){ 
04F9:  MOVF   2E,W
04FA:  SUBLW  2C
04FB:  BTFSS  03.2
04FC:  GOTO   500
04FD:  MOVF   2F,F
04FE:  BTFSC  03.2
04FF:  GOTO   510
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
0500:  MOVLW  43
0501:  BSF    03.5
0502:  BCF    03.6
0503:  ADDWF  22,W
0504:  MOVWF  04
0505:  BCF    03.7
0506:  BCF    03.5
0507:  BSF    03.6
0508:  MOVF   2E,W
0509:  MOVWF  00
....................          flag_Pos_Resp_CMD++; 
050A:  BSF    03.5
050B:  BCF    03.6
050C:  INCF   22,F
....................       }else{         
050D:  GOTO   516
050E:  BCF    03.5
050F:  BSF    03.6
....................          flag_Pos_Resp_CMD = 0x00; 
0510:  BSF    03.5
0511:  BCF    03.6
0512:  CLRF   22
....................          flag_Resp_CMD     = 0x00; 
0513:  CLRF   7D
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
0514:  MOVLW  01
0515:  MOVWF  20
....................       } 
....................        
....................    }else{ 
0516:  GOTO   53A
0517:  BCF    03.5
0518:  BSF    03.6
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
0519:  BSF    03.5
051A:  BCF    03.6
051B:  MOVF   22,W
051C:  BCF    03.5
051D:  CALL   05A
051E:  MOVWF  78
051F:  BSF    03.6
0520:  SUBWF  2E,W
0521:  BTFSS  03.2
0522:  GOTO   537
0523:  MOVF   2F,F
0524:  BTFSS  03.2
0525:  GOTO   537
....................       { 
....................          flag_Pos_Resp_CMD++; 
0526:  BSF    03.5
0527:  BCF    03.6
0528:  INCF   22,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
0529:  BCF    03.5
052A:  BSF    03.6
052B:  MOVF   30,W
052C:  BSF    03.5
052D:  BCF    03.6
052E:  SUBWF  22,W
052F:  BTFSS  03.2
0530:  GOTO   534
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
0531:  MOVLW  01
0532:  MOVWF  7D
....................             flag_Pos_Resp_CMD = 0; 
0533:  CLRF   22
....................          } 
....................       }else{ 
0534:  GOTO   53A
0535:  BCF    03.5
0536:  BSF    03.6
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
0537:  BSF    03.5
0538:  BCF    03.6
0539:  CLRF   22
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion Verifica si la bandera de recepcion de datos esta 
.................... activa y almacena los datos entrantes en el arreglo 
.................... DATA_COMMAND, Finaliza la captura de caracteres cuando 
.................... encuentra el caracter ":". 
.................... Envia al ESP8266 el fin de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
*
053F:  BSF    03.5
0540:  BCF    03.6
0541:  DECFSZ 20,W
0542:  GOTO   57B
....................       if(buffer!=':'){ 
0543:  BCF    03.5
0544:  BSF    03.6
0545:  MOVF   2E,W
0546:  SUBLW  3A
0547:  BTFSS  03.2
0548:  GOTO   54C
0549:  MOVF   2F,F
054A:  BTFSC  03.2
054B:  GOTO   575
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
054C:  MOVLW  45
054D:  BSF    03.5
054E:  BCF    03.6
054F:  ADDWF  24,W
0550:  MOVWF  04
0551:  BCF    03.7
0552:  BCF    03.5
0553:  BSF    03.6
0554:  MOVF   2E,W
0555:  MOVWF  00
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
0556:  CLRF   7C
0557:  BSF    03.5
0558:  BCF    03.6
0559:  MOVF   24,W
055A:  MOVWF  7B
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
055B:  MOVF   24,F
055C:  BTFSS  03.2
055D:  GOTO   571
055E:  BCF    03.5
055F:  BSF    03.6
0560:  MOVF   2E,W
0561:  SUBLW  2C
0562:  BTFSC  03.2
0563:  GOTO   567
0564:  BSF    03.5
0565:  BCF    03.6
0566:  GOTO   571
0567:  MOVF   2F,F
0568:  BTFSC  03.2
0569:  GOTO   56D
056A:  BSF    03.5
056B:  BCF    03.6
056C:  GOTO   571
....................             flag_Pos_Resp_Data=0; 
056D:  BSF    03.5
056E:  BCF    03.6
056F:  CLRF   24
....................          }else{ 
0570:  GOTO   572
....................             flag_Pos_Resp_Data++; 
0571:  INCF   24,F
....................          } 
....................           
....................       }else{ 
0572:  GOTO   57B
0573:  BCF    03.5
0574:  BSF    03.6
....................          flag_Pos_Resp_Data      = 0x00; 
0575:  BSF    03.5
0576:  BCF    03.6
0577:  CLRF   24
....................          flag_Resp_StartGetData  = 0x00; 
0578:  CLRF   20
....................          flag_Resp_Ready         = 1; 
0579:  MOVLW  01
057A:  MOVWF  21
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
.................... } 
....................  
.................... int run_command_wifi(void){ 
*
0AE6:  BSF    03.6
0AE7:  CLRF   10
0AE8:  CLRF   11
....................    int8 ret = 0, optSelected = 0; 
....................    char ESP8266_Resp[13] = {'{','"','c','m','d','"',':','"','o','k','"','}'}; 
0AE9:  MOVLW  7B
0AEA:  MOVWF  12
0AEB:  MOVLW  22
0AEC:  MOVWF  13
0AED:  MOVLW  63
0AEE:  MOVWF  14
0AEF:  MOVLW  6D
0AF0:  MOVWF  15
0AF1:  MOVLW  64
0AF2:  MOVWF  16
0AF3:  MOVLW  22
0AF4:  MOVWF  17
0AF5:  MOVLW  3A
0AF6:  MOVWF  18
0AF7:  MOVLW  22
0AF8:  MOVWF  19
0AF9:  MOVLW  6F
0AFA:  MOVWF  1A
0AFB:  MOVLW  6B
0AFC:  MOVWF  1B
0AFD:  MOVLW  22
0AFE:  MOVWF  1C
0AFF:  MOVLW  7D
0B00:  MOVWF  1D
0B01:  CLRF   1E
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
0B02:  BSF    03.5
0B03:  BCF    03.6
0B04:  DECFSZ 21,W
0B05:  GOTO   55A
....................        
....................       /************************** 
....................       *** Accede a las Salidas ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
0B06:  BCF    03.5
0B07:  MOVF   43,W
0B08:  SUBLW  4F
0B09:  BTFSS  03.2
0B0A:  GOTO   358
0B0B:  MOVF   44,W
0B0C:  SUBLW  50
0B0D:  BTFSS  03.2
0B0E:  GOTO   358
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
0B0F:  MOVLW  30
0B10:  SUBWF  46,W
0B11:  BSF    03.6
0B12:  MOVWF  11
....................           
....................          switch(DATA_COMMAND[0]){ 
0B13:  BCF    03.6
0B14:  MOVF   45,W
0B15:  XORLW  30
0B16:  BTFSC  03.2
0B17:  GOTO   31C
0B18:  XORLW  01
0B19:  BTFSC  03.2
0B1A:  GOTO   338
0B1B:  GOTO   354
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
0B1C:  BCF    03.0
0B1D:  BSF    03.6
0B1E:  RLF    11,W
0B1F:  ADDLW  2B
0B20:  MOVWF  04
0B21:  BCF    03.7
0B22:  INCF   04,F
0B23:  MOVF   00,W
0B24:  MOVWF  22
0B25:  DECF   04,F
0B26:  MOVF   00,W
0B27:  MOVWF  21
0B28:  MOVWF  23
0B29:  CLRF   24
0B2A:  CLRF   26
0B2B:  CLRF   25
0B2C:  BCF    03.6
0B2D:  CALL   2C4
0B2E:  BSF    03.6
0B2F:  MOVF   21,W
0B30:  MOVWF  23
0B31:  CLRF   24
0B32:  CLRF   26
0B33:  MOVLW  80
0B34:  MOVWF  25
0B35:  BCF    03.6
0B36:  CALL   2C4
....................                break; 
0B37:  GOTO   354
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
0B38:  BCF    03.0
0B39:  BSF    03.6
0B3A:  RLF    11,W
0B3B:  ADDLW  2B
0B3C:  MOVWF  04
0B3D:  BCF    03.7
0B3E:  INCF   04,F
0B3F:  MOVF   00,W
0B40:  MOVWF  22
0B41:  DECF   04,F
0B42:  MOVF   00,W
0B43:  MOVWF  21
0B44:  MOVWF  23
0B45:  MOVLW  01
0B46:  MOVWF  24
0B47:  CLRF   26
0B48:  CLRF   25
0B49:  BCF    03.6
0B4A:  CALL   2C4
0B4B:  BSF    03.6
0B4C:  MOVF   21,W
0B4D:  MOVWF  23
0B4E:  CLRF   24
0B4F:  CLRF   26
0B50:  MOVLW  80
0B51:  MOVWF  25
0B52:  BCF    03.6
0B53:  CALL   2C4
....................                break; 
....................          } 
....................           
....................          ret = 1; 
0B54:  MOVLW  01
0B55:  BSF    03.6
0B56:  MOVWF  10
0B57:  BCF    03.6
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
0B58:  MOVF   43,W
0B59:  SUBLW  4E
0B5A:  BTFSS  03.2
0B5B:  GOTO   44F
0B5C:  MOVF   44,W
0B5D:  SUBLW  43
0B5E:  BTFSS  03.2
0B5F:  GOTO   44F
....................       { 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
0B60:  BSF    03.6
0B61:  CLRF   1F
0B62:  MOVF   7C,F
0B63:  BTFSS  03.2
0B64:  GOTO   369
0B65:  MOVF   1F,W
0B66:  SUBWF  7B,W
0B67:  BTFSS  03.0
0B68:  GOTO   394
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
0B69:  MOVLW  01
0B6A:  ADDWF  1F,W
0B6B:  MOVWF  21
0B6C:  MOVLW  45
0B6D:  ADDWF  1F,W
0B6E:  MOVWF  04
0B6F:  BCF    03.7
0B70:  MOVF   00,W
0B71:  MOVWF  22
0B72:  BCF    03.6
0B73:  MOVF   0B,W
0B74:  MOVWF  77
0B75:  BCF    0B.7
0B76:  BSF    03.6
0B77:  MOVF   21,W
0B78:  MOVWF  0D
0B79:  MOVF   22,W
0B7A:  MOVWF  0C
0B7B:  BSF    03.5
0B7C:  BCF    0C.7
0B7D:  BSF    0C.2
0B7E:  MOVLW  55
0B7F:  MOVWF  0D
0B80:  MOVLW  AA
0B81:  MOVWF  0D
0B82:  BSF    0C.1
0B83:  BTFSC  0C.1
0B84:  GOTO   383
0B85:  BCF    0C.2
0B86:  MOVF   77,W
0B87:  BCF    03.5
0B88:  BCF    03.6
0B89:  IORWF  0B,F
....................             delay_ms(10); 
0B8A:  MOVLW  0A
0B8B:  BSF    03.6
0B8C:  MOVWF  22
0B8D:  BCF    0A.3
0B8E:  BCF    03.6
0B8F:  CALL   58A
0B90:  BSF    0A.3
0B91:  BSF    03.6
0B92:  INCF   1F,F
0B93:  GOTO   362
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
0B94:  MOVLW  01
0B95:  ADDWF  1F,W
0B96:  MOVWF  21
0B97:  BCF    03.6
0B98:  MOVF   0B,W
0B99:  MOVWF  77
0B9A:  BCF    0B.7
0B9B:  BSF    03.6
0B9C:  MOVF   21,W
0B9D:  MOVWF  0D
0B9E:  MOVLW  0D
0B9F:  MOVWF  0C
0BA0:  BSF    03.5
0BA1:  BCF    0C.7
0BA2:  BSF    0C.2
0BA3:  MOVLW  55
0BA4:  MOVWF  0D
0BA5:  MOVLW  AA
0BA6:  MOVWF  0D
0BA7:  BSF    0C.1
0BA8:  BTFSC  0C.1
0BA9:  GOTO   3A8
0BAA:  BCF    0C.2
0BAB:  MOVF   77,W
0BAC:  BCF    03.5
0BAD:  BCF    03.6
0BAE:  IORWF  0B,F
....................          delay_ms(10); 
0BAF:  MOVLW  0A
0BB0:  BSF    03.6
0BB1:  MOVWF  22
0BB2:  BCF    0A.3
0BB3:  BCF    03.6
0BB4:  CALL   58A
0BB5:  BSF    0A.3
....................          write_eeprom(idxNC+2,0x0A); 
0BB6:  MOVLW  02
0BB7:  BSF    03.6
0BB8:  ADDWF  1F,W
0BB9:  MOVWF  21
0BBA:  BCF    03.6
0BBB:  MOVF   0B,W
0BBC:  MOVWF  77
0BBD:  BCF    0B.7
0BBE:  BSF    03.6
0BBF:  MOVF   21,W
0BC0:  MOVWF  0D
0BC1:  MOVLW  0A
0BC2:  MOVWF  0C
0BC3:  BSF    03.5
0BC4:  BCF    0C.7
0BC5:  BSF    0C.2
0BC6:  MOVLW  55
0BC7:  MOVWF  0D
0BC8:  MOVLW  AA
0BC9:  MOVWF  0D
0BCA:  BSF    0C.1
0BCB:  BTFSC  0C.1
0BCC:  GOTO   3CB
0BCD:  BCF    0C.2
0BCE:  MOVF   77,W
0BCF:  BCF    03.5
0BD0:  BCF    03.6
0BD1:  IORWF  0B,F
....................          delay_ms(10); 
0BD2:  MOVLW  0A
0BD3:  BSF    03.6
0BD4:  MOVWF  22
0BD5:  BCF    0A.3
0BD6:  BCF    03.6
0BD7:  CALL   58A
0BD8:  BSF    0A.3
....................  
....................          // Responde la solicitud 
....................          //delay_ms(30); 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0BD9:  MOVLW  93
0BDA:  BSF    03.6
0BDB:  MOVWF  0D
0BDC:  MOVLW  00
0BDD:  MOVWF  0F
0BDE:  BCF    03.0
0BDF:  MOVLW  0B
0BE0:  MOVWF  21
0BE1:  BCF    03.6
0BE2:  CALL   0B6
0BE3:  MOVF   41,W
0BE4:  BTFSS  0C.4
0BE5:  GOTO   3E4
0BE6:  MOVWF  19
0BE7:  MOVLW  99
0BE8:  BSF    03.6
0BE9:  MOVWF  0D
0BEA:  MOVLW  00
0BEB:  MOVWF  0F
0BEC:  BSF    03.0
0BED:  MOVLW  05
0BEE:  MOVWF  21
0BEF:  BCF    03.6
0BF0:  CALL   0B6
....................          delay_ms(60); 
0BF1:  MOVLW  3C
0BF2:  BSF    03.6
0BF3:  MOVWF  22
0BF4:  BCF    0A.3
0BF5:  BCF    03.6
0BF6:  CALL   58A
0BF7:  BSF    0A.3
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
0BF8:  MOVLW  12
0BF9:  MOVWF  04
0BFA:  BSF    03.7
....................          delay_ms(110); 
*
0C18:  MOVLW  6E
0C19:  BSF    03.6
0C1A:  MOVWF  22
0C1B:  BCF    0A.3
0C1C:  BCF    03.6
0C1D:  CALL   58A
0C1E:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0C1F:  MOVLW  9D
0C20:  BSF    03.6
0C21:  MOVWF  0D
0C22:  MOVLW  00
0C23:  MOVWF  0F
0C24:  BCF    03.0
0C25:  MOVLW  0C
0C26:  MOVWF  21
0C27:  BCF    03.6
0C28:  CALL   0B6
0C29:  MOVF   41,W
0C2A:  BTFSS  0C.4
0C2B:  GOTO   42A
0C2C:  MOVWF  19
0C2D:  MOVLW  0D
0C2E:  BTFSS  0C.4
0C2F:  GOTO   42E
0C30:  MOVWF  19
0C31:  MOVLW  0A
0C32:  BTFSS  0C.4
0C33:  GOTO   432
0C34:  MOVWF  19
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
0C35:  MOVLW  A6
0C36:  BSF    03.6
0C37:  MOVWF  0D
0C38:  MOVLW  00
0C39:  MOVWF  0F
0C3A:  BCF    03.6
0C3B:  CALL   10C
....................          delay_ms(1000); 
0C3C:  MOVLW  04
0C3D:  BSF    03.6
0C3E:  MOVWF  21
0C3F:  MOVLW  FA
0C40:  MOVWF  22
0C41:  BCF    0A.3
0C42:  BCF    03.6
0C43:  CALL   58A
0C44:  BSF    0A.3
0C45:  BSF    03.6
0C46:  DECFSZ 21,F
0C47:  GOTO   43F
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
0C48:  CLRF   0A
0C49:  BCF    03.6
0C4A:  GOTO   000
....................          ret = 1; 
0C4B:  MOVLW  01
0C4C:  BSF    03.6
0C4D:  MOVWF  10
0C4E:  BCF    03.6
....................       } // Fin comando NC 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
0C4F:  MOVF   43,W
0C50:  SUBLW  4E
0C51:  BTFSS  03.2
0C52:  GOTO   4DF
0C53:  MOVF   44,W
0C54:  SUBLW  4D
0C55:  BTFSS  03.2
0C56:  GOTO   4DF
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
0C57:  MOVF   0B,W
0C58:  MOVWF  77
0C59:  BCF    0B.7
0C5A:  BSF    03.6
0C5B:  CLRF   0D
0C5C:  BCF    03.6
0C5D:  MOVF   45,W
0C5E:  BSF    03.6
0C5F:  MOVWF  0C
0C60:  BSF    03.5
0C61:  BCF    0C.7
0C62:  BSF    0C.2
0C63:  MOVLW  55
0C64:  MOVWF  0D
0C65:  MOVLW  AA
0C66:  MOVWF  0D
0C67:  BSF    0C.1
0C68:  BTFSC  0C.1
0C69:  GOTO   468
0C6A:  BCF    0C.2
0C6B:  MOVF   77,W
0C6C:  BCF    03.5
0C6D:  BCF    03.6
0C6E:  IORWF  0B,F
....................          delay_ms(10); 
0C6F:  MOVLW  0A
0C70:  BSF    03.6
0C71:  MOVWF  22
0C72:  BCF    0A.3
0C73:  BCF    03.6
0C74:  CALL   58A
0C75:  BSF    0A.3
....................           
....................          // Responde la solicitud 
....................          delay_ms(20); 
0C76:  MOVLW  14
0C77:  BSF    03.6
0C78:  MOVWF  22
0C79:  BCF    0A.3
0C7A:  BCF    03.6
0C7B:  CALL   58A
0C7C:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0C7D:  MOVLW  AC
0C7E:  BSF    03.6
0C7F:  MOVWF  0D
0C80:  MOVLW  00
0C81:  MOVWF  0F
0C82:  BCF    03.0
0C83:  MOVLW  0B
0C84:  MOVWF  21
0C85:  BCF    03.6
0C86:  CALL   0B6
0C87:  MOVF   41,W
0C88:  BTFSS  0C.4
0C89:  GOTO   488
0C8A:  MOVWF  19
0C8B:  MOVLW  B2
0C8C:  BSF    03.6
0C8D:  MOVWF  0D
0C8E:  MOVLW  00
0C8F:  MOVWF  0F
0C90:  BSF    03.0
0C91:  MOVLW  05
0C92:  MOVWF  21
0C93:  BCF    03.6
0C94:  CALL   0B6
....................          delay_ms(50); 
0C95:  MOVLW  32
0C96:  BSF    03.6
0C97:  MOVWF  22
0C98:  BCF    0A.3
0C99:  BCF    03.6
0C9A:  CALL   58A
0C9B:  BSF    0A.3
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
0C9C:  MOVLW  12
0C9D:  MOVWF  04
0C9E:  BSF    03.7
....................          delay_ms(100); 
*
0CBC:  MOVLW  64
0CBD:  BSF    03.6
0CBE:  MOVWF  22
0CBF:  BCF    0A.3
0CC0:  BCF    03.6
0CC1:  CALL   58A
0CC2:  BSF    0A.3
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0CC3:  MOVLW  B6
0CC4:  BSF    03.6
0CC5:  MOVWF  0D
0CC6:  MOVLW  00
0CC7:  MOVWF  0F
0CC8:  BCF    03.0
0CC9:  MOVLW  0C
0CCA:  MOVWF  21
0CCB:  BCF    03.6
0CCC:  CALL   0B6
0CCD:  MOVF   41,W
0CCE:  BTFSS  0C.4
0CCF:  GOTO   4CE
0CD0:  MOVWF  19
0CD1:  MOVLW  0D
0CD2:  BTFSS  0C.4
0CD3:  GOTO   4D2
0CD4:  MOVWF  19
0CD5:  MOVLW  0A
0CD6:  BTFSS  0C.4
0CD7:  GOTO   4D6
0CD8:  MOVWF  19
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
0CD9:  CLRF   0A
0CDA:  GOTO   000
....................           
....................          ret = 1; 
0CDB:  MOVLW  01
0CDC:  BSF    03.6
0CDD:  MOVWF  10
0CDE:  BCF    03.6
....................       } // Fin comando OP 
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................        
....................       // Responde la solicitud 
....................       delay_ms(20); 
0CDF:  MOVLW  14
0CE0:  BSF    03.6
0CE1:  MOVWF  22
0CE2:  BCF    0A.3
0CE3:  BCF    03.6
0CE4:  CALL   58A
0CE5:  BSF    0A.3
....................       fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0CE6:  MOVLW  BF
0CE7:  BSF    03.6
0CE8:  MOVWF  0D
0CE9:  MOVLW  00
0CEA:  MOVWF  0F
0CEB:  BCF    03.0
0CEC:  MOVLW  0B
0CED:  MOVWF  21
0CEE:  BCF    03.6
0CEF:  CALL   0B6
0CF0:  MOVF   41,W
0CF1:  BTFSS  0C.4
0CF2:  GOTO   4F1
0CF3:  MOVWF  19
0CF4:  MOVLW  C5
0CF5:  BSF    03.6
0CF6:  MOVWF  0D
0CF7:  MOVLW  00
0CF8:  MOVWF  0F
0CF9:  BSF    03.0
0CFA:  MOVLW  05
0CFB:  MOVWF  21
0CFC:  BCF    03.6
0CFD:  CALL   0B6
....................       delay_ms(50); 
0CFE:  MOVLW  32
0CFF:  BSF    03.6
0D00:  MOVWF  22
0D01:  BCF    0A.3
0D02:  BCF    03.6
0D03:  CALL   58A
0D04:  BSF    0A.3
....................       fprintf(ESP8266, "%s",ESP8266_Resp); 
0D05:  MOVLW  12
0D06:  MOVWF  04
0D07:  BSF    03.7
....................       delay_ms(100); 
*
0D25:  MOVLW  64
0D26:  BSF    03.6
0D27:  MOVWF  22
0D28:  BCF    0A.3
0D29:  BCF    03.6
0D2A:  CALL   58A
0D2B:  BSF    0A.3
....................       fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0D2C:  MOVLW  C9
0D2D:  BSF    03.6
0D2E:  MOVWF  0D
0D2F:  MOVLW  00
0D30:  MOVWF  0F
0D31:  BCF    03.0
0D32:  MOVLW  0C
0D33:  MOVWF  21
0D34:  BCF    03.6
0D35:  CALL   0B6
0D36:  MOVF   41,W
0D37:  BTFSS  0C.4
0D38:  GOTO   537
0D39:  MOVWF  19
0D3A:  MOVLW  0D
0D3B:  BTFSS  0C.4
0D3C:  GOTO   53B
0D3D:  MOVWF  19
0D3E:  MOVLW  0A
0D3F:  BTFSS  0C.4
0D40:  GOTO   53F
0D41:  MOVWF  19
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
0D42:  BSF    03.6
0D43:  CLRF   20
0D44:  MOVF   7C,F
0D45:  BTFSS  03.2
0D46:  GOTO   54B
0D47:  MOVF   20,W
0D48:  SUBWF  7B,W
0D49:  BTFSS  03.0
0D4A:  GOTO   552
....................          DATA_COMMAND[idxCb] = 0x00; 
0D4B:  MOVLW  45
0D4C:  ADDWF  20,W
0D4D:  MOVWF  04
0D4E:  BCF    03.7
0D4F:  CLRF   00
0D50:  INCF   20,F
0D51:  GOTO   544
....................       } 
....................       COMMAND[0]       = 0x00; 
0D52:  BCF    03.6
0D53:  CLRF   43
....................       COMMAND[1]       = 0x00; 
0D54:  CLRF   44
....................       ID_CONNETION[0]  = 0x00; 
0D55:  CLRF   41
....................        
....................       // Reinicia el buffer 
....................       flag_Resp_Ready  = 0x00; 
0D56:  BSF    03.5
0D57:  CLRF   21
....................       LEN_DATA_COMMAND = 0x00; 
0D58:  CLRF   7C
0D59:  CLRF   7B
....................        
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return ret; 
0D5A:  BCF    03.5
0D5B:  BSF    03.6
0D5C:  MOVF   10,W
0D5D:  MOVWF  78
0D5E:  BCF    03.6
0D5F:  RETURN
.................... } 
....................  
.................... #include "header/esp8266.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... #define  CMD_MODE             1 
.................... #define  CMD_DO_CONN          2 
.................... #define  CMD_CONN             3 
.................... #define  READY_RESPONSE_WIFI  4 
.................... #define  END_CMD_GET_IP       2 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void waitRespOK(int buffer); 
.................... void waitRespNoAp(int buffer); 
.................... void waitRespCWJAP(int buffer); 
.................... void waitRespConnected(int buffer); 
.................... void waitRespFail(int buffer); 
.................... //void waitRespError(int buffer); 
.................... int  waitResp(void); 
.................... void waitRespGetIP(char buffer); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN             = 0x00; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... //int flag_Ready_Resp         = 0; 
.................... int flag_Resp_Valid         = 0; 
.................... int flag_Resp_NoAp          = 0; 
.................... int flag_Resp_CWJAP         = 0; 
.................... int flag_Resp_Connected     = 0; 
.................... int flag_Resp_Fail          = 0; 
.................... int flag_Resp_Error         = 0; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp           = 0; 
.................... int flag_Pos_Resp_NoAp      = 0; 
.................... int flag_Pos_Resp_CWJAP     = 0; 
.................... int flag_Pos_Resp_Connected = 0; 
.................... int flag_Pos_Resp_Fail      = 0; 
.................... int flag_Pos_Resp_Error     = 0; 
....................  
.................... /*@TODO: Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    /**fprintf(ESP8266, "AT+RST\r\n"); 
....................    delay_ms(2000);**/ 
....................     
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
*
095E:  BSF    03.6
095F:  CLRF   0D
0960:  BSF    03.5
0961:  BCF    0C.7
0962:  BSF    0C.0
0963:  BCF    03.5
0964:  MOVF   0C,W
0965:  BSF    03.5
0966:  BCF    03.6
0967:  MOVWF  32
....................    delay_ms(10); 
0968:  MOVLW  0A
0969:  BCF    03.5
096A:  BSF    03.6
096B:  MOVWF  22
096C:  BCF    0A.3
096D:  BCF    03.6
096E:  CALL   58A
096F:  BSF    0A.3
....................    switch(modeStar){ 
0970:  BSF    03.5
0971:  MOVF   32,W
0972:  XORLW  31
0973:  BCF    03.5
0974:  BTFSC  03.2
0975:  GOTO   17C
0976:  XORLW  03
0977:  BTFSC  03.2
0978:  GOTO   17C
0979:  XORLW  01
097A:  BTFSS  03.2
097B:  GOTO   17D
....................       case '1': 
....................       case '2': 
....................       case '3': 
....................          break; 
097C:  GOTO   19E
....................       default: 
....................          write_eeprom(0x00,'3'); 
097D:  MOVF   0B,W
097E:  MOVWF  77
097F:  BCF    0B.7
0980:  BSF    03.6
0981:  CLRF   0D
0982:  MOVLW  33
0983:  MOVWF  0C
0984:  BSF    03.5
0985:  BCF    0C.7
0986:  BSF    0C.2
0987:  MOVLW  55
0988:  MOVWF  0D
0989:  MOVLW  AA
098A:  MOVWF  0D
098B:  BSF    0C.1
098C:  BTFSC  0C.1
098D:  GOTO   18C
098E:  BCF    0C.2
098F:  MOVF   77,W
0990:  BCF    03.5
0991:  BCF    03.6
0992:  IORWF  0B,F
....................          delay_ms(10); 
0993:  MOVLW  0A
0994:  BSF    03.6
0995:  MOVWF  22
0996:  BCF    0A.3
0997:  BCF    03.6
0998:  CALL   58A
0999:  BSF    0A.3
....................          modeStar = '3'; 
099A:  MOVLW  33
099B:  BSF    03.5
099C:  MOVWF  32
....................          break; 
099D:  BCF    03.5
....................    } 
....................    // Lanza el comando para configurar el modo de conexion 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeStar); 
099E:  MOVLW  D2
099F:  BSF    03.6
09A0:  MOVWF  0D
09A1:  MOVLW  00
09A2:  MOVWF  0F
09A3:  BCF    03.0
09A4:  MOVLW  0A
09A5:  MOVWF  21
09A6:  BCF    03.6
09A7:  CALL   0B6
09A8:  BSF    03.5
09A9:  MOVF   32,W
09AA:  BCF    03.5
09AB:  BTFSS  0C.4
09AC:  GOTO   1AB
09AD:  MOVWF  19
09AE:  MOVLW  0D
09AF:  BTFSS  0C.4
09B0:  GOTO   1AF
09B1:  MOVWF  19
09B2:  MOVLW  0A
09B3:  BTFSS  0C.4
09B4:  GOTO   1B3
09B5:  MOVWF  19
....................    CMD_RUN =  CMD_MODE; 
09B6:  MOVLW  01
09B7:  BSF    03.5
09B8:  MOVWF  25
....................     
....................    // Espera por la respuesta OK del modulo 
....................    delay_ms(50); 
09B9:  MOVLW  32
09BA:  BCF    03.5
09BB:  BSF    03.6
09BC:  MOVWF  22
09BD:  BCF    0A.3
09BE:  BCF    03.6
09BF:  CALL   58A
09C0:  BSF    0A.3
....................     
....................    // Lanza el comando para verificar si elmodulo ya se encuentra conectado 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
09C1:  MOVLW  DA
09C2:  BSF    03.6
09C3:  MOVWF  0D
09C4:  MOVLW  00
09C5:  MOVWF  0F
09C6:  BCF    03.6
09C7:  CALL   10C
....................    CMD_RUN =  CMD_DO_CONN; 
09C8:  MOVLW  02
09C9:  BSF    03.5
09CA:  MOVWF  25
....................     
....................    resp = waitResp(); 
09CB:  BCF    0A.3
09CC:  BCF    03.5
09CD:  CALL   7C4
09CE:  BSF    0A.3
09CF:  MOVF   78,W
09D0:  BSF    03.5
09D1:  MOVWF  6B
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
09D2:  MOVF   6B,W
09D3:  SUBLW  02
09D4:  BTFSS  03.2
09D5:  GOTO   269
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
09D6:  CLRF   6C
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
09D7:  MOVLW  B3
09D8:  ADDWF  6C,W
09D9:  MOVWF  04
09DA:  BCF    03.7
09DB:  MOVF   00,W
09DC:  SUBLW  0A
09DD:  BTFSC  03.2
09DE:  GOTO   20A
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
09DF:  MOVLW  B3
09E0:  ADDWF  6C,W
09E1:  MOVWF  04
09E2:  BCF    03.7
09E3:  MOVLW  01
09E4:  ADDWF  6C,W
09E5:  MOVWF  6F
09E6:  MOVF   6F,W
09E7:  BCF    03.5
09E8:  BSF    03.6
09E9:  MOVWF  0D
09EA:  BSF    03.5
09EB:  BCF    0C.7
09EC:  BSF    0C.0
09ED:  BCF    03.5
09EE:  MOVF   0C,W
09EF:  MOVWF  00
....................          delay_ms(10); 
09F0:  MOVLW  0A
09F1:  MOVWF  22
09F2:  BCF    0A.3
09F3:  BCF    03.6
09F4:  CALL   58A
09F5:  BSF    0A.3
....................          if(SSIDAndKey[idxRE]==0xFF){ 
09F6:  MOVLW  B3
09F7:  BSF    03.5
09F8:  ADDWF  6C,W
09F9:  MOVWF  04
09FA:  BCF    03.7
09FB:  INCFSZ 00,W
09FC:  GOTO   200
....................             resp = 5; 
09FD:  MOVLW  05
09FE:  MOVWF  6B
....................             break; 
09FF:  GOTO   20A
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
0A00:  MOVLW  B3
0A01:  ADDWF  6C,W
0A02:  MOVWF  04
0A03:  BCF    03.7
0A04:  MOVF   00,W
0A05:  SUBLW  0A
0A06:  BTFSC  03.2
....................             break; 
0A07:  GOTO   20A
....................          } 
....................          idxRE++; 
0A08:  INCF   6C,F
0A09:  GOTO   1D7
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
0A0A:  MOVF   6B,W
0A0B:  SUBLW  05
0A0C:  BTFSC  03.2
0A0D:  GOTO   243
....................          fprintf(ESP8266, "AT+CWJAP=%s",SSIDAndKey);     /** AT+CWJAP="UNE_C06E","00986344200771" **/ 
0A0E:  MOVLW  E0
0A0F:  BCF    03.5
0A10:  BSF    03.6
0A11:  MOVWF  0D
0A12:  MOVLW  00
0A13:  MOVWF  0F
0A14:  BCF    03.0
0A15:  MOVLW  09
0A16:  MOVWF  21
0A17:  BCF    03.6
0A18:  CALL   0B6
0A19:  MOVLW  B3
0A1A:  MOVWF  04
0A1B:  BCF    03.7
....................          CMD_RUN = CMD_CONN; 
*
0A39:  MOVLW  03
0A3A:  BSF    03.5
0A3B:  MOVWF  25
....................          resp    = waitResp(); 
0A3C:  BCF    0A.3
0A3D:  BCF    03.5
0A3E:  CALL   7C4
0A3F:  BSF    0A.3
0A40:  MOVF   78,W
0A41:  BSF    03.5
0A42:  MOVWF  6B
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
0A43:  MOVF   6B,W
0A44:  SUBLW  04
0A45:  BTFSC  03.2
0A46:  GOTO   24B
0A47:  MOVF   6B,W
0A48:  SUBLW  05
0A49:  BTFSS  03.2
0A4A:  GOTO   269
....................          fprintf(ESP8266, "AT+CWMODE=%c\r\n","3"); 
0A4B:  MOVLW  E6
0A4C:  BCF    03.5
0A4D:  BSF    03.6
0A4E:  MOVWF  0D
0A4F:  MOVLW  00
0A50:  MOVWF  0F
0A51:  BCF    03.0
0A52:  MOVLW  0A
0A53:  MOVWF  21
0A54:  BCF    03.6
0A55:  CALL   0B6
0A56:  BTFSS  0C.4
0A57:  GOTO   256
0A58:  MOVWF  19
0A59:  MOVLW  0D
0A5A:  BTFSS  0C.4
0A5B:  GOTO   25A
0A5C:  MOVWF  19
0A5D:  MOVLW  0A
0A5E:  BTFSS  0C.4
0A5F:  GOTO   25E
0A60:  MOVWF  19
....................          CMD_RUN = CMD_MODE; 
0A61:  MOVLW  01
0A62:  BSF    03.5
0A63:  MOVWF  25
....................          waitResp(); 
0A64:  BCF    0A.3
0A65:  BCF    03.5
0A66:  CALL   7C4
0A67:  BSF    0A.3
0A68:  BSF    03.5
....................       } 
....................    } // Fin del if(doConnect) 
....................     
....................    // Configura el modulo como server 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
0A69:  MOVLW  EE
0A6A:  BCF    03.5
0A6B:  BSF    03.6
0A6C:  MOVWF  0D
0A6D:  MOVLW  00
0A6E:  MOVWF  0F
0A6F:  BCF    03.6
0A70:  CALL   10C
....................    delay_ms(1000); 
0A71:  MOVLW  04
0A72:  BSF    03.5
0A73:  MOVWF  6D
0A74:  MOVLW  FA
0A75:  BCF    03.5
0A76:  BSF    03.6
0A77:  MOVWF  22
0A78:  BCF    0A.3
0A79:  BCF    03.6
0A7A:  CALL   58A
0A7B:  BSF    0A.3
0A7C:  BSF    03.5
0A7D:  DECFSZ 6D,F
0A7E:  GOTO   274
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
0A7F:  MOVLW  F5
0A80:  BCF    03.5
0A81:  BSF    03.6
0A82:  MOVWF  0D
0A83:  MOVLW  00
0A84:  MOVWF  0F
0A85:  BCF    03.6
0A86:  CALL   10C
....................    delay_ms(1000); 
0A87:  MOVLW  04
0A88:  BSF    03.5
0A89:  MOVWF  6D
0A8A:  MOVLW  FA
0A8B:  BCF    03.5
0A8C:  BSF    03.6
0A8D:  MOVWF  22
0A8E:  BCF    0A.3
0A8F:  BCF    03.6
0A90:  CALL   58A
0A91:  BSF    0A.3
0A92:  BSF    03.5
0A93:  DECFSZ 6D,F
0A94:  GOTO   28A
....................     
....................    CMD_RUN = READY_RESPONSE_WIFI; 
0A95:  MOVLW  04
0A96:  MOVWF  25
0A97:  BCF    03.5
0A98:  BCF    0A.3
0A99:  BSF    0A.4
0A9A:  GOTO   73C (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
03FA:  BSF    03.5
03FB:  BCF    03.6
03FC:  MOVF   25,W
03FD:  XORLW  01
03FE:  BCF    03.5
03FF:  BTFSC  03.2
0400:  GOTO   40B
0401:  XORLW  03
0402:  BTFSC  03.2
0403:  GOTO   411
0404:  XORLW  01
0405:  BTFSC  03.2
0406:  GOTO   45D
0407:  XORLW  07
0408:  BTFSC  03.2
0409:  GOTO   4A9
040A:  GOTO   4A9
....................             case CMD_MODE: 
....................                   waitRespOK(buffer); 
040B:  BSF    03.6
040C:  MOVF   2D,W
040D:  MOVWF  2E
040E:  BCF    03.6
040F:  CALL   3CE
....................                   break; 
0410:  GOTO   57D
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespNoAp(buffer); 
0411:  BSF    03.6
0412:  MOVF   2D,W
0413:  MOVWF  2E
....................                   waitRespCWJAP(buffer); 
*
0433:  BCF    03.5
0434:  BSF    03.6
0435:  MOVF   2D,W
0436:  MOVWF  2E
....................                   waitRespOK(buffer); 
*
0456:  BCF    03.5
0457:  BSF    03.6
0458:  MOVF   2D,W
0459:  MOVWF  2E
045A:  BCF    03.6
045B:  CALL   3CE
....................                   break; 
045C:  GOTO   57D
....................  
....................             case CMD_CONN: 
....................                   waitRespConnected(buffer); 
045D:  BSF    03.6
045E:  MOVF   2D,W
045F:  MOVWF  2E
....................                   waitRespFail(buffer); 
*
047F:  BCF    03.5
0480:  BSF    03.6
0481:  MOVF   2D,W
0482:  MOVWF  2E
....................                   waitRespOK(buffer); 
*
04A2:  BCF    03.5
04A3:  BSF    03.6
04A4:  MOVF   2D,W
04A5:  MOVWF  2E
04A6:  BCF    03.6
04A7:  CALL   3CE
....................                   break; 
04A8:  GOTO   57D
....................                    
....................             case READY_RESPONSE_WIFI: 
....................             default: 
....................                   ESP8266_Get_IPD(buffer); 
04A9:  BSF    03.6
04AA:  CLRF   2F
04AB:  MOVF   2D,W
04AC:  MOVWF  2E
....................                   ESP8266_Get_CMD(buffer); 
*
04F0:  BCF    03.5
04F1:  BSF    03.6
04F2:  CLRF   2F
04F3:  MOVF   2D,W
04F4:  MOVWF  2E
....................                   ESP8266_Get_Data(buffer); 
*
053A:  BCF    03.5
053B:  BSF    03.6
053C:  CLRF   2F
053D:  MOVF   2D,W
053E:  MOVWF  2E
....................              
....................                   CMD_RUN = 0x00; 
*
057B:  CLRF   25
....................                   break; 
057C:  BCF    03.5
....................       } // Fin del switch (CMD_RUN) 
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
07C4:  BSF    03.5
07C5:  CLRF   6D
.................... { 
....................    int ret=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(flag_Resp_Valid==0){ 
07C6:  MOVF   26,F
07C7:  BTFSS  03.2
07C8:  GOTO   7F0
....................     
....................       if(flag_Resp_CWJAP==1){ 
07C9:  DECFSZ 28,W
07CA:  GOTO   7D0
....................       // Comando doConnected Conectado a la red 
....................          flag_Pos_Resp_CWJAP  = 0; 
07CB:  CLRF   2E
....................          flag_Resp_CWJAP      = 0; 
07CC:  CLRF   28
....................          ret = 1; 
07CD:  MOVLW  01
07CE:  MOVWF  6D
....................  
....................       } else if(flag_Resp_NoAp==1){ 
07CF:  GOTO   7EF
07D0:  DECFSZ 27,W
07D1:  GOTO   7D7
....................       // Comando doConnected No se ha asignado una red 
....................          flag_Pos_Resp_NoAp  = 0; 
07D2:  CLRF   2D
....................          flag_Resp_NoAp      = 0; 
07D3:  CLRF   27
....................          ret = 2; 
07D4:  MOVLW  02
07D5:  MOVWF  6D
....................  
....................       } else if (flag_Resp_Connected==1){ 
07D6:  GOTO   7EF
07D7:  DECFSZ 29,W
07D8:  GOTO   7DE
....................       // Comando Conexion establecida 
....................          flag_Pos_Resp_Connected = 0; 
07D9:  CLRF   2F
....................          flag_Resp_Connected     = 0; 
07DA:  CLRF   29
....................          ret = 3; 
07DB:  MOVLW  03
07DC:  MOVWF  6D
....................  
....................       } else if(flag_Resp_Fail==1){ 
07DD:  GOTO   7EF
07DE:  DECFSZ 2A,W
07DF:  GOTO   7E7
....................       // Comando Conexion Fallo al intentar la Conexion 
....................       // Esta respuesta da como resultado un ERROR entonces 
....................       // Se rompe el ciclo de forma manual flag_Resp_Valid=1 
....................          flag_Pos_Resp_Fail   = 0; 
07E0:  CLRF   30
....................          flag_Resp_Fail       = 0; 
07E1:  CLRF   2A
....................          flag_Resp_Valid      = 1; 
07E2:  MOVLW  01
07E3:  MOVWF  26
....................          ret = 4; 
07E4:  MOVLW  04
07E5:  MOVWF  6D
....................       } else if(flag_Resp_Error==1){ 
07E6:  GOTO   7EF
07E7:  DECFSZ 2B,W
07E8:  GOTO   7EF
....................       // Comando Fallo 
....................       // Esta respuesta da como resultado un ERROR entonces 
....................       // Se rompe el ciclo de forma manual flag_Resp_Valid=1 
....................          flag_Pos_Resp_Error  = 0; 
07E9:  CLRF   31
....................          flag_Resp_Error      = 0; 
07EA:  CLRF   2B
....................          flag_Resp_Valid      = 1; 
07EB:  MOVLW  01
07EC:  MOVWF  26
....................          ret = 5; 
07ED:  MOVLW  05
07EE:  MOVWF  6D
....................       } 
07EF:  GOTO   7C6
....................    }; // Fin del loop 
....................    flag_Resp_Valid = 0; 
07F0:  CLRF   26
....................    CMD_RUN = 0x00; 
07F1:  CLRF   25
....................    return ret; 
07F2:  MOVF   6D,W
07F3:  MOVWF  78
07F4:  BCF    03.5
07F5:  RETURN
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
....................  
.................... void waitRespOK(int buffer) 
*
03CE:  MOVLW  04
03CF:  BSF    03.6
03D0:  MOVWF  2F
.................... { 
....................    const char ESP8266_RESP_OK[4] ={'O','K',0x0D,0x0A}; 
....................    int lenResp = 4; 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_OK[flag_Pos_Resp]) 
03D1:  BSF    03.5
03D2:  BCF    03.6
03D3:  MOVF   2C,W
03D4:  BCF    03.5
03D5:  CALL   062
03D6:  MOVWF  78
03D7:  BSF    03.6
03D8:  SUBWF  2E,W
03D9:  BTFSS  03.2
03DA:  GOTO   3ED
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp++; 
03DB:  BSF    03.5
03DC:  BCF    03.6
03DD:  INCF   2C,F
....................        
....................       if(flag_Pos_Resp==lenResp){ 
03DE:  BCF    03.5
03DF:  BSF    03.6
03E0:  MOVF   2F,W
03E1:  BSF    03.5
03E2:  BCF    03.6
03E3:  SUBWF  2C,W
03E4:  BTFSS  03.2
03E5:  GOTO   3E9
....................          // Respuesta es valida 
....................          flag_Resp_Valid   = 1; 
03E6:  MOVLW  01
03E7:  MOVWF  26
....................       }else{ 
03E8:  GOTO   3EA
....................          // Reinicia la bandera para asegurar la integridad de la respesta 
....................          flag_Resp_Valid   = 0; 
03E9:  CLRF   26
....................       } 
....................  
....................    }else{ 
03EA:  GOTO   3F1
03EB:  BCF    03.5
03EC:  BSF    03.6
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       flag_Pos_Resp     = 0; 
03ED:  BSF    03.5
03EE:  BCF    03.6
03EF:  CLRF   2C
....................       // Como esta funcion es el ultimo caracter recibido no es necesario mantener  
....................       // Activa la bandera flag_Resp_Valid 
....................       flag_Resp_Valid   = 0; 
03F0:  CLRF   26
....................    } 
03F1:  BCF    03.5
03F2:  RETURN
.................... } // Fin de la funcion waitRespOK() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_NoAp (Sin conexion) 
.................... *********************************************************/ 
.................... void waitRespNoAp(int buffer) 
*
0414:  MOVLW  05
0415:  MOVWF  2F
.................... { 
....................    const char ESP8266_RESP_NoAP[5] ={'N', 'o', ' ', 'A', 'P'}; 
....................    int lenResp = 5; 
....................     
....................    if(buffer == ESP8266_RESP_NoAp[flag_Pos_Resp_NoAp] ) 
0416:  BSF    03.5
0417:  BCF    03.6
0418:  MOVF   2D,W
0419:  BCF    03.5
041A:  CALL   06A
041B:  MOVWF  78
041C:  BSF    03.6
041D:  SUBWF  2E,W
041E:  BTFSS  03.2
041F:  GOTO   430
....................    { 
....................       flag_Pos_Resp_NoAp++; 
0420:  BSF    03.5
0421:  BCF    03.6
0422:  INCF   2D,F
....................        
....................       if(flag_Pos_Resp_NoAp==lenResp){ 
0423:  BCF    03.5
0424:  BSF    03.6
0425:  MOVF   2F,W
0426:  BSF    03.5
0427:  BCF    03.6
0428:  SUBWF  2D,W
0429:  BTFSS  03.2
042A:  GOTO   42D
....................          // Respuesta es valida 
....................          flag_Resp_NoAp   = 1; 
042B:  MOVLW  01
042C:  MOVWF  27
....................       } 
....................    }else{ 
042D:  GOTO   433
042E:  BCF    03.5
042F:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_NoAp  = 0; 
0430:  BSF    03.5
0431:  BCF    03.6
0432:  CLRF   2D
....................    } 
.................... } // Fin de la funcion waitRespNoAp() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_CWJAP (Conectado) 
.................... *********************************************************/ 
.................... void waitRespCWJAP(int buffer) 
*
0437:  MOVLW  07
0438:  MOVWF  2F
.................... { 
....................    const char ESP8266_RESP_CWJAP[7] ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
....................    int lenResp = 7; 
....................  
....................    if(buffer == ESP8266_RESP_CWJAP[flag_Pos_Resp_CWJAP] ) 
0439:  BSF    03.5
043A:  BCF    03.6
043B:  MOVF   2E,W
043C:  BCF    03.5
043D:  CALL   073
043E:  MOVWF  78
043F:  BSF    03.6
0440:  SUBWF  2E,W
0441:  BTFSS  03.2
0442:  GOTO   453
....................    { 
....................       flag_Pos_Resp_CWJAP++; 
0443:  BSF    03.5
0444:  BCF    03.6
0445:  INCF   2E,F
....................        
....................       if(flag_Pos_Resp_CWJAP==lenResp){ 
0446:  BCF    03.5
0447:  BSF    03.6
0448:  MOVF   2F,W
0449:  BSF    03.5
044A:  BCF    03.6
044B:  SUBWF  2E,W
044C:  BTFSS  03.2
044D:  GOTO   450
....................          // Respuesta es valida 
....................          flag_Resp_CWJAP   = 1; 
044E:  MOVLW  01
044F:  MOVWF  28
....................       } 
....................    }else { 
0450:  GOTO   456
0451:  BCF    03.5
0452:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_CWJAP = 0; 
0453:  BSF    03.5
0454:  BCF    03.6
0455:  CLRF   2E
....................    } 
....................     
.................... } // Fin de la funcion waitRespCWJAP() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando Conexion 
....................  *    ESP8266_RESP_Connected (Conectado) 
.................... *********************************************************/ 
.................... void waitRespConnected(int buffer) 
*
0460:  MOVLW  09
0461:  MOVWF  2F
.................... { 
....................    const char ESP8266_RESP_Connected[9] ={'C','O','N','N','E','C','T','E','D'}; 
....................    int lenResp = 9; 
....................   
....................    if(buffer == ESP8266_RESP_Connected[flag_Pos_Resp_Connected] ) 
0462:  BSF    03.5
0463:  BCF    03.6
0464:  MOVF   2F,W
0465:  BCF    03.5
0466:  CALL   07E
0467:  MOVWF  78
0468:  BSF    03.6
0469:  SUBWF  2E,W
046A:  BTFSS  03.2
046B:  GOTO   47C
....................    { 
....................       flag_Pos_Resp_Connected++; 
046C:  BSF    03.5
046D:  BCF    03.6
046E:  INCF   2F,F
....................        
....................       if(flag_Pos_Resp_Connected==lenResp){ 
046F:  BCF    03.5
0470:  BSF    03.6
0471:  MOVF   2F,W
0472:  BSF    03.5
0473:  BCF    03.6
0474:  SUBWF  2F,W
0475:  BTFSS  03.2
0476:  GOTO   479
....................          // Respuesta es valida 
....................          flag_Resp_Connected   = 1; 
0477:  MOVLW  01
0478:  MOVWF  29
....................       } 
....................    }else{ 
0479:  GOTO   47F
047A:  BCF    03.5
047B:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Connected = 0; 
047C:  BSF    03.5
047D:  BCF    03.6
047E:  CLRF   2F
....................    } 
.................... } // Fin de la funcion waitRespConnected() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando Conexion 
....................  *    ESP8266_RESP_FAIL (Fallo al intentar conectarse) 
.................... *********************************************************/ 
.................... void waitRespFail(int buffer) 
*
0483:  MOVLW  04
0484:  MOVWF  2F
.................... { 
....................    const char ESP8266_RESP_FAIL[4] ={'F', 'A', 'I', 'L'}; 
....................    int lenResp = 4; 
....................   
....................    if(buffer == ESP8266_RESP_FAIL[flag_Pos_Resp_Fail] ) 
0485:  BSF    03.5
0486:  BCF    03.6
0487:  MOVF   30,W
0488:  BCF    03.5
0489:  CALL   08B
048A:  MOVWF  78
048B:  BSF    03.6
048C:  SUBWF  2E,W
048D:  BTFSS  03.2
048E:  GOTO   49F
....................    { 
....................       flag_Pos_Resp_Fail++; 
048F:  BSF    03.5
0490:  BCF    03.6
0491:  INCF   30,F
....................        
....................       if(flag_Pos_Resp_Fail==lenResp){ 
0492:  BCF    03.5
0493:  BSF    03.6
0494:  MOVF   2F,W
0495:  BSF    03.5
0496:  BCF    03.6
0497:  SUBWF  30,W
0498:  BTFSS  03.2
0499:  GOTO   49C
....................          // Respuesta es valida 
....................          flag_Resp_Fail   = 1; 
049A:  MOVLW  01
049B:  MOVWF  2A
....................       } 
....................    }else{ 
049C:  GOTO   4A2
049D:  BCF    03.5
049E:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Fail  = 0; 
049F:  BSF    03.5
04A0:  BCF    03.6
04A1:  CLRF   30
....................    } 
.................... } // Fin de la funcion waitRespFail() 
....................  
.................... /********************************************************* 
....................  *    Espera por la respuesta del comando enviado desde 
....................  *    el menu. 
....................  *********************************************************/ 
.................... /*int waitRespCmdFromMenu(void) 
.................... { 
....................    int ret=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(flag_Resp_Valid==0){ 
....................     
....................       if(ESP8266_CMD_FROM_MENU==END_CMD_GET_IP){ 
....................          flag_Pos_Resp_GetIP  = 0; 
....................          flag_Resp_GetIP      = 0; 
....................          ret = 1; 
....................       }  
....................        
....................    } 
....................     
....................    return ret; 
.................... }*/ 
.................... /********************************************************* 
....................  *    Espera por la respuesta del comando enviado desde 
....................  *    el menu. 
....................  *********************************************************/ 
.................... /*void waitRespGetIP(char buffer) 
.................... { 
....................  
....................    const char ESP8266_RESP_GET_IP[7] ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
....................    int lenResp = 7; 
....................   
....................    if(flag_Resp_GetIP == 1){ 
....................       if(buffer!=','){ 
....................          DATA_CMD_GET_IP[flag_Pos_Resp_GetIP] = buffer; 
....................          flag_Pos_Resp_GetIP++; 
....................       }else{         
....................          flag_Pos_Resp_GetIP = 0x00; 
....................          flag_Resp_GetIP     = 0x00; 
....................           
....................          // Reinicia la bandera para liberar la captura de datos 
....................          // en la interrupcion 
....................          ESP8266_CMD_FROM_MENU=END_CMD_GET_IP; 
....................       } 
....................    }else{ 
....................       if(buffer == ESP8266_RESP_GET_IP[flag_Pos_Resp_GetIP] ) 
....................       { 
....................          flag_Pos_Resp_GetIP++; 
....................           
....................          if(flag_Pos_Resp_GetIP==lenResp){ 
....................             // Respuesta es valida 
....................             flag_Resp_GetIP   = 1; 
....................          } 
....................       }else{ 
....................          // Reinicia el contador 
....................          flag_Pos_Resp_GetIP  = 0; 
....................       } 
....................    }   
.................... }*/ 
....................  
.................... #include "header/menu.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_STA_IP     0 
....................   #define OPT_SHOW_STA_SSID   1 
....................   #define OPT_SHOW_AP_SSID    2 
....................   #define OPT_SHOW_AP_KEY     3 
....................   #define OPT_SHOW_AP_IP      4 
....................   #define OPT_MODE_AP         5 
....................   #define OPT_BACKLIGH        6 
....................   #define OPT_EXIT            7 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[9][17]    =  { {"ESTACION IP     "}, 
....................                                         {"ESTACION SSID   "}, 
....................                                         {"AP SSID         "}, 
....................                                         {"AP KEY          "}, 
....................                                         {"AP IP           "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacin     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 7; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
0EB3:  BSF    03.5
0EB4:  CLRF   6B
0EB5:  CLRF   6C
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0EB6:  SWAPF  6B,W
0EB7:  MOVWF  77
0EB8:  MOVLW  F0
0EB9:  ANDWF  77,F
0EBA:  MOVF   77,W
0EBB:  MOVWF  6D
0EBC:  MOVLW  0C
0EBD:  BCF    03.5
0EBE:  BSF    03.6
0EBF:  MOVWF  13
0EC0:  BCF    03.6
0EC1:  CALL   000
0EC2:  MOVLW  FF
0EC3:  BSF    03.6
0EC4:  MOVWF  0D
0EC5:  MOVLW  00
0EC6:  MOVWF  0F
0EC7:  BSF    03.5
0EC8:  BCF    03.6
0EC9:  MOVF   6D,W
0ECA:  BCF    03.5
0ECB:  BSF    03.6
0ECC:  ADDWF  0D,F
0ECD:  BTFSC  03.0
0ECE:  INCF   0F,F
0ECF:  BCF    03.6
0ED0:  CALL   29B
....................    showBottonMenu(); 
....................    while(!exit){ 
*
0EF1:  BSF    03.5
0EF2:  MOVF   6C,F
0EF3:  BTFSS  03.2
0EF4:  GOTO   77A
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
0EF5:  BCF    03.5
0EF6:  CALL   2E6
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0EF7:  BSF    03.5
0EF8:  BSF    06.4
0EF9:  BCF    03.5
0EFA:  BTFSC  06.4
0EFB:  GOTO   756
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0EFC:  MOVLW  02
0EFD:  BSF    03.5
0EFE:  MOVWF  6D
0EFF:  MOVLW  FA
0F00:  BCF    03.5
0F01:  BSF    03.6
0F02:  MOVWF  22
0F03:  BCF    0A.3
0F04:  BCF    03.6
0F05:  CALL   58A
0F06:  BSF    0A.3
0F07:  BSF    03.5
0F08:  DECFSZ 6D,F
0F09:  GOTO   6FF
....................          BEEP; 
0F0A:  MOVLW  04
0F0B:  BCF    03.5
0F0C:  BSF    03.6
0F0D:  MOVWF  11
0F0E:  MOVLW  B9
0F0F:  MOVWF  10
0F10:  CLRF   13
0F11:  MOVLW  14
0F12:  MOVWF  12
0F13:  BCF    03.6
0F14:  CALL   560
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0F15:  BSF    03.5
0F16:  INCF   6B,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
0F17:  MOVF   6B,W
0F18:  SUBWF  65,W
0F19:  BTFSS  03.0
....................             optSelected = 0; 
0F1A:  CLRF   6B
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0F1B:  SWAPF  6B,W
0F1C:  MOVWF  77
0F1D:  MOVLW  F0
0F1E:  ANDWF  77,F
0F1F:  MOVF   77,W
0F20:  MOVWF  6D
0F21:  MOVLW  0C
0F22:  BCF    03.5
0F23:  BSF    03.6
0F24:  MOVWF  13
0F25:  BCF    03.6
0F26:  CALL   000
0F27:  MOVLW  FF
0F28:  BSF    03.6
0F29:  MOVWF  0D
0F2A:  MOVLW  00
0F2B:  MOVWF  0F
0F2C:  BSF    03.5
0F2D:  BCF    03.6
0F2E:  MOVF   6D,W
0F2F:  BCF    03.5
0F30:  BSF    03.6
0F31:  ADDWF  0D,F
0F32:  BTFSC  03.0
0F33:  INCF   0F,F
0F34:  BCF    03.6
0F35:  CALL   29B
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0F56:  BSF    03.5
0F57:  BSF    06.5
0F58:  BCF    03.5
0F59:  BTFSC  06.5
0F5A:  GOTO   778
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0F5B:  MOVLW  02
0F5C:  BSF    03.5
0F5D:  MOVWF  6D
0F5E:  MOVLW  FA
0F5F:  BCF    03.5
0F60:  BSF    03.6
0F61:  MOVWF  22
0F62:  BCF    0A.3
0F63:  BCF    03.6
0F64:  CALL   58A
0F65:  BSF    0A.3
0F66:  BSF    03.5
0F67:  DECFSZ 6D,F
0F68:  GOTO   75E
....................          BEEP; 
0F69:  MOVLW  04
0F6A:  BCF    03.5
0F6B:  BSF    03.6
0F6C:  MOVWF  11
0F6D:  MOVLW  B9
0F6E:  MOVWF  10
0F6F:  CLRF   13
0F70:  MOVLW  14
0F71:  MOVWF  12
0F72:  BCF    03.6
0F73:  CALL   560
....................          // Rompe el Loop 
....................          exit = 1; 
0F74:  MOVLW  01
0F75:  BSF    03.5
0F76:  MOVWF  6C
0F77:  BCF    03.5
....................       } // Fin KEY_OK 
0F78:  GOTO   6F1
0F79:  BSF    03.5
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
0F7A:  MOVLW  01
0F7B:  ADDWF  6B,W
0F7C:  MOVWF  78
0F7D:  BCF    03.5
0F7E:  BCF    0A.3
0F7F:  BSF    0A.4
0F80:  GOTO   749 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
1424:  MOVLW  0C
1425:  BSF    03.6
1426:  MOVWF  14
1427:  MOVLW  02
1428:  MOVWF  15
*
14D8:  MOVLW  0C
14D9:  BCF    03.5
14DA:  BSF    03.6
14DB:  MOVWF  14
14DC:  MOVLW  02
14DD:  MOVWF  15
....................   printf(lcd_putc, "SALIR"); 
*
143D:  MOVLW  54
143E:  BSF    03.6
143F:  MOVWF  0D
1440:  MOVLW  03
1441:  MOVWF  0F
1442:  BCF    0A.4
1443:  BSF    0A.3
1444:  BCF    03.6
1445:  CALL   066
1446:  BSF    0A.4
1447:  BCF    0A.3
*
14F2:  MOVLW  54
14F3:  BSF    03.6
14F4:  MOVWF  0D
14F5:  MOVLW  03
14F6:  MOVWF  0F
14F7:  BCF    0A.4
14F8:  BSF    0A.3
14F9:  BCF    03.6
14FA:  CALL   066
14FB:  BSF    0A.4
14FC:  BCF    0A.3
....................    
....................   while(1){ 
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
*
1448:  BCF    0A.4
1449:  BSF    0A.3
144A:  CALL   2E6
144B:  BSF    0A.4
144C:  BCF    0A.3
*
14FD:  BCF    0A.4
14FE:  BSF    0A.3
14FF:  CALL   2E6
1500:  BSF    0A.4
1501:  BCF    0A.3
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
*
144D:  BSF    03.5
144E:  BSF    06.5
144F:  BCF    03.5
1450:  BTFSC  06.5
1451:  GOTO   460
*
1502:  BSF    03.5
1503:  BSF    06.5
1504:  BCF    03.5
1505:  BTFSC  06.5
1506:  GOTO   515
....................            // Elimina el rebote 
....................            delay_ms(500); 
*
1452:  MOVLW  02
1453:  BSF    03.6
1454:  MOVWF  10
1455:  MOVLW  FA
1456:  MOVWF  22
1457:  BCF    0A.4
1458:  BCF    03.6
1459:  CALL   58A
145A:  BSF    0A.4
145B:  BSF    03.6
145C:  DECFSZ 10,F
145D:  GOTO   455
*
1507:  MOVLW  02
1508:  BSF    03.6
1509:  MOVWF  10
150A:  MOVLW  FA
150B:  MOVWF  22
150C:  BCF    0A.4
150D:  BCF    03.6
150E:  CALL   58A
150F:  BSF    0A.4
1510:  BSF    03.6
1511:  DECFSZ 10,F
1512:  GOTO   50A
....................            break; 
*
145E:  GOTO   462
145F:  BCF    03.6
*
1513:  GOTO   517
1514:  BCF    03.6
....................      } 
*
1460:  GOTO   448
1461:  BSF    03.6
*
1515:  GOTO   4FD
1516:  BSF    03.6
1517:  BSF    03.5
1518:  BCF    03.6
....................   } 
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
0ED1:  MOVLW  01
0ED2:  BSF    03.6
0ED3:  MOVWF  14
0ED4:  MOVLW  02
0ED5:  MOVWF  15
*
0F36:  MOVLW  01
0F37:  BSF    03.6
0F38:  MOVWF  14
0F39:  MOVLW  02
0F3A:  MOVWF  15
*
102F:  MOVLW  01
1030:  BSF    03.6
1031:  MOVWF  14
1032:  MOVLW  02
1033:  MOVWF  15
*
10B1:  MOVLW  01
10B2:  BSF    03.6
10B3:  MOVWF  14
10B4:  MOVLW  02
10B5:  MOVWF  15
*
1154:  MOVLW  01
1155:  BSF    03.6
1156:  MOVWF  14
1157:  MOVLW  02
1158:  MOVWF  15
*
11CD:  MOVLW  01
11CE:  BSF    03.6
11CF:  MOVWF  14
11D0:  MOVLW  02
11D1:  MOVWF  15
*
12BB:  MOVLW  01
12BC:  BSF    03.6
12BD:  MOVWF  14
12BE:  MOVLW  02
12BF:  MOVWF  15
*
1333:  MOVLW  01
1334:  BSF    03.6
1335:  MOVWF  14
1336:  MOVLW  02
1337:  MOVWF  15
*
148A:  MOVLW  01
148B:  BSF    03.6
148C:  MOVWF  14
148D:  MOVLW  02
148E:  MOVWF  15
*
155D:  MOVLW  01
155E:  BSF    03.6
155F:  MOVWF  14
1560:  MOVLW  02
1561:  MOVWF  15
*
15D8:  MOVLW  01
15D9:  BSF    03.6
15DA:  MOVWF  14
15DB:  MOVLW  02
15DC:  MOVWF  15
*
1657:  MOVLW  01
1658:  BSF    03.6
1659:  MOVWF  14
165A:  MOVLW  02
165B:  MOVWF  15
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
*
0EEA:  MOVLW  57
0EEB:  BSF    03.6
0EEC:  MOVWF  0D
0EED:  MOVLW  03
0EEE:  MOVWF  0F
0EEF:  BCF    03.6
0EF0:  CALL   066
*
0F4F:  MOVLW  57
0F50:  BSF    03.6
0F51:  MOVWF  0D
0F52:  MOVLW  03
0F53:  MOVWF  0F
0F54:  BCF    03.6
0F55:  CALL   066
*
1048:  MOVLW  57
1049:  BSF    03.6
104A:  MOVWF  0D
104B:  MOVLW  03
104C:  MOVWF  0F
104D:  BCF    0A.4
104E:  BSF    0A.3
104F:  BCF    03.6
1050:  CALL   066
1051:  BSF    0A.4
1052:  BCF    0A.3
*
10CA:  MOVLW  57
10CB:  BSF    03.6
10CC:  MOVWF  0D
10CD:  MOVLW  03
10CE:  MOVWF  0F
10CF:  BCF    0A.4
10D0:  BSF    0A.3
10D1:  BCF    03.6
10D2:  CALL   066
10D3:  BSF    0A.4
10D4:  BCF    0A.3
*
116D:  MOVLW  57
116E:  BSF    03.6
116F:  MOVWF  0D
1170:  MOVLW  03
1171:  MOVWF  0F
1172:  BCF    0A.4
1173:  BSF    0A.3
1174:  BCF    03.6
1175:  CALL   066
1176:  BSF    0A.4
1177:  BCF    0A.3
*
11E6:  MOVLW  57
11E7:  BSF    03.6
11E8:  MOVWF  0D
11E9:  MOVLW  03
11EA:  MOVWF  0F
11EB:  BCF    0A.4
11EC:  BSF    0A.3
11ED:  BCF    03.6
11EE:  CALL   066
11EF:  BSF    0A.4
11F0:  BCF    0A.3
*
12D4:  MOVLW  57
12D5:  BSF    03.6
12D6:  MOVWF  0D
12D7:  MOVLW  03
12D8:  MOVWF  0F
12D9:  BCF    0A.4
12DA:  BSF    0A.3
12DB:  BCF    03.6
12DC:  CALL   066
12DD:  BSF    0A.4
12DE:  BCF    0A.3
*
134C:  MOVLW  57
134D:  BSF    03.6
134E:  MOVWF  0D
134F:  MOVLW  03
1350:  MOVWF  0F
1351:  BCF    0A.4
1352:  BSF    0A.3
1353:  BCF    03.6
1354:  CALL   066
1355:  BSF    0A.4
1356:  BCF    0A.3
*
14A3:  MOVLW  57
14A4:  BSF    03.6
14A5:  MOVWF  0D
14A6:  MOVLW  03
14A7:  MOVWF  0F
14A8:  BCF    0A.4
14A9:  BSF    0A.3
14AA:  BCF    03.6
14AB:  CALL   066
14AC:  BSF    0A.4
14AD:  BCF    0A.3
14AE:  BSF    03.5
*
1576:  MOVLW  57
1577:  BSF    03.6
1578:  MOVWF  0D
1579:  MOVLW  03
157A:  MOVWF  0F
157B:  BCF    0A.4
157C:  BSF    0A.3
157D:  BCF    03.6
157E:  CALL   066
157F:  BSF    0A.4
1580:  BCF    0A.3
*
15F1:  MOVLW  57
15F2:  BSF    03.6
15F3:  MOVWF  0D
15F4:  MOVLW  03
15F5:  MOVWF  0F
15F6:  BCF    0A.4
15F7:  BSF    0A.3
15F8:  BCF    03.6
15F9:  CALL   066
15FA:  BSF    0A.4
15FB:  BCF    0A.3
*
1670:  MOVLW  57
1671:  BSF    03.6
1672:  MOVWF  0D
1673:  MOVLW  03
1674:  MOVWF  0F
1675:  BCF    0A.4
1676:  BSF    0A.3
1677:  BCF    03.6
1678:  CALL   066
1679:  BSF    0A.4
167A:  BCF    0A.3
167B:  BSF    03.5
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
1000:  BSF    03.5
1001:  CLRF   6B
1002:  CLRF   6C
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
1003:  MOVF   6B,W
1004:  BCF    03.5
1005:  BSF    03.6
1006:  MOVWF  10
1007:  MOVLW  0F
1008:  MOVWF  11
1009:  BCF    0A.4
100A:  BSF    0A.3
100B:  BCF    03.6
100C:  CALL   781
100D:  BSF    0A.4
100E:  BCF    0A.3
100F:  MOVF   78,W
1010:  BSF    03.5
1011:  MOVWF  6D
1012:  MOVLW  0C
1013:  BCF    03.5
1014:  BSF    03.6
1015:  MOVWF  13
1016:  BCF    0A.4
1017:  BSF    0A.3
1018:  BCF    03.6
1019:  CALL   000
101A:  BSF    0A.4
101B:  BCF    0A.3
101C:  MOVLW  3F
101D:  BSF    03.6
101E:  MOVWF  0D
101F:  MOVLW  01
1020:  MOVWF  0F
1021:  BSF    03.5
1022:  BCF    03.6
1023:  MOVF   6D,W
1024:  BCF    03.5
1025:  BSF    03.6
1026:  ADDWF  0D,F
1027:  BTFSC  03.0
1028:  INCF   0F,F
1029:  BCF    0A.4
102A:  BSF    0A.3
102B:  BCF    03.6
102C:  CALL   29B
102D:  BSF    0A.4
102E:  BCF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1053:  BSF    03.5
1054:  MOVF   6C,F
1055:  BTFSS  03.2
1056:  GOTO   128
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
1057:  BCF    0A.4
1058:  BSF    0A.3
1059:  BCF    03.5
105A:  CALL   2E6
105B:  BSF    0A.4
105C:  BCF    0A.3
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
105D:  BSF    03.5
105E:  BSF    06.4
105F:  BCF    03.5
1060:  BTFSC  06.4
1061:  GOTO   0D5
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1062:  MOVLW  02
1063:  BSF    03.5
1064:  MOVWF  6D
1065:  MOVLW  FA
1066:  BCF    03.5
1067:  BSF    03.6
1068:  MOVWF  22
1069:  BCF    0A.4
106A:  BCF    03.6
106B:  CALL   58A
106C:  BSF    0A.4
106D:  BSF    03.5
106E:  DECFSZ 6D,F
106F:  GOTO   065
....................          BEEP; 
1070:  MOVLW  04
1071:  BCF    03.5
1072:  BSF    03.6
1073:  MOVWF  11
1074:  MOVLW  B9
1075:  MOVWF  10
1076:  CLRF   13
1077:  MOVLW  14
1078:  MOVWF  12
1079:  BCF    0A.4
107A:  BSF    0A.3
107B:  BCF    03.6
107C:  CALL   560
107D:  BSF    0A.4
107E:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
107F:  BSF    03.5
1080:  INCF   6B,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
1081:  MOVF   6B,W
1082:  SUBWF  66,W
1083:  BTFSS  03.0
....................             optSelected = 0; 
1084:  CLRF   6B
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
1085:  MOVF   6B,W
1086:  BCF    03.5
1087:  BSF    03.6
1088:  MOVWF  10
1089:  MOVLW  0F
108A:  MOVWF  11
108B:  BCF    0A.4
108C:  BSF    0A.3
108D:  BCF    03.6
108E:  CALL   781
108F:  BSF    0A.4
1090:  BCF    0A.3
1091:  MOVF   78,W
1092:  BSF    03.5
1093:  MOVWF  6D
1094:  MOVLW  0C
1095:  BCF    03.5
1096:  BSF    03.6
1097:  MOVWF  13
1098:  BCF    0A.4
1099:  BSF    0A.3
109A:  BCF    03.6
109B:  CALL   000
109C:  BSF    0A.4
109D:  BCF    0A.3
109E:  MOVLW  3F
109F:  BSF    03.6
10A0:  MOVWF  0D
10A1:  MOVLW  01
10A2:  MOVWF  0F
10A3:  BSF    03.5
10A4:  BCF    03.6
10A5:  MOVF   6D,W
10A6:  BCF    03.5
10A7:  BSF    03.6
10A8:  ADDWF  0D,F
10A9:  BTFSC  03.0
10AA:  INCF   0F,F
10AB:  BCF    0A.4
10AC:  BSF    0A.3
10AD:  BCF    03.6
10AE:  CALL   29B
10AF:  BSF    0A.4
10B0:  BCF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
10D5:  BSF    03.5
10D6:  BSF    06.5
10D7:  BCF    03.5
10D8:  BTFSC  06.5
10D9:  GOTO   126
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
10DA:  MOVLW  02
10DB:  BSF    03.5
10DC:  MOVWF  6D
10DD:  MOVLW  FA
10DE:  BCF    03.5
10DF:  BSF    03.6
10E0:  MOVWF  22
10E1:  BCF    0A.4
10E2:  BCF    03.6
10E3:  CALL   58A
10E4:  BSF    0A.4
10E5:  BSF    03.5
10E6:  DECFSZ 6D,F
10E7:  GOTO   0DD
....................          BEEP; 
10E8:  MOVLW  04
10E9:  BCF    03.5
10EA:  BSF    03.6
10EB:  MOVWF  11
10EC:  MOVLW  B9
10ED:  MOVWF  10
10EE:  CLRF   13
10EF:  MOVLW  14
10F0:  MOVWF  12
10F1:  BCF    0A.4
10F2:  BSF    0A.3
10F3:  BCF    03.6
10F4:  CALL   560
10F5:  BSF    0A.4
10F6:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
10F7:  BSF    03.5
10F8:  MOVF   66,W
10F9:  SUBWF  6B,W
10FA:  BTFSS  03.2
10FB:  GOTO   0FF
....................             exit = 1; 
10FC:  MOVLW  01
10FD:  MOVWF  6C
....................          }else{ 
10FE:  GOTO   127
....................             output_high(PIN_OUT[optSelected]); 
10FF:  BCF    03.0
1100:  RLF    6B,W
1101:  ADDLW  2B
1102:  MOVWF  04
1103:  BCF    03.7
1104:  INCF   04,F
1105:  MOVF   00,W
1106:  MOVWF  6E
1107:  DECF   04,F
1108:  MOVF   00,W
1109:  MOVWF  6D
110A:  BCF    03.5
110B:  BSF    03.6
110C:  MOVWF  23
110D:  MOVLW  01
110E:  MOVWF  24
110F:  CLRF   26
1110:  CLRF   25
1111:  BCF    0A.4
1112:  BSF    0A.3
1113:  BCF    03.6
1114:  CALL   2C4
1115:  BSF    0A.4
1116:  BCF    0A.3
1117:  BSF    03.5
1118:  MOVF   6D,W
1119:  BCF    03.5
111A:  BSF    03.6
111B:  MOVWF  23
111C:  CLRF   24
111D:  CLRF   26
111E:  MOVLW  80
111F:  MOVWF  25
1120:  BCF    0A.4
1121:  BSF    0A.3
1122:  BCF    03.6
1123:  CALL   2C4
1124:  BSF    0A.4
1125:  BCF    0A.3
1126:  BSF    03.5
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
1127:  GOTO   054
....................    } // FIN While Infinito 
....................  
....................    return 0; 
1128:  MOVLW  00
1129:  MOVWF  78
112A:  BCF    03.5
112B:  BCF    0A.3
112C:  BSF    0A.4
112D:  GOTO   750 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
112E:  BSF    03.5
112F:  CLRF   6B
1130:  CLRF   6C
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
1131:  SWAPF  6B,W
1132:  MOVWF  77
1133:  MOVLW  F0
1134:  ANDWF  77,F
1135:  MOVF   77,W
1136:  MOVWF  6D
1137:  MOVLW  0C
1138:  BCF    03.5
1139:  BSF    03.6
113A:  MOVWF  13
113B:  BCF    0A.4
113C:  BSF    0A.3
113D:  BCF    03.6
113E:  CALL   000
113F:  BSF    0A.4
1140:  BCF    0A.3
1141:  MOVLW  D5
1142:  BSF    03.6
1143:  MOVWF  0D
1144:  MOVLW  01
1145:  MOVWF  0F
1146:  BSF    03.5
1147:  BCF    03.6
1148:  MOVF   6D,W
1149:  BCF    03.5
114A:  BSF    03.6
114B:  ADDWF  0D,F
114C:  BTFSC  03.0
114D:  INCF   0F,F
114E:  BCF    0A.4
114F:  BSF    0A.3
1150:  BCF    03.6
1151:  CALL   29B
1152:  BSF    0A.4
1153:  BCF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1178:  BSF    03.5
1179:  MOVF   6C,F
117A:  BTFSS  03.2
117B:  GOTO   243
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
117C:  BCF    0A.4
117D:  BSF    0A.3
117E:  BCF    03.5
117F:  CALL   2E6
1180:  BSF    0A.4
1181:  BCF    0A.3
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
1182:  BSF    03.5
1183:  BSF    06.4
1184:  BCF    03.5
1185:  BTFSC  06.4
1186:  GOTO   1F1
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1187:  MOVLW  02
1188:  BSF    03.5
1189:  MOVWF  6D
118A:  MOVLW  FA
118B:  BCF    03.5
118C:  BSF    03.6
118D:  MOVWF  22
118E:  BCF    0A.4
118F:  BCF    03.6
1190:  CALL   58A
1191:  BSF    0A.4
1192:  BSF    03.5
1193:  DECFSZ 6D,F
1194:  GOTO   18A
....................          BEEP; 
1195:  MOVLW  04
1196:  BCF    03.5
1197:  BSF    03.6
1198:  MOVWF  11
1199:  MOVLW  B9
119A:  MOVWF  10
119B:  CLRF   13
119C:  MOVLW  14
119D:  MOVWF  12
119E:  BCF    0A.4
119F:  BSF    0A.3
11A0:  BCF    03.6
11A1:  CALL   560
11A2:  BSF    0A.4
11A3:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
11A4:  BSF    03.5
11A5:  INCF   6B,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
11A6:  MOVF   6B,W
11A7:  SUBWF  67,W
11A8:  BTFSS  03.0
....................             optSelected = 0; 
11A9:  CLRF   6B
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
11AA:  SWAPF  6B,W
11AB:  MOVWF  77
11AC:  MOVLW  F0
11AD:  ANDWF  77,F
11AE:  MOVF   77,W
11AF:  MOVWF  6D
11B0:  MOVLW  0C
11B1:  BCF    03.5
11B2:  BSF    03.6
11B3:  MOVWF  13
11B4:  BCF    0A.4
11B5:  BSF    0A.3
11B6:  BCF    03.6
11B7:  CALL   000
11B8:  BSF    0A.4
11B9:  BCF    0A.3
11BA:  MOVLW  D5
11BB:  BSF    03.6
11BC:  MOVWF  0D
11BD:  MOVLW  01
11BE:  MOVWF  0F
11BF:  BSF    03.5
11C0:  BCF    03.6
11C1:  MOVF   6D,W
11C2:  BCF    03.5
11C3:  BSF    03.6
11C4:  ADDWF  0D,F
11C5:  BTFSC  03.0
11C6:  INCF   0F,F
11C7:  BCF    0A.4
11C8:  BSF    0A.3
11C9:  BCF    03.6
11CA:  CALL   29B
11CB:  BSF    0A.4
11CC:  BCF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
11F1:  BSF    03.5
11F2:  BSF    06.5
11F3:  BCF    03.5
11F4:  BTFSC  06.5
11F5:  GOTO   241
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
11F6:  MOVLW  02
11F7:  BSF    03.5
11F8:  MOVWF  6D
11F9:  MOVLW  FA
11FA:  BCF    03.5
11FB:  BSF    03.6
11FC:  MOVWF  22
11FD:  BCF    0A.4
11FE:  BCF    03.6
11FF:  CALL   58A
1200:  BSF    0A.4
1201:  BSF    03.5
1202:  DECFSZ 6D,F
1203:  GOTO   1F9
....................          BEEP; 
1204:  MOVLW  04
1205:  BCF    03.5
1206:  BSF    03.6
1207:  MOVWF  11
1208:  MOVLW  B9
1209:  MOVWF  10
120A:  CLRF   13
120B:  MOVLW  14
120C:  MOVWF  12
120D:  BCF    0A.4
120E:  BSF    0A.3
120F:  BCF    03.6
1210:  CALL   560
1211:  BSF    0A.4
1212:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
1213:  BSF    03.5
1214:  MOVF   67,W
1215:  SUBWF  6B,W
1216:  BTFSS  03.2
1217:  GOTO   21B
....................             exit = 1; 
1218:  MOVLW  01
1219:  MOVWF  6C
....................          }else{ 
121A:  GOTO   242
....................             output_low(PIN_OUT[optSelected]); 
121B:  BCF    03.0
121C:  RLF    6B,W
121D:  ADDLW  2B
121E:  MOVWF  04
121F:  BCF    03.7
1220:  INCF   04,F
1221:  MOVF   00,W
1222:  MOVWF  6E
1223:  DECF   04,F
1224:  MOVF   00,W
1225:  MOVWF  6D
1226:  BCF    03.5
1227:  BSF    03.6
1228:  MOVWF  23
1229:  CLRF   24
122A:  CLRF   26
122B:  CLRF   25
122C:  BCF    0A.4
122D:  BSF    0A.3
122E:  BCF    03.6
122F:  CALL   2C4
1230:  BSF    0A.4
1231:  BCF    0A.3
1232:  BSF    03.5
1233:  MOVF   6D,W
1234:  BCF    03.5
1235:  BSF    03.6
1236:  MOVWF  23
1237:  CLRF   24
1238:  CLRF   26
1239:  MOVLW  80
123A:  MOVWF  25
123B:  BCF    0A.4
123C:  BSF    0A.3
123D:  BCF    03.6
123E:  CALL   2C4
123F:  BSF    0A.4
1240:  BCF    0A.3
1241:  BSF    03.5
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
1242:  GOTO   179
....................    } // FIN While Infinito 
....................  
....................    return 0; 
1243:  MOVLW  00
1244:  MOVWF  78
1245:  BCF    03.5
1246:  BCF    0A.3
1247:  BSF    0A.4
1248:  GOTO   755 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
....................  
....................    /******************************************** 
....................    *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................    *********************************************/ 
....................    run_command_wifi(); 
*
1529:  BCF    0A.4
152A:  BSF    0A.3
152B:  CALL   2E6
152C:  BSF    0A.4
152D:  BCF    0A.3
....................    /********************************************/ 
....................     
....................    int optSelected = 0; 
....................    int exit = 0; 
152E:  BSF    03.5
152F:  CLRF   6B
1530:  CLRF   6C
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
1531:  MOVF   6B,W
1532:  BCF    03.5
1533:  BSF    03.6
1534:  MOVWF  10
1535:  MOVLW  11
1536:  MOVWF  11
1537:  BCF    0A.4
1538:  BSF    0A.3
1539:  BCF    03.6
153A:  CALL   781
153B:  BSF    0A.4
153C:  BCF    0A.3
153D:  MOVF   78,W
153E:  BSF    03.5
153F:  MOVWF  6D
1540:  MOVLW  0C
1541:  BCF    03.5
1542:  BSF    03.6
1543:  MOVWF  13
1544:  BCF    0A.4
1545:  BSF    0A.3
1546:  BCF    03.6
1547:  CALL   000
1548:  BSF    0A.4
1549:  BCF    0A.3
154A:  MOVLW  75
154B:  BSF    03.6
154C:  MOVWF  0D
154D:  MOVLW  02
154E:  MOVWF  0F
154F:  BSF    03.5
1550:  BCF    03.6
1551:  MOVF   6D,W
1552:  BCF    03.5
1553:  BSF    03.6
1554:  ADDWF  0D,F
1555:  BTFSC  03.0
1556:  INCF   0F,F
1557:  BCF    0A.4
1558:  BSF    0A.3
1559:  BCF    03.6
155A:  CALL   29B
155B:  BSF    0A.4
155C:  BCF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1581:  BSF    03.5
1582:  MOVF   6C,F
1583:  BTFSS  03.2
1584:  GOTO   67D
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
1585:  BSF    06.4
1586:  BCF    03.5
1587:  BTFSC  06.4
1588:  GOTO   5FC
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1589:  MOVLW  02
158A:  BSF    03.5
158B:  MOVWF  6D
158C:  MOVLW  FA
158D:  BCF    03.5
158E:  BSF    03.6
158F:  MOVWF  22
1590:  BCF    0A.4
1591:  BCF    03.6
1592:  CALL   58A
1593:  BSF    0A.4
1594:  BSF    03.5
1595:  DECFSZ 6D,F
1596:  GOTO   58C
....................          BEEP; 
1597:  MOVLW  04
1598:  BCF    03.5
1599:  BSF    03.6
159A:  MOVWF  11
159B:  MOVLW  B9
159C:  MOVWF  10
159D:  CLRF   13
159E:  MOVLW  14
159F:  MOVWF  12
15A0:  BCF    0A.4
15A1:  BSF    0A.3
15A2:  BCF    03.6
15A3:  CALL   560
15A4:  BSF    0A.4
15A5:  BCF    0A.3
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
15A6:  BSF    03.5
15A7:  INCF   6B,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
15A8:  MOVF   6B,W
15A9:  SUBWF  68,W
15AA:  BTFSS  03.0
....................             optSelected = 0; 
15AB:  CLRF   6B
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
15AC:  MOVF   6B,W
15AD:  BCF    03.5
15AE:  BSF    03.6
15AF:  MOVWF  10
15B0:  MOVLW  11
15B1:  MOVWF  11
15B2:  BCF    0A.4
15B3:  BSF    0A.3
15B4:  BCF    03.6
15B5:  CALL   781
15B6:  BSF    0A.4
15B7:  BCF    0A.3
15B8:  MOVF   78,W
15B9:  BSF    03.5
15BA:  MOVWF  6D
15BB:  MOVLW  0C
15BC:  BCF    03.5
15BD:  BSF    03.6
15BE:  MOVWF  13
15BF:  BCF    0A.4
15C0:  BSF    0A.3
15C1:  BCF    03.6
15C2:  CALL   000
15C3:  BSF    0A.4
15C4:  BCF    0A.3
15C5:  MOVLW  75
15C6:  BSF    03.6
15C7:  MOVWF  0D
15C8:  MOVLW  02
15C9:  MOVWF  0F
15CA:  BSF    03.5
15CB:  BCF    03.6
15CC:  MOVF   6D,W
15CD:  BCF    03.5
15CE:  BSF    03.6
15CF:  ADDWF  0D,F
15D0:  BTFSC  03.0
15D1:  INCF   0F,F
15D2:  BCF    0A.4
15D3:  BSF    0A.3
15D4:  BCF    03.6
15D5:  CALL   29B
15D6:  BSF    0A.4
15D7:  BCF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
15FC:  BSF    03.5
15FD:  BSF    06.5
15FE:  BCF    03.5
15FF:  BTFSC  06.5
1600:  GOTO   67B
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1601:  MOVLW  02
1602:  BSF    03.5
1603:  MOVWF  6D
1604:  MOVLW  FA
1605:  BCF    03.5
1606:  BSF    03.6
1607:  MOVWF  22
1608:  BCF    0A.4
1609:  BCF    03.6
160A:  CALL   58A
160B:  BSF    0A.4
160C:  BSF    03.5
160D:  DECFSZ 6D,F
160E:  GOTO   604
....................          BEEP; 
160F:  MOVLW  04
1610:  BCF    03.5
1611:  BSF    03.6
1612:  MOVWF  11
1613:  MOVLW  B9
1614:  MOVWF  10
1615:  CLRF   13
1616:  MOVLW  14
1617:  MOVWF  12
1618:  BCF    0A.4
1619:  BSF    0A.3
161A:  BCF    03.6
161B:  CALL   560
161C:  BSF    0A.4
161D:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
161E:  BSF    03.5
161F:  MOVF   68,W
1620:  SUBWF  6B,W
1621:  BTFSS  03.2
1622:  GOTO   626
....................             exit = 1; 
1623:  MOVLW  01
1624:  MOVWF  6C
....................          }else{ 
1625:  GOTO   67C
....................             executeSetup(optSelected); 
1626:  MOVF   6B,W
1627:  MOVWF  6D
1628:  BCF    03.5
1629:  GOTO   249
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
162A:  BSF    03.5
162B:  MOVF   6B,W
162C:  BCF    03.5
162D:  BSF    03.6
162E:  MOVWF  10
162F:  MOVLW  11
1630:  MOVWF  11
1631:  BCF    0A.4
1632:  BSF    0A.3
1633:  BCF    03.6
1634:  CALL   781
1635:  BSF    0A.4
1636:  BCF    0A.3
1637:  MOVF   78,W
1638:  BSF    03.5
1639:  MOVWF  6D
163A:  MOVLW  0C
163B:  BCF    03.5
163C:  BSF    03.6
163D:  MOVWF  13
163E:  BCF    0A.4
163F:  BSF    0A.3
1640:  BCF    03.6
1641:  CALL   000
1642:  BSF    0A.4
1643:  BCF    0A.3
1644:  MOVLW  75
1645:  BSF    03.6
1646:  MOVWF  0D
1647:  MOVLW  02
1648:  MOVWF  0F
1649:  BSF    03.5
164A:  BCF    03.6
164B:  MOVF   6D,W
164C:  BCF    03.5
164D:  BSF    03.6
164E:  ADDWF  0D,F
164F:  BTFSC  03.0
1650:  INCF   0F,F
1651:  BCF    0A.4
1652:  BSF    0A.3
1653:  BCF    03.6
1654:  CALL   29B
1655:  BSF    0A.4
1656:  BCF    0A.3
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
167C:  GOTO   582
....................    } // FIN While Infinito 
....................  
....................    return 0; 
167D:  MOVLW  00
167E:  MOVWF  78
167F:  BCF    03.5
1680:  BCF    0A.3
1681:  BSF    0A.4
1682:  GOTO   75A (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................    
....................   switch(optSelect){ 
*
1249:  BSF    03.5
124A:  MOVF   6D,W
124B:  ADDLW  F8
124C:  BTFSC  03.0
124D:  GOTO   4D4
124E:  ADDLW  08
124F:  BCF    03.5
1250:  GOTO   51D
....................       
....................      case OPT_SHOW_STA_IP: 
....................         printf(lcd_putc, "\fOPT_SHOW_STA_IP"); 
1251:  MOVLW  60
1252:  BSF    03.6
1253:  MOVWF  0D
1254:  MOVLW  03
1255:  MOVWF  0F
1256:  BCF    0A.4
1257:  BSF    0A.3
1258:  BCF    03.6
1259:  CALL   066
125A:  BSF    0A.4
125B:  BCF    0A.3
....................         break; 
125C:  BSF    03.5
125D:  GOTO   4D4
....................          
....................      case OPT_SHOW_STA_SSID: 
....................         printf(lcd_putc, "\fOPT_SHOW_STA_SSID"); 
125E:  MOVLW  69
125F:  BSF    03.6
1260:  MOVWF  0D
1261:  MOVLW  03
1262:  MOVWF  0F
1263:  BCF    0A.4
1264:  BSF    0A.3
1265:  BCF    03.6
1266:  CALL   066
1267:  BSF    0A.4
1268:  BCF    0A.3
....................         break; 
1269:  BSF    03.5
126A:  GOTO   4D4
....................          
....................      case OPT_SHOW_AP_SSID: 
....................         printf(lcd_putc, "\fOPT_SHOW_AP_SSID"); 
126B:  MOVLW  73
126C:  BSF    03.6
126D:  MOVWF  0D
126E:  MOVLW  03
126F:  MOVWF  0F
1270:  BCF    0A.4
1271:  BSF    0A.3
1272:  BCF    03.6
1273:  CALL   066
1274:  BSF    0A.4
1275:  BCF    0A.3
....................         break; 
1276:  BSF    03.5
1277:  GOTO   4D4
....................          
....................      case OPT_SHOW_AP_KEY: 
....................         printf(lcd_putc, "\fOPT_SHOW_AP_KEY"); 
1278:  MOVLW  7C
1279:  BSF    03.6
127A:  MOVWF  0D
127B:  MOVLW  03
127C:  MOVWF  0F
127D:  BCF    0A.4
127E:  BSF    0A.3
127F:  BCF    03.6
1280:  CALL   066
1281:  BSF    0A.4
1282:  BCF    0A.3
....................         break; 
1283:  BSF    03.5
1284:  GOTO   4D4
....................          
....................      case OPT_SHOW_AP_IP: 
....................         printf(lcd_putc, "\fOPT_SHOW_AP_IP"); 
1285:  MOVLW  85
1286:  BSF    03.6
1287:  MOVWF  0D
1288:  MOVLW  03
1289:  MOVWF  0F
128A:  BCF    0A.4
128B:  BSF    0A.3
128C:  BCF    03.6
128D:  CALL   066
128E:  BSF    0A.4
128F:  BCF    0A.3
....................         break; 
1290:  BSF    03.5
1291:  GOTO   4D4
....................          
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
....................         break; 
*
14B0:  GOTO   4D4
....................          
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
14B1:  BSF    03.5
14B2:  BCF    08.3
14B3:  MOVLW  08
14B4:  BCF    03.5
14B5:  XORWF  08,F
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
14B6:  BTFSS  08.3
14B7:  GOTO   4C4
....................            printf(lcd_putc, "\fBacklight On"); 
14B8:  MOVLW  8D
14B9:  BSF    03.6
14BA:  MOVWF  0D
14BB:  MOVLW  03
14BC:  MOVWF  0F
14BD:  BCF    0A.4
14BE:  BSF    0A.3
14BF:  BCF    03.6
14C0:  CALL   066
14C1:  BSF    0A.4
14C2:  BCF    0A.3
....................         }else{ 
14C3:  GOTO   4CF
....................            printf(lcd_putc, "\fBacklight Off"); 
14C4:  MOVLW  94
14C5:  BSF    03.6
14C6:  MOVWF  0D
14C7:  MOVLW  03
14C8:  MOVWF  0F
14C9:  BCF    0A.4
14CA:  BSF    0A.3
14CB:  BCF    03.6
14CC:  CALL   066
14CD:  BSF    0A.4
14CE:  BCF    0A.3
....................         } 
....................         break; 
14CF:  BSF    03.5
14D0:  GOTO   4D4
....................          
....................      case OPT_EXIT: 
....................         break; 
14D1:  BSF    03.5
14D2:  GOTO   4D4
14D3:  BSF    03.5
....................          
....................   } 
....................    
....................   if(optSelect!=OPT_EXIT){ 
14D4:  MOVF   6D,W
14D5:  SUBLW  07
14D6:  BTFSC  03.2
14D7:  GOTO   519
....................    pressExit(); 
....................   } 
*
1519:  BCF    03.5
151A:  BCF    0A.3
151B:  BSF    0A.4
151C:  GOTO   62A (RETURN)
.................... } 
....................    
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
*
1292:  BSF    03.5
1293:  CLRF   6E
1294:  CLRF   6F
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
1295:  MOVF   6E,W
1296:  BCF    03.5
1297:  BSF    03.6
1298:  MOVWF  10
1299:  MOVLW  0E
129A:  MOVWF  11
129B:  BCF    0A.4
129C:  BSF    0A.3
129D:  BCF    03.6
129E:  CALL   781
129F:  BSF    0A.4
12A0:  BCF    0A.3
12A1:  MOVF   78,W
12A2:  BSF    03.6
12A3:  MOVWF  10
12A4:  MOVLW  0C
12A5:  MOVWF  13
12A6:  BCF    0A.4
12A7:  BSF    0A.3
12A8:  BCF    03.6
12A9:  CALL   000
12AA:  BSF    0A.4
12AB:  BCF    0A.3
12AC:  MOVLW  0E
12AD:  BSF    03.6
12AE:  MOVWF  0D
12AF:  MOVLW  03
12B0:  MOVWF  0F
12B1:  MOVF   10,W
12B2:  ADDWF  0D,F
12B3:  BTFSC  03.0
12B4:  INCF   0F,F
12B5:  BCF    0A.4
12B6:  BSF    0A.3
12B7:  BCF    03.6
12B8:  CALL   29B
12B9:  BSF    0A.4
12BA:  BCF    0A.3
....................   showBottonMenu(); 
....................    
....................   while(!exit){ 
*
12DF:  BSF    03.5
12E0:  MOVF   6F,F
12E1:  BTFSS  03.2
12E2:  GOTO   4B0
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
12E3:  BCF    0A.4
12E4:  BSF    0A.3
12E5:  BCF    03.5
12E6:  CALL   2E6
12E7:  BSF    0A.4
12E8:  BCF    0A.3
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
12E9:  BSF    03.5
12EA:  BSF    06.4
12EB:  BCF    03.5
12EC:  BTFSC  06.4
12ED:  GOTO   357
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
12EE:  MOVLW  02
12EF:  BSF    03.6
12F0:  MOVWF  10
12F1:  MOVLW  FA
12F2:  MOVWF  22
12F3:  BCF    0A.4
12F4:  BCF    03.6
12F5:  CALL   58A
12F6:  BSF    0A.4
12F7:  BSF    03.6
12F8:  DECFSZ 10,F
12F9:  GOTO   2F1
....................         BEEP; 
12FA:  MOVLW  04
12FB:  MOVWF  11
12FC:  MOVLW  B9
12FD:  MOVWF  10
12FE:  CLRF   13
12FF:  MOVLW  14
1300:  MOVWF  12
1301:  BCF    0A.4
1302:  BSF    0A.3
1303:  BCF    03.6
1304:  CALL   560
1305:  BSF    0A.4
1306:  BCF    0A.3
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
1307:  BSF    03.5
1308:  INCF   6E,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
1309:  MOVF   6E,W
130A:  SUBWF  69,W
130B:  BTFSS  03.0
....................            optSelected = 0; 
130C:  CLRF   6E
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
130D:  MOVF   6E,W
130E:  BCF    03.5
130F:  BSF    03.6
1310:  MOVWF  10
1311:  MOVLW  0E
1312:  MOVWF  11
1313:  BCF    0A.4
1314:  BSF    0A.3
1315:  BCF    03.6
1316:  CALL   781
1317:  BSF    0A.4
1318:  BCF    0A.3
1319:  MOVF   78,W
131A:  BSF    03.6
131B:  MOVWF  10
131C:  MOVLW  0C
131D:  MOVWF  13
131E:  BCF    0A.4
131F:  BSF    0A.3
1320:  BCF    03.6
1321:  CALL   000
1322:  BSF    0A.4
1323:  BCF    0A.3
1324:  MOVLW  0E
1325:  BSF    03.6
1326:  MOVWF  0D
1327:  MOVLW  03
1328:  MOVWF  0F
1329:  MOVF   10,W
132A:  ADDWF  0D,F
132B:  BTFSC  03.0
132C:  INCF   0F,F
132D:  BCF    0A.4
132E:  BSF    0A.3
132F:  BCF    03.6
1330:  CALL   29B
1331:  BSF    0A.4
1332:  BCF    0A.3
....................         showBottonMenu(); 
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
*
1357:  BSF    03.5
1358:  BSF    06.5
1359:  BCF    03.5
135A:  BTFSC  06.5
135B:  GOTO   4AE
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
135C:  MOVLW  02
135D:  BSF    03.6
135E:  MOVWF  10
135F:  MOVLW  FA
1360:  MOVWF  22
1361:  BCF    0A.4
1362:  BCF    03.6
1363:  CALL   58A
1364:  BSF    0A.4
1365:  BSF    03.6
1366:  DECFSZ 10,F
1367:  GOTO   35F
....................         BEEP; 
1368:  MOVLW  04
1369:  MOVWF  11
136A:  MOVLW  B9
136B:  MOVWF  10
136C:  CLRF   13
136D:  MOVLW  14
136E:  MOVWF  12
136F:  BCF    0A.4
1370:  BSF    0A.3
1371:  BCF    03.6
1372:  CALL   560
1373:  BSF    0A.4
1374:  BCF    0A.3
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
1375:  BSF    03.5
1376:  MOVF   69,W
1377:  SUBWF  6E,W
1378:  BTFSS  03.2
1379:  GOTO   37D
....................            exit = 1; 
137A:  MOVLW  01
137B:  MOVWF  6F
....................         }else{ 
137C:  GOTO   4AF
....................            switch(optSelected){ 
137D:  MOVF   6E,W
137E:  XORLW  00
137F:  BCF    03.5
1380:  BTFSC  03.2
1381:  GOTO   389
1382:  XORLW  01
1383:  BTFSC  03.2
1384:  GOTO   3BD
1385:  XORLW  03
1386:  BTFSC  03.2
1387:  GOTO   3F1
1388:  GOTO   424
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
1389:  MOVLW  9C
138A:  BSF    03.6
138B:  MOVWF  0D
138C:  MOVLW  03
138D:  MOVWF  0F
138E:  BCF    0A.4
138F:  BSF    0A.3
1390:  BCF    03.6
1391:  CALL   10C
1392:  BSF    0A.4
1393:  BCF    0A.3
....................                  write_eeprom(0,'1'); 
1394:  MOVF   0B,W
1395:  MOVWF  77
1396:  BCF    0B.7
1397:  BSF    03.6
1398:  CLRF   0D
1399:  MOVLW  31
139A:  MOVWF  0C
139B:  BSF    03.5
139C:  BCF    0C.7
139D:  BSF    0C.2
139E:  MOVLW  55
139F:  MOVWF  0D
13A0:  MOVLW  AA
13A1:  MOVWF  0D
13A2:  BSF    0C.1
13A3:  BTFSC  0C.1
13A4:  GOTO   3A3
13A5:  BCF    0C.2
13A6:  MOVF   77,W
13A7:  BCF    03.5
13A8:  BCF    03.6
13A9:  IORWF  0B,F
....................                  delay_ms(10); 
13AA:  MOVLW  0A
13AB:  BSF    03.6
13AC:  MOVWF  22
13AD:  BCF    0A.4
13AE:  BCF    03.6
13AF:  CALL   58A
13B0:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig Cliente"); 
13B1:  MOVLW  A5
13B2:  BSF    03.6
13B3:  MOVWF  0D
13B4:  MOVLW  03
13B5:  MOVWF  0F
13B6:  BCF    0A.4
13B7:  BSF    0A.3
13B8:  BCF    03.6
13B9:  CALL   066
13BA:  BSF    0A.4
13BB:  BCF    0A.3
....................                  break; 
13BC:  GOTO   424
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
13BD:  MOVLW  AD
13BE:  BSF    03.6
13BF:  MOVWF  0D
13C0:  MOVLW  03
13C1:  MOVWF  0F
13C2:  BCF    0A.4
13C3:  BSF    0A.3
13C4:  BCF    03.6
13C5:  CALL   10C
13C6:  BSF    0A.4
13C7:  BCF    0A.3
....................                  write_eeprom(0,'2'); 
13C8:  MOVF   0B,W
13C9:  MOVWF  77
13CA:  BCF    0B.7
13CB:  BSF    03.6
13CC:  CLRF   0D
13CD:  MOVLW  32
13CE:  MOVWF  0C
13CF:  BSF    03.5
13D0:  BCF    0C.7
13D1:  BSF    0C.2
13D2:  MOVLW  55
13D3:  MOVWF  0D
13D4:  MOVLW  AA
13D5:  MOVWF  0D
13D6:  BSF    0C.1
13D7:  BTFSC  0C.1
13D8:  GOTO   3D7
13D9:  BCF    0C.2
13DA:  MOVF   77,W
13DB:  BCF    03.5
13DC:  BCF    03.6
13DD:  IORWF  0B,F
....................                  delay_ms(10); 
13DE:  MOVLW  0A
13DF:  BSF    03.6
13E0:  MOVWF  22
13E1:  BCF    0A.4
13E2:  BCF    03.6
13E3:  CALL   58A
13E4:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig AP"); 
13E5:  MOVLW  B6
13E6:  BSF    03.6
13E7:  MOVWF  0D
13E8:  MOVLW  03
13E9:  MOVWF  0F
13EA:  BCF    0A.4
13EB:  BSF    0A.3
13EC:  BCF    03.6
13ED:  CALL   066
13EE:  BSF    0A.4
13EF:  BCF    0A.3
....................                  break; 
13F0:  GOTO   424
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
13F1:  MOVLW  BC
13F2:  BSF    03.6
13F3:  MOVWF  0D
13F4:  MOVLW  03
13F5:  MOVWF  0F
13F6:  BCF    0A.4
13F7:  BSF    0A.3
13F8:  BCF    03.6
13F9:  CALL   10C
13FA:  BSF    0A.4
13FB:  BCF    0A.3
....................                  write_eeprom(0,'3'); 
13FC:  MOVF   0B,W
13FD:  MOVWF  77
13FE:  BCF    0B.7
13FF:  BSF    03.6
1400:  CLRF   0D
1401:  MOVLW  33
1402:  MOVWF  0C
1403:  BSF    03.5
1404:  BCF    0C.7
1405:  BSF    0C.2
1406:  MOVLW  55
1407:  MOVWF  0D
1408:  MOVLW  AA
1409:  MOVWF  0D
140A:  BSF    0C.1
140B:  BTFSC  0C.1
140C:  GOTO   40B
140D:  BCF    0C.2
140E:  MOVF   77,W
140F:  BCF    03.5
1410:  BCF    03.6
1411:  IORWF  0B,F
....................                  delay_ms(10); 
1412:  MOVLW  0A
1413:  BSF    03.6
1414:  MOVWF  22
1415:  BCF    0A.4
1416:  BCF    03.6
1417:  CALL   58A
1418:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
1419:  MOVLW  C5
141A:  BSF    03.6
141B:  MOVWF  0D
141C:  MOVLW  03
141D:  MOVWF  0F
141E:  BCF    0A.4
141F:  BSF    0A.3
1420:  BCF    03.6
1421:  CALL   066
1422:  BSF    0A.4
1423:  BCF    0A.3
....................                  break; 
....................            } 
....................            pressExit(); 
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
*
1462:  BSF    03.5
1463:  BCF    03.6
1464:  MOVF   6E,W
1465:  BCF    03.5
1466:  BSF    03.6
1467:  MOVWF  10
1468:  MOVLW  0E
1469:  MOVWF  11
146A:  BCF    0A.4
146B:  BSF    0A.3
146C:  BCF    03.6
146D:  CALL   781
146E:  BSF    0A.4
146F:  BCF    0A.3
1470:  MOVF   78,W
1471:  BSF    03.6
1472:  MOVWF  10
1473:  MOVLW  0C
1474:  MOVWF  13
1475:  BCF    0A.4
1476:  BSF    0A.3
1477:  BCF    03.6
1478:  CALL   000
1479:  BSF    0A.4
147A:  BCF    0A.3
147B:  MOVLW  0E
147C:  BSF    03.6
147D:  MOVWF  0D
147E:  MOVLW  03
147F:  MOVWF  0F
1480:  MOVF   10,W
1481:  ADDWF  0D,F
1482:  BTFSC  03.0
1483:  INCF   0F,F
1484:  BCF    0A.4
1485:  BSF    0A.3
1486:  BCF    03.6
1487:  CALL   29B
1488:  BSF    0A.4
1489:  BCF    0A.3
....................            showBottonMenu(); 
....................         } 
....................      } // Fin KEY_OK 
*
14AF:  GOTO   2E0
....................   } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
.................... #ZERO_RAM 
.................... /******************************************** 
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
03F3:  BTFSS  0C.5
03F4:  GOTO   3F3
03F5:  MOVF   1A,W
03F6:  BSF    03.6
03F7:  MOVWF  2C
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
03F8:  MOVF   2C,W
03F9:  MOVWF  2D
*
057D:  BCF    0C.5
057E:  BCF    0A.3
057F:  BCF    0A.4
0580:  GOTO   02D
.................... } 
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
*
1683:  MOVF   03,W
1684:  ANDLW  1F
1685:  MOVWF  03
1686:  MOVLW  57
1687:  MOVWF  77
1688:  MOVLW  20
1689:  MOVWF  04
168A:  BCF    03.7
168B:  CLRF   00
168C:  INCF   04,F
168D:  DECFSZ 77,F
168E:  GOTO   68B
168F:  CLRF   78
1690:  CLRF   79
1691:  CLRF   7A
1692:  CLRF   7B
1693:  CLRF   7C
1694:  CLRF   7D
1695:  CLRF   7E
1696:  MOVLW  50
1697:  MOVWF  77
1698:  MOVLW  A0
1699:  MOVWF  04
169A:  BCF    03.7
169B:  CLRF   00
169C:  INCF   04,F
169D:  DECFSZ 77,F
169E:  GOTO   69B
169F:  MOVLW  60
16A0:  MOVWF  77
16A1:  MOVLW  10
16A2:  MOVWF  04
16A3:  BSF    03.7
16A4:  CLRF   00
16A5:  INCF   04,F
16A6:  DECFSZ 77,F
16A7:  GOTO   6A4
16A8:  BCF    03.7
16A9:  MOVLW  60
16AA:  MOVWF  77
16AB:  MOVLW  90
16AC:  MOVWF  04
16AD:  BSF    03.7
16AE:  CLRF   00
16AF:  INCF   04,F
16B0:  DECFSZ 77,F
16B1:  GOTO   6AE
16B2:  BCF    03.7
16B3:  CLRF   20
16B4:  BSF    03.5
16B5:  BSF    03.6
16B6:  BSF    07.3
16B7:  MOVLW  08
16B8:  BCF    03.6
16B9:  MOVWF  19
16BA:  MOVLW  02
16BB:  MOVWF  1A
16BC:  MOVLW  A6
16BD:  MOVWF  18
16BE:  MOVLW  90
16BF:  BCF    03.5
16C0:  MOVWF  18
16C1:  BSF    03.5
16C2:  BCF    06.0
16C3:  BCF    03.5
16C4:  BSF    06.0
16C5:  CLRF   7C
16C6:  CLRF   7B
16C7:  CLRF   7D
16C8:  CLRF   7E
16C9:  BSF    03.5
16CA:  CLRF   20
16CB:  CLRF   21
16CC:  CLRF   22
16CD:  CLRF   23
16CE:  CLRF   24
16CF:  CLRF   25
16D0:  CLRF   26
16D1:  CLRF   27
16D2:  CLRF   28
16D3:  CLRF   29
16D4:  CLRF   2A
16D5:  CLRF   2B
16D6:  CLRF   2C
16D7:  CLRF   2D
16D8:  CLRF   2E
16D9:  CLRF   2F
16DA:  CLRF   30
16DB:  CLRF   31
16DC:  MOVLW  02
16DD:  MOVWF  65
16DE:  MOVLW  08
16DF:  MOVWF  66
16E0:  MOVWF  67
16E1:  MOVLW  07
16E2:  MOVWF  68
16E3:  MOVLW  03
16E4:  MOVWF  69
16E5:  CLRF   6A
16E6:  BSF    03.6
16E7:  MOVF   09,W
16E8:  ANDLW  C0
16E9:  MOVWF  09
16EA:  BCF    03.6
16EB:  BCF    1F.4
16EC:  BCF    1F.5
16ED:  MOVLW  00
16EE:  BSF    03.6
16EF:  MOVWF  08
16F0:  BCF    03.5
16F1:  CLRF   07
16F2:  CLRF   08
16F3:  CLRF   09
16F4:  BCF    03.7
....................    {       
....................       /*for(int idxNC=0;idxNC<=255;idxNC++){ 
....................          write_eeprom(idxNC,0xFF); 
....................          delay_ms(10); 
....................       }*/ 
....................           
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
*
1710:  MOVLW  02
1711:  BSF    03.5
1712:  MOVWF  6B
1713:  MOVLW  FA
1714:  BCF    03.5
1715:  BSF    03.6
1716:  MOVWF  22
1717:  BCF    0A.4
1718:  BCF    03.6
1719:  CALL   58A
171A:  BSF    0A.4
171B:  BSF    03.5
171C:  DECFSZ 6B,F
171D:  GOTO   713
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
171E:  MOVLW  30
171F:  MOVWF  15
1720:  BCF    01.7
....................       set_tris_b(0b00110010); 
1721:  MOVLW  32
1722:  MOVWF  06
....................       enable_interrupts(INT_RDA);  
1723:  BSF    0C.5
....................       enable_interrupts(GLOBAL);  
1724:  MOVLW  C0
1725:  BCF    03.5
1726:  IORWF  0B,F
....................  
....................       // Inicializa la LCD 
....................       lcd_init(); 
1727:  BCF    0A.4
1728:  GOTO   6F0
1729:  BSF    0A.4
....................       printf(lcd_putc, "\fConfigurando..."); 
172A:  MOVLW  81
172B:  BSF    03.6
172C:  MOVWF  0D
172D:  MOVLW  05
172E:  MOVWF  0F
172F:  BCF    0A.4
1730:  BSF    0A.3
1731:  BCF    03.6
1732:  CALL   066
1733:  BSF    0A.4
1734:  BCF    0A.3
....................        
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
1735:  BSF    03.5
1736:  BCF    08.3
1737:  BCF    03.5
1738:  BSF    08.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
1739:  BCF    0A.4
173A:  BSF    0A.3
173B:  GOTO   15E
173C:  BSF    0A.4
173D:  BCF    0A.3
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
173E:  BSF    03.5
173F:  MOVF   6A,W
1740:  ADDLW  FC
1741:  BTFSC  03.0
1742:  GOTO   75F
1743:  ADDLW  04
1744:  BCF    03.5
1745:  GOTO   761
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
1746:  BCF    0A.4
1747:  BSF    0A.3
1748:  GOTO   6B3
1749:  BSF    0A.4
174A:  BCF    0A.3
174B:  MOVF   78,W
174C:  BSF    03.5
174D:  MOVWF  6A
....................                break; 
174E:  GOTO   75F
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
174F:  GOTO   000
1750:  MOVF   78,W
1751:  BSF    03.5
1752:  MOVWF  6A
....................                break; 
1753:  GOTO   75F
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
1754:  GOTO   12E
1755:  MOVF   78,W
1756:  BSF    03.5
1757:  MOVWF  6A
....................                break; 
1758:  GOTO   75F
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
1759:  GOTO   529
175A:  MOVF   78,W
175B:  BSF    03.5
175C:  MOVWF  6A
....................                break; 
175D:  GOTO   75F
175E:  BSF    03.5
....................          } // Fin del Switch(menuActive) 
175F:  GOTO   73F
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
1760:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
