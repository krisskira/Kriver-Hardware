CCS PCH C Compiler, Version 5.015, 5967               18-dic.-17 00:10

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   9262 bytes (14%)
                           Largest free fragment is 56270
               RAM used:   267 (7%) at main() level
                           317 (8%) worst case
               Stack used: 14 locations (10 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   229E
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  F9D.5
0004A:  GOTO   0054
0004E:  BTFSC  F9E.5
00050:  GOTO   0BB2
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... #include "header/config.h" 
.................... #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
00096:  CLRF   FF7
00098:  ADDLW  A6
0009A:  MOVWF  FF6
0009C:  MOVLW  00
0009E:  ADDWFC FF7,F
000A0:  TBLRD*+
000A2:  MOVF   FF5,W
000A4:  RETURN 0
000A6:  DATA 2B,49
000A8:  DATA 50,44
000AA:  DATA 2C,00
000AC:  CLRF   FF7
000AE:  ADDLW  BC
000B0:  MOVWF  FF6
000B2:  MOVLW  00
000B4:  ADDWFC FF7,F
000B6:  TBLRD*+
000B8:  MOVF   FF5,W
000BA:  RETURN 0
000BC:  DATA 43,4D
000BE:  DATA 44,3A
000C0:  CLRF   FF7
000C2:  ADDLW  D0
000C4:  MOVWF  FF6
000C6:  MOVLW  00
000C8:  ADDWFC FF7,F
000CA:  TBLRD*+
000CC:  MOVF   FF5,W
000CE:  RETURN 0
000D0:  DATA 4F,4B
000D2:  DATA 0D,0A
000D4:  DATA 00,00
000D6:  CLRF   FF7
000D8:  ADDLW  E6
000DA:  MOVWF  FF6
000DC:  MOVLW  00
000DE:  ADDWFC FF7,F
000E0:  TBLRD*+
000E2:  MOVF   FF5,W
000E4:  RETURN 0
000E6:  DATA 4E,6F
000E8:  DATA 20,41
000EA:  DATA 70,00
000EC:  CLRF   FF7
000EE:  ADDLW  FC
000F0:  MOVWF  FF6
000F2:  MOVLW  00
000F4:  ADDWFC FF7,F
000F6:  TBLRD*+
000F8:  MOVF   FF5,W
000FA:  RETURN 0
000FC:  DATA 2B,43
000FE:  DATA 57,4A
00100:  DATA 41,50
00102:  DATA 3A,00
00104:  CLRF   FF7
00106:  ADDLW  14
00108:  MOVWF  FF6
0010A:  MOVLW  01
0010C:  ADDWFC FF7,F
0010E:  TBLRD*+
00110:  MOVF   FF5,W
00112:  RETURN 0
00114:  DATA 43,4F
00116:  DATA 4E,4E
00118:  DATA 45,43
0011A:  DATA 54,45
0011C:  DATA 44,00
0011E:  CLRF   FF7
00120:  ADDLW  2E
00122:  MOVWF  FF6
00124:  MOVLW  01
00126:  ADDWFC FF7,F
00128:  TBLRD*+
0012A:  MOVF   FF5,W
0012C:  RETURN 0
0012E:  DATA 46,41
00130:  DATA 49,4C
00132:  DATA 00,00
00134:  DATA 41,54
00136:  DATA 2B,43
00138:  DATA 49,50
0013A:  DATA 53,45
0013C:  DATA 4E,44
0013E:  DATA 3D,25
00140:  DATA 63,2C
00142:  DATA 31,32
00144:  DATA 0D,0A
00146:  DATA 00,00
00148:  DATA 41,54
0014A:  DATA 2B,43
0014C:  DATA 49,50
0014E:  DATA 43,4C
00150:  DATA 4F,53
00152:  DATA 45,3D
00154:  DATA 25,63
00156:  DATA 0D,0A
00158:  DATA 00,00
0015A:  DATA 41,54
0015C:  DATA 2B,43
0015E:  DATA 57,51
00160:  DATA 41,50
00162:  DATA 0A,0D
00164:  DATA 00,00
00166:  DATA 41,54
00168:  DATA 2B,43
0016A:  DATA 49,50
0016C:  DATA 53,45
0016E:  DATA 4E,44
00170:  DATA 3D,25
00172:  DATA 63,2C
00174:  DATA 31,32
00176:  DATA 0D,0A
00178:  DATA 00,00
0017A:  DATA 41,54
0017C:  DATA 2B,43
0017E:  DATA 49,50
00180:  DATA 43,4C
00182:  DATA 4F,53
00184:  DATA 45,3D
00186:  DATA 25,63
00188:  DATA 0D,0A
0018A:  DATA 00,00
0018C:  DATA 41,54
0018E:  DATA 2B,43
00190:  DATA 57,53
00192:  DATA 41,50
00194:  DATA 5F,44
00196:  DATA 45,46
00198:  DATA 3D,25
0019A:  DATA 73,2C
0019C:  DATA 31,2C
0019E:  DATA 34,0D
001A0:  DATA 0A,00
001A2:  DATA 41,54
001A4:  DATA 2B,43
001A6:  DATA 49,50
001A8:  DATA 53,45
001AA:  DATA 4E,44
001AC:  DATA 3D,25
001AE:  DATA 63,2C
001B0:  DATA 31,32
001B2:  DATA 0D,0A
001B4:  DATA 00,00
001B6:  DATA 41,54
001B8:  DATA 2B,43
001BA:  DATA 49,50
001BC:  DATA 43,4C
001BE:  DATA 4F,53
001C0:  DATA 45,3D
001C2:  DATA 25,63
001C4:  DATA 0D,0A
001C6:  DATA 00,00
001C8:  DATA 41,54
001CA:  DATA 2B,43
001CC:  DATA 49,50
001CE:  DATA 53,45
001D0:  DATA 4E,44
001D2:  DATA 3D,25
001D4:  DATA 63,2C
001D6:  DATA 31,32
001D8:  DATA 0D,0A
001DA:  DATA 00,00
001DC:  DATA 41,54
001DE:  DATA 2B,43
001E0:  DATA 49,50
001E2:  DATA 43,4C
001E4:  DATA 4F,53
001E6:  DATA 45,3D
001E8:  DATA 25,63
001EA:  DATA 0D,0A
001EC:  DATA 00,00
001EE:  DATA 41,54
001F0:  DATA 2B,43
001F2:  DATA 57,4D
001F4:  DATA 4F,44
001F6:  DATA 45,3D
001F8:  DATA 25,63
001FA:  DATA 0D,0A
001FC:  DATA 00,00
001FE:  DATA 41,54
00200:  DATA 2B,43
00202:  DATA 57,4A
00204:  DATA 41,50
00206:  DATA 3F,0D
00208:  DATA 0A,00
0020A:  DATA 41,54
0020C:  DATA 2B,43
0020E:  DATA 57,4A
00210:  DATA 41,50
00212:  DATA 3D,25
00214:  DATA 73,00
00216:  DATA 41,54
00218:  DATA 2B,43
0021A:  DATA 57,4D
0021C:  DATA 4F,44
0021E:  DATA 45,3D
00220:  DATA 25,63
00222:  DATA 0D,0A
00224:  DATA 00,00
00226:  DATA 41,54
00228:  DATA 2B,43
0022A:  DATA 49,50
0022C:  DATA 4D,55
0022E:  DATA 58,3D
00230:  DATA 31,0D
00232:  DATA 0A,00
00234:  DATA 41,54
00236:  DATA 2B,43
00238:  DATA 49,50
0023A:  DATA 53,45
0023C:  DATA 52,56
0023E:  DATA 45,52
00240:  DATA 3D,31
00242:  DATA 2C,38
00244:  DATA 30,0D
00246:  DATA 0A,00
00248:  DATA 45,6E
0024A:  DATA 63,65
0024C:  DATA 6E,64
0024E:  DATA 65,72
00250:  DATA 20,4D
00252:  DATA 61,6E
00254:  DATA 75,61
00256:  DATA 6C,00
00258:  DATA 41,70
0025A:  DATA 61,67
0025C:  DATA 61,64
0025E:  DATA 6F,20
00260:  DATA 4D,61
00262:  DATA 6E,75
00264:  DATA 61,6C
00266:  DATA 20,00
00268:  DATA 43,6F
0026A:  DATA 6E,66
0026C:  DATA 69,67
0026E:  DATA 75,72
00270:  DATA 61,63
00272:  DATA 69,6F
00274:  DATA 6E,20
00276:  DATA 20,00
00278:  DATA 00,00
0027A:  DATA 00,00
0027C:  DATA 00,00
0027E:  DATA 00,00
00280:  DATA 00,00
00282:  DATA 00,00
00284:  DATA 00,00
00286:  DATA 00,00
00288:  DATA 4F,6E
0028A:  DATA 20,2D
0028C:  DATA 3E,20
0028E:  DATA 53,61
00290:  DATA 6C,69
00292:  DATA 64,61
00294:  DATA 20,31
00296:  DATA 00,4F
00298:  DATA 6E,20
0029A:  DATA 2D,3E
0029C:  DATA 20,53
0029E:  DATA 61,6C
002A0:  DATA 69,64
002A2:  DATA 61,20
002A4:  DATA 32,00
002A6:  DATA 4F,6E
002A8:  DATA 20,2D
002AA:  DATA 3E,20
002AC:  DATA 53,61
002AE:  DATA 6C,69
002B0:  DATA 64,61
002B2:  DATA 20,33
002B4:  DATA 00,4F
002B6:  DATA 6E,20
002B8:  DATA 2D,3E
002BA:  DATA 20,53
002BC:  DATA 61,6C
002BE:  DATA 69,64
002C0:  DATA 61,20
002C2:  DATA 34,00
002C4:  DATA 4F,6E
002C6:  DATA 20,2D
002C8:  DATA 3E,20
002CA:  DATA 53,61
002CC:  DATA 6C,69
002CE:  DATA 64,61
002D0:  DATA 20,35
002D2:  DATA 00,4F
002D4:  DATA 6E,20
002D6:  DATA 2D,3E
002D8:  DATA 20,53
002DA:  DATA 61,6C
002DC:  DATA 69,64
002DE:  DATA 61,20
002E0:  DATA 36,00
002E2:  DATA 4F,6E
002E4:  DATA 20,2D
002E6:  DATA 3E,20
002E8:  DATA 53,61
002EA:  DATA 6C,69
002EC:  DATA 64,61
002EE:  DATA 20,37
002F0:  DATA 00,4F
002F2:  DATA 6E,20
002F4:  DATA 2D,3E
002F6:  DATA 20,53
002F8:  DATA 61,6C
002FA:  DATA 69,64
002FC:  DATA 61,20
002FE:  DATA 38,00
00300:  DATA 53,41
00302:  DATA 4C,49
00304:  DATA 52,20
00306:  DATA 20,20
00308:  DATA 20,20
0030A:  DATA 20,20
0030C:  DATA 20,20
0030E:  DATA 00,00
00310:  DATA 00,00
00312:  DATA 00,00
00314:  DATA 00,00
00316:  DATA 00,00
00318:  DATA 00,00
0031A:  DATA 00,00
0031C:  DATA 00,00
0031E:  DATA 4F,66
00320:  DATA 66,20
00322:  DATA 2D,3E
00324:  DATA 20,53
00326:  DATA 61,6C
00328:  DATA 69,64
0032A:  DATA 61,20
0032C:  DATA 31,00
0032E:  DATA 4F,66
00330:  DATA 66,20
00332:  DATA 2D,3E
00334:  DATA 20,53
00336:  DATA 61,6C
00338:  DATA 69,64
0033A:  DATA 61,20
0033C:  DATA 32,00
0033E:  DATA 4F,66
00340:  DATA 66,20
00342:  DATA 2D,3E
00344:  DATA 20,53
00346:  DATA 61,6C
00348:  DATA 69,64
0034A:  DATA 61,20
0034C:  DATA 33,00
0034E:  DATA 4F,66
00350:  DATA 66,20
00352:  DATA 2D,3E
00354:  DATA 20,53
00356:  DATA 61,6C
00358:  DATA 69,64
0035A:  DATA 61,20
0035C:  DATA 34,00
0035E:  DATA 4F,66
00360:  DATA 66,20
00362:  DATA 2D,3E
00364:  DATA 20,53
00366:  DATA 61,6C
00368:  DATA 69,64
0036A:  DATA 61,20
0036C:  DATA 35,00
0036E:  DATA 4F,66
00370:  DATA 66,20
00372:  DATA 2D,3E
00374:  DATA 20,53
00376:  DATA 61,6C
00378:  DATA 69,64
0037A:  DATA 61,20
0037C:  DATA 36,00
0037E:  DATA 4F,66
00380:  DATA 66,20
00382:  DATA 2D,3E
00384:  DATA 20,53
00386:  DATA 61,6C
00388:  DATA 69,64
0038A:  DATA 61,20
0038C:  DATA 37,00
0038E:  DATA 4F,66
00390:  DATA 66,20
00392:  DATA 2D,3E
00394:  DATA 20,53
00396:  DATA 61,6C
00398:  DATA 69,64
0039A:  DATA 61,20
0039C:  DATA 38,00
0039E:  DATA 53,41
003A0:  DATA 4C,49
003A2:  DATA 52,20
003A4:  DATA 20,20
003A6:  DATA 20,20
003A8:  DATA 20,20
003AA:  DATA 20,20
003AC:  DATA 20,00
003AE:  DATA 00,00
003B0:  DATA 00,00
003B2:  DATA 00,00
003B4:  DATA 00,00
003B6:  DATA 00,00
003B8:  DATA 00,00
003BA:  DATA 00,00
003BC:  DATA 00,00
003BE:  DATA 45,53
003C0:  DATA 54,41
003C2:  DATA 43,49
003C4:  DATA 4F,4E
003C6:  DATA 20,49
003C8:  DATA 50,20
003CA:  DATA 20,20
003CC:  DATA 20,20
003CE:  DATA 00,45
003D0:  DATA 53,54
003D2:  DATA 41,43
003D4:  DATA 49,4F
003D6:  DATA 4E,20
003D8:  DATA 53,53
003DA:  DATA 49,44
003DC:  DATA 20,20
003DE:  DATA 20,00
003E0:  DATA 41,50
003E2:  DATA 20,53
003E4:  DATA 53,49
003E6:  DATA 44,20
003E8:  DATA 20,20
003EA:  DATA 20,20
003EC:  DATA 20,20
003EE:  DATA 20,20
003F0:  DATA 00,41
003F2:  DATA 50,20
003F4:  DATA 4B,45
003F6:  DATA 59,20
003F8:  DATA 20,20
003FA:  DATA 20,20
003FC:  DATA 20,20
003FE:  DATA 20,20
00400:  DATA 20,00
00402:  DATA 41,50
00404:  DATA 20,49
00406:  DATA 50,20
00408:  DATA 20,20
0040A:  DATA 20,20
0040C:  DATA 20,20
0040E:  DATA 20,20
00410:  DATA 20,20
00412:  DATA 00,43
00414:  DATA 6F,6E
00416:  DATA 66,20
00418:  DATA 41,63
0041A:  DATA 63,65
0041C:  DATA 73,73
0041E:  DATA 6F,20
00420:  DATA 52,65
00422:  DATA 64,00
00424:  DATA 4F,6E
00426:  DATA 2F,4F
00428:  DATA 66,66
0042A:  DATA 20,42
0042C:  DATA 61,63
0042E:  DATA 6B,6C
00430:  DATA 69,67
00432:  DATA 68,74
00434:  DATA 00,53
00436:  DATA 41,4C
00438:  DATA 49,52
0043A:  DATA 20,20
0043C:  DATA 20,20
0043E:  DATA 20,20
00440:  DATA 20,20
00442:  DATA 20,20
00444:  DATA 20,00
00446:  DATA 00,00
00448:  DATA 00,00
0044A:  DATA 00,00
0044C:  DATA 00,00
0044E:  DATA 00,00
00450:  DATA 00,00
00452:  DATA 00,00
00454:  DATA 00,00
00456:  DATA 00,00
00458:  DATA 45,73
0045A:  DATA 74,61
0045C:  DATA 63,69
0045E:  DATA F3,6E
00460:  DATA 20,20
00462:  DATA 20,20
00464:  DATA 20,00
00466:  DATA 41,63
00468:  DATA 63,65
0046A:  DATA 73,73
0046C:  DATA 20,50
0046E:  DATA 6F,69
00470:  DATA 6E,74
00472:  DATA 20,00
00474:  DATA 45,73
00476:  DATA 74,61
00478:  DATA 63,69
0047A:  DATA 6F,6E
0047C:  DATA 20,2B
0047E:  DATA 20,41
00480:  DATA 50,00
00482:  DATA 53,41
00484:  DATA 4C,49
00486:  DATA 52,20
00488:  DATA 20,20
0048A:  DATA 20,20
0048C:  DATA 20,20
0048E:  DATA 20,00
00490:  DATA 00,00
00492:  DATA 00,00
00494:  DATA 00,00
00496:  DATA 00,00
00498:  DATA 00,00
0049A:  DATA 00,00
0049C:  DATA 00,00
0049E:  DATA 53,41
004A0:  DATA 4C,49
004A2:  DATA 52,00
004A4:  DATA 5B,53
004A6:  DATA 49,47
004A8:  DATA 5D,20
004AA:  DATA 20,20
004AC:  DATA 20,20
004AE:  DATA 20,5B
004B0:  DATA 45,4E
004B2:  DATA 54,5D
004B4:  DATA 00,00
004B6:  DATA 41,54
004B8:  DATA 2B,43
004BA:  DATA 49,46
004BC:  DATA 53,52
004BE:  DATA 0D,0A
004C0:  DATA 00,00
004C2:  DATA 0C,43
004C4:  DATA 61,72
004C6:  DATA 67,61
004C8:  DATA 6E,64
004CA:  DATA 6F,2E
004CC:  DATA 2E,2E
004CE:  DATA 00,00
004D0:  DATA 41,54
004D2:  DATA 2B,43
004D4:  DATA 49,46
004D6:  DATA 53,52
004D8:  DATA 0D,0A
004DA:  DATA 00,00
004DC:  DATA 0C,43
004DE:  DATA 61,72
004E0:  DATA 67,61
004E2:  DATA 6E,64
004E4:  DATA 6F,2E
004E6:  DATA 2E,2E
004E8:  DATA 00,00
004EA:  DATA 41,54
004EC:  DATA 2B,43
004EE:  DATA 57,4A
004F0:  DATA 41,50
004F2:  DATA 3F,0D
004F4:  DATA 0A,00
004F6:  DATA 0C,43
004F8:  DATA 61,72
004FA:  DATA 67,61
004FC:  DATA 6E,64
004FE:  DATA 6F,2E
00500:  DATA 2E,2E
00502:  DATA 00,00
00504:  DATA 0C,44
00506:  DATA 65,73
00508:  DATA 68,61
0050A:  DATA 62,69
0050C:  DATA 6C,69
0050E:  DATA 74,61
00510:  DATA 64,6F
00512:  DATA 00,00
00514:  DATA 41,54
00516:  DATA 2B,43
00518:  DATA 57,53
0051A:  DATA 41,50
0051C:  DATA 3F,0D
0051E:  DATA 0A,00
00520:  DATA 0C,43
00522:  DATA 61,72
00524:  DATA 67,61
00526:  DATA 6E,64
00528:  DATA 6F,2E
0052A:  DATA 2E,2E
0052C:  DATA 00,00
0052E:  DATA 0C,44
00530:  DATA 65,73
00532:  DATA 68,61
00534:  DATA 62,69
00536:  DATA 6C,69
00538:  DATA 74,61
0053A:  DATA 64,6F
0053C:  DATA 00,00
0053E:  DATA 41,54
00540:  DATA 2B,43
00542:  DATA 57,53
00544:  DATA 41,50
00546:  DATA 3F,0D
00548:  DATA 0A,00
0054A:  DATA 0C,43
0054C:  DATA 61,72
0054E:  DATA 67,61
00550:  DATA 6E,64
00552:  DATA 6F,2E
00554:  DATA 2E,2E
00556:  DATA 00,00
00558:  DATA 0C,44
0055A:  DATA 65,73
0055C:  DATA 68,61
0055E:  DATA 62,69
00560:  DATA 6C,69
00562:  DATA 74,61
00564:  DATA 64,6F
00566:  DATA 00,00
00568:  DATA 0C,42
0056A:  DATA 61,63
0056C:  DATA 6B,6C
0056E:  DATA 69,67
00570:  DATA 68,74
00572:  DATA 20,4F
00574:  DATA 6E,00
00576:  DATA 0C,42
00578:  DATA 61,63
0057A:  DATA 6B,6C
0057C:  DATA 69,67
0057E:  DATA 68,74
00580:  DATA 20,4F
00582:  DATA 66,66
00584:  DATA 00,00
00586:  DATA 41,54
00588:  DATA 2B,43
0058A:  DATA 57,4D
0058C:  DATA 4F,44
0058E:  DATA 45,5F
00590:  DATA 44,45
00592:  DATA 46,3D
00594:  DATA 31,0D
00596:  DATA 0A,00
00598:  DATA 0C,43
0059A:  DATA 6F,6E
0059C:  DATA 66,69
0059E:  DATA 67,20
005A0:  DATA 43,6C
005A2:  DATA 69,65
005A4:  DATA 6E,74
005A6:  DATA 65,00
005A8:  DATA 41,54
005AA:  DATA 2B,43
005AC:  DATA 57,4D
005AE:  DATA 4F,44
005B0:  DATA 45,5F
005B2:  DATA 44,45
005B4:  DATA 46,3D
005B6:  DATA 32,0D
005B8:  DATA 0A,00
005BA:  DATA 0C,43
005BC:  DATA 6F,6E
005BE:  DATA 66,69
005C0:  DATA 67,20
005C2:  DATA 41,50
005C4:  DATA 00,00
005C6:  DATA 41,54
005C8:  DATA 2B,43
005CA:  DATA 57,4D
005CC:  DATA 4F,44
005CE:  DATA 45,5F
005D0:  DATA 44,45
005D2:  DATA 46,3D
005D4:  DATA 33,0D
005D6:  DATA 0A,00
005D8:  DATA 0C,43
005DA:  DATA 6F,6E
005DC:  DATA 66,69
005DE:  DATA 67,20
005E0:  DATA 43,6C
005E2:  DATA 69,65
005E4:  DATA 6E,74
005E6:  DATA 65,41
005E8:  DATA 50,00
*
007DC:  ADDWF  FE8,W
007DE:  CLRF   FF7
007E0:  RLCF   FF7,F
007E2:  ADDLW  F7
007E4:  MOVWF  FF6
007E6:  MOVLW  07
007E8:  ADDWFC FF7,F
007EA:  TBLRD*-
007EC:  MOVF   FF5,W
007EE:  MOVWF  FFA
007F0:  TBLRD*
007F2:  MOVF   FF5,W
007F4:  MOVWF  FF9
007F6:  DATA 00,06
007F8:  DATA 58,06
007FA:  DATA 2E,06
007FC:  DATA 82,06
007FE:  DATA AC,06
*
008AC:  ADDWF  FE8,W
008AE:  CLRF   FF7
008B0:  RLCF   FF7,F
008B2:  ADDLW  C7
008B4:  MOVWF  FF6
008B6:  MOVLW  08
008B8:  ADDWFC FF7,F
008BA:  TBLRD*-
008BC:  MOVF   FF5,W
008BE:  MOVWF  FFA
008C0:  TBLRD*
008C2:  MOVF   FF5,W
008C4:  MOVWF  FF9
008C6:  DATA A0,08
008C8:  DATA A0,08
008CA:  DATA A0,08
008CC:  DATA A0,08
008CE:  DATA A0,08
*
00946:  ADDWF  FE8,W
00948:  CLRF   FF7
0094A:  RLCF   FF7,F
0094C:  ADDLW  61
0094E:  MOVWF  FF6
00950:  MOVLW  09
00952:  ADDWFC FF7,F
00954:  TBLRD*-
00956:  MOVF   FF5,W
00958:  MOVWF  FFA
0095A:  TBLRD*
0095C:  MOVF   FF5,W
0095E:  MOVWF  FF9
00960:  DATA 3A,09
00962:  DATA 3A,09
00964:  DATA 3A,09
00966:  DATA 3A,09
*
00BCA:  DATA 0C,43
00BCC:  DATA 6F,6E
00BCE:  DATA 66,69
00BD0:  DATA 67,75
00BD2:  DATA 72,61
00BD4:  DATA 6E,64
00BD6:  DATA 6F,2E
00BD8:  DATA 2E,2E
00BDA:  DATA 00,00
*
00E78:  TBLRD*+
00E7A:  MOVF   FF5,F
00E7C:  BZ    0E96
00E7E:  MOVFF  FF6,110
00E82:  MOVFF  FF7,111
00E86:  MOVFF  FF5,112
00E8A:  RCALL  0E0C
00E8C:  MOVFF  110,FF6
00E90:  MOVFF  111,FF7
00E94:  BRA    0E78
00E96:  RETURN 0
00E98:  TBLRD*+
00E9A:  MOVFF  FF6,121
00E9E:  MOVFF  FF7,122
00EA2:  MOVF   FF5,W
00EA4:  BTFSS  F9E.4
00EA6:  BRA    0EA4
00EA8:  MOVWF  FAD
00EAA:  MOVFF  121,FF6
00EAE:  MOVFF  122,FF7
00EB2:  MOVLB  1
00EB4:  DECFSZ x20,F
00EB6:  BRA    0EBA
00EB8:  BRA    0EBE
00EBA:  MOVLB  0
00EBC:  BRA    0E98
00EBE:  MOVLB  0
00EC0:  RETURN 0
00EC2:  TBLRD*+
00EC4:  MOVF   FF5,F
00EC6:  BZ    0EE2
00EC8:  MOVFF  FF6,120
00ECC:  MOVFF  FF7,121
00ED0:  MOVF   FF5,W
00ED2:  BTFSS  F9E.4
00ED4:  BRA    0ED2
00ED6:  MOVWF  FAD
00ED8:  MOVFF  120,FF6
00EDC:  MOVFF  121,FF7
00EE0:  BRA    0EC2
00EE2:  RETURN 0
*
00FD4:  MOVF   FEF,F
00FD6:  BZ    0FF8
00FD8:  MOVFF  FEA,121
00FDC:  MOVFF  FE9,120
00FE0:  MOVF   FEF,W
00FE2:  BTFSS  F9E.4
00FE4:  BRA    0FE2
00FE6:  MOVWF  FAD
00FE8:  MOVFF  121,FEA
00FEC:  MOVFF  120,FE9
00FF0:  INCF   FE9,F
00FF2:  BTFSC  FD8.2
00FF4:  INCF   FEA,F
00FF6:  BRA    0FD4
00FF8:  RETURN 0
*
0120E:  MOVLB  1
01210:  MOVF   x22,W
01212:  ANDLW  07
01214:  MOVWF  00
01216:  RRCF   x22,W
01218:  MOVWF  01
0121A:  RRCF   01,F
0121C:  RRCF   01,F
0121E:  MOVLW  1F
01220:  ANDWF  01,F
01222:  MOVF   01,W
01224:  ADDWF  x24,W
01226:  MOVWF  FE9
01228:  MOVLW  00
0122A:  ADDWFC x25,W
0122C:  MOVWF  FEA
0122E:  CLRF   01
01230:  INCF   01,F
01232:  INCF   00,F
01234:  BRA    1238
01236:  RLCF   01,F
01238:  DECFSZ 00,F
0123A:  BRA    1236
0123C:  MOVF   x23,F
0123E:  BZ    1246
01240:  MOVF   01,W
01242:  IORWF  FEF,F
01244:  BRA    124C
01246:  COMF   01,F
01248:  MOVF   01,W
0124A:  ANDWF  FEF,F
0124C:  MOVLB  0
0124E:  RETURN 0
*
0172E:  BTFSC  FD8.1
01730:  BRA    173A
01732:  MOVLW  01
01734:  MOVWF  FEA
01736:  MOVLW  25
01738:  MOVWF  FE9
0173A:  CLRF   00
0173C:  CLRF   01
0173E:  CLRF   02
01740:  CLRF   03
01742:  MOVLB  1
01744:  CLRF   x25
01746:  CLRF   x26
01748:  CLRF   x27
0174A:  CLRF   x28
0174C:  MOVF   x24,W
0174E:  IORWF  x23,W
01750:  IORWF  x22,W
01752:  IORWF  x21,W
01754:  BZ    17AE
01756:  MOVLW  20
01758:  MOVWF  x29
0175A:  BCF    FD8.0
0175C:  RLCF   x1D,F
0175E:  RLCF   x1E,F
01760:  RLCF   x1F,F
01762:  RLCF   x20,F
01764:  RLCF   x25,F
01766:  RLCF   x26,F
01768:  RLCF   x27,F
0176A:  RLCF   x28,F
0176C:  MOVF   x24,W
0176E:  SUBWF  x28,W
01770:  BNZ   1782
01772:  MOVF   x23,W
01774:  SUBWF  x27,W
01776:  BNZ   1782
01778:  MOVF   x22,W
0177A:  SUBWF  x26,W
0177C:  BNZ   1782
0177E:  MOVF   x21,W
01780:  SUBWF  x25,W
01782:  BNC   17A2
01784:  MOVF   x21,W
01786:  SUBWF  x25,F
01788:  MOVF   x22,W
0178A:  BTFSS  FD8.0
0178C:  INCFSZ x22,W
0178E:  SUBWF  x26,F
01790:  MOVF   x23,W
01792:  BTFSS  FD8.0
01794:  INCFSZ x23,W
01796:  SUBWF  x27,F
01798:  MOVF   x24,W
0179A:  BTFSS  FD8.0
0179C:  INCFSZ x24,W
0179E:  SUBWF  x28,F
017A0:  BSF    FD8.0
017A2:  RLCF   00,F
017A4:  RLCF   01,F
017A6:  RLCF   02,F
017A8:  RLCF   03,F
017AA:  DECFSZ x29,F
017AC:  BRA    175A
017AE:  MOVFF  125,FEF
017B2:  MOVFF  126,FEC
017B6:  MOVFF  127,FEC
017BA:  MOVFF  128,FEC
017BE:  MOVLB  0
017C0:  GOTO   1898 (RETURN)
017C4:  MOVLB  1
017C6:  CLRF   x25
017C8:  CLRF   x26
017CA:  MOVLW  01
017CC:  MOVWF  x27
017CE:  CLRF   FDA
017D0:  CLRF   FD9
017D2:  MOVWF  x2A
017D4:  MOVLW  1D
017D6:  MOVWF  x29
017D8:  MOVLW  01
017DA:  MOVWF  FEA
017DC:  MOVLW  21
017DE:  MOVWF  FE9
017E0:  MOVFF  12A,FE2
017E4:  MOVFF  129,FE1
017E8:  MOVFF  127,128
017EC:  BCF    FD8.0
017EE:  MOVF   FE5,W
017F0:  MULWF  FEE
017F2:  MOVF   FF3,W
017F4:  ADDWFC x25,F
017F6:  MOVF   FF4,W
017F8:  ADDWFC x26,F
017FA:  DECFSZ x28,F
017FC:  BRA    17EC
017FE:  MOVFF  125,FDE
01802:  MOVFF  126,125
01806:  CLRF   x26
01808:  BTFSC  FD8.0
0180A:  INCF   x26,F
0180C:  INCF   x29,F
0180E:  BTFSC  FD8.2
01810:  INCF   x2A,F
01812:  INCF   x27,F
01814:  MOVF   x27,W
01816:  SUBLW  05
01818:  BNZ   17D8
0181A:  MOVLB  0
0181C:  GOTO   18C8 (RETURN)
*
01CF0:  MOVF   FEF,F
01CF2:  BZ    1D14
01CF4:  MOVFF  FEA,10E
01CF8:  MOVFF  FE9,10D
01CFC:  MOVFF  FEF,112
01D00:  CALL   0E0C
01D04:  MOVFF  10E,FEA
01D08:  MOVFF  10D,FE9
01D0C:  INCF   FE9,F
01D0E:  BTFSC  FD8.2
01D10:  INCF   FEA,F
01D12:  BRA    1CF0
01D14:  RETURN 0
*
0213A:  MOVFF  FF2,0D
0213E:  BCF    FF2.7
02140:  ADDWF  FE8,W
02142:  CLRF   FF7
02144:  RLCF   FF7,F
02146:  ADDLW  5F
02148:  MOVWF  FF6
0214A:  MOVLW  21
0214C:  ADDWFC FF7,F
0214E:  TBLRD*-
02150:  MOVF   FF5,W
02152:  MOVWF  FFA
02154:  TBLRD*
02156:  MOVF   FF5,W
02158:  BTFSC  0D.7
0215A:  BSF    FF2.7
0215C:  MOVWF  FF9
0215E:  DATA D2,1F
02160:  DATA 0C,20
02162:  DATA 5A,20
02164:  DATA A8,20
02166:  DATA 98,1F
02168:  DATA F6,20
0216A:  DATA FC,20
0216C:  DATA 22,21
*
02406:  MOVFF  FF2,0D
0240A:  BCF    FF2.7
0240C:  ADDWF  FE8,W
0240E:  CLRF   FF7
02410:  RLCF   FF7,F
02412:  ADDLW  2B
02414:  MOVWF  FF6
02416:  MOVLW  24
02418:  ADDWFC FF7,F
0241A:  TBLRD*-
0241C:  MOVF   FF5,W
0241E:  MOVWF  FFA
02420:  TBLRD*
02422:  MOVF   FF5,W
02424:  BTFSC  0D.7
02426:  BSF    FF2.7
02428:  MOVWF  FF9
0242A:  DATA D2,23
0242C:  DATA DE,23
0242E:  DATA EA,23
02430:  DATA F6,23
....................  
.................... #list 
....................  
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20M) 
*
00BDC:  MOVLW  01
00BDE:  MOVWF  FEA
00BE0:  MOVLW  21
00BE2:  MOVWF  FE9
00BE4:  MOVF   FEF,W
00BE6:  BZ    0C02
00BE8:  MOVLW  06
00BEA:  MOVWF  01
00BEC:  CLRF   00
00BEE:  DECFSZ 00,F
00BF0:  BRA    0BEE
00BF2:  DECFSZ 01,F
00BF4:  BRA    0BEC
00BF6:  MOVLW  7B
00BF8:  MOVWF  00
00BFA:  DECFSZ 00,F
00BFC:  BRA    0BFA
00BFE:  DECFSZ FEF,F
00C00:  BRA    0BE8
00C02:  RETURN 0
*
01820:  MOVLW  03
01822:  MOVLB  1
01824:  SUBWF  x1E,F
01826:  BNC   183C
01828:  MOVLW  01
0182A:  MOVWF  FEA
0182C:  MOVLW  1E
0182E:  MOVWF  FE9
01830:  MOVF   FEF,W
01832:  BZ    183C
01834:  BRA    1838
01836:  BRA    1838
01838:  DECFSZ FEF,F
0183A:  BRA    1836
0183C:  MOVLB  0
0183E:  RETURN 0
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00CA6:  BSF    F95.4
....................    output_float(LCD_DATA5); 
00CA8:  BSF    F95.5
....................    output_float(LCD_DATA6); 
00CAA:  BSF    F95.6
....................    output_float(LCD_DATA7); 
00CAC:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00CAE:  BSF    F8C.1
00CB0:  BCF    F95.1
....................    delay_cycles(1); 
00CB2:  NOP   
....................    lcd_output_enable(1); 
00CB4:  BSF    F8C.0
00CB6:  BCF    F95.0
....................    delay_cycles(1); 
00CB8:  NOP   
....................    high = lcd_read_nibble(); 
00CBA:  RCALL  0C50
00CBC:  MOVFF  01,11A
....................        
....................    lcd_output_enable(0); 
00CC0:  BCF    F8C.0
00CC2:  BCF    F95.0
....................    delay_cycles(1); 
00CC4:  NOP   
....................    lcd_output_enable(1); 
00CC6:  BSF    F8C.0
00CC8:  BCF    F95.0
....................    delay_us(1); 
00CCA:  BRA    0CCC
00CCC:  BRA    0CCE
00CCE:  NOP   
....................    low = lcd_read_nibble(); 
00CD0:  RCALL  0C50
00CD2:  MOVFF  01,119
....................        
....................    lcd_output_enable(0); 
00CD6:  BCF    F8C.0
00CD8:  BCF    F95.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00CDA:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00CDC:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00CDE:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00CE0:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00CE2:  MOVLB  1
00CE4:  SWAPF  x1A,W
00CE6:  MOVWF  00
00CE8:  MOVLW  F0
00CEA:  ANDWF  00,F
00CEC:  MOVF   00,W
00CEE:  IORWF  x19,W
00CF0:  MOVWF  01
00CF2:  MOVLB  0
00CF4:  GOTO   0D04 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00C50:  MOVLB  1
00C52:  CLRF   x1B
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00C54:  BSF    F95.4
00C56:  MOVLW  00
00C58:  BTFSC  F83.4
00C5A:  MOVLW  01
00C5C:  IORWF  x1B,F
....................    n |= input(LCD_DATA5) << 1; 
00C5E:  BSF    F95.5
00C60:  MOVLW  00
00C62:  BTFSC  F83.5
00C64:  MOVLW  01
00C66:  MOVWF  00
00C68:  BCF    FD8.0
00C6A:  RLCF   00,F
00C6C:  MOVF   00,W
00C6E:  IORWF  x1B,F
....................    n |= input(LCD_DATA6) << 2; 
00C70:  BSF    F95.6
00C72:  MOVLW  00
00C74:  BTFSC  F83.6
00C76:  MOVLW  01
00C78:  MOVWF  00
00C7A:  RLCF   00,F
00C7C:  RLCF   00,F
00C7E:  MOVLW  FC
00C80:  ANDWF  00,F
00C82:  MOVF   00,W
00C84:  IORWF  x1B,F
....................    n |= input(LCD_DATA7) << 3; 
00C86:  BSF    F95.7
00C88:  MOVLW  00
00C8A:  BTFSC  F83.7
00C8C:  MOVLW  01
00C8E:  MOVWF  00
00C90:  RLCF   00,F
00C92:  RLCF   00,F
00C94:  RLCF   00,F
00C96:  MOVLW  F8
00C98:  ANDWF  00,F
00C9A:  MOVF   00,W
00C9C:  IORWF  x1B,F
....................     
....................    return(n); 
00C9E:  MOVFF  11B,01
....................   #else 
00CA2:  MOVLB  0
00CA4:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00C04:  MOVLB  1
00C06:  BTFSC  x1A.0
00C08:  BRA    0C0E
00C0A:  BCF    F8C.4
00C0C:  BRA    0C10
00C0E:  BSF    F8C.4
00C10:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00C12:  BTFSC  x1A.1
00C14:  BRA    0C1A
00C16:  BCF    F8C.5
00C18:  BRA    0C1C
00C1A:  BSF    F8C.5
00C1C:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00C1E:  BTFSC  x1A.2
00C20:  BRA    0C26
00C22:  BCF    F8C.6
00C24:  BRA    0C28
00C26:  BSF    F8C.6
00C28:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00C2A:  BTFSC  x1A.3
00C2C:  BRA    0C32
00C2E:  BCF    F8C.7
00C30:  BRA    0C34
00C32:  BSF    F8C.7
00C34:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00C36:  NOP   
....................    lcd_output_enable(1); 
00C38:  BSF    F8C.0
00C3A:  BCF    F95.0
....................    delay_us(2); 
00C3C:  MOVLW  02
00C3E:  MOVWF  00
00C40:  DECFSZ 00,F
00C42:  BRA    0C40
00C44:  BRA    0C46
00C46:  NOP   
....................    lcd_output_enable(0); 
00C48:  BCF    F8C.0
00C4A:  BCF    F95.0
00C4C:  MOVLB  0
00C4E:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00CF8:  BCF    F95.0
....................    lcd_rs_tris(); 
00CFA:  BCF    F95.2
....................    lcd_rw_tris(); 
00CFC:  BCF    F95.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00CFE:  BCF    F8C.2
00D00:  BCF    F95.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
00D02:  BRA    0CA6
00D04:  MOVFF  01,119
00D08:  MOVLB  1
00D0A:  BTFSS  01.7
00D0C:  BRA    0D12
00D0E:  MOVLB  0
00D10:  BRA    0D02
....................    lcd_output_rs(address); 
00D12:  MOVF   x17,F
00D14:  BNZ   0D1A
00D16:  BCF    F8C.2
00D18:  BRA    0D1C
00D1A:  BSF    F8C.2
00D1C:  BCF    F95.2
....................    delay_cycles(1); 
00D1E:  NOP   
....................    lcd_output_rw(0); 
00D20:  BCF    F8C.1
00D22:  BCF    F95.1
....................    delay_cycles(1); 
00D24:  NOP   
....................    lcd_output_enable(0); 
00D26:  BCF    F8C.0
00D28:  BCF    F95.0
....................    lcd_send_nibble(n >> 4); 
00D2A:  SWAPF  x18,W
00D2C:  MOVWF  x19
00D2E:  MOVLW  0F
00D30:  ANDWF  x19,F
00D32:  MOVFF  119,11A
00D36:  MOVLB  0
00D38:  RCALL  0C04
....................    lcd_send_nibble(n & 0xf); 
00D3A:  MOVLB  1
00D3C:  MOVF   x18,W
00D3E:  ANDLW  0F
00D40:  MOVWF  x19
00D42:  MOVWF  x1A
00D44:  MOVLB  0
00D46:  RCALL  0C04
00D48:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00D4A:  MOVLW  28
00D4C:  MOVLB  1
00D4E:  MOVWF  x0B
00D50:  MOVLW  0C
00D52:  MOVWF  x0C
00D54:  MOVLW  01
00D56:  MOVWF  x0D
00D58:  MOVLW  06
00D5A:  MOVWF  x0E
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00D5C:  BCF    F8C.0
00D5E:  BCF    F95.0
....................    lcd_output_rs(0); 
00D60:  BCF    F8C.2
00D62:  BCF    F95.2
....................    lcd_output_rw(0); 
00D64:  BCF    F8C.1
00D66:  BCF    F95.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00D68:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00D6A:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00D6C:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00D6E:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00D70:  BCF    F95.0
....................    lcd_rs_tris(); 
00D72:  BCF    F95.2
....................    lcd_rw_tris(); 
00D74:  BCF    F95.1
....................  #endif 
....................      
....................    delay_ms(15); 
00D76:  MOVLW  0F
00D78:  MOVWF  x21
00D7A:  MOVLB  0
00D7C:  RCALL  0BDC
....................    for(i=1;i<=3;++i) 
00D7E:  MOVLW  01
00D80:  MOVLB  1
00D82:  MOVWF  x0A
00D84:  MOVF   x0A,W
00D86:  SUBLW  03
00D88:  BNC   0DA2
....................    { 
....................        lcd_send_nibble(3); 
00D8A:  MOVLW  03
00D8C:  MOVWF  x1A
00D8E:  MOVLB  0
00D90:  RCALL  0C04
....................        delay_ms(5); 
00D92:  MOVLW  05
00D94:  MOVLB  1
00D96:  MOVWF  x21
00D98:  MOVLB  0
00D9A:  RCALL  0BDC
00D9C:  MOVLB  1
00D9E:  INCF   x0A,F
00DA0:  BRA    0D84
....................    } 
....................     
....................    lcd_send_nibble(2); 
00DA2:  MOVLW  02
00DA4:  MOVWF  x1A
00DA6:  MOVLB  0
00DA8:  RCALL  0C04
....................    delay_ms(5); 
00DAA:  MOVLW  05
00DAC:  MOVLB  1
00DAE:  MOVWF  x21
00DB0:  MOVLB  0
00DB2:  RCALL  0BDC
....................    for(i=0;i<=3;++i) 
00DB4:  MOVLB  1
00DB6:  CLRF   x0A
00DB8:  MOVF   x0A,W
00DBA:  SUBLW  03
00DBC:  BNC   0DE0
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00DBE:  CLRF   03
00DC0:  MOVF   x0A,W
00DC2:  ADDLW  0B
00DC4:  MOVWF  FE9
00DC6:  MOVLW  01
00DC8:  ADDWFC 03,W
00DCA:  MOVWF  FEA
00DCC:  MOVFF  FEF,10F
00DD0:  CLRF   x17
00DD2:  MOVFF  10F,118
00DD6:  MOVLB  0
00DD8:  RCALL  0CF8
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00DDA:  MOVLB  1
00DDC:  INCF   x0A,F
00DDE:  BRA    0DB8
00DE0:  MOVLB  0
00DE2:  GOTO   23AE (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00DE6:  MOVLB  1
00DE8:  DECFSZ x14,W
00DEA:  BRA    0DEE
00DEC:  BRA    0DF4
....................       address=LCD_LINE_TWO; 
00DEE:  MOVLW  40
00DF0:  MOVWF  x15
00DF2:  BRA    0DF6
....................    else 
....................       address=0; 
00DF4:  CLRF   x15
....................       
....................    address+=x-1; 
00DF6:  MOVLW  01
00DF8:  SUBWF  x13,W
00DFA:  ADDWF  x15,F
....................    lcd_send_byte(0,0x80|address); 
00DFC:  MOVF   x15,W
00DFE:  IORLW  80
00E00:  MOVWF  x16
00E02:  CLRF   x17
00E04:  MOVWF  x18
00E06:  MOVLB  0
00E08:  RCALL  0CF8
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00E0A:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00E0C:  MOVLB  1
00E0E:  MOVF   x12,W
00E10:  XORLW  07
00E12:  MOVLB  0
00E14:  BZ    0E24
00E16:  XORLW  0B
00E18:  BZ    0E32
00E1A:  XORLW  06
00E1C:  BZ    0E4A
00E1E:  XORLW  02
00E20:  BZ    0E5A
00E22:  BRA    0E68
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00E24:  MOVLW  01
00E26:  MOVLB  1
00E28:  MOVWF  x13
00E2A:  MOVWF  x14
00E2C:  MOVLB  0
00E2E:  RCALL  0DE6
00E30:  BRA    0E76
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
00E32:  MOVLB  1
00E34:  CLRF   x17
00E36:  MOVLW  01
00E38:  MOVWF  x18
00E3A:  MOVLB  0
00E3C:  RCALL  0CF8
....................                      delay_ms(2); 
00E3E:  MOVLW  02
00E40:  MOVLB  1
00E42:  MOVWF  x21
00E44:  MOVLB  0
00E46:  RCALL  0BDC
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
00E48:  BRA    0E76
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00E4A:  MOVLW  01
00E4C:  MOVLB  1
00E4E:  MOVWF  x13
00E50:  MOVLW  02
00E52:  MOVWF  x14
00E54:  MOVLB  0
00E56:  RCALL  0DE6
00E58:  BRA    0E76
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00E5A:  MOVLB  1
00E5C:  CLRF   x17
00E5E:  MOVLW  10
00E60:  MOVWF  x18
00E62:  MOVLB  0
00E64:  RCALL  0CF8
00E66:  BRA    0E76
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
00E68:  MOVLW  01
00E6A:  MOVLB  1
00E6C:  MOVWF  x17
00E6E:  MOVFF  112,118
00E72:  MOVLB  0
00E74:  RCALL  0CF8
....................      #endif 
....................    } 
00E76:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
01840:  MOVLB  1
01842:  CLRF   x14
01844:  CLRF   x13
01846:  CLRF   x16
01848:  CLRF   x15
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
0184A:  MOVF   x10,F
0184C:  BNZ   1856
0184E:  MOVF   x0F,W
01850:  SUBLW  13
01852:  BTFSC  FD8.0
01854:  BRA    1984
01856:  MOVF   x10,W
01858:  SUBLW  4E
0185A:  BTFSS  FD8.0
0185C:  BRA    1984
0185E:  BNZ   1868
01860:  MOVF   x0F,W
01862:  SUBLW  20
01864:  BTFSS  FD8.0
01866:  BRA    1984
....................       tmp=100000; 
01868:  CLRF   x1C
0186A:  MOVLW  01
0186C:  MOVWF  x1B
0186E:  MOVLW  86
01870:  MOVWF  x1A
01872:  MOVLW  A0
01874:  MOVWF  x19
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
01876:  BCF    FD8.1
01878:  MOVFF  11C,120
0187C:  MOVFF  11B,11F
01880:  MOVFF  11A,11E
01884:  MOVFF  119,11D
01888:  CLRF   x24
0188A:  CLRF   x23
0188C:  MOVFF  110,122
01890:  MOVFF  10F,121
01894:  MOVLB  0
01896:  BRA    172E
01898:  MOVFF  03,11C
0189C:  MOVFF  02,11B
018A0:  MOVFF  01,11A
018A4:  MOVFF  00,119
....................       tmp*=5;    
018A8:  MOVFF  11C,120
018AC:  MOVFF  11B,11F
018B0:  MOVFF  11A,11E
018B4:  MOVFF  119,11D
018B8:  MOVLB  1
018BA:  CLRF   x24
018BC:  CLRF   x23
018BE:  CLRF   x22
018C0:  MOVLW  05
018C2:  MOVWF  x21
018C4:  MOVLB  0
018C6:  BRA    17C4
018C8:  MOVFF  03,11C
018CC:  MOVFF  02,11B
018D0:  MOVFF  01,11A
018D4:  MOVFF  00,119
....................       uS=tmp; 
018D8:  MOVFF  11A,118
018DC:  MOVFF  119,117
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
018E0:  BCF    F93.2
018E2:  BSF    F8A.2
....................          delay_us(uS);           // con los retardos mientras 
018E4:  MOVFF  118,11D
018E8:  MOVLB  1
018EA:  INCF   x1D,F
018EC:  DECF   x1D,F
018EE:  BTFSC  FD8.2
018F0:  BRA    18FC
018F2:  SETF   x1E
018F4:  MOVLB  0
018F6:  RCALL  1820
018F8:  MOVLB  1
018FA:  BRA    18EC
018FC:  MOVFF  117,11E
01900:  MOVLB  0
01902:  RCALL  1820
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
01904:  MOVLB  1
01906:  MOVF   x17,W
01908:  ADDWF  x15,F
0190A:  MOVF   x18,W
0190C:  ADDWFC x16,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0190E:  BCF    F93.2
01910:  BCF    F8A.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
01912:  MOVFF  118,11D
01916:  INCF   x1D,F
01918:  DECF   x1D,F
0191A:  BTFSC  FD8.2
0191C:  BRA    1928
0191E:  SETF   x1E
01920:  MOVLB  0
01922:  RCALL  1820
01924:  MOVLB  1
01926:  BRA    1918
01928:  MOVFF  117,11E
0192C:  MOVLB  0
0192E:  RCALL  1820
....................          CiclosL+=(uS);          //  
01930:  MOVLB  1
01932:  MOVF   x17,W
01934:  ADDWF  x15,F
01936:  MOVF   x18,W
01938:  ADDWFC x16,F
....................          CiclosL+=25;            // Compensador. 
0193A:  MOVLW  19
0193C:  ADDWF  x15,F
0193E:  MOVLW  00
01940:  ADDWFC x16,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
01942:  MOVF   x16,W
01944:  SUBLW  02
01946:  BC    196A
01948:  XORLW  FF
0194A:  BNZ   1952
0194C:  MOVF   x15,W
0194E:  SUBLW  E7
01950:  BC    196A
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
01952:  MOVLW  E8
01954:  SUBWF  x15,F
01956:  MOVLW  03
01958:  SUBWFB x16,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0195A:  INCF   x13,F
0195C:  BTFSC  FD8.2
0195E:  INCF   x14,F
....................             CiclosL+=25;         // Compensador. 
01960:  MOVLW  19
01962:  ADDWF  x15,F
01964:  MOVLW  00
01966:  ADDWFC x16,F
01968:  BRA    1942
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
0196A:  MOVF   x14,W
0196C:  SUBWF  x12,W
0196E:  BNC   1984
01970:  BTFSC  FD8.2
01972:  BRA    1978
01974:  MOVLB  0
01976:  BRA    18E0
01978:  MOVF   x11,W
0197A:  SUBWF  x13,W
0197C:  BTFSC  FD8.0
0197E:  BRA    1984
01980:  MOVLB  0
01982:  BRA    18E0
....................                                          // tiempo indicado. 
....................    } 
01984:  MOVLB  0
01986:  RETURN 0
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /***************************************************************** 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... ****************************************************************** 
....................  
.................... ******************************************** 
.................... *   Formato de comando en la respuesta:    * 
.................... *   INICIO:COMANDO:DATOS:<-(FIN)           * 
.................... *   e.g. CMD:CMD_SSID_AND_PASS,DATA:       * 
.................... ******************************************** 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:OP,[op][port]:                 | 
.................... |-----------------------------------------------| 
.................... |> Realiaza Operaciones en el Puerto de Salida  | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,[1|0][0-7]:                       | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      op:    1   -> Encender                   | 
.................... |             0   -> Apagar                     | 
.................... |      port:  0-7 -> No. del puerto.            | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,10:  Enciende el PORT 0        | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NC,"SSID","KEY":               | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el SSID y Key de la    | 
.................... |  Red donde se conectara.                      | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NC,"SSID","KEY":                     | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      SSID:  "Nombre de la Red."               | 
.................... |                                               | 
.................... |      KEY:   "Clave."                          | 
.................... |                                               | 
.................... |** @e.g. CMD:NC,"myRed","12345678":            | 
.................... | Intentara conectarse y almacenar en la eeprom | 
.................... | al nombre de la red con key pasados como      | 
.................... | parametro.                                    | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NM,[ModeConection]:            | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el modo de la conexion | 
.................... |                                               | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NM,[1|2|3]:                          | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      ModeConection:  "1" -> STA               | 
.................... |                      "2" -> AP                | 
.................... |                      "3" -> STA/AP            | 
.................... |                                               | 
.................... |** @e.g. CMD:NM,3:                             | 
.................... |                                               | 
.................... +-----------------------------------------------+ 
.................... */ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio recepcion de request,  
.................... y retorna el ID de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
009AA:  MOVLW  05
009AC:  MOVLB  1
009AE:  MOVWF  x2F
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
009B0:  DECFSZ 65,W
009B2:  BRA    09DA
....................        
....................       if(buffer!=','){ 
009B4:  MOVF   x2D,W
009B6:  SUBLW  2C
009B8:  BNZ   09BE
009BA:  MOVF   x2E,F
009BC:  BZ    09D4
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
009BE:  CLRF   03
009C0:  MOVF   69,W
009C2:  ADDLW  2C
009C4:  MOVWF  FE9
009C6:  MOVLW  00
009C8:  ADDWFC 03,W
009CA:  MOVWF  FEA
009CC:  MOVFF  12D,FEF
....................          flag_Pos_Resp_IPD++; 
009D0:  INCF   69,F
....................       }else{ 
009D2:  BRA    09D8
....................          flag_Pos_Resp_IPD       = 0x00; 
009D4:  CLRF   69
....................          flag_Resp_IPD           = 0x00; 
009D6:  CLRF   65
....................       } 
....................    }else{ 
009D8:  BRA    0A0C
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
009DA:  CLRF   03
009DC:  MOVF   69,W
009DE:  MOVFF  FF2,130
009E2:  BCF    FF2.7
009E4:  MOVLB  0
009E6:  CALL   0096
009EA:  MOVLB  1
009EC:  BTFSC  x30.7
009EE:  BSF    FF2.7
009F0:  MOVWF  01
009F2:  SUBWF  x2D,W
009F4:  BNZ   0A0A
009F6:  MOVF   x2E,F
009F8:  BNZ   0A0A
....................       { 
....................          flag_Pos_Resp_IPD++; 
009FA:  INCF   69,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
009FC:  MOVF   x2F,W
009FE:  SUBWF  69,W
00A00:  BNZ   0A08
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
00A02:  MOVLW  01
00A04:  MOVWF  65
....................             flag_Pos_Resp_IPD = 0; 
00A06:  CLRF   69
....................          } 
....................       }else{ 
00A08:  BRA    0A0C
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
00A0A:  CLRF   69
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00A0C:  MOVLB  0
00A0E:  GOTO   0B94 (RETURN)
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio comando,  
.................... y retorna el Comando enviado, Activa la bandera 
.................... de recepcion de datos 
.................... *********************************************************/ 
....................  
.................... void ESP8266_Get_CMD(char buffer[]){ 
00A12:  MOVLW  04
00A14:  MOVLB  1
00A16:  MOVWF  x2F
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
00A18:  DECFSZ 64,W
00A1A:  BRA    0A46
....................     
....................       if(buffer!=','){ 
00A1C:  MOVF   x2D,W
00A1E:  SUBLW  2C
00A20:  BNZ   0A26
00A22:  MOVF   x2E,F
00A24:  BZ    0A3C
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
00A26:  CLRF   03
00A28:  MOVF   68,W
00A2A:  ADDLW  2E
00A2C:  MOVWF  FE9
00A2E:  MOVLW  00
00A30:  ADDWFC 03,W
00A32:  MOVWF  FEA
00A34:  MOVFF  12D,FEF
....................          flag_Pos_Resp_CMD++; 
00A38:  INCF   68,F
....................       }else{         
00A3A:  BRA    0A44
....................          flag_Pos_Resp_CMD = 0x00; 
00A3C:  CLRF   68
....................          flag_Resp_CMD     = 0x00; 
00A3E:  CLRF   64
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
00A40:  MOVLW  01
00A42:  MOVWF  66
....................       } 
....................        
....................    }else{ 
00A44:  BRA    0A78
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
00A46:  CLRF   03
00A48:  MOVF   68,W
00A4A:  MOVFF  FF2,130
00A4E:  BCF    FF2.7
00A50:  MOVLB  0
00A52:  CALL   00AC
00A56:  MOVLB  1
00A58:  BTFSC  x30.7
00A5A:  BSF    FF2.7
00A5C:  MOVWF  01
00A5E:  SUBWF  x2D,W
00A60:  BNZ   0A76
00A62:  MOVF   x2E,F
00A64:  BNZ   0A76
....................       { 
....................          flag_Pos_Resp_CMD++; 
00A66:  INCF   68,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
00A68:  MOVF   x2F,W
00A6A:  SUBWF  68,W
00A6C:  BNZ   0A74
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
00A6E:  MOVLW  01
00A70:  MOVWF  64
....................             flag_Pos_Resp_CMD = 0; 
00A72:  CLRF   68
....................          } 
....................       }else{ 
00A74:  BRA    0A78
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
00A76:  CLRF   68
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00A78:  MOVLB  0
00A7A:  GOTO   0BA0 (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion Verifica si la bandera de recepcion de datos esta 
.................... activa y almacena los datos entrantes en el arreglo 
.................... DATA_COMMAND, Finaliza la captura de caracteres cuando 
.................... encuentra el caracter ":". 
.................... Envia al ESP8266 el fin de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
00A7E:  DECFSZ 66,W
00A80:  BRA    0AC4
....................       if(buffer!=':'){ 
00A82:  MOVLB  1
00A84:  MOVF   x2D,W
00A86:  SUBLW  3A
00A88:  BNZ   0A8E
00A8A:  MOVF   x2E,F
00A8C:  BZ    0ABC
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
00A8E:  CLRF   03
00A90:  MOVF   6A,W
00A92:  ADDLW  30
00A94:  MOVWF  FE9
00A96:  MOVLW  00
00A98:  ADDWFC 03,W
00A9A:  MOVWF  FEA
00A9C:  MOVFF  12D,FEF
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
00AA0:  CLRF   63
00AA2:  MOVFF  6A,62
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
00AA6:  MOVF   6A,F
00AA8:  BNZ   0AB8
00AAA:  MOVF   x2D,W
00AAC:  SUBLW  2C
00AAE:  BNZ   0AB8
00AB0:  MOVF   x2E,F
00AB2:  BNZ   0AB8
....................             flag_Pos_Resp_Data=0; 
00AB4:  CLRF   6A
....................          }else{ 
00AB6:  BRA    0ABA
....................             flag_Pos_Resp_Data++; 
00AB8:  INCF   6A,F
....................          } 
....................           
....................       }else{ 
00ABA:  BRA    0AC4
....................          flag_Pos_Resp_Data      = 0x00; 
00ABC:  CLRF   6A
....................          flag_Resp_StartGetData  = 0x00; 
00ABE:  CLRF   66
....................          flag_Resp_Ready         = 1; 
00AC0:  MOVLW  01
00AC2:  MOVWF  67
00AC4:  MOVLB  0
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
00AC6:  GOTO   0BAC (RETURN)
.................... } 
....................  
.................... int run_command_wifi(void){ 
*
01250:  MOVLB  1
01252:  CLRF   x0F
01254:  CLRF   x10
....................    int8 ret = 0, optSelected = 0; 
....................    char ESP8266_Resp[13] = {'{','"','c','m','d','"',':','"','o','k','"','}'}; 
01256:  MOVLW  7B
01258:  MOVWF  x11
0125A:  MOVLW  22
0125C:  MOVWF  x12
0125E:  MOVLW  63
01260:  MOVWF  x13
01262:  MOVLW  6D
01264:  MOVWF  x14
01266:  MOVLW  64
01268:  MOVWF  x15
0126A:  MOVLW  22
0126C:  MOVWF  x16
0126E:  MOVLW  3A
01270:  MOVWF  x17
01272:  MOVLW  22
01274:  MOVWF  x18
01276:  MOVLW  6F
01278:  MOVWF  x19
0127A:  MOVLW  6B
0127C:  MOVWF  x1A
0127E:  MOVLW  22
01280:  MOVWF  x1B
01282:  MOVLW  7D
01284:  MOVWF  x1C
01286:  CLRF   x1D
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
01288:  DECFSZ 67,W
0128A:  BRA    1726
....................        
....................       /************************** 
....................       *** Accede a las Salidas ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
0128C:  MOVF   2E,W
0128E:  SUBLW  4F
01290:  BNZ   133A
01292:  MOVF   2F,W
01294:  SUBLW  50
01296:  BNZ   133A
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
01298:  MOVLW  30
0129A:  SUBWF  31,W
0129C:  MOVWF  x10
....................           
....................          switch(DATA_COMMAND[0]){ 
0129E:  MOVF   30,W
012A0:  XORLW  30
012A2:  MOVLB  0
012A4:  BZ    12AC
012A6:  XORLW  01
012A8:  BZ    12F0
012AA:  BRA    1334
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
012AC:  BCF    FD8.0
012AE:  MOVLB  1
012B0:  RLCF   x10,W
012B2:  CLRF   03
012B4:  ADDLW  16
012B6:  MOVWF  FE9
012B8:  MOVLW  00
012BA:  ADDWFC 03,W
012BC:  MOVWF  FEA
012BE:  MOVFF  FEC,121
012C2:  MOVF   FED,F
012C4:  MOVFF  FEF,120
012C8:  MOVFF  120,122
012CC:  CLRF   x23
012CE:  MOVLW  0F
012D0:  MOVWF  x25
012D2:  MOVLW  89
012D4:  MOVWF  x24
012D6:  MOVLB  0
012D8:  RCALL  120E
012DA:  MOVFF  120,122
012DE:  MOVLB  1
012E0:  CLRF   x23
012E2:  MOVLW  0F
012E4:  MOVWF  x25
012E6:  MOVLW  92
012E8:  MOVWF  x24
012EA:  MOVLB  0
012EC:  RCALL  120E
....................                break; 
012EE:  BRA    1334
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
012F0:  BCF    FD8.0
012F2:  MOVLB  1
012F4:  RLCF   x10,W
012F6:  CLRF   03
012F8:  ADDLW  16
012FA:  MOVWF  FE9
012FC:  MOVLW  00
012FE:  ADDWFC 03,W
01300:  MOVWF  FEA
01302:  MOVFF  FEC,121
01306:  MOVF   FED,F
01308:  MOVFF  FEF,120
0130C:  MOVFF  120,122
01310:  MOVLW  01
01312:  MOVWF  x23
01314:  MOVLW  0F
01316:  MOVWF  x25
01318:  MOVLW  89
0131A:  MOVWF  x24
0131C:  MOVLB  0
0131E:  RCALL  120E
01320:  MOVFF  120,122
01324:  MOVLB  1
01326:  CLRF   x23
01328:  MOVLW  0F
0132A:  MOVWF  x25
0132C:  MOVLW  92
0132E:  MOVWF  x24
01330:  MOVLB  0
01332:  RCALL  120E
....................                break; 
....................          } 
....................           
....................          ret = 1; 
01334:  MOVLW  01
01336:  MOVLB  1
01338:  MOVWF  x0F
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
0133A:  MOVF   2E,W
0133C:  SUBLW  4E
0133E:  BTFSS  FD8.2
01340:  BRA    14C6
01342:  MOVF   2F,W
01344:  SUBLW  43
01346:  BTFSS  FD8.2
01348:  BRA    14C6
....................       { 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
0134A:  CLRF   x1E
0134C:  MOVF   63,F
0134E:  BNZ   1356
01350:  MOVF   x1E,W
01352:  SUBWF  62,W
01354:  BNC   13AA
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
01356:  MOVLW  01
01358:  ADDWF  x1E,W
0135A:  MOVWF  x20
0135C:  CLRF   03
0135E:  MOVF   x1E,W
01360:  ADDLW  30
01362:  MOVWF  FE9
01364:  MOVLW  00
01366:  ADDWFC 03,W
01368:  MOVWF  FEA
0136A:  MOVFF  FEF,121
0136E:  MOVF   FF2,W
01370:  MOVWF  00
01372:  BCF    FF2.7
01374:  CLRF   FAA
01376:  MOVFF  120,FA9
0137A:  MOVFF  121,FA8
0137E:  BCF    FA6.6
01380:  BCF    FA6.7
01382:  BSF    FA6.2
01384:  MOVLB  F
01386:  MOVLW  55
01388:  MOVWF  FA7
0138A:  MOVLW  AA
0138C:  MOVWF  FA7
0138E:  BSF    FA6.1
01390:  BTFSC  FA6.1
01392:  BRA    1390
01394:  BCF    FA6.2
01396:  MOVF   00,W
01398:  IORWF  FF2,F
....................             delay_ms(10); 
0139A:  MOVLW  0A
0139C:  MOVLB  1
0139E:  MOVWF  x21
013A0:  MOVLB  0
013A2:  RCALL  0BDC
013A4:  MOVLB  1
013A6:  INCF   x1E,F
013A8:  BRA    134C
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
013AA:  MOVLW  01
013AC:  ADDWF  x1E,W
013AE:  MOVWF  x20
013B0:  MOVF   FF2,W
013B2:  MOVWF  00
013B4:  BCF    FF2.7
013B6:  CLRF   FAA
013B8:  MOVFF  120,FA9
013BC:  MOVLW  0D
013BE:  MOVWF  FA8
013C0:  BCF    FA6.6
013C2:  BCF    FA6.7
013C4:  BSF    FA6.2
013C6:  MOVLB  F
013C8:  MOVLW  55
013CA:  MOVWF  FA7
013CC:  MOVLW  AA
013CE:  MOVWF  FA7
013D0:  BSF    FA6.1
013D2:  BTFSC  FA6.1
013D4:  BRA    13D2
013D6:  BCF    FA6.2
013D8:  MOVF   00,W
013DA:  IORWF  FF2,F
....................          delay_ms(10); 
013DC:  MOVLW  0A
013DE:  MOVLB  1
013E0:  MOVWF  x21
013E2:  MOVLB  0
013E4:  CALL   0BDC
....................          write_eeprom(idxNC+2,0x0A); 
013E8:  MOVLW  02
013EA:  MOVLB  1
013EC:  ADDWF  x1E,W
013EE:  MOVWF  x20
013F0:  MOVF   FF2,W
013F2:  MOVWF  00
013F4:  BCF    FF2.7
013F6:  CLRF   FAA
013F8:  MOVFF  120,FA9
013FC:  MOVLW  0A
013FE:  MOVWF  FA8
01400:  BCF    FA6.6
01402:  BCF    FA6.7
01404:  BSF    FA6.2
01406:  MOVLB  F
01408:  MOVLW  55
0140A:  MOVWF  FA7
0140C:  MOVLW  AA
0140E:  MOVWF  FA7
01410:  BSF    FA6.1
01412:  BTFSC  FA6.1
01414:  BRA    1412
01416:  BCF    FA6.2
01418:  MOVF   00,W
0141A:  IORWF  FF2,F
....................          delay_ms(10); 
0141C:  MOVLW  0A
0141E:  MOVLB  1
01420:  MOVWF  x21
01422:  MOVLB  0
01424:  CALL   0BDC
....................  
....................          // Responde la solicitud 
....................          //delay_ms(30); 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
01428:  MOVLW  34
0142A:  MOVWF  FF6
0142C:  MOVLW  01
0142E:  MOVWF  FF7
01430:  MOVLW  0B
01432:  MOVLB  1
01434:  MOVWF  x20
01436:  MOVLB  0
01438:  RCALL  0E98
0143A:  MOVF   2C,W
0143C:  BTFSS  F9E.4
0143E:  BRA    143C
01440:  MOVWF  FAD
01442:  MOVLW  41
01444:  MOVWF  FF6
01446:  MOVLW  01
01448:  MOVWF  FF7
0144A:  MOVLW  05
0144C:  MOVLB  1
0144E:  MOVWF  x20
01450:  MOVLB  0
01452:  RCALL  0E98
....................          delay_ms(60); 
01454:  MOVLW  3C
01456:  MOVLB  1
01458:  MOVWF  x21
0145A:  MOVLB  0
0145C:  CALL   0BDC
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
01460:  MOVLW  01
01462:  MOVWF  FEA
01464:  MOVLW  11
01466:  MOVWF  FE9
01468:  RCALL  0FD4
....................          delay_ms(110); 
0146A:  MOVLW  6E
0146C:  MOVLB  1
0146E:  MOVWF  x21
01470:  MOVLB  0
01472:  CALL   0BDC
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01476:  MOVLW  48
01478:  MOVWF  FF6
0147A:  MOVLW  01
0147C:  MOVWF  FF7
0147E:  MOVLW  0C
01480:  MOVLB  1
01482:  MOVWF  x20
01484:  MOVLB  0
01486:  RCALL  0E98
01488:  MOVF   2C,W
0148A:  BTFSS  F9E.4
0148C:  BRA    148A
0148E:  MOVWF  FAD
01490:  MOVLW  0D
01492:  BTFSS  F9E.4
01494:  BRA    1492
01496:  MOVWF  FAD
01498:  MOVLW  0A
0149A:  BTFSS  F9E.4
0149C:  BRA    149A
0149E:  MOVWF  FAD
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
014A0:  MOVLW  5A
014A2:  MOVWF  FF6
014A4:  MOVLW  01
014A6:  MOVWF  FF7
014A8:  RCALL  0EC2
....................          delay_ms(1000); 
014AA:  MOVLW  04
014AC:  MOVLB  1
014AE:  MOVWF  x20
014B0:  MOVLW  FA
014B2:  MOVWF  x21
014B4:  MOVLB  0
014B6:  CALL   0BDC
014BA:  MOVLB  1
014BC:  DECFSZ x20,F
014BE:  BRA    14B0
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
014C0:  RESET
....................          ret = 1; 
014C2:  MOVLW  01
014C4:  MOVWF  x0F
....................       } // Fin comando NC 
....................       /********************************** 
....................       *** Cambia el SSID y Key del AP  ** 
....................       *** CMD:AP,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='A' && 
....................          COMMAND[1]=='P') 
014C6:  MOVF   2E,W
014C8:  SUBLW  41
014CA:  BNZ   15A4
014CC:  MOVF   2F,W
014CE:  SUBLW  50
014D0:  BNZ   15A4
....................       { 
....................          // Responde la solicitud 
....................          //delay_ms(30); 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
014D2:  MOVLW  66
014D4:  MOVWF  FF6
014D6:  MOVLW  01
014D8:  MOVWF  FF7
014DA:  MOVLW  0B
014DC:  MOVWF  x20
014DE:  MOVLB  0
014E0:  RCALL  0E98
014E2:  MOVF   2C,W
014E4:  BTFSS  F9E.4
014E6:  BRA    14E4
014E8:  MOVWF  FAD
014EA:  MOVLW  73
014EC:  MOVWF  FF6
014EE:  MOVLW  01
014F0:  MOVWF  FF7
014F2:  MOVLW  05
014F4:  MOVLB  1
014F6:  MOVWF  x20
014F8:  MOVLB  0
014FA:  RCALL  0E98
....................          delay_ms(60); 
014FC:  MOVLW  3C
014FE:  MOVLB  1
01500:  MOVWF  x21
01502:  MOVLB  0
01504:  CALL   0BDC
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
01508:  MOVLW  01
0150A:  MOVWF  FEA
0150C:  MOVLW  11
0150E:  MOVWF  FE9
01510:  RCALL  0FD4
....................          delay_ms(110); 
01512:  MOVLW  6E
01514:  MOVLB  1
01516:  MOVWF  x21
01518:  MOVLB  0
0151A:  CALL   0BDC
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0151E:  MOVLW  7A
01520:  MOVWF  FF6
01522:  MOVLW  01
01524:  MOVWF  FF7
01526:  MOVLW  0C
01528:  MOVLB  1
0152A:  MOVWF  x20
0152C:  MOVLB  0
0152E:  RCALL  0E98
01530:  MOVF   2C,W
01532:  BTFSS  F9E.4
01534:  BRA    1532
01536:  MOVWF  FAD
01538:  MOVLW  0D
0153A:  BTFSS  F9E.4
0153C:  BRA    153A
0153E:  MOVWF  FAD
01540:  MOVLW  0A
01542:  BTFSS  F9E.4
01544:  BRA    1542
01546:  MOVWF  FAD
....................           
....................          delay_ms(1500); 
01548:  MOVLW  06
0154A:  MOVLB  1
0154C:  MOVWF  x20
0154E:  MOVLW  FA
01550:  MOVWF  x21
01552:  MOVLB  0
01554:  CALL   0BDC
01558:  MOVLB  1
0155A:  DECFSZ x20,F
0155C:  BRA    154E
....................          fprintf(ESP8266, "AT+CWSAP_DEF=%s,1,4\r\n",DATA_COMMAND); 
0155E:  MOVLW  8C
01560:  MOVWF  FF6
01562:  MOVLW  01
01564:  MOVWF  FF7
01566:  MOVLW  0D
01568:  MOVWF  x20
0156A:  MOVLB  0
0156C:  RCALL  0E98
0156E:  CLRF   FEA
01570:  MOVLW  30
01572:  MOVWF  FE9
01574:  RCALL  0FD4
01576:  MOVLW  9B
01578:  MOVWF  FF6
0157A:  MOVLW  01
0157C:  MOVWF  FF7
0157E:  MOVLW  06
01580:  MOVLB  1
01582:  MOVWF  x20
01584:  MOVLB  0
01586:  RCALL  0E98
....................          delay_ms(1000); 
01588:  MOVLW  04
0158A:  MOVLB  1
0158C:  MOVWF  x20
0158E:  MOVLW  FA
01590:  MOVWF  x21
01592:  MOVLB  0
01594:  CALL   0BDC
01598:  MOVLB  1
0159A:  DECFSZ x20,F
0159C:  BRA    158E
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
0159E:  RESET
....................          ret = 1; 
015A0:  MOVLW  01
015A2:  MOVWF  x0F
....................       } // Fin comando NC 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
015A4:  MOVF   2E,W
015A6:  SUBLW  4E
015A8:  BNZ   1672
015AA:  MOVF   2F,W
015AC:  SUBLW  4D
015AE:  BNZ   1672
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
015B0:  MOVF   FF2,W
015B2:  MOVWF  00
015B4:  BCF    FF2.7
015B6:  CLRF   FAA
015B8:  CLRF   FA9
015BA:  MOVFF  30,FA8
015BE:  BCF    FA6.6
015C0:  BCF    FA6.7
015C2:  BSF    FA6.2
015C4:  MOVLB  F
015C6:  MOVLW  55
015C8:  MOVWF  FA7
015CA:  MOVLW  AA
015CC:  MOVWF  FA7
015CE:  BSF    FA6.1
015D0:  BTFSC  FA6.1
015D2:  BRA    15D0
015D4:  BCF    FA6.2
015D6:  MOVF   00,W
015D8:  IORWF  FF2,F
....................          delay_ms(10); 
015DA:  MOVLW  0A
015DC:  MOVLB  1
015DE:  MOVWF  x21
015E0:  MOVLB  0
015E2:  CALL   0BDC
....................           
....................          // Responde la solicitud 
....................          delay_ms(20); 
015E6:  MOVLW  14
015E8:  MOVLB  1
015EA:  MOVWF  x21
015EC:  MOVLB  0
015EE:  CALL   0BDC
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
015F2:  MOVLW  A2
015F4:  MOVWF  FF6
015F6:  MOVLW  01
015F8:  MOVWF  FF7
015FA:  MOVLW  0B
015FC:  MOVLB  1
015FE:  MOVWF  x20
01600:  MOVLB  0
01602:  RCALL  0E98
01604:  MOVF   2C,W
01606:  BTFSS  F9E.4
01608:  BRA    1606
0160A:  MOVWF  FAD
0160C:  MOVLW  AF
0160E:  MOVWF  FF6
01610:  MOVLW  01
01612:  MOVWF  FF7
01614:  MOVLW  05
01616:  MOVLB  1
01618:  MOVWF  x20
0161A:  MOVLB  0
0161C:  RCALL  0E98
....................          delay_ms(50); 
0161E:  MOVLW  32
01620:  MOVLB  1
01622:  MOVWF  x21
01624:  MOVLB  0
01626:  CALL   0BDC
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
0162A:  MOVLW  01
0162C:  MOVWF  FEA
0162E:  MOVLW  11
01630:  MOVWF  FE9
01632:  RCALL  0FD4
....................          delay_ms(100); 
01634:  MOVLW  64
01636:  MOVLB  1
01638:  MOVWF  x21
0163A:  MOVLB  0
0163C:  CALL   0BDC
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01640:  MOVLW  B6
01642:  MOVWF  FF6
01644:  MOVLW  01
01646:  MOVWF  FF7
01648:  MOVLW  0C
0164A:  MOVLB  1
0164C:  MOVWF  x20
0164E:  MOVLB  0
01650:  RCALL  0E98
01652:  MOVF   2C,W
01654:  BTFSS  F9E.4
01656:  BRA    1654
01658:  MOVWF  FAD
0165A:  MOVLW  0D
0165C:  BTFSS  F9E.4
0165E:  BRA    165C
01660:  MOVWF  FAD
01662:  MOVLW  0A
01664:  BTFSS  F9E.4
01666:  BRA    1664
01668:  MOVWF  FAD
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
0166A:  RESET
....................           
....................          ret = 1; 
0166C:  MOVLW  01
0166E:  MOVLB  1
01670:  MOVWF  x0F
....................       } // Fin comando OP 
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................        
....................       // Responde la solicitud 
....................       delay_ms(20); 
01672:  MOVLW  14
01674:  MOVWF  x21
01676:  MOVLB  0
01678:  CALL   0BDC
....................       fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0167C:  MOVLW  C8
0167E:  MOVWF  FF6
01680:  MOVLW  01
01682:  MOVWF  FF7
01684:  MOVLW  0B
01686:  MOVLB  1
01688:  MOVWF  x20
0168A:  MOVLB  0
0168C:  RCALL  0E98
0168E:  MOVF   2C,W
01690:  BTFSS  F9E.4
01692:  BRA    1690
01694:  MOVWF  FAD
01696:  MOVLW  D5
01698:  MOVWF  FF6
0169A:  MOVLW  01
0169C:  MOVWF  FF7
0169E:  MOVLW  05
016A0:  MOVLB  1
016A2:  MOVWF  x20
016A4:  MOVLB  0
016A6:  CALL   0E98
....................       delay_ms(50); 
016AA:  MOVLW  32
016AC:  MOVLB  1
016AE:  MOVWF  x21
016B0:  MOVLB  0
016B2:  CALL   0BDC
....................       fprintf(ESP8266, "%s",ESP8266_Resp); 
016B6:  MOVLW  01
016B8:  MOVWF  FEA
016BA:  MOVLW  11
016BC:  MOVWF  FE9
016BE:  RCALL  0FD4
....................       delay_ms(100); 
016C0:  MOVLW  64
016C2:  MOVLB  1
016C4:  MOVWF  x21
016C6:  MOVLB  0
016C8:  CALL   0BDC
....................       fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
016CC:  MOVLW  DC
016CE:  MOVWF  FF6
016D0:  MOVLW  01
016D2:  MOVWF  FF7
016D4:  MOVLW  0C
016D6:  MOVLB  1
016D8:  MOVWF  x20
016DA:  MOVLB  0
016DC:  CALL   0E98
016E0:  MOVF   2C,W
016E2:  BTFSS  F9E.4
016E4:  BRA    16E2
016E6:  MOVWF  FAD
016E8:  MOVLW  0D
016EA:  BTFSS  F9E.4
016EC:  BRA    16EA
016EE:  MOVWF  FAD
016F0:  MOVLW  0A
016F2:  BTFSS  F9E.4
016F4:  BRA    16F2
016F6:  MOVWF  FAD
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
016F8:  MOVLB  1
016FA:  CLRF   x1F
016FC:  MOVF   63,F
016FE:  BNZ   1706
01700:  MOVF   x1F,W
01702:  SUBWF  62,W
01704:  BNC   171A
....................          DATA_COMMAND[idxCb] = 0x00; 
01706:  CLRF   03
01708:  MOVF   x1F,W
0170A:  ADDLW  30
0170C:  MOVWF  FE9
0170E:  MOVLW  00
01710:  ADDWFC 03,W
01712:  MOVWF  FEA
01714:  CLRF   FEF
01716:  INCF   x1F,F
01718:  BRA    16FC
....................       } 
....................       COMMAND[0]       = 0x00; 
0171A:  CLRF   2E
....................       COMMAND[1]       = 0x00; 
0171C:  CLRF   2F
....................       ID_CONNETION[0]  = 0x00; 
0171E:  CLRF   2C
....................        
....................       // Reinicia el buffer 
....................       flag_Resp_Ready  = 0x00; 
01720:  CLRF   67
....................       LEN_DATA_COMMAND = 0x00; 
01722:  CLRF   63
01724:  CLRF   62
....................        
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return ret; 
01726:  MOVFF  10F,01
0172A:  MOVLB  0
0172C:  RETURN 0
.................... } 
....................  
.................... #include "header/esp8266.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... #define  CMD_MODE                   1 
.................... #define  CMD_DO_CONN                2 
.................... #define  CMD_CONN                   3 
.................... #define  READY_RESPONSE_WIFI        4  
.................... #define  CMD_GET_IP_FROM_MENU       5 
.................... #define  CMD_GET_AP_INFO_FROM_MENU  6 
.................... #define  CMD_GET_STA_INFO_FROM_MENU 7 
....................  
.................... /* Key flag responses */ 
.................... const int   Valid      = 0; 
.................... const int   CWJAP      = 1; 
.................... const int   NoAp       = 2; 
.................... const int   Connected  = 3; 
.................... const int   Fail       = 4; 
.................... const int   Error      = 5; 
....................  
.................... //#define  END_CMD_GET_IP       2 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void getIP(int buffer); 
.................... void getAPInfo(int buffer); 
.................... void getSTAInfo(int buffer); 
.................... int  waitResp(void); 
.................... void waitRespMajor(int buffer,int flag_resp); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int resp_Pos   = 1; 
.................... int resp_Flag  = 0; 
.................... int countResp  = 5;     //Conteo de Respuestas esperadas 
....................  
.................... char buffer_flag_Resp[2][6]   =   
.................... { 
....................    {0,0,0,0,0,0}, // Flag_Responses Command valid 
....................    {0,0,0,0,0,0}  // Flag_Pos_Responses 
.................... }; 
....................  
.................... char buffer_Resp_CMD[5][16]   = 
.................... { 
....................    {"0.0.0.0"},   // IP    AP 
....................    {"0.0.0.0"},   // IP    STA 
....................    {""},          // SSID  AP 
....................    {"KEY"},       // Key   AP 
....................    {"SSID"}       // SSID  STA 
.................... }; 
....................  
.................... int flag_Resp_Get_IP_CMD = 0; 
.................... int flag_Pos_Get_IP_CMD  = 0; 
....................  
.................... int flag_Resp_Get_AP_Info_CMD = 0; 
.................... int flag_Pos_Get_AP_Info_CMD  = 0; 
....................  
.................... int flag_Resp_Get_STA_Info_CMD = 0; 
.................... int flag_Pos_Get_STA_Info_CMD  = 0; 
....................  
.................... /*Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    /**fprintf(ESP8266, "AT+RST\r\n"); 
....................    delay_ms(2000);**/ 
....................     
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
*
00FFA:  MOVFF  FF2,10C
00FFE:  BCF    FF2.7
01000:  CLRF   FAA
01002:  CLRF   FA9
01004:  BCF    FA6.6
01006:  BCF    FA6.7
01008:  BSF    FA6.0
0100A:  MOVF   FA8,W
0100C:  MOVLB  1
0100E:  BTFSC  x0C.7
01010:  BSF    FF2.7
01012:  MOVLB  0
01014:  MOVWF  xD1
....................    delay_ms(10); 
01016:  MOVLW  0A
01018:  MOVLB  1
0101A:  MOVWF  x21
0101C:  MOVLB  0
0101E:  RCALL  0BDC
....................    switch(modeStar){ 
01020:  MOVF   xD1,W
01022:  XORLW  31
01024:  BZ    1030
01026:  XORLW  03
01028:  BZ    1030
0102A:  XORLW  01
0102C:  BZ    1030
0102E:  BRA    1032
....................       case '1': 
....................       case '2': 
....................       case '3': 
....................          break; 
01030:  BRA    106A
....................       default: 
....................          write_eeprom(0x00,'3'); 
01032:  MOVF   FF2,W
01034:  MOVWF  00
01036:  BCF    FF2.7
01038:  CLRF   FAA
0103A:  CLRF   FA9
0103C:  MOVLW  33
0103E:  MOVWF  FA8
01040:  BCF    FA6.6
01042:  BCF    FA6.7
01044:  BSF    FA6.2
01046:  MOVLB  F
01048:  MOVLW  55
0104A:  MOVWF  FA7
0104C:  MOVLW  AA
0104E:  MOVWF  FA7
01050:  BSF    FA6.1
01052:  BTFSC  FA6.1
01054:  BRA    1052
01056:  BCF    FA6.2
01058:  MOVF   00,W
0105A:  IORWF  FF2,F
....................          delay_ms(10); 
0105C:  MOVLW  0A
0105E:  MOVLB  1
01060:  MOVWF  x21
01062:  MOVLB  0
01064:  RCALL  0BDC
....................          modeStar = '3'; 
01066:  MOVLW  33
01068:  MOVWF  xD1
....................          break; 
....................    } 
....................    // Lanza el comando para configurar el modo de conexion 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeStar); 
0106A:  MOVLW  EE
0106C:  MOVWF  FF6
0106E:  MOVLW  01
01070:  MOVWF  FF7
01072:  MOVLW  0A
01074:  MOVLB  1
01076:  MOVWF  x20
01078:  MOVLB  0
0107A:  RCALL  0E98
0107C:  MOVF   xD1,W
0107E:  BTFSS  F9E.4
01080:  BRA    107E
01082:  MOVWF  FAD
01084:  MOVLW  0D
01086:  BTFSS  F9E.4
01088:  BRA    1086
0108A:  MOVWF  FAD
0108C:  MOVLW  0A
0108E:  BTFSS  F9E.4
01090:  BRA    108E
01092:  MOVWF  FAD
....................    CMD_RUN =  CMD_MODE;  
01094:  MOVLW  01
01096:  MOVWF  6B
....................     
....................    // Espera por la respuesta OK del modulo 
....................    delay_ms(50); 
01098:  MOVLW  32
0109A:  MOVLB  1
0109C:  MOVWF  x21
0109E:  MOVLB  0
010A0:  RCALL  0BDC
....................     
....................    // Lanza el comando para verificar si elmodulo ya se encuentra conectado 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
010A2:  MOVLW  FE
010A4:  MOVWF  FF6
010A6:  MOVLW  01
010A8:  MOVWF  FF7
010AA:  RCALL  0EC2
....................    CMD_RUN =  CMD_DO_CONN; 
010AC:  MOVLW  02
010AE:  MOVWF  6B
....................  
....................    resp = waitResp(); 
010B0:  RCALL  0EE4
010B2:  MOVFF  01,10A
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
010B6:  MOVLB  1
010B8:  MOVF   x0A,W
010BA:  SUBLW  02
010BC:  BTFSS  FD8.2
010BE:  BRA    11AA
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
010C0:  CLRF   x0B
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
010C2:  CLRF   03
010C4:  MOVF   x0B,W
010C6:  ADDLW  D2
010C8:  MOVWF  FE9
010CA:  MOVLW  00
010CC:  ADDWFC 03,W
010CE:  MOVWF  FEA
010D0:  MOVF   FEF,W
010D2:  SUBLW  0A
010D4:  BZ    1140
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
010D6:  CLRF   03
010D8:  MOVF   x0B,W
010DA:  ADDLW  D2
010DC:  MOVWF  FE9
010DE:  MOVLW  00
010E0:  ADDWFC 03,W
010E2:  MOVWF  FEA
010E4:  MOVLW  01
010E6:  ADDWF  x0B,W
010E8:  MOVWF  x0E
010EA:  MOVFF  FF2,10F
010EE:  BCF    FF2.7
010F0:  CLRF   FAA
010F2:  MOVFF  10E,FA9
010F6:  BCF    FA6.6
010F8:  BCF    FA6.7
010FA:  BSF    FA6.0
010FC:  MOVF   FA8,W
010FE:  BTFSC  x0F.7
01100:  BSF    FF2.7
01102:  MOVWF  FEF
....................          delay_ms(10); 
01104:  MOVLW  0A
01106:  MOVWF  x21
01108:  MOVLB  0
0110A:  RCALL  0BDC
....................          if(SSIDAndKey[idxRE]==0xFF){ 
0110C:  CLRF   03
0110E:  MOVLB  1
01110:  MOVF   x0B,W
01112:  ADDLW  D2
01114:  MOVWF  FE9
01116:  MOVLW  00
01118:  ADDWFC 03,W
0111A:  MOVWF  FEA
0111C:  INCFSZ FEF,W
0111E:  BRA    1126
....................             resp = 5; 
01120:  MOVLW  05
01122:  MOVWF  x0A
....................             break; 
01124:  BRA    1140
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
01126:  CLRF   03
01128:  MOVF   x0B,W
0112A:  ADDLW  D2
0112C:  MOVWF  FE9
0112E:  MOVLW  00
01130:  ADDWFC 03,W
01132:  MOVWF  FEA
01134:  MOVF   FEF,W
01136:  SUBLW  0A
01138:  BNZ   113C
....................             break; 
0113A:  BRA    1140
....................          } 
....................          idxRE++; 
0113C:  INCF   x0B,F
0113E:  BRA    10C2
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
01140:  MOVF   x0A,W
01142:  SUBLW  05
01144:  BZ    116A
....................          fprintf(ESP8266, "AT+CWJAP=%s",SSIDAndKey);     /** AT+CWJAP="UNE_C06E","00986344200771" **/ 
01146:  MOVLW  0A
01148:  MOVWF  FF6
0114A:  MOVLW  02
0114C:  MOVWF  FF7
0114E:  MOVLW  09
01150:  MOVWF  x20
01152:  MOVLB  0
01154:  RCALL  0E98
01156:  CLRF   FEA
01158:  MOVLW  D2
0115A:  MOVWF  FE9
0115C:  RCALL  0FD4
....................          CMD_RUN = CMD_CONN; 
0115E:  MOVLW  03
01160:  MOVWF  6B
....................          resp    = waitResp(); 
01162:  RCALL  0EE4
01164:  MOVFF  01,10A
01168:  MOVLB  1
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
0116A:  MOVF   x0A,W
0116C:  SUBLW  04
0116E:  BZ    1176
01170:  MOVF   x0A,W
01172:  SUBLW  05
01174:  BNZ   11AA
....................          fprintf(ESP8266, "AT+CWMODE=%c\r\n","3"); 
01176:  MOVLW  16
01178:  MOVWF  FF6
0117A:  MOVLW  02
0117C:  MOVWF  FF7
0117E:  MOVLW  0A
01180:  MOVWF  x20
01182:  MOVLB  0
01184:  RCALL  0E98
01186:  MOVLB  4
01188:  MOVF   xB5,W
0118A:  BTFSS  F9E.4
0118C:  BRA    118A
0118E:  MOVWF  FAD
01190:  MOVLW  0D
01192:  BTFSS  F9E.4
01194:  BRA    1192
01196:  MOVWF  FAD
01198:  MOVLW  0A
0119A:  BTFSS  F9E.4
0119C:  BRA    119A
0119E:  MOVWF  FAD
....................          CMD_RUN = CMD_MODE; 
011A0:  MOVLW  01
011A2:  MOVWF  6B
....................          waitResp(); 
011A4:  MOVLB  0
011A6:  RCALL  0EE4
011A8:  MOVLB  1
....................       } 
....................    } // Fin del if(doConnect) 
....................  
....................    // Configura el modulo como server 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
011AA:  MOVLW  26
011AC:  MOVWF  FF6
011AE:  MOVLW  02
011B0:  MOVWF  FF7
011B2:  MOVLB  0
011B4:  RCALL  0EC2
....................    delay_ms(1000); 
011B6:  MOVLW  04
011B8:  MOVLB  1
011BA:  MOVWF  x0C
011BC:  MOVLW  FA
011BE:  MOVWF  x21
011C0:  MOVLB  0
011C2:  RCALL  0BDC
011C4:  MOVLB  1
011C6:  DECFSZ x0C,F
011C8:  BRA    11BC
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
011CA:  MOVLW  34
011CC:  MOVWF  FF6
011CE:  MOVLW  02
011D0:  MOVWF  FF7
011D2:  MOVLB  0
011D4:  RCALL  0EC2
....................    delay_ms(1000); 
011D6:  MOVLW  04
011D8:  MOVLB  1
011DA:  MOVWF  x0C
011DC:  MOVLW  FA
011DE:  MOVWF  x21
011E0:  MOVLB  0
011E2:  RCALL  0BDC
011E4:  MOVLB  1
011E6:  DECFSZ x0C,F
011E8:  BRA    11DC
....................     
....................    CMD_RUN = READY_RESPONSE_WIFI; 
011EA:  MOVLW  04
011EC:  MOVWF  6B
011EE:  MOVLB  0
011F0:  GOTO   23C2 (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
00ACA:  MOVF   6B,W
00ACC:  XORLW  01
00ACE:  BZ    0AEA
00AD0:  XORLW  03
00AD2:  BZ    0AF8
00AD4:  XORLW  01
00AD6:  BZ    0B22
00AD8:  XORLW  06
00ADA:  BZ    0B4C
00ADC:  XORLW  03
00ADE:  BZ    0B60
00AE0:  XORLW  01
00AE2:  BZ    0B74
00AE4:  XORLW  03
00AE6:  BZ    0B88
00AE8:  BRA    0B88
....................             case CMD_MODE: 
....................                   waitRespMajor(buffer,Valid); 
00AEA:  MOVFF  12C,12D
00AEE:  MOVLB  1
00AF0:  CLRF   x2E
00AF2:  MOVLB  0
00AF4:  RCALL  05EA
....................                   break; 
00AF6:  BRA    0BAE
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespMajor(buffer,NoAp); 
00AF8:  MOVFF  12C,12D
00AFC:  MOVLW  02
00AFE:  MOVLB  1
00B00:  MOVWF  x2E
00B02:  MOVLB  0
00B04:  RCALL  05EA
....................                   waitRespMajor(buffer,CWJAP); 
00B06:  MOVFF  12C,12D
00B0A:  MOVLW  01
00B0C:  MOVLB  1
00B0E:  MOVWF  x2E
00B10:  MOVLB  0
00B12:  RCALL  05EA
....................                   waitRespMajor(buffer,Valid); 
00B14:  MOVFF  12C,12D
00B18:  MOVLB  1
00B1A:  CLRF   x2E
00B1C:  MOVLB  0
00B1E:  RCALL  05EA
....................                   break; 
00B20:  BRA    0BAE
....................  
....................             case CMD_CONN: 
....................                   waitRespMajor(buffer,Connected); 
00B22:  MOVFF  12C,12D
00B26:  MOVLW  03
00B28:  MOVLB  1
00B2A:  MOVWF  x2E
00B2C:  MOVLB  0
00B2E:  RCALL  05EA
....................                   waitRespMajor(buffer,Fail); 
00B30:  MOVFF  12C,12D
00B34:  MOVLW  04
00B36:  MOVLB  1
00B38:  MOVWF  x2E
00B3A:  MOVLB  0
00B3C:  RCALL  05EA
....................                   waitRespMajor(buffer,Valid); 
00B3E:  MOVFF  12C,12D
00B42:  MOVLB  1
00B44:  CLRF   x2E
00B46:  MOVLB  0
00B48:  RCALL  05EA
....................                   break; 
00B4A:  BRA    0BAE
....................              
....................             case CMD_GET_IP_FROM_MENU: 
....................                   getIP(buffer); 
00B4C:  MOVFF  12C,12D
00B50:  BRA    0800
....................                   waitRespMajor(buffer,Valid); 
00B52:  MOVFF  12C,12D
00B56:  MOVLB  1
00B58:  CLRF   x2E
00B5A:  MOVLB  0
00B5C:  RCALL  05EA
....................                   break; 
00B5E:  BRA    0BAE
....................                    
....................             case CMD_GET_AP_INFO_FROM_MENU: 
....................                   getAPInfo(buffer); 
00B60:  MOVFF  12C,12D
00B64:  BRA    08D0
....................                   waitRespMajor(buffer,Valid); 
00B66:  MOVFF  12C,12D
00B6A:  MOVLB  1
00B6C:  CLRF   x2E
00B6E:  MOVLB  0
00B70:  RCALL  05EA
....................                   break; 
00B72:  BRA    0BAE
....................              
....................             case CMD_GET_STA_INFO_FROM_MENU: 
....................                   getSTAInfo(buffer); 
00B74:  MOVFF  12C,12D
00B78:  BRA    0968
....................                   waitRespMajor(buffer,Valid); 
00B7A:  MOVFF  12C,12D
00B7E:  MOVLB  1
00B80:  CLRF   x2E
00B82:  MOVLB  0
00B84:  RCALL  05EA
....................                   break; 
00B86:  BRA    0BAE
....................                    
....................             case READY_RESPONSE_WIFI: 
....................             default: 
....................                   ESP8266_Get_IPD(buffer); 
00B88:  MOVLB  1
00B8A:  CLRF   x2E
00B8C:  MOVFF  12C,12D
00B90:  MOVLB  0
00B92:  BRA    09AA
....................                   ESP8266_Get_CMD(buffer); 
00B94:  MOVLB  1
00B96:  CLRF   x2E
00B98:  MOVFF  12C,12D
00B9C:  MOVLB  0
00B9E:  BRA    0A12
....................                   ESP8266_Get_Data(buffer); 
00BA0:  MOVLB  1
00BA2:  CLRF   x2E
00BA4:  MOVFF  12C,12D
00BA8:  MOVLB  0
00BAA:  BRA    0A7E
....................              
....................                   CMD_RUN = 0x00; 
00BAC:  CLRF   6B
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
00BAE:  GOTO   0BC4 (RETURN)
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
00EE4:  MOVLB  1
00EE6:  CLRF   x0D
00EE8:  CLRF   x0E
.................... { 
....................    int ret=0,idx=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(buffer_flag_Resp[resp_Flag][Valid]==0){ 
00EEA:  MOVF   6D,W
00EEC:  MULLW  06
00EEE:  MOVF   FF3,W
00EF0:  CLRF   x10
00EF2:  MOVWF  x0F
00EF4:  MOVLW  6F
00EF6:  ADDWF  x0F,W
00EF8:  MOVWF  FE9
00EFA:  MOVLW  00
00EFC:  ADDWFC x10,W
00EFE:  MOVWF  FEA
00F00:  MOVF   FEF,F
00F02:  BNZ   0FA8
....................       idx++; 
00F04:  INCF   x0E,F
....................       if(buffer_flag_Resp[resp_Flag][idx]==1){ 
00F06:  MOVF   6D,W
00F08:  MULLW  06
00F0A:  MOVF   FF3,W
00F0C:  CLRF   x10
00F0E:  MOVWF  x0F
00F10:  CLRF   03
00F12:  MOVF   x0E,W
00F14:  ADDWF  x0F,W
00F16:  MOVWF  01
00F18:  MOVF   x10,W
00F1A:  ADDWFC 03,F
00F1C:  MOVF   01,W
00F1E:  ADDLW  6F
00F20:  MOVWF  FE9
00F22:  MOVLW  00
00F24:  ADDWFC 03,W
00F26:  MOVWF  FEA
00F28:  DECFSZ FEF,W
00F2A:  BRA    0F9E
....................          buffer_flag_Resp[resp_Pos][idx]   = 0; 
00F2C:  MOVF   6C,W
00F2E:  MULLW  06
00F30:  MOVF   FF3,W
00F32:  CLRF   x10
00F34:  MOVWF  x0F
00F36:  CLRF   03
00F38:  MOVF   x0E,W
00F3A:  ADDWF  x0F,W
00F3C:  MOVWF  01
00F3E:  MOVF   x10,W
00F40:  ADDWFC 03,F
00F42:  MOVF   01,W
00F44:  ADDLW  6F
00F46:  MOVWF  FE9
00F48:  MOVLW  00
00F4A:  ADDWFC 03,W
00F4C:  MOVWF  FEA
00F4E:  CLRF   FEF
....................          buffer_flag_Resp[resp_Flag][idx]  = 0; 
00F50:  MOVF   6D,W
00F52:  MULLW  06
00F54:  MOVF   FF3,W
00F56:  CLRF   x10
00F58:  MOVWF  x0F
00F5A:  CLRF   03
00F5C:  MOVF   x0E,W
00F5E:  ADDWF  x0F,W
00F60:  MOVWF  01
00F62:  MOVF   x10,W
00F64:  ADDWFC 03,F
00F66:  MOVF   01,W
00F68:  ADDLW  6F
00F6A:  MOVWF  FE9
00F6C:  MOVLW  00
00F6E:  ADDWFC 03,W
00F70:  MOVWF  FEA
00F72:  CLRF   FEF
....................          
....................          if(idx == Fail || idx == Error){ 
00F74:  MOVF   x0E,W
00F76:  SUBLW  04
00F78:  BZ    0F80
00F7A:  MOVF   x0E,W
00F7C:  SUBLW  05
00F7E:  BNZ   0F9A
....................             buffer_flag_Resp[resp_Flag][Valid]  = 1; 
00F80:  MOVF   6D,W
00F82:  MULLW  06
00F84:  MOVF   FF3,W
00F86:  CLRF   x10
00F88:  MOVWF  x0F
00F8A:  MOVLW  6F
00F8C:  ADDWF  x0F,W
00F8E:  MOVWF  FE9
00F90:  MOVLW  00
00F92:  ADDWFC x10,W
00F94:  MOVWF  FEA
00F96:  MOVLW  01
00F98:  MOVWF  FEF
....................          } 
....................          ret = idx; 
00F9A:  MOVFF  10E,10D
....................       } 
....................       // Reinicia el contador para no desbordar el array de flag_resp 
....................       if(idx>=countResp){ 
00F9E:  MOVF   6E,W
00FA0:  SUBWF  x0E,W
00FA2:  BNC   0FA6
....................          idx = 0; 
00FA4:  CLRF   x0E
....................       } 
00FA6:  BRA    0EEA
....................        
....................    }; // Fin del loop 
....................     
....................    buffer_flag_Resp[resp_Flag][Valid] = 0; 
00FA8:  MOVF   6D,W
00FAA:  MULLW  06
00FAC:  MOVF   FF3,W
00FAE:  CLRF   x10
00FB0:  MOVWF  x0F
00FB2:  MOVLW  6F
00FB4:  ADDWF  x0F,W
00FB6:  MOVWF  FE9
00FB8:  MOVLW  00
00FBA:  ADDWFC x10,W
00FBC:  MOVWF  FEA
00FBE:  CLRF   FEF
....................    CMD_RUN = 0x00; 
00FC0:  CLRF   6B
....................    delay_ms(10); 
00FC2:  MOVLW  0A
00FC4:  MOVWF  x21
00FC6:  MOVLB  0
00FC8:  RCALL  0BDC
....................    return ret; 
00FCA:  MOVLB  1
00FCC:  MOVFF  10D,01
00FD0:  MOVLB  0
00FD2:  RETURN 0
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
.................... void waitRespMajor(int buffer,int flag_resp) 
*
005EA:  MOVLB  1
005EC:  CLRF   x39
005EE:  CLRF   x3A
.................... { 
....................     
....................    char  strResp[10]; 
....................    int   lenResp = 0,restartFlag = 0; 
....................  
....................    switch(flag_resp) 
005F0:  MOVF   x2E,W
005F2:  ADDLW  FB
005F4:  BTFSC  FD8.0
005F6:  BRA    06DC
005F8:  ADDLW  05
005FA:  MOVLB  0
005FC:  GOTO   07DC
....................    { 
....................       case Valid: 
....................          strResp = "OK\r\n"; 
00600:  MOVLW  01
00602:  MOVWF  FEA
00604:  MOVLW  2F
00606:  MOVWF  FE9
00608:  MOVFF  FF2,13B
0060C:  BCF    FF2.7
0060E:  MOVLW  00
00610:  RCALL  00C0
00612:  TBLRD*-
00614:  TBLRD*+
00616:  MOVF   FF5,W
00618:  MOVWF  FEE
0061A:  IORLW  00
0061C:  BNZ   0614
0061E:  MOVLB  1
00620:  BTFSC  x3B.7
00622:  BSF    FF2.7
....................          lenResp = 4; 
00624:  MOVLW  04
00626:  MOVWF  x39
....................          // Como esta funcion es el ultimo caracter recibido no es necesario mantener 
....................          // Activa la bandera flag_Resp_Valid 
....................          restartFlag = 1; 
00628:  MOVLW  01
0062A:  MOVWF  x3A
....................          break; 
0062C:  BRA    06DC
....................  
....................       case NoAp: 
....................          strResp = "No Ap"; 
0062E:  MOVLW  01
00630:  MOVWF  FEA
00632:  MOVLW  2F
00634:  MOVWF  FE9
00636:  MOVFF  FF2,13B
0063A:  BCF    FF2.7
0063C:  MOVLW  00
0063E:  RCALL  00D6
00640:  TBLRD*-
00642:  TBLRD*+
00644:  MOVF   FF5,W
00646:  MOVWF  FEE
00648:  IORLW  00
0064A:  BNZ   0642
0064C:  MOVLB  1
0064E:  BTFSC  x3B.7
00650:  BSF    FF2.7
....................          lenResp = 5; 
00652:  MOVLW  05
00654:  MOVWF  x39
....................          break; 
00656:  BRA    06DC
....................  
....................       case CWJAP: 
....................          strResp = "+CWJAP:"; 
00658:  MOVLW  01
0065A:  MOVWF  FEA
0065C:  MOVLW  2F
0065E:  MOVWF  FE9
00660:  MOVFF  FF2,13B
00664:  BCF    FF2.7
00666:  MOVLW  00
00668:  RCALL  00EC
0066A:  TBLRD*-
0066C:  TBLRD*+
0066E:  MOVF   FF5,W
00670:  MOVWF  FEE
00672:  IORLW  00
00674:  BNZ   066C
00676:  MOVLB  1
00678:  BTFSC  x3B.7
0067A:  BSF    FF2.7
....................          lenResp = 7; 
0067C:  MOVLW  07
0067E:  MOVWF  x39
....................          break; 
00680:  BRA    06DC
....................           
....................       case Connected: 
....................          strResp = "CONNECTED"; 
00682:  MOVLW  01
00684:  MOVWF  FEA
00686:  MOVLW  2F
00688:  MOVWF  FE9
0068A:  MOVFF  FF2,13B
0068E:  BCF    FF2.7
00690:  MOVLW  00
00692:  RCALL  0104
00694:  TBLRD*-
00696:  TBLRD*+
00698:  MOVF   FF5,W
0069A:  MOVWF  FEE
0069C:  IORLW  00
0069E:  BNZ   0696
006A0:  MOVLB  1
006A2:  BTFSC  x3B.7
006A4:  BSF    FF2.7
....................          lenResp = 9; 
006A6:  MOVLW  09
006A8:  MOVWF  x39
....................          break; 
006AA:  BRA    06DC
....................        
....................       case Fail: 
....................          strResp = "FAIL"; 
006AC:  MOVLW  01
006AE:  MOVWF  FEA
006B0:  MOVLW  2F
006B2:  MOVWF  FE9
006B4:  MOVFF  FF2,13B
006B8:  BCF    FF2.7
006BA:  MOVLW  00
006BC:  RCALL  011E
006BE:  TBLRD*-
006C0:  TBLRD*+
006C2:  MOVF   FF5,W
006C4:  MOVWF  FEE
006C6:  IORLW  00
006C8:  BNZ   06C0
006CA:  MOVLB  1
006CC:  BTFSC  x3B.7
006CE:  BSF    FF2.7
....................          lenResp = 4; 
006D0:  MOVLW  04
006D2:  MOVWF  x39
....................          restartFlag = 1; 
006D4:  MOVLW  01
006D6:  MOVWF  x3A
....................          break; 
006D8:  BRA    06DC
006DA:  MOVLB  1
....................    } 
....................  
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................  
....................    if(buffer == strResp[buffer_flag_Resp[resp_Pos][flag_resp]]) 
006DC:  MOVF   6C,W
006DE:  MULLW  06
006E0:  MOVF   FF3,W
006E2:  CLRF   x3C
006E4:  MOVWF  x3B
006E6:  CLRF   03
006E8:  MOVF   x2E,W
006EA:  ADDWF  x3B,W
006EC:  MOVWF  01
006EE:  MOVF   x3C,W
006F0:  ADDWFC 03,F
006F2:  MOVF   01,W
006F4:  ADDLW  6F
006F6:  MOVWF  FE9
006F8:  MOVLW  00
006FA:  ADDWFC 03,W
006FC:  MOVWF  FEA
006FE:  CLRF   03
00700:  MOVF   FEF,W
00702:  ADDLW  2F
00704:  MOVWF  FE9
00706:  MOVLW  01
00708:  ADDWFC 03,W
0070A:  MOVWF  FEA
0070C:  MOVF   FEF,W
0070E:  SUBWF  x2D,W
00710:  BNZ   078C
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       buffer_flag_Resp[resp_Pos][flag_resp]++; 
00712:  MOVF   6C,W
00714:  MULLW  06
00716:  MOVF   FF3,W
00718:  CLRF   x3C
0071A:  MOVWF  x3B
0071C:  CLRF   03
0071E:  MOVF   x2E,W
00720:  ADDWF  x3B,W
00722:  MOVWF  01
00724:  MOVF   x3C,W
00726:  ADDWFC 03,F
00728:  MOVF   01,W
0072A:  ADDLW  6F
0072C:  MOVWF  FE9
0072E:  MOVLW  00
00730:  ADDWFC 03,W
00732:  MOVWF  FEA
00734:  INCF   FEF,F
....................        
....................       if(buffer_flag_Resp[resp_Pos][flag_resp]==lenResp){ 
00736:  MOVF   6C,W
00738:  MULLW  06
0073A:  MOVF   FF3,W
0073C:  CLRF   x3C
0073E:  MOVWF  x3B
00740:  CLRF   03
00742:  MOVF   x2E,W
00744:  ADDWF  x3B,W
00746:  MOVWF  01
00748:  MOVF   x3C,W
0074A:  ADDWFC 03,F
0074C:  MOVF   01,W
0074E:  ADDLW  6F
00750:  MOVWF  FE9
00752:  MOVLW  00
00754:  ADDWFC 03,W
00756:  MOVWF  FEA
00758:  MOVF   x39,W
0075A:  SUBWF  FEF,W
0075C:  BNZ   0786
....................          // Respuesta es valida 
....................          buffer_flag_Resp[resp_Flag][flag_resp]  = 1; 
0075E:  MOVF   6D,W
00760:  MULLW  06
00762:  MOVF   FF3,W
00764:  CLRF   x3C
00766:  MOVWF  x3B
00768:  CLRF   03
0076A:  MOVF   x2E,W
0076C:  ADDWF  x3B,W
0076E:  MOVWF  01
00770:  MOVF   x3C,W
00772:  ADDWFC 03,F
00774:  MOVF   01,W
00776:  ADDLW  6F
00778:  MOVWF  FE9
0077A:  MOVLW  00
0077C:  ADDWFC 03,W
0077E:  MOVWF  FEA
00780:  MOVLW  01
00782:  MOVWF  FEF
....................       }else if(flag_resp == Valid) { 
00784:  BRA    078A
00786:  MOVF   x2E,F
00788:  BNZ   078A
....................          // Reinicia la bandera para indicar el final del comando 
....................           //buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
....................       } 
....................         
....................    }else{ 
0078A:  BRA    07D8
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       buffer_flag_Resp[resp_Pos][flag_resp]   = 0; 
0078C:  MOVF   6C,W
0078E:  MULLW  06
00790:  MOVF   FF3,W
00792:  CLRF   x3C
00794:  MOVWF  x3B
00796:  CLRF   03
00798:  MOVF   x2E,W
0079A:  ADDWF  x3B,W
0079C:  MOVWF  01
0079E:  MOVF   x3C,W
007A0:  ADDWFC 03,F
007A2:  MOVF   01,W
007A4:  ADDLW  6F
007A6:  MOVWF  FE9
007A8:  MOVLW  00
007AA:  ADDWFC 03,W
007AC:  MOVWF  FEA
007AE:  CLRF   FEF
....................  
....................       // Banderas que se reinician 
....................       if(restartFlag == 1){ 
007B0:  DECFSZ x3A,W
007B2:  BRA    07D8
....................          buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
007B4:  MOVF   6D,W
007B6:  MULLW  06
007B8:  MOVF   FF3,W
007BA:  CLRF   x3C
007BC:  MOVWF  x3B
007BE:  CLRF   03
007C0:  MOVF   x2E,W
007C2:  ADDWF  x3B,W
007C4:  MOVWF  01
007C6:  MOVF   x3C,W
007C8:  ADDWFC 03,F
007CA:  MOVF   01,W
007CC:  ADDLW  6F
007CE:  MOVWF  FE9
007D0:  MOVLW  00
007D2:  ADDWFC 03,W
007D4:  MOVWF  FEA
007D6:  CLRF   FEF
....................       } 
....................        
....................    } 
007D8:  MOVLB  0
007DA:  RETURN 0
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la IP del modo AP, STA, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getIP(int buffer) 
.................... { 
....................    const int END_GET_IP_CMD = 6; 
....................     
....................    // bandera de IP_First esta habilita 
....................    if(flag_Resp_Get_IP_CMD==1){ 
*
00800:  DECFSZ xCB,W
00802:  BRA    085A
....................       // Fin de Get First IP 
....................       if(buffer == '"'){ 
00804:  MOVLB  1
00806:  MOVF   x2D,W
00808:  SUBLW  22
0080A:  BNZ   0828
....................          // Finaliza el almacenamiento en el buffer 
....................          if( modeStar=='1' || modeStar=='2' ){ 
0080C:  MOVLB  0
0080E:  MOVF   xD1,W
00810:  SUBLW  31
00812:  BZ    081A
00814:  MOVF   xD1,W
00816:  SUBLW  32
00818:  BNZ   0822
....................             flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
0081A:  MOVLW  06
0081C:  MOVWF  xCB
....................             flag_Pos_Get_IP_CMD =0; 
0081E:  CLRF   xCC
....................          }else{ 
00820:  BRA    0824
....................             // Activa Bandera de IP_STACION, reinicia el contador de Pos 
....................             flag_Pos_Get_IP_CMD =0; 
00822:  CLRF   xCC
....................          } 
....................  
....................       }else{ 
00824:  BRA    0858
00826:  MOVLB  1
....................          if(modeStar=='1'){ 
00828:  MOVLB  0
0082A:  MOVF   xD1,W
0082C:  SUBLW  31
0082E:  BNZ   0844
....................             // IP Estacion 
....................             buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
00830:  CLRF   03
00832:  MOVF   xCC,W
00834:  ADDLW  8B
00836:  MOVWF  FE9
00838:  MOVLW  00
0083A:  ADDWFC 03,W
0083C:  MOVWF  FEA
0083E:  MOVFF  12D,FEF
....................          }else{ 
00842:  BRA    0856
....................             // IP AP 
....................              buffer_Resp_CMD[0][flag_Pos_Get_IP_CMD] = buffer; 
00844:  CLRF   03
00846:  MOVF   xCC,W
00848:  ADDLW  7B
0084A:  MOVWF  FE9
0084C:  MOVLW  00
0084E:  ADDWFC 03,W
00850:  MOVWF  FEA
00852:  MOVFF  12D,FEF
....................          } 
....................          flag_Pos_Get_IP_CMD++; 
00856:  INCF   xCC,F
....................       } // Fin del if(buffer == '"') 
....................     
....................    // bandera de IP_Second(Estacion) esta habilita 
....................    }else if(flag_Resp_Get_IP_CMD==5){ 
00858:  BRA    088A
0085A:  MOVF   xCB,W
0085C:  SUBLW  05
0085E:  BNZ   088A
....................        if(buffer == '"'){ 
00860:  MOVLB  1
00862:  MOVF   x2D,W
00864:  SUBLW  22
00866:  BNZ   0874
....................          flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
00868:  MOVLW  06
0086A:  MOVLB  0
0086C:  MOVWF  xCB
....................          flag_Pos_Get_IP_CMD =0; 
0086E:  CLRF   xCC
....................        }else{ 
00870:  BRA    088A
00872:  MOVLB  1
....................          buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
00874:  CLRF   03
00876:  MOVLB  0
00878:  MOVF   xCC,W
0087A:  ADDLW  8B
0087C:  MOVWF  FE9
0087E:  MOVLW  00
00880:  ADDWFC 03,W
00882:  MOVWF  FEA
00884:  MOVFF  12D,FEF
....................          flag_Pos_Get_IP_CMD++; 
00888:  INCF   xCC,F
....................        } 
....................    } // Fin de if(flag_Resp_Get_IP_CMD) 
....................        
....................    if( buffer == '"'){ 
0088A:  MOVLB  1
0088C:  MOVF   x2D,W
0088E:  SUBLW  22
00890:  BNZ   08A6
....................       switch(flag_Resp_Get_IP_CMD){ 
00892:  MOVLB  0
00894:  MOVF   xCB,W
00896:  ADDLW  FB
00898:  BC    08A4
0089A:  ADDLW  05
0089C:  GOTO   08AC
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................          case 4: 
....................             flag_Resp_Get_IP_CMD++; 
008A0:  INCF   xCB,F
....................             flag_Pos_Get_IP_CMD =0; 
008A2:  CLRF   xCC
....................             break; 
008A4:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
008A6:  MOVLB  0
008A8:  GOTO   0B52 (RETURN)
.................... } // Fin de la funcion getIP() 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo AP, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getAPInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_AP_Info_CMD==1){ 
*
008D0:  DECFSZ xCD,W
008D2:  BRA    08F8
....................        
....................       if(buffer != '"'){ 
008D4:  MOVLB  1
008D6:  MOVF   x2D,W
008D8:  SUBLW  22
008DA:  BZ    08F4
....................          buffer_Resp_CMD[2][flag_Pos_Get_AP_Info_CMD] = buffer; 
008DC:  CLRF   03
008DE:  MOVLB  0
008E0:  MOVF   xCE,W
008E2:  ADDLW  9B
008E4:  MOVWF  FE9
008E6:  MOVLW  00
008E8:  ADDWFC 03,W
008EA:  MOVWF  FEA
008EC:  MOVFF  12D,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
008F0:  INCF   xCE,F
008F2:  MOVLB  1
....................       } 
....................  
....................    }else if(flag_Resp_Get_AP_Info_CMD==3){ 
008F4:  BRA    0926
008F6:  MOVLB  0
008F8:  MOVF   xCD,W
008FA:  SUBLW  03
008FC:  BNZ   0924
....................        
....................       if(buffer != '"'){ 
008FE:  MOVLB  1
00900:  MOVF   x2D,W
00902:  SUBLW  22
00904:  BZ    0920
....................          buffer_Resp_CMD[3][flag_Pos_Get_AP_Info_CMD] = buffer; 
00906:  CLRF   03
00908:  MOVLB  0
0090A:  MOVF   xCE,W
0090C:  ADDLW  AB
0090E:  MOVWF  FE9
00910:  MOVLW  00
00912:  ADDWFC 03,W
00914:  MOVWF  FEA
00916:  MOVFF  12D,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
0091A:  INCF   xCE,F
....................       }else{ 
0091C:  BRA    0924
0091E:  MOVLB  1
....................          flag_Pos_Get_AP_Info_CMD =0; 
00920:  MOVLB  0
00922:  CLRF   xCE
00924:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
00926:  MOVF   x2D,W
00928:  SUBLW  22
0092A:  BNZ   0940
....................       switch(flag_Resp_Get_AP_Info_CMD){ 
0092C:  MOVLB  0
0092E:  MOVF   xCD,W
00930:  ADDLW  FC
00932:  BC    093E
00934:  ADDLW  04
00936:  GOTO   0946
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................             flag_Resp_Get_AP_Info_CMD++; 
0093A:  INCF   xCD,F
....................             flag_Pos_Get_AP_Info_CMD =0; 
0093C:  CLRF   xCE
....................             break; 
0093E:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
00940:  MOVLB  0
00942:  GOTO   0B66 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo STA 
....................  *     
....................  *********************************************************/ 
.................... void getSTAInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_STA_Info_CMD==1){ 
*
00968:  DECFSZ xCF,W
0096A:  BRA    098A
....................        
....................       if(buffer != '"'){ 
0096C:  MOVLB  1
0096E:  MOVF   x2D,W
00970:  SUBLW  22
00972:  BZ    098C
....................          buffer_Resp_CMD[4][flag_Pos_Get_STA_Info_CMD] = buffer; 
00974:  CLRF   03
00976:  MOVLB  0
00978:  MOVF   xD0,W
0097A:  ADDLW  BB
0097C:  MOVWF  FE9
0097E:  MOVLW  00
00980:  ADDWFC 03,W
00982:  MOVWF  FEA
00984:  MOVFF  12D,FEF
....................          flag_Pos_Get_STA_Info_CMD++; 
00988:  INCF   xD0,F
0098A:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
0098C:  MOVF   x2D,W
0098E:  SUBLW  22
00990:  BNZ   09A4
....................       switch(flag_Resp_Get_STA_Info_CMD){ 
00992:  MOVLB  0
00994:  MOVF   xCF,W
00996:  BZ    099E
00998:  XORLW  01
0099A:  BZ    099E
0099C:  BRA    09A2
....................          case 0: 
....................          case 1: 
....................             flag_Resp_Get_STA_Info_CMD++; 
0099E:  INCF   xCF,F
....................             flag_Pos_Get_STA_Info_CMD =0; 
009A0:  CLRF   xD0
....................             break; 
009A2:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_STA_Info_CMD) 
....................    } // Fin del if(buffer == '"')  
009A4:  MOVLB  0
009A6:  GOTO   0B7A (RETURN)
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_STA_IP     0 
....................   #define OPT_SHOW_STA_SSID   1 
....................   #define OPT_SHOW_AP_SSID    2 
....................   #define OPT_SHOW_AP_KEY     3 
....................   #define OPT_SHOW_AP_IP      4 
....................   #define OPT_MODE_AP         5 
....................   #define OPT_BACKLIGH        6 
....................   #define OPT_EXIT            7 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[9][17]    =  { {"ESTACION IP     "}, 
....................                                         {"ESTACION SSID   "}, 
....................                                         {"AP SSID         "}, 
....................                                         {"AP KEY          "}, 
....................                                         {"AP IP           "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacin     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 7; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
01988:  MOVLB  1
0198A:  CLRF   x0A
0198C:  CLRF   x0B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0198E:  MOVF   x0A,W
01990:  MULLW  10
01992:  MOVF   FF3,W
01994:  CLRF   03
01996:  MOVWF  x0C
01998:  MOVLW  0C
0199A:  MOVWF  x12
0199C:  MOVLB  0
0199E:  CALL   0E0C
019A2:  MOVLW  48
019A4:  MOVWF  FF6
019A6:  MOVLW  02
019A8:  MOVWF  FF7
019AA:  MOVLB  1
019AC:  MOVF   x0C,W
019AE:  ADDWF  FF6,F
019B0:  MOVLW  00
019B2:  ADDWFC FF7,F
019B4:  MOVLB  0
019B6:  CALL   0E78
....................    showBottonMenu(); 
019BA:  RCALL  11F4
....................    while(!exit){ 
019BC:  MOVLB  1
019BE:  MOVF   x0B,F
019C0:  BNZ   1A6A
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
019C2:  MOVLB  0
019C4:  RCALL  1250
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
019C6:  BSF    F93.4
019C8:  BTFSC  F81.4
019CA:  BRA    1A30
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
019CC:  MOVLW  02
019CE:  MOVLB  1
019D0:  MOVWF  x0C
019D2:  MOVLW  FA
019D4:  MOVWF  x21
019D6:  MOVLB  0
019D8:  CALL   0BDC
019DC:  MOVLB  1
019DE:  DECFSZ x0C,F
019E0:  BRA    19D2
....................          BEEP; 
019E2:  MOVLW  04
019E4:  MOVWF  x10
019E6:  MOVLW  B9
019E8:  MOVWF  x0F
019EA:  CLRF   x12
019EC:  MOVLW  14
019EE:  MOVWF  x11
019F0:  MOVLB  0
019F2:  RCALL  1840
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
019F4:  MOVLB  1
019F6:  INCF   x0A,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
019F8:  MOVF   x0A,W
019FA:  SUBWF  x04,W
019FC:  BC    1A00
....................             optSelected = 0; 
019FE:  CLRF   x0A
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
01A00:  MOVF   x0A,W
01A02:  MULLW  10
01A04:  MOVF   FF3,W
01A06:  CLRF   03
01A08:  MOVWF  x0C
01A0A:  MOVLW  0C
01A0C:  MOVWF  x12
01A0E:  MOVLB  0
01A10:  CALL   0E0C
01A14:  MOVLW  48
01A16:  MOVWF  FF6
01A18:  MOVLW  02
01A1A:  MOVWF  FF7
01A1C:  MOVLB  1
01A1E:  MOVF   x0C,W
01A20:  ADDWF  FF6,F
01A22:  MOVLW  00
01A24:  ADDWFC FF7,F
01A26:  MOVLB  0
01A28:  CALL   0E78
....................          showBottonMenu(); 
01A2C:  CALL   11F4
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01A30:  BSF    F93.5
01A32:  BTFSC  F81.5
01A34:  BRA    1A66
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01A36:  MOVLW  02
01A38:  MOVLB  1
01A3A:  MOVWF  x0C
01A3C:  MOVLW  FA
01A3E:  MOVWF  x21
01A40:  MOVLB  0
01A42:  CALL   0BDC
01A46:  MOVLB  1
01A48:  DECFSZ x0C,F
01A4A:  BRA    1A3C
....................          BEEP; 
01A4C:  MOVLW  04
01A4E:  MOVWF  x10
01A50:  MOVLW  B9
01A52:  MOVWF  x0F
01A54:  CLRF   x12
01A56:  MOVLW  14
01A58:  MOVWF  x11
01A5A:  MOVLB  0
01A5C:  RCALL  1840
....................          // Rompe el Loop 
....................          exit = 1; 
01A5E:  MOVLW  01
01A60:  MOVLB  1
01A62:  MOVWF  x0B
01A64:  MOVLB  0
....................       } // Fin KEY_OK 
01A66:  BRA    19BC
01A68:  MOVLB  1
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
01A6A:  MOVLW  01
01A6C:  ADDWF  x0A,W
01A6E:  MOVWF  01
01A70:  MOVLB  0
01A72:  GOTO   23D6 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
01D16:  MOVLW  0C
01D18:  MOVLB  1
01D1A:  MOVWF  x13
01D1C:  MOVLW  02
01D1E:  MOVWF  x14
01D20:  MOVLB  0
01D22:  CALL   0DE6
....................   printf(lcd_putc, "SALIR"); 
01D26:  MOVLW  9E
01D28:  MOVWF  FF6
01D2A:  MOVLW  04
01D2C:  MOVWF  FF7
01D2E:  CALL   0E78
....................    
....................   while(1){ 
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01D32:  CALL   1250
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
01D36:  BSF    F93.5
01D38:  BTFSC  F81.5
01D3A:  BRA    1D56
....................            // Elimina el rebote 
....................            delay_ms(500); 
01D3C:  MOVLW  02
01D3E:  MOVLB  1
01D40:  MOVWF  x0F
01D42:  MOVLW  FA
01D44:  MOVWF  x21
01D46:  MOVLB  0
01D48:  CALL   0BDC
01D4C:  MOVLB  1
01D4E:  DECFSZ x0F,F
01D50:  BRA    1D42
....................            break; 
01D52:  BRA    1D5A
01D54:  MOVLB  0
....................      } 
01D56:  BRA    1D32
01D58:  MOVLB  1
....................   } 
01D5A:  MOVLB  0
01D5C:  RETURN 0
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
011F4:  MOVLW  01
011F6:  MOVLB  1
011F8:  MOVWF  x13
011FA:  MOVLW  02
011FC:  MOVWF  x14
011FE:  MOVLB  0
01200:  RCALL  0DE6
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
01202:  MOVLW  A4
01204:  MOVWF  FF6
01206:  MOVLW  04
01208:  MOVWF  FF7
0120A:  RCALL  0E78
0120C:  RETURN 0
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
01A76:  MOVLB  1
01A78:  CLRF   x0A
01A7A:  CLRF   x0B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
01A7C:  MOVF   x0A,W
01A7E:  MULLW  0F
01A80:  MOVF   FF3,W
01A82:  CLRF   03
01A84:  MOVWF  x0C
01A86:  MOVLW  0C
01A88:  MOVWF  x12
01A8A:  MOVLB  0
01A8C:  CALL   0E0C
01A90:  MOVLW  88
01A92:  MOVWF  FF6
01A94:  MOVLW  02
01A96:  MOVWF  FF7
01A98:  MOVLB  1
01A9A:  MOVF   x0C,W
01A9C:  ADDWF  FF6,F
01A9E:  MOVLW  00
01AA0:  ADDWFC FF7,F
01AA2:  MOVLB  0
01AA4:  CALL   0E78
....................    showBottonMenu(); 
01AA8:  CALL   11F4
....................     
....................    while(!exit){ 
01AAC:  MOVLB  1
01AAE:  MOVF   x0B,F
01AB0:  BTFSS  FD8.2
01AB2:  BRA    1BAA
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01AB4:  MOVLB  0
01AB6:  CALL   1250
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01ABA:  BSF    F93.4
01ABC:  BTFSC  F81.4
01ABE:  BRA    1B24
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01AC0:  MOVLW  02
01AC2:  MOVLB  1
01AC4:  MOVWF  x0C
01AC6:  MOVLW  FA
01AC8:  MOVWF  x21
01ACA:  MOVLB  0
01ACC:  CALL   0BDC
01AD0:  MOVLB  1
01AD2:  DECFSZ x0C,F
01AD4:  BRA    1AC6
....................          BEEP; 
01AD6:  MOVLW  04
01AD8:  MOVWF  x10
01ADA:  MOVLW  B9
01ADC:  MOVWF  x0F
01ADE:  CLRF   x12
01AE0:  MOVLW  14
01AE2:  MOVWF  x11
01AE4:  MOVLB  0
01AE6:  RCALL  1840
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
01AE8:  MOVLB  1
01AEA:  INCF   x0A,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
01AEC:  MOVF   x0A,W
01AEE:  SUBWF  x05,W
01AF0:  BC    1AF4
....................             optSelected = 0; 
01AF2:  CLRF   x0A
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
01AF4:  MOVF   x0A,W
01AF6:  MULLW  0F
01AF8:  MOVF   FF3,W
01AFA:  CLRF   03
01AFC:  MOVWF  x0C
01AFE:  MOVLW  0C
01B00:  MOVWF  x12
01B02:  MOVLB  0
01B04:  CALL   0E0C
01B08:  MOVLW  88
01B0A:  MOVWF  FF6
01B0C:  MOVLW  02
01B0E:  MOVWF  FF7
01B10:  MOVLB  1
01B12:  MOVF   x0C,W
01B14:  ADDWF  FF6,F
01B16:  MOVLW  00
01B18:  ADDWFC FF7,F
01B1A:  MOVLB  0
01B1C:  CALL   0E78
....................          showBottonMenu(); 
01B20:  CALL   11F4
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01B24:  BSF    F93.5
01B26:  BTFSC  F81.5
01B28:  BRA    1BA6
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01B2A:  MOVLW  02
01B2C:  MOVLB  1
01B2E:  MOVWF  x0C
01B30:  MOVLW  FA
01B32:  MOVWF  x21
01B34:  MOVLB  0
01B36:  CALL   0BDC
01B3A:  MOVLB  1
01B3C:  DECFSZ x0C,F
01B3E:  BRA    1B30
....................          BEEP; 
01B40:  MOVLW  04
01B42:  MOVWF  x10
01B44:  MOVLW  B9
01B46:  MOVWF  x0F
01B48:  CLRF   x12
01B4A:  MOVLW  14
01B4C:  MOVWF  x11
01B4E:  MOVLB  0
01B50:  RCALL  1840
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuOn){ 
01B52:  MOVLB  1
01B54:  MOVF   x05,W
01B56:  SUBWF  x0A,W
01B58:  BNZ   1B60
....................             exit = 1; 
01B5A:  MOVLW  01
01B5C:  MOVWF  x0B
....................          }else{ 
01B5E:  BRA    1BA8
....................             output_high(PIN_OUT[optSelected]); 
01B60:  BCF    FD8.0
01B62:  RLCF   x0A,W
01B64:  CLRF   03
01B66:  ADDLW  16
01B68:  MOVWF  FE9
01B6A:  MOVLW  00
01B6C:  ADDWFC 03,W
01B6E:  MOVWF  FEA
01B70:  MOVFF  FEC,10D
01B74:  MOVF   FED,F
01B76:  MOVFF  FEF,10C
01B7A:  MOVFF  10C,122
01B7E:  MOVLW  01
01B80:  MOVWF  x23
01B82:  MOVLW  0F
01B84:  MOVWF  x25
01B86:  MOVLW  89
01B88:  MOVWF  x24
01B8A:  MOVLB  0
01B8C:  CALL   120E
01B90:  MOVFF  10C,122
01B94:  MOVLB  1
01B96:  CLRF   x23
01B98:  MOVLW  0F
01B9A:  MOVWF  x25
01B9C:  MOVLW  92
01B9E:  MOVWF  x24
01BA0:  MOVLB  0
01BA2:  CALL   120E
01BA6:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
01BA8:  BRA    1AAE
....................    } // FIN While Infinito 
....................  
....................    return 0; 
01BAA:  MOVLW  00
01BAC:  MOVWF  01
01BAE:  MOVLB  0
01BB0:  GOTO   23E2 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
01BB4:  MOVLB  1
01BB6:  CLRF   x0A
01BB8:  CLRF   x0B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
01BBA:  MOVF   x0A,W
01BBC:  MULLW  10
01BBE:  MOVF   FF3,W
01BC0:  CLRF   03
01BC2:  MOVWF  x0C
01BC4:  MOVLW  0C
01BC6:  MOVWF  x12
01BC8:  MOVLB  0
01BCA:  CALL   0E0C
01BCE:  MOVLW  1E
01BD0:  MOVWF  FF6
01BD2:  MOVLW  03
01BD4:  MOVWF  FF7
01BD6:  MOVLB  1
01BD8:  MOVF   x0C,W
01BDA:  ADDWF  FF6,F
01BDC:  MOVLW  00
01BDE:  ADDWFC FF7,F
01BE0:  MOVLB  0
01BE2:  CALL   0E78
....................    showBottonMenu(); 
01BE6:  CALL   11F4
....................     
....................    while(!exit){ 
01BEA:  MOVLB  1
01BEC:  MOVF   x0B,F
01BEE:  BTFSS  FD8.2
01BF0:  BRA    1CE6
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01BF2:  MOVLB  0
01BF4:  CALL   1250
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01BF8:  BSF    F93.4
01BFA:  BTFSC  F81.4
01BFC:  BRA    1C62
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01BFE:  MOVLW  02
01C00:  MOVLB  1
01C02:  MOVWF  x0C
01C04:  MOVLW  FA
01C06:  MOVWF  x21
01C08:  MOVLB  0
01C0A:  CALL   0BDC
01C0E:  MOVLB  1
01C10:  DECFSZ x0C,F
01C12:  BRA    1C04
....................          BEEP; 
01C14:  MOVLW  04
01C16:  MOVWF  x10
01C18:  MOVLW  B9
01C1A:  MOVWF  x0F
01C1C:  CLRF   x12
01C1E:  MOVLW  14
01C20:  MOVWF  x11
01C22:  MOVLB  0
01C24:  RCALL  1840
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
01C26:  MOVLB  1
01C28:  INCF   x0A,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
01C2A:  MOVF   x0A,W
01C2C:  SUBWF  x06,W
01C2E:  BC    1C32
....................             optSelected = 0; 
01C30:  CLRF   x0A
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
01C32:  MOVF   x0A,W
01C34:  MULLW  10
01C36:  MOVF   FF3,W
01C38:  CLRF   03
01C3A:  MOVWF  x0C
01C3C:  MOVLW  0C
01C3E:  MOVWF  x12
01C40:  MOVLB  0
01C42:  CALL   0E0C
01C46:  MOVLW  1E
01C48:  MOVWF  FF6
01C4A:  MOVLW  03
01C4C:  MOVWF  FF7
01C4E:  MOVLB  1
01C50:  MOVF   x0C,W
01C52:  ADDWF  FF6,F
01C54:  MOVLW  00
01C56:  ADDWFC FF7,F
01C58:  MOVLB  0
01C5A:  CALL   0E78
....................          showBottonMenu(); 
01C5E:  CALL   11F4
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01C62:  BSF    F93.5
01C64:  BTFSC  F81.5
01C66:  BRA    1CE2
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01C68:  MOVLW  02
01C6A:  MOVLB  1
01C6C:  MOVWF  x0C
01C6E:  MOVLW  FA
01C70:  MOVWF  x21
01C72:  MOVLB  0
01C74:  CALL   0BDC
01C78:  MOVLB  1
01C7A:  DECFSZ x0C,F
01C7C:  BRA    1C6E
....................          BEEP; 
01C7E:  MOVLW  04
01C80:  MOVWF  x10
01C82:  MOVLW  B9
01C84:  MOVWF  x0F
01C86:  CLRF   x12
01C88:  MOVLW  14
01C8A:  MOVWF  x11
01C8C:  MOVLB  0
01C8E:  RCALL  1840
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
01C90:  MOVLB  1
01C92:  MOVF   x06,W
01C94:  SUBWF  x0A,W
01C96:  BNZ   1C9E
....................             exit = 1; 
01C98:  MOVLW  01
01C9A:  MOVWF  x0B
....................          }else{ 
01C9C:  BRA    1CE4
....................             output_low(PIN_OUT[optSelected]); 
01C9E:  BCF    FD8.0
01CA0:  RLCF   x0A,W
01CA2:  CLRF   03
01CA4:  ADDLW  16
01CA6:  MOVWF  FE9
01CA8:  MOVLW  00
01CAA:  ADDWFC 03,W
01CAC:  MOVWF  FEA
01CAE:  MOVFF  FEC,10D
01CB2:  MOVF   FED,F
01CB4:  MOVFF  FEF,10C
01CB8:  MOVFF  10C,122
01CBC:  CLRF   x23
01CBE:  MOVLW  0F
01CC0:  MOVWF  x25
01CC2:  MOVLW  89
01CC4:  MOVWF  x24
01CC6:  MOVLB  0
01CC8:  CALL   120E
01CCC:  MOVFF  10C,122
01CD0:  MOVLB  1
01CD2:  CLRF   x23
01CD4:  MOVLW  0F
01CD6:  MOVWF  x25
01CD8:  MOVLW  92
01CDA:  MOVWF  x24
01CDC:  MOVLB  0
01CDE:  CALL   120E
01CE2:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
01CE4:  BRA    1BEC
....................    } // FIN While Infinito 
....................  
....................    return 0; 
01CE6:  MOVLW  00
01CE8:  MOVWF  01
01CEA:  MOVLB  0
01CEC:  GOTO   23EE (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
....................  
....................    /******************************************** 
....................    *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................    *********************************************/ 
....................    run_command_wifi(); 
*
0216E:  CALL   1250
....................    /********************************************/ 
....................     
....................    int optSelected = 0; 
....................    int exit = 0; 
02172:  MOVLB  1
02174:  CLRF   x0A
02176:  CLRF   x0B
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02178:  MOVF   x0A,W
0217A:  MULLW  11
0217C:  MOVF   FF3,W
0217E:  CLRF   03
02180:  MOVWF  x0C
02182:  MOVLW  0C
02184:  MOVWF  x12
02186:  MOVLB  0
02188:  CALL   0E0C
0218C:  MOVLW  BE
0218E:  MOVWF  FF6
02190:  MOVLW  03
02192:  MOVWF  FF7
02194:  MOVLB  1
02196:  MOVF   x0C,W
02198:  ADDWF  FF6,F
0219A:  MOVLW  00
0219C:  ADDWFC FF7,F
0219E:  MOVLB  0
021A0:  CALL   0E78
....................    showBottonMenu(); 
021A4:  CALL   11F4
....................     
....................    while(!exit){ 
021A8:  MOVLB  1
021AA:  MOVF   x0B,F
021AC:  BNZ   2294
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
021AE:  BSF    F93.4
021B0:  BTFSC  F81.4
021B2:  BRA    221A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
021B4:  MOVLW  02
021B6:  MOVWF  x0C
021B8:  MOVLW  FA
021BA:  MOVWF  x21
021BC:  MOVLB  0
021BE:  CALL   0BDC
021C2:  MOVLB  1
021C4:  DECFSZ x0C,F
021C6:  BRA    21B8
....................          BEEP; 
021C8:  MOVLW  04
021CA:  MOVWF  x10
021CC:  MOVLW  B9
021CE:  MOVWF  x0F
021D0:  CLRF   x12
021D2:  MOVLW  14
021D4:  MOVWF  x11
021D6:  MOVLB  0
021D8:  CALL   1840
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
021DC:  MOVLB  1
021DE:  INCF   x0A,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
021E0:  MOVF   x0A,W
021E2:  SUBWF  x07,W
021E4:  BC    21E8
....................             optSelected = 0; 
021E6:  CLRF   x0A
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
021E8:  MOVF   x0A,W
021EA:  MULLW  11
021EC:  MOVF   FF3,W
021EE:  CLRF   03
021F0:  MOVWF  x0C
021F2:  MOVLW  0C
021F4:  MOVWF  x12
021F6:  MOVLB  0
021F8:  CALL   0E0C
021FC:  MOVLW  BE
021FE:  MOVWF  FF6
02200:  MOVLW  03
02202:  MOVWF  FF7
02204:  MOVLB  1
02206:  MOVF   x0C,W
02208:  ADDWF  FF6,F
0220A:  MOVLW  00
0220C:  ADDWFC FF7,F
0220E:  MOVLB  0
02210:  CALL   0E78
....................          showBottonMenu(); 
02214:  CALL   11F4
02218:  MOVLB  1
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0221A:  BSF    F93.5
0221C:  BTFSC  F81.5
0221E:  BRA    2292
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02220:  MOVLW  02
02222:  MOVWF  x0C
02224:  MOVLW  FA
02226:  MOVWF  x21
02228:  MOVLB  0
0222A:  CALL   0BDC
0222E:  MOVLB  1
02230:  DECFSZ x0C,F
02232:  BRA    2224
....................          BEEP; 
02234:  MOVLW  04
02236:  MOVWF  x10
02238:  MOVLW  B9
0223A:  MOVWF  x0F
0223C:  CLRF   x12
0223E:  MOVLW  14
02240:  MOVWF  x11
02242:  MOVLB  0
02244:  CALL   1840
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
02248:  MOVLB  1
0224A:  MOVF   x07,W
0224C:  SUBWF  x0A,W
0224E:  BNZ   2256
....................             exit = 1; 
02250:  MOVLW  01
02252:  MOVWF  x0B
....................          }else{ 
02254:  BRA    2292
....................             executeSetup(optSelected); 
02256:  MOVFF  10A,10C
0225A:  MOVLB  0
0225C:  BRA    1F86
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0225E:  MOVLB  1
02260:  MOVF   x0A,W
02262:  MULLW  11
02264:  MOVF   FF3,W
02266:  CLRF   03
02268:  MOVWF  x0C
0226A:  MOVLW  0C
0226C:  MOVWF  x12
0226E:  MOVLB  0
02270:  CALL   0E0C
02274:  MOVLW  BE
02276:  MOVWF  FF6
02278:  MOVLW  03
0227A:  MOVWF  FF7
0227C:  MOVLB  1
0227E:  MOVF   x0C,W
02280:  ADDWF  FF6,F
02282:  MOVLW  00
02284:  ADDWFC FF7,F
02286:  MOVLB  0
02288:  CALL   0E78
....................             showBottonMenu(); 
0228C:  CALL   11F4
02290:  MOVLB  1
....................          } 
....................       } // Fin KEY_OK 
02292:  BRA    21AA
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02294:  MOVLW  00
02296:  MOVWF  01
02298:  MOVLB  0
0229A:  GOTO   23F8 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................     
....................    
....................   switch(optSelect){ 
*
01F86:  MOVLB  1
01F88:  MOVF   x0C,W
01F8A:  ADDLW  F8
01F8C:  BTFSC  FD8.0
01F8E:  BRA    2128
01F90:  ADDLW  08
01F92:  MOVLB  0
01F94:  GOTO   213A
....................    
....................      case OPT_SHOW_AP_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
01F98:  MOVLW  B6
01F9A:  MOVWF  FF6
01F9C:  MOVLW  04
01F9E:  MOVWF  FF7
01FA0:  CALL   0EC2
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
01FA4:  MOVLW  05
01FA6:  MOVWF  6B
....................         printf(lcd_putc, "\fCargando..."); 
01FA8:  MOVLW  C2
01FAA:  MOVWF  FF6
01FAC:  MOVLW  04
01FAE:  MOVWF  FF7
01FB0:  CALL   0E78
....................         waitResp(); 
01FB4:  CALL   0EE4
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[0]); 
01FB8:  MOVLW  0C
01FBA:  MOVLB  1
01FBC:  MOVWF  x12
01FBE:  MOVLB  0
01FC0:  CALL   0E0C
01FC4:  CLRF   FEA
01FC6:  MOVLW  7B
01FC8:  MOVWF  FE9
01FCA:  RCALL  1CF0
....................         flag_Resp_Get_IP_CMD = 0; 
01FCC:  CLRF   xCB
....................         break; 
01FCE:  MOVLB  1
01FD0:  BRA    2128
....................          
....................      case OPT_SHOW_STA_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
01FD2:  MOVLW  D0
01FD4:  MOVWF  FF6
01FD6:  MOVLW  04
01FD8:  MOVWF  FF7
01FDA:  CALL   0EC2
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
01FDE:  MOVLW  05
01FE0:  MOVWF  6B
....................         printf(lcd_putc, "\fCargando..."); 
01FE2:  MOVLW  DC
01FE4:  MOVWF  FF6
01FE6:  MOVLW  04
01FE8:  MOVWF  FF7
01FEA:  CALL   0E78
....................         waitResp(); 
01FEE:  CALL   0EE4
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[1]); 
01FF2:  MOVLW  0C
01FF4:  MOVLB  1
01FF6:  MOVWF  x12
01FF8:  MOVLB  0
01FFA:  CALL   0E0C
01FFE:  CLRF   FEA
02000:  MOVLW  8B
02002:  MOVWF  FE9
02004:  RCALL  1CF0
....................         flag_Resp_Get_IP_CMD = 0; 
02006:  CLRF   xCB
....................         break; 
02008:  MOVLB  1
0200A:  BRA    2128
....................          
....................      case OPT_SHOW_STA_SSID: 
....................         if(modeStar!='2'){ 
0200C:  MOVF   xD1,W
0200E:  SUBLW  32
02010:  BZ    204A
....................            fprintf(ESP8266, "AT+CWJAP?\r\n"); 
02012:  MOVLW  EA
02014:  MOVWF  FF6
02016:  MOVLW  04
02018:  MOVWF  FF7
0201A:  CALL   0EC2
....................            CMD_RUN = CMD_GET_STA_INFO_FROM_MENU; 
0201E:  MOVLW  07
02020:  MOVWF  6B
....................            printf(lcd_putc, "\fCargando..."); 
02022:  MOVLW  F6
02024:  MOVWF  FF6
02026:  MOVLW  04
02028:  MOVWF  FF7
0202A:  CALL   0E78
....................            waitResp(); 
0202E:  CALL   0EE4
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[4]); 
02032:  MOVLW  0C
02034:  MOVLB  1
02036:  MOVWF  x12
02038:  MOVLB  0
0203A:  CALL   0E0C
0203E:  CLRF   FEA
02040:  MOVLW  BB
02042:  MOVWF  FE9
02044:  RCALL  1CF0
....................            flag_Resp_Get_STA_Info_CMD=0; 
02046:  CLRF   xCF
....................         }else{ 
02048:  BRA    2056
....................            printf(lcd_putc, "\fDeshabilitado"); 
0204A:  MOVLW  04
0204C:  MOVWF  FF6
0204E:  MOVLW  05
02050:  MOVWF  FF7
02052:  CALL   0E78
....................         } 
....................         break; 
02056:  MOVLB  1
02058:  BRA    2128
....................          
....................      case OPT_SHOW_AP_SSID: 
....................         if(modeStar!='1'){ 
0205A:  MOVF   xD1,W
0205C:  SUBLW  31
0205E:  BZ    2098
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
02060:  MOVLW  14
02062:  MOVWF  FF6
02064:  MOVLW  05
02066:  MOVWF  FF7
02068:  CALL   0EC2
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
0206C:  MOVLW  06
0206E:  MOVWF  6B
....................            printf(lcd_putc, "\fCargando..."); 
02070:  MOVLW  20
02072:  MOVWF  FF6
02074:  MOVLW  05
02076:  MOVWF  FF7
02078:  CALL   0E78
....................            waitResp(); 
0207C:  CALL   0EE4
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[2]); 
02080:  MOVLW  0C
02082:  MOVLB  1
02084:  MOVWF  x12
02086:  MOVLB  0
02088:  CALL   0E0C
0208C:  CLRF   FEA
0208E:  MOVLW  9B
02090:  MOVWF  FE9
02092:  RCALL  1CF0
....................            flag_Resp_Get_AP_Info_CMD=0; 
02094:  CLRF   xCD
....................         }else{ 
02096:  BRA    20A4
....................            printf(lcd_putc, "\fDeshabilitado"); 
02098:  MOVLW  2E
0209A:  MOVWF  FF6
0209C:  MOVLW  05
0209E:  MOVWF  FF7
020A0:  CALL   0E78
....................         } 
....................         break; 
020A4:  MOVLB  1
020A6:  BRA    2128
....................          
....................      case OPT_SHOW_AP_KEY: 
....................         if(modeStar!='1'){ 
020A8:  MOVF   xD1,W
020AA:  SUBLW  31
020AC:  BZ    20E6
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
020AE:  MOVLW  3E
020B0:  MOVWF  FF6
020B2:  MOVLW  05
020B4:  MOVWF  FF7
020B6:  CALL   0EC2
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
020BA:  MOVLW  06
020BC:  MOVWF  6B
....................            printf(lcd_putc, "\fCargando..."); 
020BE:  MOVLW  4A
020C0:  MOVWF  FF6
020C2:  MOVLW  05
020C4:  MOVWF  FF7
020C6:  CALL   0E78
....................            waitResp(); 
020CA:  CALL   0EE4
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[3]); 
020CE:  MOVLW  0C
020D0:  MOVLB  1
020D2:  MOVWF  x12
020D4:  MOVLB  0
020D6:  CALL   0E0C
020DA:  CLRF   FEA
020DC:  MOVLW  AB
020DE:  MOVWF  FE9
020E0:  RCALL  1CF0
....................            flag_Resp_Get_AP_Info_CMD=0; 
020E2:  CLRF   xCD
....................         }else{ 
020E4:  BRA    20F2
....................            printf(lcd_putc, "\fDeshabilitado"); 
020E6:  MOVLW  58
020E8:  MOVWF  FF6
020EA:  MOVLW  05
020EC:  MOVWF  FF7
020EE:  CALL   0E78
....................         } 
....................         break; 
020F2:  MOVLB  1
020F4:  BRA    2128
....................          
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
020F6:  BRA    1D5E
....................         break; 
020F8:  MOVLB  1
020FA:  BRA    2128
....................          
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
020FC:  BCF    F95.3
020FE:  BTG    F8C.3
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
02100:  BTFSS  F83.3
02102:  BRA    2112
....................            printf(lcd_putc, "\fBacklight On"); 
02104:  MOVLW  68
02106:  MOVWF  FF6
02108:  MOVLW  05
0210A:  MOVWF  FF7
0210C:  CALL   0E78
....................         }else{ 
02110:  BRA    211E
....................            printf(lcd_putc, "\fBacklight Off"); 
02112:  MOVLW  76
02114:  MOVWF  FF6
02116:  MOVLW  05
02118:  MOVWF  FF7
0211A:  CALL   0E78
....................         } 
....................         break; 
0211E:  MOVLB  1
02120:  BRA    2128
....................          
....................      case OPT_EXIT: 
....................         break; 
02122:  MOVLB  1
02124:  BRA    2128
02126:  MOVLB  1
....................          
....................   } 
....................    
....................   if(optSelect!=OPT_EXIT){ 
02128:  MOVF   x0C,W
0212A:  SUBLW  07
0212C:  BZ    2134
....................    pressExit(); 
0212E:  MOVLB  0
02130:  RCALL  1D16
02132:  MOVLB  1
....................   } 
02134:  MOVLB  0
02136:  GOTO   225E (RETURN)
.................... } 
....................    
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
*
01D5E:  MOVLB  1
01D60:  CLRF   x0D
01D62:  CLRF   x0E
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
01D64:  MOVF   x0D,W
01D66:  MULLW  0E
01D68:  MOVF   FF3,W
01D6A:  CLRF   03
01D6C:  MOVWF  x0F
01D6E:  MOVLW  0C
01D70:  MOVWF  x12
01D72:  MOVLB  0
01D74:  CALL   0E0C
01D78:  MOVLW  58
01D7A:  MOVWF  FF6
01D7C:  MOVLW  04
01D7E:  MOVWF  FF7
01D80:  MOVLB  1
01D82:  MOVF   x0F,W
01D84:  ADDWF  FF6,F
01D86:  MOVLW  00
01D88:  ADDWFC FF7,F
01D8A:  MOVLB  0
01D8C:  CALL   0E78
....................   showBottonMenu(); 
01D90:  CALL   11F4
....................    
....................   while(!exit){ 
01D94:  MOVLB  1
01D96:  MOVF   x0E,F
01D98:  BTFSS  FD8.2
01D9A:  BRA    1F80
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01D9C:  MOVLB  0
01D9E:  CALL   1250
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
01DA2:  BSF    F93.4
01DA4:  BTFSC  F81.4
01DA6:  BRA    1E0C
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
01DA8:  MOVLW  02
01DAA:  MOVLB  1
01DAC:  MOVWF  x0F
01DAE:  MOVLW  FA
01DB0:  MOVWF  x21
01DB2:  MOVLB  0
01DB4:  CALL   0BDC
01DB8:  MOVLB  1
01DBA:  DECFSZ x0F,F
01DBC:  BRA    1DAE
....................         BEEP; 
01DBE:  MOVLW  04
01DC0:  MOVWF  x10
01DC2:  MOVLW  B9
01DC4:  MOVWF  x0F
01DC6:  CLRF   x12
01DC8:  MOVLW  14
01DCA:  MOVWF  x11
01DCC:  MOVLB  0
01DCE:  RCALL  1840
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
01DD0:  MOVLB  1
01DD2:  INCF   x0D,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
01DD4:  MOVF   x0D,W
01DD6:  SUBWF  x08,W
01DD8:  BC    1DDC
....................            optSelected = 0; 
01DDA:  CLRF   x0D
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
01DDC:  MOVF   x0D,W
01DDE:  MULLW  0E
01DE0:  MOVF   FF3,W
01DE2:  CLRF   03
01DE4:  MOVWF  x0F
01DE6:  MOVLW  0C
01DE8:  MOVWF  x12
01DEA:  MOVLB  0
01DEC:  CALL   0E0C
01DF0:  MOVLW  58
01DF2:  MOVWF  FF6
01DF4:  MOVLW  04
01DF6:  MOVWF  FF7
01DF8:  MOVLB  1
01DFA:  MOVF   x0F,W
01DFC:  ADDWF  FF6,F
01DFE:  MOVLW  00
01E00:  ADDWFC FF7,F
01E02:  MOVLB  0
01E04:  CALL   0E78
....................         showBottonMenu(); 
01E08:  CALL   11F4
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
01E0C:  BSF    F93.5
01E0E:  BTFSC  F81.5
01E10:  BRA    1F7C
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
01E12:  MOVLW  02
01E14:  MOVLB  1
01E16:  MOVWF  x0F
01E18:  MOVLW  FA
01E1A:  MOVWF  x21
01E1C:  MOVLB  0
01E1E:  CALL   0BDC
01E22:  MOVLB  1
01E24:  DECFSZ x0F,F
01E26:  BRA    1E18
....................         BEEP; 
01E28:  MOVLW  04
01E2A:  MOVWF  x10
01E2C:  MOVLW  B9
01E2E:  MOVWF  x0F
01E30:  CLRF   x12
01E32:  MOVLW  14
01E34:  MOVWF  x11
01E36:  MOVLB  0
01E38:  RCALL  1840
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
01E3A:  MOVLB  1
01E3C:  MOVF   x08,W
01E3E:  SUBWF  x0D,W
01E40:  BNZ   1E48
....................            exit = 1; 
01E42:  MOVLW  01
01E44:  MOVWF  x0E
....................         }else{ 
01E46:  BRA    1F7E
....................            switch(optSelected){ 
01E48:  MOVF   x0D,W
01E4A:  XORLW  00
01E4C:  MOVLB  0
01E4E:  BZ    1E5A
01E50:  XORLW  01
01E52:  BZ    1EAA
01E54:  XORLW  03
01E56:  BZ    1EFA
01E58:  BRA    1F48
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
01E5A:  MOVLW  86
01E5C:  MOVWF  FF6
01E5E:  MOVLW  05
01E60:  MOVWF  FF7
01E62:  CALL   0EC2
....................                  write_eeprom(0,'1'); 
01E66:  MOVF   FF2,W
01E68:  MOVWF  00
01E6A:  BCF    FF2.7
01E6C:  CLRF   FAA
01E6E:  CLRF   FA9
01E70:  MOVLW  31
01E72:  MOVWF  FA8
01E74:  BCF    FA6.6
01E76:  BCF    FA6.7
01E78:  BSF    FA6.2
01E7A:  MOVLB  F
01E7C:  MOVLW  55
01E7E:  MOVWF  FA7
01E80:  MOVLW  AA
01E82:  MOVWF  FA7
01E84:  BSF    FA6.1
01E86:  BTFSC  FA6.1
01E88:  BRA    1E86
01E8A:  BCF    FA6.2
01E8C:  MOVF   00,W
01E8E:  IORWF  FF2,F
....................                  delay_ms(10); 
01E90:  MOVLW  0A
01E92:  MOVLB  1
01E94:  MOVWF  x21
01E96:  MOVLB  0
01E98:  CALL   0BDC
....................                  printf(lcd_putc, "\fConfig Cliente"); 
01E9C:  MOVLW  98
01E9E:  MOVWF  FF6
01EA0:  MOVLW  05
01EA2:  MOVWF  FF7
01EA4:  CALL   0E78
....................                  break; 
01EA8:  BRA    1F48
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
01EAA:  MOVLW  A8
01EAC:  MOVWF  FF6
01EAE:  MOVLW  05
01EB0:  MOVWF  FF7
01EB2:  CALL   0EC2
....................                  write_eeprom(0,'2'); 
01EB6:  MOVF   FF2,W
01EB8:  MOVWF  00
01EBA:  BCF    FF2.7
01EBC:  CLRF   FAA
01EBE:  CLRF   FA9
01EC0:  MOVLW  32
01EC2:  MOVWF  FA8
01EC4:  BCF    FA6.6
01EC6:  BCF    FA6.7
01EC8:  BSF    FA6.2
01ECA:  MOVLB  F
01ECC:  MOVLW  55
01ECE:  MOVWF  FA7
01ED0:  MOVLW  AA
01ED2:  MOVWF  FA7
01ED4:  BSF    FA6.1
01ED6:  BTFSC  FA6.1
01ED8:  BRA    1ED6
01EDA:  BCF    FA6.2
01EDC:  MOVF   00,W
01EDE:  IORWF  FF2,F
....................                  delay_ms(10); 
01EE0:  MOVLW  0A
01EE2:  MOVLB  1
01EE4:  MOVWF  x21
01EE6:  MOVLB  0
01EE8:  CALL   0BDC
....................                  printf(lcd_putc, "\fConfig AP"); 
01EEC:  MOVLW  BA
01EEE:  MOVWF  FF6
01EF0:  MOVLW  05
01EF2:  MOVWF  FF7
01EF4:  CALL   0E78
....................                  break; 
01EF8:  BRA    1F48
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
01EFA:  MOVLW  C6
01EFC:  MOVWF  FF6
01EFE:  MOVLW  05
01F00:  MOVWF  FF7
01F02:  CALL   0EC2
....................                  write_eeprom(0,'3'); 
01F06:  MOVF   FF2,W
01F08:  MOVWF  00
01F0A:  BCF    FF2.7
01F0C:  CLRF   FAA
01F0E:  CLRF   FA9
01F10:  MOVLW  33
01F12:  MOVWF  FA8
01F14:  BCF    FA6.6
01F16:  BCF    FA6.7
01F18:  BSF    FA6.2
01F1A:  MOVLB  F
01F1C:  MOVLW  55
01F1E:  MOVWF  FA7
01F20:  MOVLW  AA
01F22:  MOVWF  FA7
01F24:  BSF    FA6.1
01F26:  BTFSC  FA6.1
01F28:  BRA    1F26
01F2A:  BCF    FA6.2
01F2C:  MOVF   00,W
01F2E:  IORWF  FF2,F
....................                  delay_ms(10); 
01F30:  MOVLW  0A
01F32:  MOVLB  1
01F34:  MOVWF  x21
01F36:  MOVLB  0
01F38:  CALL   0BDC
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
01F3C:  MOVLW  D8
01F3E:  MOVWF  FF6
01F40:  MOVLW  05
01F42:  MOVWF  FF7
01F44:  CALL   0E78
....................                  break; 
....................            } 
....................            pressExit(); 
01F48:  RCALL  1D16
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
01F4A:  MOVLB  1
01F4C:  MOVF   x0D,W
01F4E:  MULLW  0E
01F50:  MOVF   FF3,W
01F52:  CLRF   03
01F54:  MOVWF  x0F
01F56:  MOVLW  0C
01F58:  MOVWF  x12
01F5A:  MOVLB  0
01F5C:  CALL   0E0C
01F60:  MOVLW  58
01F62:  MOVWF  FF6
01F64:  MOVLW  04
01F66:  MOVWF  FF7
01F68:  MOVLB  1
01F6A:  MOVF   x0F,W
01F6C:  ADDWF  FF6,F
01F6E:  MOVLW  00
01F70:  ADDWFC FF7,F
01F72:  MOVLB  0
01F74:  CALL   0E78
....................            showBottonMenu(); 
01F78:  CALL   11F4
01F7C:  MOVLB  1
....................         } 
....................      } // Fin KEY_OK 
01F7E:  BRA    1D96
....................   } // FIN While Infinito 
01F80:  MOVLB  0
01F82:  GOTO   20F8 (RETURN)
.................... } // Fin funcion setMenuModo 
....................  
....................  
.................... /******************************************** 
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
00BB2:  BTFSS  F9E.5
00BB4:  BRA    0BB2
00BB6:  MOVFF  FAE,12B
00BBA:  MOVLB  1
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
00BBC:  MOVFF  12B,12C
00BC0:  MOVLB  0
00BC2:  BRA    0ACA
00BC4:  BCF    F9E.5
00BC6:  GOTO   0054
.................... } 
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
*
0229E:  CLRF   FF8
022A0:  BCF    FD0.7
022A2:  BSF    07.7
022A4:  BSF    FB8.3
022A6:  MOVLW  08
022A8:  MOVWF  FAF
022AA:  MOVLW  02
022AC:  MOVWF  FB0
022AE:  MOVLW  A6
022B0:  MOVWF  FAC
022B2:  MOVLW  90
022B4:  MOVWF  FAB
022B6:  BCF    F93.0
022B8:  BSF    F8A.0
022BA:  CLRF   63
022BC:  CLRF   62
022BE:  CLRF   64
022C0:  CLRF   65
022C2:  CLRF   66
022C4:  CLRF   67
022C6:  CLRF   68
022C8:  CLRF   69
022CA:  CLRF   6A
022CC:  CLRF   6B
022CE:  MOVLW  01
022D0:  MOVWF  6C
022D2:  CLRF   6D
022D4:  MOVLW  05
022D6:  MOVWF  6E
022D8:  CLRF   xCB
022DA:  CLRF   xCC
022DC:  CLRF   xCD
022DE:  CLRF   xCE
022E0:  CLRF   xCF
022E2:  CLRF   xD0
022E4:  MOVLW  02
022E6:  MOVLB  1
022E8:  MOVWF  x04
022EA:  MOVLW  08
022EC:  MOVWF  x05
022EE:  MOVWF  x06
022F0:  MOVLW  07
022F2:  MOVWF  x07
022F4:  MOVLW  03
022F6:  MOVWF  x08
022F8:  CLRF   x09
022FA:  MOVF   FC1,W
022FC:  ANDLW  C0
022FE:  IORLW  0F
02300:  MOVWF  FC1
02302:  MOVLW  07
02304:  MOVWF  FB4
02306:  BRA    234A
02308:  DATA 12,00
0230A:  DATA 16,22
0230C:  DATA 7C,21
0230E:  DATA 7C,20
02310:  DATA 7C,04
02312:  DATA 7C,00
02314:  DATA 7C,01
02316:  DATA 7C,02
02318:  DATA 7C,03
0231A:  DATA 7C,00
0231C:  DATA 00,0C
0231E:  DATA 40,6F
02320:  DATA 00,07
02322:  DATA 80,30
02324:  DATA 2E,30
02326:  DATA 2E,30
02328:  DATA 2E,30
0232A:  DATA 09,C0
0232C:  DATA 00,07
0232E:  DATA 80,30
02330:  DATA 2E,30
02332:  DATA 2E,30
02334:  DATA 2E,30
02336:  DATA 19,C0
02338:  DATA 00,03
0233A:  DATA 80,4B
0233C:  DATA 45,59
0233E:  DATA 0D,C0
02340:  DATA 00,05
02342:  DATA 80,53
02344:  DATA 53,49
02346:  DATA 44,00
02348:  DATA 00,00
0234A:  MOVLW  00
0234C:  MOVWF  FF8
0234E:  MOVLW  23
02350:  MOVWF  FF7
02352:  MOVLW  08
02354:  MOVWF  FF6
02356:  TBLRD*+
02358:  MOVF   FF5,W
0235A:  MOVWF  00
0235C:  XORLW  00
0235E:  BZ    2386
02360:  TBLRD*+
02362:  MOVF   FF5,W
02364:  MOVWF  01
02366:  BTFSC  FE8.7
02368:  BRA    2374
0236A:  ANDLW  0F
0236C:  MOVWF  FEA
0236E:  TBLRD*+
02370:  MOVFF  FF5,FE9
02374:  BTFSC  01.6
02376:  TBLRD*+
02378:  BTFSS  01.6
0237A:  TBLRD*+
0237C:  MOVFF  FF5,FEE
02380:  DCFSNZ 00,F
02382:  BRA    2356
02384:  BRA    2378
02386:  CLRF   FF8
....................    {       
....................       /*for(int idxNC=0;idxNC<=255;idxNC++){ 
....................          write_eeprom(idxNC,0xFF); 
....................          delay_ms(10); 
....................       }*/ 
....................           
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
02388:  MOVLW  02
0238A:  MOVWF  x0A
0238C:  MOVLW  FA
0238E:  MOVWF  x21
02390:  MOVLB  0
02392:  CALL   0BDC
02396:  MOVLB  1
02398:  DECFSZ x0A,F
0239A:  BRA    238C
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
0239C:  BCF    FF1.7
....................       set_tris_b(0b00110010); 
0239E:  MOVLW  32
023A0:  MOVWF  F93
....................       enable_interrupts(INT_RDA);  
023A2:  BSF    F9D.5
....................       enable_interrupts(GLOBAL);  
023A4:  MOVLW  C0
023A6:  IORWF  FF2,F
....................        
....................       // Inicializa la LCD 
....................       lcd_init(); 
023A8:  MOVLB  0
023AA:  GOTO   0D4A
....................       printf(lcd_putc, "\fConfigurando..."); 
023AE:  MOVLW  CA
023B0:  MOVWF  FF6
023B2:  MOVLW  0B
023B4:  MOVWF  FF7
023B6:  CALL   0E78
....................        
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
023BA:  BCF    F95.3
023BC:  BSF    F8C.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
023BE:  GOTO   0FFA
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
023C2:  MOVLB  1
023C4:  MOVF   x09,W
023C6:  ADDLW  FC
023C8:  BC    2402
023CA:  ADDLW  04
023CC:  MOVLB  0
023CE:  GOTO   2406
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
023D2:  GOTO   1988
023D6:  MOVFF  01,109
....................                break; 
023DA:  MOVLB  1
023DC:  BRA    2402
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
023DE:  GOTO   1A76
023E2:  MOVFF  01,109
....................                break; 
023E6:  MOVLB  1
023E8:  BRA    2402
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
023EA:  GOTO   1BB4
023EE:  MOVFF  01,109
....................                break; 
023F2:  MOVLB  1
023F4:  BRA    2402
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
023F6:  BRA    216E
023F8:  MOVFF  01,109
....................                break; 
023FC:  MOVLB  1
023FE:  BRA    2402
02400:  MOVLB  1
....................          } // Fin del Switch(menuActive) 
02402:  BRA    23C4
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
02404:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
