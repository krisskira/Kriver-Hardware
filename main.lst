CCS PCM C Compiler, Version 5.015, 5967               04-dic.-17 21:32

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   4557 words (56%)
                           Largest free fragment is 2048
               RAM used:   88 (24%) at main() level
                           127 (35%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0E
0001:  MOVWF  0A
0002:  GOTO   673
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   35A
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  4F
0056:  RETLW  4B
0057:  RETLW  0D
0058:  RETLW  0A
0059:  BCF    0A.0
005A:  BCF    0A.1
005B:  BCF    0A.2
005C:  ADDWF  02,F
005D:  RETLW  4E
005E:  RETLW  6F
005F:  RETLW  20
0060:  RETLW  41
0061:  RETLW  50
0062:  BCF    0A.0
0063:  BCF    0A.1
0064:  BCF    0A.2
0065:  ADDWF  02,F
0066:  RETLW  2B
0067:  RETLW  43
0068:  RETLW  57
0069:  RETLW  4A
006A:  RETLW  41
006B:  RETLW  50
006C:  RETLW  3A
006D:  BCF    0A.0
006E:  BCF    0A.1
006F:  BCF    0A.2
0070:  ADDWF  02,F
0071:  RETLW  43
0072:  RETLW  4F
0073:  RETLW  4E
0074:  RETLW  4E
0075:  RETLW  45
0076:  RETLW  43
0077:  RETLW  54
0078:  RETLW  45
0079:  RETLW  44
007A:  BCF    0A.0
007B:  BCF    0A.1
007C:  BCF    0A.2
007D:  ADDWF  02,F
007E:  RETLW  46
007F:  RETLW  41
0080:  RETLW  49
0081:  RETLW  4C
0082:  RETLW  45
0083:  RETLW  6E
0084:  RETLW  63
0085:  RETLW  65
0086:  RETLW  6E
0087:  RETLW  64
0088:  RETLW  65
0089:  RETLW  72
008A:  RETLW  20
008B:  RETLW  4D
008C:  RETLW  61
008D:  RETLW  6E
008E:  RETLW  75
008F:  RETLW  61
0090:  RETLW  6C
0091:  RETLW  00
0092:  RETLW  41
0093:  RETLW  70
0094:  RETLW  61
0095:  RETLW  67
0096:  RETLW  61
0097:  RETLW  64
0098:  RETLW  6F
0099:  RETLW  20
009A:  RETLW  4D
009B:  RETLW  61
009C:  RETLW  6E
009D:  RETLW  75
009E:  RETLW  61
009F:  RETLW  6C
00A0:  RETLW  20
00A1:  RETLW  00
00A2:  RETLW  43
00A3:  RETLW  6F
00A4:  RETLW  6E
00A5:  RETLW  66
00A6:  RETLW  69
00A7:  RETLW  67
00A8:  RETLW  75
00A9:  RETLW  72
00AA:  RETLW  61
00AB:  RETLW  63
00AC:  RETLW  69
00AD:  RETLW  6F
00AE:  RETLW  6E
00AF:  RETLW  20
00B0:  RETLW  20
00B1:  RETLW  00
00B2:  RETLW  00
00B3:  RETLW  00
00B4:  RETLW  00
00B5:  RETLW  00
00B6:  RETLW  00
00B7:  RETLW  00
00B8:  RETLW  00
00B9:  RETLW  00
00BA:  RETLW  00
00BB:  RETLW  00
00BC:  RETLW  00
00BD:  RETLW  00
00BE:  RETLW  00
00BF:  RETLW  00
00C0:  RETLW  00
00C1:  RETLW  00
00C2:  RETLW  4F
00C3:  RETLW  6E
00C4:  RETLW  20
00C5:  RETLW  2D
00C6:  RETLW  3E
00C7:  RETLW  20
00C8:  RETLW  53
00C9:  RETLW  61
00CA:  RETLW  6C
00CB:  RETLW  69
00CC:  RETLW  64
00CD:  RETLW  61
00CE:  RETLW  20
00CF:  RETLW  31
00D0:  RETLW  00
00D1:  RETLW  4F
00D2:  RETLW  6E
00D3:  RETLW  20
00D4:  RETLW  2D
00D5:  RETLW  3E
00D6:  RETLW  20
00D7:  RETLW  53
00D8:  RETLW  61
00D9:  RETLW  6C
00DA:  RETLW  69
00DB:  RETLW  64
00DC:  RETLW  61
00DD:  RETLW  20
00DE:  RETLW  32
00DF:  RETLW  00
00E0:  RETLW  4F
00E1:  RETLW  6E
00E2:  RETLW  20
00E3:  RETLW  2D
00E4:  RETLW  3E
00E5:  RETLW  20
00E6:  RETLW  53
00E7:  RETLW  61
00E8:  RETLW  6C
00E9:  RETLW  69
00EA:  RETLW  64
00EB:  RETLW  61
00EC:  RETLW  20
00ED:  RETLW  33
00EE:  RETLW  00
00EF:  RETLW  4F
00F0:  RETLW  6E
00F1:  RETLW  20
00F2:  RETLW  2D
00F3:  RETLW  3E
00F4:  RETLW  20
00F5:  RETLW  53
00F6:  RETLW  61
00F7:  RETLW  6C
00F8:  RETLW  69
00F9:  RETLW  64
00FA:  RETLW  61
00FB:  RETLW  20
00FC:  RETLW  34
00FD:  RETLW  00
00FE:  RETLW  4F
00FF:  RETLW  6E
0100:  RETLW  20
0101:  RETLW  2D
0102:  RETLW  3E
0103:  RETLW  20
0104:  RETLW  53
0105:  RETLW  61
0106:  RETLW  6C
0107:  RETLW  69
0108:  RETLW  64
0109:  RETLW  61
010A:  RETLW  20
010B:  RETLW  35
010C:  RETLW  00
010D:  RETLW  4F
010E:  RETLW  6E
010F:  RETLW  20
0110:  RETLW  2D
0111:  RETLW  3E
0112:  RETLW  20
0113:  RETLW  53
0114:  RETLW  61
0115:  RETLW  6C
0116:  RETLW  69
0117:  RETLW  64
0118:  RETLW  61
0119:  RETLW  20
011A:  RETLW  36
011B:  RETLW  00
011C:  RETLW  4F
011D:  RETLW  6E
011E:  RETLW  20
011F:  RETLW  2D
0120:  RETLW  3E
0121:  RETLW  20
0122:  RETLW  53
0123:  RETLW  61
0124:  RETLW  6C
0125:  RETLW  69
0126:  RETLW  64
0127:  RETLW  61
0128:  RETLW  20
0129:  RETLW  37
012A:  RETLW  00
012B:  RETLW  4F
012C:  RETLW  6E
012D:  RETLW  20
012E:  RETLW  2D
012F:  RETLW  3E
0130:  RETLW  20
0131:  RETLW  53
0132:  RETLW  61
0133:  RETLW  6C
0134:  RETLW  69
0135:  RETLW  64
0136:  RETLW  61
0137:  RETLW  20
0138:  RETLW  38
0139:  RETLW  00
013A:  RETLW  53
013B:  RETLW  41
013C:  RETLW  4C
013D:  RETLW  49
013E:  RETLW  52
013F:  RETLW  20
0140:  RETLW  20
0141:  RETLW  20
0142:  RETLW  20
0143:  RETLW  20
0144:  RETLW  20
0145:  RETLW  20
0146:  RETLW  20
0147:  RETLW  20
0148:  RETLW  00
0149:  RETLW  00
014A:  RETLW  00
014B:  RETLW  00
014C:  RETLW  00
014D:  RETLW  00
014E:  RETLW  00
014F:  RETLW  00
0150:  RETLW  00
0151:  RETLW  00
0152:  RETLW  00
0153:  RETLW  00
0154:  RETLW  00
0155:  RETLW  00
0156:  RETLW  00
0157:  RETLW  00
0158:  RETLW  4F
0159:  RETLW  66
015A:  RETLW  66
015B:  RETLW  20
015C:  RETLW  2D
015D:  RETLW  3E
015E:  RETLW  20
015F:  RETLW  53
0160:  RETLW  61
0161:  RETLW  6C
0162:  RETLW  69
0163:  RETLW  64
0164:  RETLW  61
0165:  RETLW  20
0166:  RETLW  31
0167:  RETLW  00
0168:  RETLW  4F
0169:  RETLW  66
016A:  RETLW  66
016B:  RETLW  20
016C:  RETLW  2D
016D:  RETLW  3E
016E:  RETLW  20
016F:  RETLW  53
0170:  RETLW  61
0171:  RETLW  6C
0172:  RETLW  69
0173:  RETLW  64
0174:  RETLW  61
0175:  RETLW  20
0176:  RETLW  32
0177:  RETLW  00
0178:  RETLW  4F
0179:  RETLW  66
017A:  RETLW  66
017B:  RETLW  20
017C:  RETLW  2D
017D:  RETLW  3E
017E:  RETLW  20
017F:  RETLW  53
0180:  RETLW  61
0181:  RETLW  6C
0182:  RETLW  69
0183:  RETLW  64
0184:  RETLW  61
0185:  RETLW  20
0186:  RETLW  33
0187:  RETLW  00
0188:  RETLW  4F
0189:  RETLW  66
018A:  RETLW  66
018B:  RETLW  20
018C:  RETLW  2D
018D:  RETLW  3E
018E:  RETLW  20
018F:  RETLW  53
0190:  RETLW  61
0191:  RETLW  6C
0192:  RETLW  69
0193:  RETLW  64
0194:  RETLW  61
0195:  RETLW  20
0196:  RETLW  34
0197:  RETLW  00
0198:  RETLW  4F
0199:  RETLW  66
019A:  RETLW  66
019B:  RETLW  20
019C:  RETLW  2D
019D:  RETLW  3E
019E:  RETLW  20
019F:  RETLW  53
01A0:  RETLW  61
01A1:  RETLW  6C
01A2:  RETLW  69
01A3:  RETLW  64
01A4:  RETLW  61
01A5:  RETLW  20
01A6:  RETLW  35
01A7:  RETLW  00
01A8:  RETLW  4F
01A9:  RETLW  66
01AA:  RETLW  66
01AB:  RETLW  20
01AC:  RETLW  2D
01AD:  RETLW  3E
01AE:  RETLW  20
01AF:  RETLW  53
01B0:  RETLW  61
01B1:  RETLW  6C
01B2:  RETLW  69
01B3:  RETLW  64
01B4:  RETLW  61
01B5:  RETLW  20
01B6:  RETLW  36
01B7:  RETLW  00
01B8:  RETLW  4F
01B9:  RETLW  66
01BA:  RETLW  66
01BB:  RETLW  20
01BC:  RETLW  2D
01BD:  RETLW  3E
01BE:  RETLW  20
01BF:  RETLW  53
01C0:  RETLW  61
01C1:  RETLW  6C
01C2:  RETLW  69
01C3:  RETLW  64
01C4:  RETLW  61
01C5:  RETLW  20
01C6:  RETLW  37
01C7:  RETLW  00
01C8:  RETLW  4F
01C9:  RETLW  66
01CA:  RETLW  66
01CB:  RETLW  20
01CC:  RETLW  2D
01CD:  RETLW  3E
01CE:  RETLW  20
01CF:  RETLW  53
01D0:  RETLW  61
01D1:  RETLW  6C
01D2:  RETLW  69
01D3:  RETLW  64
01D4:  RETLW  61
01D5:  RETLW  20
01D6:  RETLW  38
01D7:  RETLW  00
01D8:  RETLW  53
01D9:  RETLW  41
01DA:  RETLW  4C
01DB:  RETLW  49
01DC:  RETLW  52
01DD:  RETLW  20
01DE:  RETLW  20
01DF:  RETLW  20
01E0:  RETLW  20
01E1:  RETLW  20
01E2:  RETLW  20
01E3:  RETLW  20
01E4:  RETLW  20
01E5:  RETLW  20
01E6:  RETLW  20
01E7:  RETLW  00
01E8:  RETLW  00
01E9:  RETLW  00
01EA:  RETLW  00
01EB:  RETLW  00
01EC:  RETLW  00
01ED:  RETLW  00
01EE:  RETLW  00
01EF:  RETLW  00
01F0:  RETLW  00
01F1:  RETLW  00
01F2:  RETLW  00
01F3:  RETLW  00
01F4:  RETLW  00
01F5:  RETLW  00
01F6:  RETLW  00
01F7:  RETLW  00
01F8:  RETLW  56
01F9:  RETLW  45
01FA:  RETLW  52
01FB:  RETLW  20
01FC:  RETLW  49
01FD:  RETLW  50
01FE:  RETLW  20
01FF:  RETLW  20
0200:  RETLW  20
0201:  RETLW  20
0202:  RETLW  20
0203:  RETLW  20
0204:  RETLW  20
0205:  RETLW  20
0206:  RETLW  20
0207:  RETLW  20
0208:  RETLW  00
0209:  RETLW  56
020A:  RETLW  45
020B:  RETLW  52
020C:  RETLW  20
020D:  RETLW  53
020E:  RETLW  53
020F:  RETLW  49
0210:  RETLW  44
0211:  RETLW  20
0212:  RETLW  20
0213:  RETLW  20
0214:  RETLW  20
0215:  RETLW  20
0216:  RETLW  20
0217:  RETLW  20
0218:  RETLW  20
0219:  RETLW  00
021A:  RETLW  56
021B:  RETLW  45
021C:  RETLW  52
021D:  RETLW  20
021E:  RETLW  4B
021F:  RETLW  45
0220:  RETLW  59
0221:  RETLW  20
0222:  RETLW  20
0223:  RETLW  20
0224:  RETLW  20
0225:  RETLW  20
0226:  RETLW  20
0227:  RETLW  20
0228:  RETLW  20
0229:  RETLW  20
022A:  RETLW  00
022B:  RETLW  43
022C:  RETLW  6F
022D:  RETLW  6E
022E:  RETLW  66
022F:  RETLW  20
0230:  RETLW  41
0231:  RETLW  63
0232:  RETLW  63
0233:  RETLW  65
0234:  RETLW  73
0235:  RETLW  73
0236:  RETLW  6F
0237:  RETLW  20
0238:  RETLW  52
0239:  RETLW  65
023A:  RETLW  64
023B:  RETLW  00
023C:  RETLW  4F
023D:  RETLW  6E
023E:  RETLW  2F
023F:  RETLW  4F
0240:  RETLW  66
0241:  RETLW  66
0242:  RETLW  20
0243:  RETLW  42
0244:  RETLW  61
0245:  RETLW  63
0246:  RETLW  6B
0247:  RETLW  6C
0248:  RETLW  69
0249:  RETLW  67
024A:  RETLW  68
024B:  RETLW  74
024C:  RETLW  00
024D:  RETLW  53
024E:  RETLW  41
024F:  RETLW  4C
0250:  RETLW  49
0251:  RETLW  52
0252:  RETLW  20
0253:  RETLW  20
0254:  RETLW  20
0255:  RETLW  20
0256:  RETLW  20
0257:  RETLW  20
0258:  RETLW  20
0259:  RETLW  20
025A:  RETLW  20
025B:  RETLW  20
025C:  RETLW  20
025D:  RETLW  00
025E:  RETLW  00
025F:  RETLW  00
0260:  RETLW  00
0261:  RETLW  00
0262:  RETLW  00
0263:  RETLW  00
0264:  RETLW  00
0265:  RETLW  00
0266:  RETLW  00
0267:  RETLW  00
0268:  RETLW  00
0269:  RETLW  00
026A:  RETLW  00
026B:  RETLW  00
026C:  RETLW  00
026D:  RETLW  00
026E:  RETLW  00
026F:  RETLW  45
0270:  RETLW  73
0271:  RETLW  74
0272:  RETLW  61
0273:  RETLW  63
0274:  RETLW  69
0275:  RETLW  6F
0276:  RETLW  6E
0277:  RETLW  20
0278:  RETLW  20
0279:  RETLW  20
027A:  RETLW  20
027B:  RETLW  20
027C:  RETLW  00
027D:  RETLW  41
027E:  RETLW  63
027F:  RETLW  63
0280:  RETLW  65
0281:  RETLW  73
0282:  RETLW  73
0283:  RETLW  20
0284:  RETLW  50
0285:  RETLW  6F
0286:  RETLW  69
0287:  RETLW  6E
0288:  RETLW  74
0289:  RETLW  20
028A:  RETLW  00
028B:  RETLW  45
028C:  RETLW  73
028D:  RETLW  74
028E:  RETLW  61
028F:  RETLW  63
0290:  RETLW  69
0291:  RETLW  6F
0292:  RETLW  6E
0293:  RETLW  20
0294:  RETLW  2B
0295:  RETLW  20
0296:  RETLW  41
0297:  RETLW  50
0298:  RETLW  00
0299:  RETLW  53
029A:  RETLW  41
029B:  RETLW  4C
029C:  RETLW  49
029D:  RETLW  52
029E:  RETLW  20
029F:  RETLW  20
02A0:  RETLW  20
02A1:  RETLW  20
02A2:  RETLW  20
02A3:  RETLW  20
02A4:  RETLW  20
02A5:  RETLW  20
02A6:  RETLW  00
02A7:  RETLW  00
02A8:  RETLW  00
02A9:  RETLW  00
02AA:  RETLW  00
02AB:  RETLW  00
02AC:  RETLW  00
02AD:  RETLW  00
02AE:  RETLW  00
02AF:  RETLW  00
02B0:  RETLW  00
02B1:  RETLW  00
02B2:  RETLW  00
02B3:  RETLW  00
02B4:  RETLW  00
02B5:  DATA D3,20
02B6:  DATA CC,24
02B7:  DATA 52,00
02B8:  DATA DB,29
02B9:  DATA C9,23
02BA:  DATA 5D,10
02BB:  DATA 20,10
02BC:  DATA 20,10
02BD:  DATA A0,2D
02BE:  DATA 45,27
02BF:  DATA D4,2E
02C0:  DATA 00,00
02C1:  DATA 8C,18
02C2:  DATA 39,19
02C3:  DATA AE,18
02C4:  DATA 36,1C
02C5:  DATA 2E,18
02C6:  DATA AE,18
02C7:  DATA 00,01
02C8:  DATA 8C,21
02C9:  DATA B0,23
02CA:  DATA B3,2F
02CB:  DATA 55,27
02CC:  DATA 45,00
02CD:  DATA 8C,18
02CE:  DATA B2,19
02CF:  DATA B4,20
02D0:  DATA FA,10
02D1:  DATA 00,01
02D2:  DATA 0C,21
02D3:  DATA E1,31
02D4:  DATA 6B,36
02D5:  DATA E9,33
02D6:  DATA 68,3A
02D7:  DATA A0,27
02D8:  DATA 6E,00
02D9:  DATA 0C,21
02DA:  DATA E1,31
02DB:  DATA 6B,36
02DC:  DATA E9,33
02DD:  DATA 68,3A
02DE:  DATA A0,27
02DF:  DATA 66,33
02E0:  DATA 00,01
02E1:  DATA 41,2A
02E2:  DATA AB,21
02E3:  DATA D7,26
02E4:  DATA 4F,22
02E5:  DATA C5,2F
02E6:  DATA C4,22
02E7:  DATA C6,1E
02E8:  DATA B1,06
02E9:  DATA 0A,00
02EA:  DATA 8C,21
02EB:  DATA 6F,37
02EC:  DATA E6,34
02ED:  DATA 67,10
02EE:  DATA 43,36
02EF:  DATA E9,32
02F0:  DATA 6E,3A
02F1:  DATA 65,00
02F2:  DATA 41,2A
02F3:  DATA AB,21
02F4:  DATA D7,26
02F5:  DATA 4F,22
02F6:  DATA C5,2F
02F7:  DATA C4,22
02F8:  DATA C6,1E
02F9:  DATA B2,06
02FA:  DATA 0A,00
02FB:  DATA 8C,21
02FC:  DATA 6F,37
02FD:  DATA E6,34
02FE:  DATA 67,10
02FF:  DATA 41,28
0300:  DATA 00,01
0301:  DATA 41,2A
0302:  DATA AB,21
0303:  DATA D7,26
0304:  DATA 4F,22
0305:  DATA C5,2F
0306:  DATA C4,22
0307:  DATA C6,1E
0308:  DATA B3,06
0309:  DATA 0A,00
030A:  DATA 8C,21
030B:  DATA 6F,37
030C:  DATA E6,34
030D:  DATA 67,10
030E:  DATA 43,36
030F:  DATA E9,32
0310:  DATA 6E,3A
0311:  DATA E5,20
0312:  DATA 50,00
0313:  DATA 41,2A
0314:  DATA 2B,29
0315:  DATA 53,2A
0316:  DATA 0D,05
0317:  DATA 00,00
0318:  DATA 41,2A
0319:  DATA AB,21
031A:  DATA D7,26
031B:  DATA 4F,22
031C:  DATA C5,1E
031D:  DATA A5,39
031E:  DATA 0D,05
031F:  DATA 00,00
0320:  DATA 41,2A
0321:  DATA AB,21
0322:  DATA 57,25
0323:  DATA 41,28
0324:  DATA BF,06
0325:  DATA 0A,00
0326:  DATA 41,2A
0327:  DATA AB,21
0328:  DATA 57,25
0329:  DATA 41,28
032A:  DATA BD,12
032B:  DATA 73,00
032C:  DATA 41,2A
032D:  DATA AB,21
032E:  DATA 49,28
032F:  DATA CD,2A
0330:  DATA D8,1E
0331:  DATA B1,06
0332:  DATA 0A,00
0333:  DATA 41,2A
0334:  DATA AB,21
0335:  DATA 49,28
0336:  DATA D3,22
0337:  DATA 52,2B
0338:  DATA 45,29
0339:  DATA BD,18
033A:  DATA 2C,1C
033B:  DATA B0,06
033C:  DATA 0A,00
*
060B:  MOVF   0B,W
060C:  MOVWF  7B
060D:  BCF    0B.7
060E:  BSF    03.5
060F:  BSF    03.6
0610:  BSF    0C.7
0611:  BSF    0C.0
0612:  NOP
0613:  NOP
0614:  BTFSS  7B.7
0615:  GOTO   61B
0616:  BCF    03.5
0617:  BCF    03.6
0618:  BSF    0B.7
0619:  BSF    03.5
061A:  BSF    03.6
061B:  BCF    03.5
061C:  MOVF   0C,W
061D:  ANDLW  7F
061E:  BTFSC  03.2
061F:  GOTO   65B
0620:  MOVWF  7B
0621:  MOVF   0D,W
0622:  MOVWF  7C
0623:  MOVF   0F,W
0624:  MOVWF  7D
0625:  MOVF   7B,W
0626:  BCF    03.6
0627:  BTFSS  0C.4
0628:  GOTO   627
0629:  MOVWF  19
062A:  MOVF   7C,W
062B:  BSF    03.6
062C:  MOVWF  0D
062D:  MOVF   7D,W
062E:  MOVWF  0F
062F:  BCF    03.6
0630:  MOVF   0B,W
0631:  MOVWF  7E
0632:  BCF    0B.7
0633:  BSF    03.5
0634:  BSF    03.6
0635:  BSF    0C.7
0636:  BSF    0C.0
0637:  NOP
0638:  NOP
0639:  BTFSS  7E.7
063A:  GOTO   640
063B:  BCF    03.5
063C:  BCF    03.6
063D:  BSF    0B.7
063E:  BSF    03.5
063F:  BSF    03.6
0640:  BCF    03.5
0641:  RLF    0C,W
0642:  RLF    0E,W
0643:  ANDLW  7F
0644:  BTFSC  03.2
0645:  GOTO   65B
0646:  MOVWF  7B
0647:  MOVF   0D,W
0648:  MOVWF  7C
0649:  MOVF   0F,W
064A:  MOVWF  7D
064B:  MOVF   7B,W
064C:  BCF    03.6
064D:  BTFSS  0C.4
064E:  GOTO   64D
064F:  MOVWF  19
0650:  MOVF   7C,W
0651:  BSF    03.6
0652:  MOVWF  0D
0653:  MOVF   7D,W
0654:  MOVWF  0F
0655:  INCF   0D,F
0656:  BTFSC  03.2
0657:  INCF   0F,F
0658:  BCF    03.6
0659:  GOTO   60B
065A:  BSF    03.6
065B:  BCF    03.6
065C:  RETURN
*
06B5:  MOVF   0B,W
06B6:  MOVWF  7C
06B7:  BCF    0B.7
06B8:  BSF    03.5
06B9:  BSF    03.6
06BA:  BSF    0C.7
06BB:  BSF    0C.0
06BC:  NOP
06BD:  NOP
06BE:  BTFSS  7C.7
06BF:  GOTO   6C5
06C0:  BCF    03.5
06C1:  BCF    03.6
06C2:  BSF    0B.7
06C3:  BSF    03.5
06C4:  BSF    03.6
06C5:  BCF    03.5
06C6:  MOVF   0C,F
06C7:  BTFSC  03.2
06C8:  GOTO   6DC
06C9:  MOVF   0D,W
06CA:  MOVWF  7C
06CB:  MOVF   0F,W
06CC:  MOVWF  7D
06CD:  MOVF   0C,W
06CE:  MOVWF  7E
06CF:  BCF    03.6
06D0:  CALL   65D
06D1:  MOVF   7C,W
06D2:  BSF    03.6
06D3:  MOVWF  0D
06D4:  MOVF   7D,W
06D5:  MOVWF  0F
06D6:  INCF   0D,F
06D7:  BTFSC  03.2
06D8:  INCF   0F,F
06D9:  BCF    03.6
06DA:  GOTO   6B5
06DB:  BSF    03.6
06DC:  BCF    03.6
06DD:  RETURN
06DE:  MOVF   0B,W
06DF:  MOVWF  7B
06E0:  BCF    0B.7
06E1:  BSF    03.5
06E2:  BSF    03.6
06E3:  BSF    0C.7
06E4:  BSF    0C.0
06E5:  NOP
06E6:  NOP
06E7:  BTFSS  7B.7
06E8:  GOTO   6EE
06E9:  BCF    03.5
06EA:  BCF    03.6
06EB:  BSF    0B.7
06EC:  BSF    03.5
06ED:  BSF    03.6
06EE:  BCF    03.5
06EF:  MOVF   0C,W
06F0:  ANDLW  7F
06F1:  BTFSC  03.2
06F2:  GOTO   72C
06F3:  MOVWF  7B
06F4:  MOVF   0D,W
06F5:  MOVWF  7C
06F6:  MOVF   0F,W
06F7:  MOVWF  7D
06F8:  MOVF   7B,W
06F9:  MOVWF  7E
06FA:  BCF    03.6
06FB:  CALL   65D
06FC:  MOVF   7C,W
06FD:  BSF    03.6
06FE:  MOVWF  0D
06FF:  MOVF   7D,W
0700:  MOVWF  0F
0701:  BCF    03.6
0702:  MOVF   0B,W
0703:  MOVWF  7E
0704:  BCF    0B.7
0705:  BSF    03.5
0706:  BSF    03.6
0707:  BSF    0C.7
0708:  BSF    0C.0
0709:  NOP
070A:  NOP
070B:  BTFSS  7E.7
070C:  GOTO   712
070D:  BCF    03.5
070E:  BCF    03.6
070F:  BSF    0B.7
0710:  BSF    03.5
0711:  BSF    03.6
0712:  BCF    03.5
0713:  RLF    0C,W
0714:  RLF    0E,W
0715:  ANDLW  7F
0716:  BTFSC  03.2
0717:  GOTO   72C
0718:  MOVWF  7B
0719:  MOVF   0D,W
071A:  MOVWF  7C
071B:  MOVF   0F,W
071C:  MOVWF  7D
071D:  MOVF   7B,W
071E:  MOVWF  7E
071F:  BCF    03.6
0720:  CALL   65D
0721:  MOVF   7C,W
0722:  BSF    03.6
0723:  MOVWF  0D
0724:  MOVF   7D,W
0725:  MOVWF  0F
0726:  INCF   0D,F
0727:  BTFSC  03.2
0728:  INCF   0F,F
0729:  BCF    03.6
072A:  GOTO   6DE
072B:  BSF    03.6
072C:  BCF    03.6
072D:  RETURN
*
07D5:  CLRF   77
07D6:  CLRF   78
07D7:  MOVF   7B,W
07D8:  BCF    03.0
07D9:  BTFSC  7C.0
07DA:  ADDWF  77,F
07DB:  RRF    77,F
07DC:  RRF    78,F
07DD:  BTFSC  7C.1
07DE:  ADDWF  77,F
07DF:  RRF    77,F
07E0:  RRF    78,F
07E1:  BTFSC  7C.2
07E2:  ADDWF  77,F
07E3:  RRF    77,F
07E4:  RRF    78,F
07E5:  BTFSC  7C.3
07E6:  ADDWF  77,F
07E7:  RRF    77,F
07E8:  RRF    78,F
07E9:  BTFSC  7C.4
07EA:  ADDWF  77,F
07EB:  RRF    77,F
07EC:  RRF    78,F
07ED:  BTFSC  7C.5
07EE:  ADDWF  77,F
07EF:  RRF    77,F
07F0:  RRF    78,F
07F1:  BTFSC  7C.6
07F2:  ADDWF  77,F
07F3:  RRF    77,F
07F4:  RRF    78,F
07F5:  BTFSC  7C.7
07F6:  ADDWF  77,F
07F7:  RRF    77,F
07F8:  RRF    78,F
07F9:  RETURN
*
080E:  BCF    03.6
080F:  MOVF   0B,W
0810:  BSF    03.5
0811:  MOVWF  20
0812:  BCF    03.5
0813:  BCF    0B.7
0814:  BSF    03.5
0815:  BSF    03.6
0816:  BSF    0C.7
0817:  BSF    0C.0
0818:  NOP
0819:  NOP
081A:  BCF    03.6
081B:  BTFSS  20.7
081C:  GOTO   020
081D:  BCF    03.5
081E:  BSF    0B.7
081F:  BSF    03.5
0820:  BTFSC  03.0
0821:  GOTO   05A
0822:  BCF    03.5
0823:  BSF    03.6
0824:  MOVF   0C,W
0825:  ANDLW  7F
0826:  BSF    03.5
0827:  BCF    03.6
0828:  MOVWF  20
0829:  BCF    03.5
082A:  BSF    03.6
082B:  MOVF   0D,W
082C:  BSF    03.5
082D:  BCF    03.6
082E:  MOVWF  21
082F:  BCF    03.5
0830:  BSF    03.6
0831:  MOVF   0F,W
0832:  BSF    03.5
0833:  BCF    03.6
0834:  MOVWF  22
0835:  MOVF   20,W
0836:  BCF    03.5
0837:  BTFSS  0C.4
0838:  GOTO   037
0839:  MOVWF  19
083A:  BSF    03.5
083B:  MOVF   21,W
083C:  BCF    03.5
083D:  BSF    03.6
083E:  MOVWF  0D
083F:  BSF    03.5
0840:  BCF    03.6
0841:  MOVF   22,W
0842:  BCF    03.5
0843:  BSF    03.6
0844:  MOVWF  0F
0845:  BCF    03.6
0846:  MOVF   0B,W
0847:  BSF    03.5
0848:  MOVWF  23
0849:  BCF    03.5
084A:  BCF    0B.7
084B:  BSF    03.5
084C:  BSF    03.6
084D:  BSF    0C.7
084E:  BSF    0C.0
084F:  NOP
0850:  NOP
0851:  BCF    03.6
0852:  BTFSS  23.7
0853:  GOTO   057
0854:  BCF    03.5
0855:  BSF    0B.7
0856:  BSF    03.5
0857:  DECFSZ 7B,F
0858:  GOTO   05A
0859:  GOTO   086
085A:  BCF    03.5
085B:  BSF    03.6
085C:  RLF    0C,W
085D:  RLF    0E,W
085E:  ANDLW  7F
085F:  BSF    03.5
0860:  BCF    03.6
0861:  MOVWF  20
0862:  BCF    03.5
0863:  BSF    03.6
0864:  MOVF   0D,W
0865:  BSF    03.5
0866:  BCF    03.6
0867:  MOVWF  21
0868:  BCF    03.5
0869:  BSF    03.6
086A:  MOVF   0F,W
086B:  BSF    03.5
086C:  BCF    03.6
086D:  MOVWF  22
086E:  MOVF   20,W
086F:  BCF    03.5
0870:  BTFSS  0C.4
0871:  GOTO   070
0872:  MOVWF  19
0873:  BSF    03.5
0874:  MOVF   21,W
0875:  BCF    03.5
0876:  BSF    03.6
0877:  MOVWF  0D
0878:  BSF    03.5
0879:  BCF    03.6
087A:  MOVF   22,W
087B:  BCF    03.5
087C:  BSF    03.6
087D:  MOVWF  0F
087E:  INCF   0D,F
087F:  BTFSC  03.2
0880:  INCF   0F,F
0881:  BCF    03.0
0882:  DECFSZ 7B,F
0883:  GOTO   00E
0884:  BSF    03.5
0885:  BCF    03.6
*
088B:  MOVF   00,F
088C:  BTFSC  03.2
088D:  GOTO   0A3
088E:  CLRF   7C
088F:  MOVF   04,W
0890:  MOVWF  7B
0891:  BCF    7C.0
0892:  BTFSC  03.7
0893:  BSF    7C.0
0894:  MOVF   00,W
0895:  BCF    03.5
0896:  BTFSS  0C.4
0897:  GOTO   096
0898:  MOVWF  19
0899:  MOVF   7B,W
089A:  MOVWF  04
089B:  BCF    03.7
089C:  BTFSC  7C.0
089D:  BSF    03.7
089E:  INCF   04,F
089F:  BTFSC  03.2
08A0:  INCF   05,F
08A1:  BSF    03.5
08A2:  GOTO   08B
*
08D4:  BCF    03.6
08D5:  MOVF   0B,W
08D6:  BSF    03.5
08D7:  MOVWF  20
08D8:  BCF    03.5
08D9:  BCF    0B.7
08DA:  BSF    03.5
08DB:  BSF    03.6
08DC:  BSF    0C.7
08DD:  BSF    0C.0
08DE:  NOP
08DF:  NOP
08E0:  BCF    03.6
08E1:  BTFSS  20.7
08E2:  GOTO   0E6
08E3:  BCF    03.5
08E4:  BSF    0B.7
08E5:  BSF    03.5
08E6:  BTFSC  03.0
08E7:  GOTO   120
08E8:  BCF    03.5
08E9:  BSF    03.6
08EA:  MOVF   0C,W
08EB:  ANDLW  7F
08EC:  BSF    03.5
08ED:  BCF    03.6
08EE:  MOVWF  20
08EF:  BCF    03.5
08F0:  BSF    03.6
08F1:  MOVF   0D,W
08F2:  BSF    03.5
08F3:  BCF    03.6
08F4:  MOVWF  21
08F5:  BCF    03.5
08F6:  BSF    03.6
08F7:  MOVF   0F,W
08F8:  BSF    03.5
08F9:  BCF    03.6
08FA:  MOVWF  22
08FB:  MOVF   20,W
08FC:  BCF    03.5
08FD:  BTFSS  0C.4
08FE:  GOTO   0FD
08FF:  MOVWF  19
0900:  BSF    03.5
0901:  MOVF   21,W
0902:  BCF    03.5
0903:  BSF    03.6
0904:  MOVWF  0D
0905:  BSF    03.5
0906:  BCF    03.6
0907:  MOVF   22,W
0908:  BCF    03.5
0909:  BSF    03.6
090A:  MOVWF  0F
090B:  BCF    03.6
090C:  MOVF   0B,W
090D:  BSF    03.5
090E:  MOVWF  23
090F:  BCF    03.5
0910:  BCF    0B.7
0911:  BSF    03.5
0912:  BSF    03.6
0913:  BSF    0C.7
0914:  BSF    0C.0
0915:  NOP
0916:  NOP
0917:  BCF    03.6
0918:  BTFSS  23.7
0919:  GOTO   11D
091A:  BCF    03.5
091B:  BSF    0B.7
091C:  BSF    03.5
091D:  DECFSZ 7B,F
091E:  GOTO   120
091F:  GOTO   14C
0920:  BCF    03.5
0921:  BSF    03.6
0922:  RLF    0C,W
0923:  RLF    0E,W
0924:  ANDLW  7F
0925:  BSF    03.5
0926:  BCF    03.6
0927:  MOVWF  20
0928:  BCF    03.5
0929:  BSF    03.6
092A:  MOVF   0D,W
092B:  BSF    03.5
092C:  BCF    03.6
092D:  MOVWF  21
092E:  BCF    03.5
092F:  BSF    03.6
0930:  MOVF   0F,W
0931:  BSF    03.5
0932:  BCF    03.6
0933:  MOVWF  22
0934:  MOVF   20,W
0935:  BCF    03.5
0936:  BTFSS  0C.4
0937:  GOTO   136
0938:  MOVWF  19
0939:  BSF    03.5
093A:  MOVF   21,W
093B:  BCF    03.5
093C:  BSF    03.6
093D:  MOVWF  0D
093E:  BSF    03.5
093F:  BCF    03.6
0940:  MOVF   22,W
0941:  BCF    03.5
0942:  BSF    03.6
0943:  MOVWF  0F
0944:  INCF   0D,F
0945:  BTFSC  03.2
0946:  INCF   0F,F
0947:  BCF    03.0
0948:  DECFSZ 7B,F
0949:  GOTO   0D4
094A:  BSF    03.5
094B:  BCF    03.6
*
0951:  MOVF   00,F
0952:  BTFSC  03.2
0953:  GOTO   169
0954:  CLRF   7C
0955:  MOVF   04,W
0956:  MOVWF  7B
0957:  BCF    7C.0
0958:  BTFSC  03.7
0959:  BSF    7C.0
095A:  MOVF   00,W
095B:  BCF    03.5
095C:  BTFSS  0C.4
095D:  GOTO   15C
095E:  MOVWF  19
095F:  MOVF   7B,W
0960:  MOVWF  04
0961:  BCF    03.7
0962:  BTFSC  7C.0
0963:  BSF    03.7
0964:  INCF   04,F
0965:  BTFSC  03.2
0966:  INCF   05,F
0967:  BSF    03.5
0968:  GOTO   151
*
0982:  BCF    03.6
0983:  MOVF   0B,W
0984:  BSF    03.5
0985:  MOVWF  20
0986:  BCF    03.5
0987:  BCF    0B.7
0988:  BSF    03.5
0989:  BSF    03.6
098A:  BSF    0C.7
098B:  BSF    0C.0
098C:  NOP
098D:  NOP
098E:  BCF    03.6
098F:  BTFSS  20.7
0990:  GOTO   194
0991:  BCF    03.5
0992:  BSF    0B.7
0993:  BSF    03.5
0994:  BTFSC  03.0
0995:  GOTO   1CE
0996:  BCF    03.5
0997:  BSF    03.6
0998:  MOVF   0C,W
0999:  ANDLW  7F
099A:  BSF    03.5
099B:  BCF    03.6
099C:  MOVWF  20
099D:  BCF    03.5
099E:  BSF    03.6
099F:  MOVF   0D,W
09A0:  BSF    03.5
09A1:  BCF    03.6
09A2:  MOVWF  21
09A3:  BCF    03.5
09A4:  BSF    03.6
09A5:  MOVF   0F,W
09A6:  BSF    03.5
09A7:  BCF    03.6
09A8:  MOVWF  22
09A9:  MOVF   20,W
09AA:  BCF    03.5
09AB:  BTFSS  0C.4
09AC:  GOTO   1AB
09AD:  MOVWF  19
09AE:  BSF    03.5
09AF:  MOVF   21,W
09B0:  BCF    03.5
09B1:  BSF    03.6
09B2:  MOVWF  0D
09B3:  BSF    03.5
09B4:  BCF    03.6
09B5:  MOVF   22,W
09B6:  BCF    03.5
09B7:  BSF    03.6
09B8:  MOVWF  0F
09B9:  BCF    03.6
09BA:  MOVF   0B,W
09BB:  BSF    03.5
09BC:  MOVWF  23
09BD:  BCF    03.5
09BE:  BCF    0B.7
09BF:  BSF    03.5
09C0:  BSF    03.6
09C1:  BSF    0C.7
09C2:  BSF    0C.0
09C3:  NOP
09C4:  NOP
09C5:  BCF    03.6
09C6:  BTFSS  23.7
09C7:  GOTO   1CB
09C8:  BCF    03.5
09C9:  BSF    0B.7
09CA:  BSF    03.5
09CB:  DECFSZ 7B,F
09CC:  GOTO   1CE
09CD:  GOTO   1FA
09CE:  BCF    03.5
09CF:  BSF    03.6
09D0:  RLF    0C,W
09D1:  RLF    0E,W
09D2:  ANDLW  7F
09D3:  BSF    03.5
09D4:  BCF    03.6
09D5:  MOVWF  20
09D6:  BCF    03.5
09D7:  BSF    03.6
09D8:  MOVF   0D,W
09D9:  BSF    03.5
09DA:  BCF    03.6
09DB:  MOVWF  21
09DC:  BCF    03.5
09DD:  BSF    03.6
09DE:  MOVF   0F,W
09DF:  BSF    03.5
09E0:  BCF    03.6
09E1:  MOVWF  22
09E2:  MOVF   20,W
09E3:  BCF    03.5
09E4:  BTFSS  0C.4
09E5:  GOTO   1E4
09E6:  MOVWF  19
09E7:  BSF    03.5
09E8:  MOVF   21,W
09E9:  BCF    03.5
09EA:  BSF    03.6
09EB:  MOVWF  0D
09EC:  BSF    03.5
09ED:  BCF    03.6
09EE:  MOVF   22,W
09EF:  BCF    03.5
09F0:  BSF    03.6
09F1:  MOVWF  0F
09F2:  INCF   0D,F
09F3:  BTFSC  03.2
09F4:  INCF   0F,F
09F5:  BCF    03.0
09F6:  DECFSZ 7B,F
09F7:  GOTO   182
09F8:  BSF    03.5
09F9:  BCF    03.6
*
09FF:  MOVF   00,F
0A00:  BTFSC  03.2
0A01:  GOTO   217
0A02:  CLRF   7C
0A03:  MOVF   04,W
0A04:  MOVWF  7B
0A05:  BCF    7C.0
0A06:  BTFSC  03.7
0A07:  BSF    7C.0
0A08:  MOVF   00,W
0A09:  BCF    03.5
0A0A:  BTFSS  0C.4
0A0B:  GOTO   20A
0A0C:  MOVWF  19
0A0D:  MOVF   7B,W
0A0E:  MOVWF  04
0A0F:  BCF    03.7
0A10:  BTFSC  7C.0
0A11:  BSF    03.7
0A12:  INCF   04,F
0A13:  BTFSC  03.2
0A14:  INCF   05,F
0A15:  BSF    03.5
0A16:  GOTO   1FF
*
0A80:  BTFSC  03.1
0A81:  GOTO   285
0A82:  MOVLW  B2
0A83:  MOVWF  04
0A84:  BCF    03.7
0A85:  CLRF   77
0A86:  CLRF   78
0A87:  CLRF   79
0A88:  CLRF   7A
0A89:  CLRF   32
0A8A:  CLRF   33
0A8B:  CLRF   34
0A8C:  CLRF   35
0A8D:  MOVF   31,W
0A8E:  IORWF  30,W
0A8F:  IORWF  2F,W
0A90:  IORWF  2E,W
0A91:  BTFSC  03.2
0A92:  GOTO   2C3
0A93:  MOVLW  20
0A94:  MOVWF  36
0A95:  BCF    03.0
0A96:  RLF    2A,F
0A97:  RLF    2B,F
0A98:  RLF    2C,F
0A99:  RLF    2D,F
0A9A:  RLF    32,F
0A9B:  RLF    33,F
0A9C:  RLF    34,F
0A9D:  RLF    35,F
0A9E:  MOVF   31,W
0A9F:  SUBWF  35,W
0AA0:  BTFSS  03.2
0AA1:  GOTO   2AC
0AA2:  MOVF   30,W
0AA3:  SUBWF  34,W
0AA4:  BTFSS  03.2
0AA5:  GOTO   2AC
0AA6:  MOVF   2F,W
0AA7:  SUBWF  33,W
0AA8:  BTFSS  03.2
0AA9:  GOTO   2AC
0AAA:  MOVF   2E,W
0AAB:  SUBWF  32,W
0AAC:  BTFSS  03.0
0AAD:  GOTO   2BD
0AAE:  MOVF   2E,W
0AAF:  SUBWF  32,F
0AB0:  MOVF   2F,W
0AB1:  BTFSS  03.0
0AB2:  INCFSZ 2F,W
0AB3:  SUBWF  33,F
0AB4:  MOVF   30,W
0AB5:  BTFSS  03.0
0AB6:  INCFSZ 30,W
0AB7:  SUBWF  34,F
0AB8:  MOVF   31,W
0AB9:  BTFSS  03.0
0ABA:  INCFSZ 31,W
0ABB:  SUBWF  35,F
0ABC:  BSF    03.0
0ABD:  RLF    77,F
0ABE:  RLF    78,F
0ABF:  RLF    79,F
0AC0:  RLF    7A,F
0AC1:  DECFSZ 36,F
0AC2:  GOTO   295
0AC3:  MOVF   32,W
0AC4:  MOVWF  00
0AC5:  INCF   04,F
0AC6:  MOVF   33,W
0AC7:  MOVWF  00
0AC8:  INCF   04,F
0AC9:  MOVF   34,W
0ACA:  MOVWF  00
0ACB:  INCF   04,F
0ACC:  MOVF   35,W
0ACD:  MOVWF  00
*
0AE3:  MOVLW  20
0AE4:  MOVWF  36
0AE5:  CLRF   32
0AE6:  CLRF   33
0AE7:  CLRF   34
0AE8:  CLRF   35
0AE9:  MOVF   2D,W
0AEA:  MOVWF  7A
0AEB:  MOVF   2C,W
0AEC:  MOVWF  79
0AED:  MOVF   2B,W
0AEE:  MOVWF  78
0AEF:  MOVF   2A,W
0AF0:  MOVWF  77
0AF1:  BCF    03.0
0AF2:  BTFSS  77.0
0AF3:  GOTO   302
0AF4:  MOVF   2E,W
0AF5:  ADDWF  32,F
0AF6:  MOVF   2F,W
0AF7:  BTFSC  03.0
0AF8:  INCFSZ 2F,W
0AF9:  ADDWF  33,F
0AFA:  MOVF   30,W
0AFB:  BTFSC  03.0
0AFC:  INCFSZ 30,W
0AFD:  ADDWF  34,F
0AFE:  MOVF   31,W
0AFF:  BTFSC  03.0
0B00:  INCFSZ 31,W
0B01:  ADDWF  35,F
0B02:  RRF    35,F
0B03:  RRF    34,F
0B04:  RRF    33,F
0B05:  RRF    32,F
0B06:  RRF    7A,F
0B07:  RRF    79,F
0B08:  RRF    78,F
0B09:  RRF    77,F
0B0A:  DECFSZ 36,F
0B0B:  GOTO   2F1
*
0BA3:  MOVF   76,W
0BA4:  ANDLW  07
0BA5:  MOVWF  77
0BA6:  RRF    76,W
0BA7:  MOVWF  78
0BA8:  RRF    78,F
0BA9:  RRF    78,F
0BAA:  MOVLW  1F
0BAB:  ANDWF  78,F
0BAC:  MOVF   78,W
0BAD:  ADDWF  7C,W
0BAE:  MOVWF  04
0BAF:  BCF    03.7
0BB0:  BTFSC  7D.0
0BB1:  BSF    03.7
0BB2:  CLRF   78
0BB3:  INCF   78,F
0BB4:  INCF   77,F
0BB5:  GOTO   3B7
0BB6:  RLF    78,F
0BB7:  DECFSZ 77,F
0BB8:  GOTO   3B6
0BB9:  MOVF   7B,F
0BBA:  BTFSC  03.2
0BBB:  GOTO   3BF
0BBC:  MOVF   78,W
0BBD:  IORWF  00,F
0BBE:  GOTO   3C2
0BBF:  COMF   78,F
0BC0:  MOVF   78,W
0BC1:  ANDWF  00,F
0BC2:  RETURN
*
0F37:  BSF    0A.0
0F38:  BSF    0A.1
0F39:  BSF    0A.2
0F3A:  ADDWF  02,F
0F3B:  GOTO   724
0F3C:  GOTO   72A
0F3D:  GOTO   72E
0F3E:  GOTO   732
*
128A:  BCF    0A.0
128B:  BSF    0A.1
128C:  BCF    0A.2
128D:  ADDWF  02,F
128E:  GOTO   006
128F:  GOTO   044
1290:  GOTO   082
1291:  GOTO   0C0
1292:  GOTO   238
1293:  GOTO   287
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20000000) 
*
03F0:  MOVLW  A0
03F1:  MOVWF  04
03F2:  BCF    03.7
03F3:  MOVF   00,W
03F4:  BTFSC  03.2
03F5:  GOTO   403
03F6:  MOVLW  06
03F7:  MOVWF  78
03F8:  CLRF   77
03F9:  DECFSZ 77,F
03FA:  GOTO   3F9
03FB:  DECFSZ 78,F
03FC:  GOTO   3F8
03FD:  MOVLW  7B
03FE:  MOVWF  77
03FF:  DECFSZ 77,F
0400:  GOTO   3FF
0401:  DECFSZ 00,F
0402:  GOTO   3F6
0403:  RETURN
*
0B24:  MOVLW  03
0B25:  SUBWF  2B,F
0B26:  BTFSS  03.0
0B27:  GOTO   332
0B28:  MOVLW  AB
0B29:  MOVWF  04
0B2A:  BCF    03.7
0B2B:  MOVF   00,W
0B2C:  BTFSC  03.2
0B2D:  GOTO   332
0B2E:  GOTO   330
0B2F:  GOTO   330
0B30:  DECFSZ 00,F
0B31:  GOTO   32F
*
0B35:  MOVLW  03
0B36:  SUBWF  2B,F
0B37:  BTFSS  03.0
0B38:  GOTO   343
0B39:  MOVLW  AB
0B3A:  MOVWF  04
0B3B:  BCF    03.7
0B3C:  MOVF   00,W
0B3D:  BTFSC  03.2
0B3E:  GOTO   343
0B3F:  GOTO   341
0B40:  GOTO   341
0B41:  DECFSZ 00,F
0B42:  GOTO   340
*
0B55:  MOVLW  03
0B56:  SUBWF  2B,F
0B57:  BTFSS  03.0
0B58:  GOTO   363
0B59:  MOVLW  AB
0B5A:  MOVWF  04
0B5B:  BCF    03.7
0B5C:  MOVF   00,W
0B5D:  BTFSC  03.2
0B5E:  GOTO   363
0B5F:  GOTO   361
0B60:  GOTO   361
0B61:  DECFSZ 00,F
0B62:  GOTO   360
*
0B66:  MOVLW  03
0B67:  SUBWF  2B,F
0B68:  BTFSS  03.0
0B69:  GOTO   374
0B6A:  MOVLW  AB
0B6B:  MOVWF  04
0B6C:  BCF    03.7
0B6D:  MOVF   00,W
0B6E:  BTFSC  03.2
0B6F:  GOTO   374
0B70:  GOTO   372
0B71:  GOTO   372
0B72:  DECFSZ 00,F
0B73:  GOTO   371
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
*
0EAD:  MOVLW  4A
0EAE:  BCF    03.6
0EAF:  MOVWF  2B
0EB0:  CLRF   2C
0EB1:  MOVLW  49
0EB2:  MOVWF  2D
0EB3:  CLRF   2E
0EB4:  MOVLW  48
0EB5:  MOVWF  2F
0EB6:  CLRF   30
0EB7:  MOVLW  2C
0EB8:  MOVWF  31
0EB9:  CLRF   32
0EBA:  MOVLW  28
0EBB:  MOVWF  33
0EBC:  CLRF   34
0EBD:  MOVLW  29
0EBE:  MOVWF  35
0EBF:  CLRF   36
0EC0:  MOVLW  2A
0EC1:  MOVWF  37
0EC2:  CLRF   38
0EC3:  MOVLW  2B
0EC4:  MOVWF  39
0EC5:  CLRF   3A
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
0EC6:  CLRF   3B
0EC7:  CLRF   3C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
040C:  BSF    08.4
....................    output_float(LCD_DATA5); 
040D:  BSF    08.5
....................    output_float(LCD_DATA6); 
040E:  BSF    08.6
....................    output_float(LCD_DATA7); 
040F:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0410:  BCF    03.5
0411:  BSF    08.1
0412:  BSF    03.5
0413:  BCF    08.1
....................    delay_cycles(1); 
0414:  NOP
....................    lcd_output_enable(1); 
0415:  BCF    03.5
0416:  BSF    08.0
0417:  BSF    03.5
0418:  BCF    08.0
....................    delay_cycles(1); 
0419:  NOP
....................    high = lcd_read_nibble(); 
*
044A:  MOVF   78,W
044B:  MOVWF  27
....................        
....................    lcd_output_enable(0); 
044C:  BCF    03.5
044D:  BCF    08.0
044E:  BSF    03.5
044F:  BCF    08.0
....................    delay_cycles(1); 
0450:  NOP
....................    lcd_output_enable(1); 
0451:  BCF    03.5
0452:  BSF    08.0
0453:  BSF    03.5
0454:  BCF    08.0
....................    delay_us(1); 
0455:  GOTO   456
0456:  GOTO   457
0457:  NOP
....................    low = lcd_read_nibble(); 
*
0488:  MOVF   78,W
0489:  MOVWF  26
....................        
....................    lcd_output_enable(0); 
048A:  BCF    03.5
048B:  BCF    08.0
048C:  BSF    03.5
048D:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
048E:  BCF    08.4
....................    output_drive(LCD_DATA5); 
048F:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0490:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0491:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0492:  SWAPF  27,W
0493:  MOVWF  77
0494:  MOVLW  F0
0495:  ANDWF  77,F
0496:  MOVF   77,W
0497:  IORWF  26,W
0498:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
041A:  CLRF   28
*
0458:  CLRF   28
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
041B:  BSF    08.4
041C:  MOVLW  00
041D:  BCF    03.5
041E:  BTFSC  08.4
041F:  MOVLW  01
0420:  BSF    03.5
0421:  IORWF  28,F
*
0459:  BSF    08.4
045A:  MOVLW  00
045B:  BCF    03.5
045C:  BTFSC  08.4
045D:  MOVLW  01
045E:  BSF    03.5
045F:  IORWF  28,F
....................    n |= input(LCD_DATA5) << 1; 
*
0422:  BSF    08.5
0423:  MOVLW  00
0424:  BCF    03.5
0425:  BTFSC  08.5
0426:  MOVLW  01
0427:  MOVWF  77
0428:  BCF    03.0
0429:  RLF    77,F
042A:  MOVF   77,W
042B:  BSF    03.5
042C:  IORWF  28,F
*
0460:  BSF    08.5
0461:  MOVLW  00
0462:  BCF    03.5
0463:  BTFSC  08.5
0464:  MOVLW  01
0465:  MOVWF  77
0466:  BCF    03.0
0467:  RLF    77,F
0468:  MOVF   77,W
0469:  BSF    03.5
046A:  IORWF  28,F
....................    n |= input(LCD_DATA6) << 2; 
*
042D:  BSF    08.6
042E:  MOVLW  00
042F:  BCF    03.5
0430:  BTFSC  08.6
0431:  MOVLW  01
0432:  MOVWF  77
0433:  RLF    77,F
0434:  RLF    77,F
0435:  MOVLW  FC
0436:  ANDWF  77,F
0437:  MOVF   77,W
0438:  BSF    03.5
0439:  IORWF  28,F
*
046B:  BSF    08.6
046C:  MOVLW  00
046D:  BCF    03.5
046E:  BTFSC  08.6
046F:  MOVLW  01
0470:  MOVWF  77
0471:  RLF    77,F
0472:  RLF    77,F
0473:  MOVLW  FC
0474:  ANDWF  77,F
0475:  MOVF   77,W
0476:  BSF    03.5
0477:  IORWF  28,F
....................    n |= input(LCD_DATA7) << 3; 
*
043A:  BSF    08.7
043B:  MOVLW  00
043C:  BCF    03.5
043D:  BTFSC  08.7
043E:  MOVLW  01
043F:  MOVWF  77
0440:  RLF    77,F
0441:  RLF    77,F
0442:  RLF    77,F
0443:  MOVLW  F8
0444:  ANDWF  77,F
0445:  MOVF   77,W
0446:  BSF    03.5
0447:  IORWF  28,F
*
0478:  BSF    08.7
0479:  MOVLW  00
047A:  BCF    03.5
047B:  BTFSC  08.7
047C:  MOVLW  01
047D:  MOVWF  77
047E:  RLF    77,F
047F:  RLF    77,F
0480:  RLF    77,F
0481:  MOVLW  F8
0482:  ANDWF  77,F
0483:  MOVF   77,W
0484:  BSF    03.5
0485:  IORWF  28,F
....................     
....................    return(n); 
*
0448:  MOVF   28,W
0449:  MOVWF  78
*
0486:  MOVF   28,W
0487:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
04B8:  BTFSC  27.0
04B9:  GOTO   4BE
04BA:  BCF    03.5
04BB:  BCF    08.4
04BC:  GOTO   4C0
04BD:  BSF    03.5
04BE:  BCF    03.5
04BF:  BSF    08.4
04C0:  BSF    03.5
04C1:  BCF    08.4
*
04F4:  BTFSC  27.0
04F5:  GOTO   4FA
04F6:  BCF    03.5
04F7:  BCF    08.4
04F8:  GOTO   4FC
04F9:  BSF    03.5
04FA:  BCF    03.5
04FB:  BSF    08.4
04FC:  BSF    03.5
04FD:  BCF    08.4
*
0554:  BTFSC  27.0
0555:  GOTO   55A
0556:  BCF    03.5
0557:  BCF    08.4
0558:  GOTO   55C
0559:  BSF    03.5
055A:  BCF    03.5
055B:  BSF    08.4
055C:  BSF    03.5
055D:  BCF    08.4
*
0594:  BTFSC  27.0
0595:  GOTO   59A
0596:  BCF    03.5
0597:  BCF    08.4
0598:  GOTO   59C
0599:  BSF    03.5
059A:  BCF    03.5
059B:  BSF    08.4
059C:  BSF    03.5
059D:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
*
04C2:  BTFSC  27.1
04C3:  GOTO   4C8
04C4:  BCF    03.5
04C5:  BCF    08.5
04C6:  GOTO   4CA
04C7:  BSF    03.5
04C8:  BCF    03.5
04C9:  BSF    08.5
04CA:  BSF    03.5
04CB:  BCF    08.5
*
04FE:  BTFSC  27.1
04FF:  GOTO   504
0500:  BCF    03.5
0501:  BCF    08.5
0502:  GOTO   506
0503:  BSF    03.5
0504:  BCF    03.5
0505:  BSF    08.5
0506:  BSF    03.5
0507:  BCF    08.5
*
055E:  BTFSC  27.1
055F:  GOTO   564
0560:  BCF    03.5
0561:  BCF    08.5
0562:  GOTO   566
0563:  BSF    03.5
0564:  BCF    03.5
0565:  BSF    08.5
0566:  BSF    03.5
0567:  BCF    08.5
*
059E:  BTFSC  27.1
059F:  GOTO   5A4
05A0:  BCF    03.5
05A1:  BCF    08.5
05A2:  GOTO   5A6
05A3:  BSF    03.5
05A4:  BCF    03.5
05A5:  BSF    08.5
05A6:  BSF    03.5
05A7:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
*
04CC:  BTFSC  27.2
04CD:  GOTO   4D2
04CE:  BCF    03.5
04CF:  BCF    08.6
04D0:  GOTO   4D4
04D1:  BSF    03.5
04D2:  BCF    03.5
04D3:  BSF    08.6
04D4:  BSF    03.5
04D5:  BCF    08.6
*
0508:  BTFSC  27.2
0509:  GOTO   50E
050A:  BCF    03.5
050B:  BCF    08.6
050C:  GOTO   510
050D:  BSF    03.5
050E:  BCF    03.5
050F:  BSF    08.6
0510:  BSF    03.5
0511:  BCF    08.6
*
0568:  BTFSC  27.2
0569:  GOTO   56E
056A:  BCF    03.5
056B:  BCF    08.6
056C:  GOTO   570
056D:  BSF    03.5
056E:  BCF    03.5
056F:  BSF    08.6
0570:  BSF    03.5
0571:  BCF    08.6
*
05A8:  BTFSC  27.2
05A9:  GOTO   5AE
05AA:  BCF    03.5
05AB:  BCF    08.6
05AC:  GOTO   5B0
05AD:  BSF    03.5
05AE:  BCF    03.5
05AF:  BSF    08.6
05B0:  BSF    03.5
05B1:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
*
04D6:  BTFSC  27.3
04D7:  GOTO   4DC
04D8:  BCF    03.5
04D9:  BCF    08.7
04DA:  GOTO   4DE
04DB:  BSF    03.5
04DC:  BCF    03.5
04DD:  BSF    08.7
04DE:  BSF    03.5
04DF:  BCF    08.7
*
0512:  BTFSC  27.3
0513:  GOTO   518
0514:  BCF    03.5
0515:  BCF    08.7
0516:  GOTO   51A
0517:  BSF    03.5
0518:  BCF    03.5
0519:  BSF    08.7
051A:  BSF    03.5
051B:  BCF    08.7
*
0572:  BTFSC  27.3
0573:  GOTO   578
0574:  BCF    03.5
0575:  BCF    08.7
0576:  GOTO   57A
0577:  BSF    03.5
0578:  BCF    03.5
0579:  BSF    08.7
057A:  BSF    03.5
057B:  BCF    08.7
*
05B2:  BTFSC  27.3
05B3:  GOTO   5B8
05B4:  BCF    03.5
05B5:  BCF    08.7
05B6:  GOTO   5BA
05B7:  BSF    03.5
05B8:  BCF    03.5
05B9:  BSF    08.7
05BA:  BSF    03.5
05BB:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
*
04E0:  NOP
*
051C:  NOP
*
057C:  NOP
*
05BC:  NOP
....................    lcd_output_enable(1); 
*
04E1:  BCF    03.5
04E2:  BSF    08.0
04E3:  BSF    03.5
04E4:  BCF    08.0
*
051D:  BCF    03.5
051E:  BSF    08.0
051F:  BSF    03.5
0520:  BCF    08.0
*
057D:  BCF    03.5
057E:  BSF    08.0
057F:  BSF    03.5
0580:  BCF    08.0
*
05BD:  BCF    03.5
05BE:  BSF    08.0
05BF:  BSF    03.5
05C0:  BCF    08.0
....................    delay_us(2); 
*
04E5:  MOVLW  02
04E6:  MOVWF  77
04E7:  DECFSZ 77,F
04E8:  GOTO   4E7
04E9:  GOTO   4EA
04EA:  NOP
*
0521:  MOVLW  02
0522:  MOVWF  77
0523:  DECFSZ 77,F
0524:  GOTO   523
0525:  GOTO   526
0526:  NOP
*
0581:  MOVLW  02
0582:  MOVWF  77
0583:  DECFSZ 77,F
0584:  GOTO   583
0585:  GOTO   586
0586:  NOP
*
05C1:  MOVLW  02
05C2:  MOVWF  77
05C3:  DECFSZ 77,F
05C4:  GOTO   5C3
05C5:  GOTO   5C6
05C6:  NOP
....................    lcd_output_enable(0); 
*
04EB:  BCF    03.5
04EC:  BCF    08.0
04ED:  BSF    03.5
04EE:  BCF    08.0
*
0527:  BCF    03.5
0528:  BCF    08.0
0529:  BSF    03.5
052A:  BCF    08.0
*
0587:  BCF    03.5
0588:  BCF    08.0
0589:  BSF    03.5
058A:  BCF    08.0
*
05C7:  BCF    03.5
05C8:  BCF    08.0
05C9:  BSF    03.5
05CA:  BCF    08.0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0404:  BSF    03.5
0405:  BCF    08.0
....................    lcd_rs_tris(); 
0406:  BCF    08.2
....................    lcd_rw_tris(); 
0407:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0408:  BCF    03.5
0409:  BCF    08.2
040A:  BSF    03.5
040B:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0499:  MOVF   78,W
049A:  MOVWF  26
049B:  BTFSC  26.7
049C:  GOTO   40C
....................    lcd_output_rs(address); 
049D:  MOVF   24,F
049E:  BTFSS  03.2
049F:  GOTO   4A4
04A0:  BCF    03.5
04A1:  BCF    08.2
04A2:  GOTO   4A6
04A3:  BSF    03.5
04A4:  BCF    03.5
04A5:  BSF    08.2
04A6:  BSF    03.5
04A7:  BCF    08.2
....................    delay_cycles(1); 
04A8:  NOP
....................    lcd_output_rw(0); 
04A9:  BCF    03.5
04AA:  BCF    08.1
04AB:  BSF    03.5
04AC:  BCF    08.1
....................    delay_cycles(1); 
04AD:  NOP
....................    lcd_output_enable(0); 
04AE:  BCF    03.5
04AF:  BCF    08.0
04B0:  BSF    03.5
04B1:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
04B2:  SWAPF  25,W
04B3:  MOVWF  26
04B4:  MOVLW  0F
04B5:  ANDWF  26,F
04B6:  MOVF   26,W
04B7:  MOVWF  27
....................    lcd_send_nibble(n & 0xf); 
*
04EF:  MOVF   25,W
04F0:  ANDLW  0F
04F1:  MOVWF  26
04F2:  MOVF   26,W
04F3:  MOVWF  27
*
052B:  BCF    03.5
052C:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
052D:  MOVLW  28
052E:  MOVWF  73
052F:  MOVLW  0C
0530:  MOVWF  74
0531:  MOVLW  01
0532:  MOVWF  75
0533:  MOVLW  06
0534:  MOVWF  76
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0535:  BCF    08.0
0536:  BSF    03.5
0537:  BCF    08.0
....................    lcd_output_rs(0); 
0538:  BCF    03.5
0539:  BCF    08.2
053A:  BSF    03.5
053B:  BCF    08.2
....................    lcd_output_rw(0); 
053C:  BCF    03.5
053D:  BCF    08.1
053E:  BSF    03.5
053F:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0540:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0541:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0542:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0543:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0544:  BCF    08.0
....................    lcd_rs_tris(); 
0545:  BCF    08.2
....................    lcd_rw_tris(); 
0546:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
0547:  MOVLW  0F
0548:  MOVWF  20
0549:  BCF    03.5
054A:  CALL   3F0
....................    for(i=1;i<=3;++i) 
054B:  MOVLW  01
054C:  MOVWF  72
054D:  MOVF   72,W
054E:  SUBLW  03
054F:  BTFSS  03.0
0550:  GOTO   591
....................    { 
....................        lcd_send_nibble(3); 
0551:  MOVLW  03
0552:  BSF    03.5
0553:  MOVWF  27
....................        delay_ms(5); 
*
058B:  MOVLW  05
058C:  MOVWF  20
058D:  BCF    03.5
058E:  CALL   3F0
058F:  INCF   72,F
0590:  GOTO   54D
....................    } 
....................     
....................    lcd_send_nibble(2); 
0591:  MOVLW  02
0592:  BSF    03.5
0593:  MOVWF  27
....................    delay_ms(5); 
*
05CB:  MOVLW  05
05CC:  MOVWF  20
05CD:  BCF    03.5
05CE:  CALL   3F0
....................    for(i=0;i<=3;++i) 
05CF:  CLRF   72
05D0:  MOVF   72,W
05D1:  SUBLW  03
05D2:  BTFSS  03.0
05D3:  GOTO   5E2
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
05D4:  MOVLW  73
05D5:  ADDWF  72,W
05D6:  MOVWF  04
05D7:  BCF    03.7
05D8:  MOVF   00,W
05D9:  MOVWF  7B
05DA:  BSF    03.5
05DB:  CLRF   24
05DC:  MOVF   7B,W
05DD:  MOVWF  25
05DE:  BCF    03.5
05DF:  CALL   404
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
05E0:  INCF   72,F
05E1:  GOTO   5D0
05E2:  BSF    0A.3
05E3:  BCF    0A.4
05E4:  GOTO   718 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
066F:  DECFSZ 21,W
0670:  GOTO   672
0671:  GOTO   675
*
0693:  DECFSZ 21,W
0694:  GOTO   696
0695:  GOTO   699
*
0749:  DECFSZ 21,W
074A:  GOTO   74C
074B:  GOTO   74F
*
079B:  DECFSZ 21,W
079C:  GOTO   79E
079D:  GOTO   7A1
*
0BE5:  DECFSZ 21,W
0BE6:  GOTO   3E8
0BE7:  GOTO   3EB
*
0C42:  DECFSZ 21,W
0C43:  GOTO   445
0C44:  GOTO   448
*
0CBB:  DECFSZ 21,W
0CBC:  GOTO   4BE
0CBD:  GOTO   4C1
*
0D15:  DECFSZ 21,W
0D16:  GOTO   518
0D17:  GOTO   51B
*
0D90:  DECFSZ 21,W
0D91:  GOTO   593
0D92:  GOTO   596
*
0DED:  DECFSZ 21,W
0DEE:  GOTO   5F0
0DEF:  GOTO   5F3
*
0E50:  DECFSZ 21,W
0E51:  GOTO   653
0E52:  GOTO   656
*
1014:  DECFSZ 21,W
1015:  GOTO   017
1016:  GOTO   01A
*
1052:  DECFSZ 21,W
1053:  GOTO   055
1054:  GOTO   058
*
1090:  DECFSZ 21,W
1091:  GOTO   093
1092:  GOTO   096
*
10E2:  DECFSZ 21,W
10E3:  GOTO   0E5
10E4:  GOTO   0E8
*
1143:  DECFSZ 21,W
1144:  GOTO   146
1145:  GOTO   149
*
11CA:  DECFSZ 21,W
11CB:  GOTO   1CD
11CC:  GOTO   1D0
*
1219:  DECFSZ 21,W
121A:  GOTO   21C
121B:  GOTO   21F
*
1257:  DECFSZ 21,W
1258:  GOTO   25A
1259:  GOTO   25D
....................       address=LCD_LINE_TWO; 
*
0672:  MOVLW  40
0673:  MOVWF  22
0674:  GOTO   676
*
0696:  MOVLW  40
0697:  MOVWF  22
0698:  GOTO   69A
*
074C:  MOVLW  40
074D:  MOVWF  22
074E:  GOTO   750
*
079E:  MOVLW  40
079F:  MOVWF  22
07A0:  GOTO   7A2
*
0BE8:  MOVLW  40
0BE9:  MOVWF  22
0BEA:  GOTO   3EC
*
0C45:  MOVLW  40
0C46:  MOVWF  22
0C47:  GOTO   449
*
0CBE:  MOVLW  40
0CBF:  MOVWF  22
0CC0:  GOTO   4C2
*
0D18:  MOVLW  40
0D19:  MOVWF  22
0D1A:  GOTO   51C
*
0D93:  MOVLW  40
0D94:  MOVWF  22
0D95:  GOTO   597
*
0DF0:  MOVLW  40
0DF1:  MOVWF  22
0DF2:  GOTO   5F4
*
0E53:  MOVLW  40
0E54:  MOVWF  22
0E55:  GOTO   657
*
1017:  MOVLW  40
1018:  MOVWF  22
1019:  GOTO   01B
*
1055:  MOVLW  40
1056:  MOVWF  22
1057:  GOTO   059
*
1093:  MOVLW  40
1094:  MOVWF  22
1095:  GOTO   097
*
10E5:  MOVLW  40
10E6:  MOVWF  22
10E7:  GOTO   0E9
*
1146:  MOVLW  40
1147:  MOVWF  22
1148:  GOTO   14A
*
11CD:  MOVLW  40
11CE:  MOVWF  22
11CF:  GOTO   1D1
*
121C:  MOVLW  40
121D:  MOVWF  22
121E:  GOTO   220
*
125A:  MOVLW  40
125B:  MOVWF  22
125C:  GOTO   25E
....................    else 
....................       address=0; 
*
0675:  CLRF   22
*
0699:  CLRF   22
*
074F:  CLRF   22
*
07A1:  CLRF   22
*
0BEB:  CLRF   22
*
0C48:  CLRF   22
*
0CC1:  CLRF   22
*
0D1B:  CLRF   22
*
0D96:  CLRF   22
*
0DF3:  CLRF   22
*
0E56:  CLRF   22
*
101A:  CLRF   22
*
1058:  CLRF   22
*
1096:  CLRF   22
*
10E8:  CLRF   22
*
1149:  CLRF   22
*
11D0:  CLRF   22
*
121F:  CLRF   22
*
125D:  CLRF   22
....................       
....................    address+=x-1; 
*
0676:  MOVLW  01
0677:  SUBWF  20,W
0678:  ADDWF  22,F
*
069A:  MOVLW  01
069B:  SUBWF  20,W
069C:  ADDWF  22,F
*
0750:  MOVLW  01
0751:  SUBWF  20,W
0752:  ADDWF  22,F
*
07A2:  MOVLW  01
07A3:  SUBWF  20,W
07A4:  ADDWF  22,F
*
0BEC:  MOVLW  01
0BED:  SUBWF  20,W
0BEE:  ADDWF  22,F
*
0C49:  MOVLW  01
0C4A:  SUBWF  20,W
0C4B:  ADDWF  22,F
*
0CC2:  MOVLW  01
0CC3:  SUBWF  20,W
0CC4:  ADDWF  22,F
*
0D1C:  MOVLW  01
0D1D:  SUBWF  20,W
0D1E:  ADDWF  22,F
*
0D97:  MOVLW  01
0D98:  SUBWF  20,W
0D99:  ADDWF  22,F
*
0DF4:  MOVLW  01
0DF5:  SUBWF  20,W
0DF6:  ADDWF  22,F
*
0E57:  MOVLW  01
0E58:  SUBWF  20,W
0E59:  ADDWF  22,F
*
101B:  MOVLW  01
101C:  SUBWF  20,W
101D:  ADDWF  22,F
*
1059:  MOVLW  01
105A:  SUBWF  20,W
105B:  ADDWF  22,F
*
1097:  MOVLW  01
1098:  SUBWF  20,W
1099:  ADDWF  22,F
*
10E9:  MOVLW  01
10EA:  SUBWF  20,W
10EB:  ADDWF  22,F
*
114A:  MOVLW  01
114B:  SUBWF  20,W
114C:  ADDWF  22,F
*
11D1:  MOVLW  01
11D2:  SUBWF  20,W
11D3:  ADDWF  22,F
*
1220:  MOVLW  01
1221:  SUBWF  20,W
1222:  ADDWF  22,F
*
125E:  MOVLW  01
125F:  SUBWF  20,W
1260:  ADDWF  22,F
....................    lcd_send_byte(0,0x80|address); 
*
0679:  MOVF   22,W
067A:  IORLW  80
067B:  MOVWF  23
067C:  CLRF   24
067D:  MOVF   23,W
067E:  MOVWF  25
067F:  BCF    03.5
0680:  CALL   404
*
069D:  MOVF   22,W
069E:  IORLW  80
069F:  MOVWF  23
06A0:  CLRF   24
06A1:  MOVF   23,W
06A2:  MOVWF  25
06A3:  BCF    03.5
06A4:  CALL   404
*
0753:  MOVF   22,W
0754:  IORLW  80
0755:  MOVWF  23
0756:  CLRF   24
0757:  MOVF   23,W
0758:  MOVWF  25
0759:  BCF    03.5
075A:  CALL   404
*
07A5:  MOVF   22,W
07A6:  IORLW  80
07A7:  MOVWF  23
07A8:  CLRF   24
07A9:  MOVF   23,W
07AA:  MOVWF  25
07AB:  BCF    03.5
07AC:  CALL   404
*
0BEF:  MOVF   22,W
0BF0:  IORLW  80
0BF1:  MOVWF  23
0BF2:  CLRF   24
0BF3:  MOVF   23,W
0BF4:  MOVWF  25
0BF5:  BCF    0A.3
0BF6:  BCF    03.5
0BF7:  CALL   404
0BF8:  BSF    0A.3
*
0C4C:  MOVF   22,W
0C4D:  IORLW  80
0C4E:  MOVWF  23
0C4F:  CLRF   24
0C50:  MOVF   23,W
0C51:  MOVWF  25
0C52:  BCF    0A.3
0C53:  BCF    03.5
0C54:  CALL   404
0C55:  BSF    0A.3
*
0CC5:  MOVF   22,W
0CC6:  IORLW  80
0CC7:  MOVWF  23
0CC8:  CLRF   24
0CC9:  MOVF   23,W
0CCA:  MOVWF  25
0CCB:  BCF    0A.3
0CCC:  BCF    03.5
0CCD:  CALL   404
0CCE:  BSF    0A.3
*
0D1F:  MOVF   22,W
0D20:  IORLW  80
0D21:  MOVWF  23
0D22:  CLRF   24
0D23:  MOVF   23,W
0D24:  MOVWF  25
0D25:  BCF    0A.3
0D26:  BCF    03.5
0D27:  CALL   404
0D28:  BSF    0A.3
*
0D9A:  MOVF   22,W
0D9B:  IORLW  80
0D9C:  MOVWF  23
0D9D:  CLRF   24
0D9E:  MOVF   23,W
0D9F:  MOVWF  25
0DA0:  BCF    0A.3
0DA1:  BCF    03.5
0DA2:  CALL   404
0DA3:  BSF    0A.3
*
0DF7:  MOVF   22,W
0DF8:  IORLW  80
0DF9:  MOVWF  23
0DFA:  CLRF   24
0DFB:  MOVF   23,W
0DFC:  MOVWF  25
0DFD:  BCF    0A.3
0DFE:  BCF    03.5
0DFF:  CALL   404
0E00:  BSF    0A.3
*
0E5A:  MOVF   22,W
0E5B:  IORLW  80
0E5C:  MOVWF  23
0E5D:  CLRF   24
0E5E:  MOVF   23,W
0E5F:  MOVWF  25
0E60:  BCF    0A.3
0E61:  BCF    03.5
0E62:  CALL   404
0E63:  BSF    0A.3
*
101E:  MOVF   22,W
101F:  IORLW  80
1020:  MOVWF  23
1021:  CLRF   24
1022:  MOVF   23,W
1023:  MOVWF  25
1024:  BCF    0A.4
1025:  BCF    03.5
1026:  CALL   404
1027:  BSF    0A.4
*
105C:  MOVF   22,W
105D:  IORLW  80
105E:  MOVWF  23
105F:  CLRF   24
1060:  MOVF   23,W
1061:  MOVWF  25
1062:  BCF    0A.4
1063:  BCF    03.5
1064:  CALL   404
1065:  BSF    0A.4
*
109A:  MOVF   22,W
109B:  IORLW  80
109C:  MOVWF  23
109D:  CLRF   24
109E:  MOVF   23,W
109F:  MOVWF  25
10A0:  BCF    0A.4
10A1:  BCF    03.5
10A2:  CALL   404
10A3:  BSF    0A.4
*
10EC:  MOVF   22,W
10ED:  IORLW  80
10EE:  MOVWF  23
10EF:  CLRF   24
10F0:  MOVF   23,W
10F1:  MOVWF  25
10F2:  BCF    0A.4
10F3:  BCF    03.5
10F4:  CALL   404
10F5:  BSF    0A.4
*
114D:  MOVF   22,W
114E:  IORLW  80
114F:  MOVWF  23
1150:  CLRF   24
1151:  MOVF   23,W
1152:  MOVWF  25
1153:  BCF    0A.4
1154:  BCF    03.5
1155:  CALL   404
1156:  BSF    0A.4
*
11D4:  MOVF   22,W
11D5:  IORLW  80
11D6:  MOVWF  23
11D7:  CLRF   24
11D8:  MOVF   23,W
11D9:  MOVWF  25
11DA:  BCF    0A.4
11DB:  BCF    03.5
11DC:  CALL   404
11DD:  BSF    0A.4
*
1223:  MOVF   22,W
1224:  IORLW  80
1225:  MOVWF  23
1226:  CLRF   24
1227:  MOVF   23,W
1228:  MOVWF  25
1229:  BCF    0A.4
122A:  BCF    03.5
122B:  CALL   404
122C:  BSF    0A.4
*
1261:  MOVF   22,W
1262:  IORLW  80
1263:  MOVWF  23
1264:  CLRF   24
1265:  MOVF   23,W
1266:  MOVWF  25
1267:  BCF    0A.4
1268:  BCF    03.5
1269:  CALL   404
126A:  BSF    0A.4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
065D:  MOVF   7E,W
065E:  XORLW  07
065F:  BTFSC  03.2
0660:  GOTO   66B
0661:  XORLW  0B
0662:  BTFSC  03.2
0663:  GOTO   682
0664:  XORLW  06
0665:  BTFSC  03.2
0666:  GOTO   68E
0667:  XORLW  02
0668:  BTFSC  03.2
0669:  GOTO   6A6
066A:  GOTO   6AD
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
066B:  MOVLW  01
066C:  BSF    03.5
066D:  MOVWF  20
066E:  MOVWF  21
*
0681:  GOTO   6B4
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0682:  BSF    03.5
0683:  CLRF   24
0684:  MOVLW  01
0685:  MOVWF  25
0686:  BCF    03.5
0687:  CALL   404
....................                      delay_ms(2); 
0688:  MOVLW  02
0689:  BSF    03.5
068A:  MOVWF  20
068B:  BCF    03.5
068C:  CALL   3F0
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
068D:  GOTO   6B4
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
068E:  MOVLW  01
068F:  BSF    03.5
0690:  MOVWF  20
0691:  MOVLW  02
0692:  MOVWF  21
*
06A5:  GOTO   6B4
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
06A6:  BSF    03.5
06A7:  CLRF   24
06A8:  MOVLW  10
06A9:  MOVWF  25
06AA:  BCF    03.5
06AB:  CALL   404
06AC:  GOTO   6B4
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
06AD:  MOVLW  01
06AE:  BSF    03.5
06AF:  MOVWF  24
06B0:  MOVF   7E,W
06B1:  MOVWF  25
06B2:  BCF    03.5
06B3:  CALL   404
....................      #endif 
....................    } 
06B4:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
0A54:  BSF    03.5
0A55:  CLRF   21
0A56:  CLRF   20
0A57:  CLRF   23
0A58:  CLRF   22
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
0A59:  MOVF   7C,F
0A5A:  BTFSS  03.2
0A5B:  GOTO   260
0A5C:  MOVF   7B,W
0A5D:  SUBLW  13
0A5E:  BTFSC  03.0
0A5F:  GOTO   3A1
0A60:  MOVF   7C,W
0A61:  SUBLW  4E
0A62:  BTFSS  03.0
0A63:  GOTO   3A1
0A64:  BTFSS  03.2
0A65:  GOTO   26A
0A66:  MOVF   7B,W
0A67:  SUBLW  20
0A68:  BTFSS  03.0
0A69:  GOTO   3A1
....................       tmp=100000; 
0A6A:  CLRF   29
0A6B:  MOVLW  01
0A6C:  MOVWF  28
0A6D:  MOVLW  86
0A6E:  MOVWF  27
0A6F:  MOVLW  A0
0A70:  MOVWF  26
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
0A71:  BCF    03.1
0A72:  MOVF   29,W
0A73:  MOVWF  2D
0A74:  MOVF   28,W
0A75:  MOVWF  2C
0A76:  MOVF   27,W
0A77:  MOVWF  2B
0A78:  MOVF   26,W
0A79:  MOVWF  2A
0A7A:  CLRF   31
0A7B:  CLRF   30
0A7C:  MOVF   7C,W
0A7D:  MOVWF  2F
0A7E:  MOVF   7B,W
0A7F:  MOVWF  2E
*
0ACE:  MOVF   7A,W
0ACF:  MOVWF  29
0AD0:  MOVF   79,W
0AD1:  MOVWF  28
0AD2:  MOVF   78,W
0AD3:  MOVWF  27
0AD4:  MOVF   77,W
0AD5:  MOVWF  26
....................       tmp*=5;    
0AD6:  MOVF   29,W
0AD7:  MOVWF  2D
0AD8:  MOVF   28,W
0AD9:  MOVWF  2C
0ADA:  MOVF   27,W
0ADB:  MOVWF  2B
0ADC:  MOVF   26,W
0ADD:  MOVWF  2A
0ADE:  CLRF   31
0ADF:  CLRF   30
0AE0:  CLRF   2F
0AE1:  MOVLW  05
0AE2:  MOVWF  2E
*
0B0C:  MOVF   7A,W
0B0D:  MOVWF  29
0B0E:  MOVF   79,W
0B0F:  MOVWF  28
0B10:  MOVF   78,W
0B11:  MOVWF  27
0B12:  MOVF   77,W
0B13:  MOVWF  26
....................       uS=tmp; 
0B14:  MOVF   27,W
0B15:  MOVWF  25
0B16:  MOVF   26,W
0B17:  MOVWF  24
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
0B18:  BCF    06.2
0B19:  BCF    03.5
0B1A:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0B1B:  BSF    03.5
0B1C:  MOVF   25,W
0B1D:  MOVWF  2A
0B1E:  INCF   2A,F
0B1F:  DECF   2A,F
0B20:  BTFSC  03.2
0B21:  GOTO   333
0B22:  MOVLW  FF
0B23:  MOVWF  2B
*
0B32:  GOTO   31F
0B33:  MOVF   24,W
0B34:  MOVWF  2B
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
0B43:  MOVF   24,W
0B44:  ADDWF  22,F
0B45:  MOVF   25,W
0B46:  BTFSC  03.0
0B47:  INCFSZ 25,W
0B48:  ADDWF  23,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0B49:  BCF    06.2
0B4A:  BCF    03.5
0B4B:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
0B4C:  BSF    03.5
0B4D:  MOVF   25,W
0B4E:  MOVWF  2A
0B4F:  INCF   2A,F
0B50:  DECF   2A,F
0B51:  BTFSC  03.2
0B52:  GOTO   364
0B53:  MOVLW  FF
0B54:  MOVWF  2B
*
0B63:  GOTO   350
0B64:  MOVF   24,W
0B65:  MOVWF  2B
....................          CiclosL+=(uS);          //  
*
0B74:  MOVF   24,W
0B75:  ADDWF  22,F
0B76:  MOVF   25,W
0B77:  BTFSC  03.0
0B78:  INCFSZ 25,W
0B79:  ADDWF  23,F
....................          CiclosL+=25;            // Compensador. 
0B7A:  MOVLW  19
0B7B:  ADDWF  22,F
0B7C:  BTFSC  03.0
0B7D:  INCF   23,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
0B7E:  MOVF   23,W
0B7F:  SUBLW  02
0B80:  BTFSC  03.0
0B81:  GOTO   397
0B82:  XORLW  FF
0B83:  BTFSS  03.2
0B84:  GOTO   389
0B85:  MOVF   22,W
0B86:  SUBLW  E7
0B87:  BTFSC  03.0
0B88:  GOTO   397
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0B89:  MOVLW  E8
0B8A:  SUBWF  22,F
0B8B:  MOVLW  03
0B8C:  BTFSS  03.0
0B8D:  MOVLW  04
0B8E:  SUBWF  23,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0B8F:  INCF   20,F
0B90:  BTFSC  03.2
0B91:  INCF   21,F
....................             CiclosL+=25;         // Compensador. 
0B92:  MOVLW  19
0B93:  ADDWF  22,F
0B94:  BTFSC  03.0
0B95:  INCF   23,F
0B96:  GOTO   37E
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
0B97:  MOVF   21,W
0B98:  SUBWF  7E,W
0B99:  BTFSS  03.0
0B9A:  GOTO   3A1
0B9B:  BTFSS  03.2
0B9C:  GOTO   318
0B9D:  MOVF   7D,W
0B9E:  SUBWF  20,W
0B9F:  BTFSS  03.0
0BA0:  GOTO   318
....................                                          // tiempo indicado. 
....................    } 
0BA1:  BCF    03.5
0BA2:  RETURN
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/func_menu_setup.h" 
.................... #include "header/menu.h" 
.................... #include "header/esp8266.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_IP     0 
....................   #define OPT_SHOW_SSID   1 
....................   #define OPT_SHOW_KEY    2 
....................   #define OPT_MODE_AP     3 
....................   #define OPT_BACKLIGH    4 
....................   #define OPT_EXIT        5 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[7][17]    =  { {"VER IP          "}, 
....................                                         {"VER SSID        "}, 
....................                                         {"VER KEY         "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacion     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 5; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
072E:  CLRF   72
072F:  CLRF   73
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0730:  SWAPF  72,W
0731:  MOVWF  77
0732:  MOVLW  F0
0733:  ANDWF  77,F
0734:  MOVF   77,W
0735:  MOVWF  74
0736:  MOVLW  0C
0737:  MOVWF  7E
0738:  CALL   65D
0739:  MOVLW  82
073A:  BSF    03.6
073B:  MOVWF  0D
073C:  MOVLW  00
073D:  MOVWF  0F
073E:  MOVF   74,W
073F:  ADDWF  0D,F
0740:  BTFSC  03.0
0741:  INCF   0F,F
0742:  BCF    03.6
0743:  CALL   6B5
....................    showBottonMenu(); 
....................    while(!exit){ 
*
0762:  MOVF   73,F
0763:  BTFSS  03.2
0764:  GOTO   7CF
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0765:  BSF    03.5
0766:  BSF    06.4
0767:  BCF    03.5
0768:  BTFSC  06.4
0769:  GOTO   7B4
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
076A:  MOVLW  02
076B:  MOVWF  74
076C:  MOVLW  FA
076D:  BSF    03.5
076E:  MOVWF  20
076F:  BCF    03.5
0770:  CALL   3F0
0771:  DECFSZ 74,F
0772:  GOTO   76C
....................          BEEP; 
0773:  MOVLW  04
0774:  MOVWF  7C
0775:  MOVLW  B9
0776:  MOVWF  7B
0777:  CLRF   7E
0778:  MOVLW  14
0779:  MOVWF  7D
077A:  BSF    0A.3
077B:  CALL   254
077C:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
077D:  INCF   72,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
077E:  MOVF   72,W
077F:  SUBWF  41,W
0780:  BTFSS  03.0
....................             optSelected = 0; 
0781:  CLRF   72
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0782:  SWAPF  72,W
0783:  MOVWF  77
0784:  MOVLW  F0
0785:  ANDWF  77,F
0786:  MOVF   77,W
0787:  MOVWF  74
0788:  MOVLW  0C
0789:  MOVWF  7E
078A:  CALL   65D
078B:  MOVLW  82
078C:  BSF    03.6
078D:  MOVWF  0D
078E:  MOVLW  00
078F:  MOVWF  0F
0790:  MOVF   74,W
0791:  ADDWF  0D,F
0792:  BTFSC  03.0
0793:  INCF   0F,F
0794:  BCF    03.6
0795:  CALL   6B5
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
07B4:  BSF    03.5
07B5:  BSF    06.5
07B6:  BCF    03.5
07B7:  BTFSC  06.5
07B8:  GOTO   7CE
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
07B9:  MOVLW  02
07BA:  MOVWF  74
07BB:  MOVLW  FA
07BC:  BSF    03.5
07BD:  MOVWF  20
07BE:  BCF    03.5
07BF:  CALL   3F0
07C0:  DECFSZ 74,F
07C1:  GOTO   7BB
....................          BEEP; 
07C2:  MOVLW  04
07C3:  MOVWF  7C
07C4:  MOVLW  B9
07C5:  MOVWF  7B
07C6:  CLRF   7E
07C7:  MOVLW  14
07C8:  MOVWF  7D
07C9:  BSF    0A.3
07CA:  CALL   254
07CB:  BCF    0A.3
....................          // Rompe el Loop 
....................          exit = 1; 
07CC:  MOVLW  01
07CD:  MOVWF  73
....................       } // Fin KEY_OK 
07CE:  GOTO   762
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
07CF:  MOVLW  01
07D0:  ADDWF  72,W
07D1:  MOVWF  78
07D2:  BSF    0A.3
07D3:  BCF    0A.4
07D4:  GOTO   726 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
100F:  MOVLW  0C
1010:  BSF    03.5
1011:  MOVWF  20
1012:  MOVLW  02
1013:  MOVWF  21
*
104D:  MOVLW  0C
104E:  BSF    03.5
104F:  MOVWF  20
1050:  MOVLW  02
1051:  MOVWF  21
*
108B:  MOVLW  0C
108C:  BSF    03.5
108D:  MOVWF  20
108E:  MOVLW  02
108F:  MOVWF  21
*
11C5:  MOVLW  0C
11C6:  BSF    03.5
11C7:  MOVWF  20
11C8:  MOVLW  02
11C9:  MOVWF  21
*
1252:  MOVLW  0C
1253:  BSF    03.5
1254:  MOVWF  20
1255:  MOVLW  02
1256:  MOVWF  21
....................   printf(lcd_putc, "SALIR"); 
*
1028:  MOVLW  B5
1029:  BSF    03.6
102A:  MOVWF  0D
102B:  MOVLW  02
102C:  MOVWF  0F
102D:  BCF    0A.4
102E:  BCF    03.6
102F:  CALL   6DE
1030:  BSF    0A.4
*
1066:  MOVLW  B5
1067:  BSF    03.6
1068:  MOVWF  0D
1069:  MOVLW  02
106A:  MOVWF  0F
106B:  BCF    0A.4
106C:  BCF    03.6
106D:  CALL   6DE
106E:  BSF    0A.4
*
10A4:  MOVLW  B5
10A5:  BSF    03.6
10A6:  MOVWF  0D
10A7:  MOVLW  02
10A8:  MOVWF  0F
10A9:  BCF    0A.4
10AA:  BCF    03.6
10AB:  CALL   6DE
10AC:  BSF    0A.4
*
11DE:  MOVLW  B5
11DF:  BSF    03.6
11E0:  MOVWF  0D
11E1:  MOVLW  02
11E2:  MOVWF  0F
11E3:  BCF    0A.4
11E4:  BCF    03.6
11E5:  CALL   6DE
11E6:  BSF    0A.4
*
126B:  MOVLW  B5
126C:  BSF    03.6
126D:  MOVWF  0D
126E:  MOVLW  02
126F:  MOVWF  0F
1270:  BCF    0A.4
1271:  BCF    03.6
1272:  CALL   6DE
1273:  BSF    0A.4
....................   while(1){ 
....................      if(input(KEY_OK)==0){ 
*
1031:  BSF    03.5
1032:  BSF    06.5
1033:  BCF    03.5
1034:  BTFSC  06.5
1035:  GOTO   042
*
106F:  BSF    03.5
1070:  BSF    06.5
1071:  BCF    03.5
1072:  BTFSC  06.5
1073:  GOTO   080
*
10AD:  BSF    03.5
10AE:  BSF    06.5
10AF:  BCF    03.5
10B0:  BTFSC  06.5
10B1:  GOTO   0BE
*
11E7:  BSF    03.5
11E8:  BSF    06.5
11E9:  BCF    03.5
11EA:  BTFSC  06.5
11EB:  GOTO   1F8
*
1274:  BSF    03.5
1275:  BSF    06.5
1276:  BCF    03.5
1277:  BTFSC  06.5
1278:  GOTO   285
....................            // Elimina el rebote 
....................            delay_ms(500); 
*
1036:  MOVLW  02
1037:  MOVWF  7B
1038:  MOVLW  FA
1039:  BSF    03.5
103A:  MOVWF  20
103B:  BCF    0A.4
103C:  BCF    03.5
103D:  CALL   3F0
103E:  BSF    0A.4
103F:  DECFSZ 7B,F
1040:  GOTO   038
*
1074:  MOVLW  02
1075:  MOVWF  7B
1076:  MOVLW  FA
1077:  BSF    03.5
1078:  MOVWF  20
1079:  BCF    0A.4
107A:  BCF    03.5
107B:  CALL   3F0
107C:  BSF    0A.4
107D:  DECFSZ 7B,F
107E:  GOTO   076
*
10B2:  MOVLW  02
10B3:  MOVWF  7B
10B4:  MOVLW  FA
10B5:  BSF    03.5
10B6:  MOVWF  20
10B7:  BCF    0A.4
10B8:  BCF    03.5
10B9:  CALL   3F0
10BA:  BSF    0A.4
10BB:  DECFSZ 7B,F
10BC:  GOTO   0B4
*
11EC:  MOVLW  02
11ED:  MOVWF  7B
11EE:  MOVLW  FA
11EF:  BSF    03.5
11F0:  MOVWF  20
11F1:  BCF    0A.4
11F2:  BCF    03.5
11F3:  CALL   3F0
11F4:  BSF    0A.4
11F5:  DECFSZ 7B,F
11F6:  GOTO   1EE
*
1279:  MOVLW  02
127A:  MOVWF  7B
127B:  MOVLW  FA
127C:  BSF    03.5
127D:  MOVWF  20
127E:  BCF    0A.4
127F:  BCF    03.5
1280:  CALL   3F0
1281:  BSF    0A.4
1282:  DECFSZ 7B,F
1283:  GOTO   27B
....................            break; 
*
1041:  GOTO   043
*
107F:  GOTO   081
*
10BD:  GOTO   0BF
*
11F7:  GOTO   1F9
*
1284:  GOTO   286
....................      } 
*
1042:  GOTO   031
*
1080:  GOTO   06F
*
10BE:  GOTO   0AD
*
11F8:  GOTO   1E7
*
1285:  GOTO   274
....................   } 
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
0744:  MOVLW  01
0745:  BSF    03.5
0746:  MOVWF  20
0747:  MOVLW  02
0748:  MOVWF  21
*
0796:  MOVLW  01
0797:  BSF    03.5
0798:  MOVWF  20
0799:  MOVLW  02
079A:  MOVWF  21
*
0BE0:  MOVLW  01
0BE1:  BSF    03.5
0BE2:  MOVWF  20
0BE3:  MOVLW  02
0BE4:  MOVWF  21
*
0C3D:  MOVLW  01
0C3E:  BSF    03.5
0C3F:  MOVWF  20
0C40:  MOVLW  02
0C41:  MOVWF  21
*
0CB6:  MOVLW  01
0CB7:  BSF    03.5
0CB8:  MOVWF  20
0CB9:  MOVLW  02
0CBA:  MOVWF  21
*
0D10:  MOVLW  01
0D11:  BSF    03.5
0D12:  MOVWF  20
0D13:  MOVLW  02
0D14:  MOVWF  21
*
0D8B:  MOVLW  01
0D8C:  BSF    03.5
0D8D:  MOVWF  20
0D8E:  MOVLW  02
0D8F:  MOVWF  21
*
0DE8:  MOVLW  01
0DE9:  BSF    03.5
0DEA:  MOVWF  20
0DEB:  MOVLW  02
0DEC:  MOVWF  21
*
0E4B:  MOVLW  01
0E4C:  BSF    03.5
0E4D:  MOVWF  20
0E4E:  MOVLW  02
0E4F:  MOVWF  21
*
10DD:  MOVLW  01
10DE:  BSF    03.5
10DF:  MOVWF  20
10E0:  MOVLW  02
10E1:  MOVWF  21
*
113E:  MOVLW  01
113F:  BSF    03.5
1140:  MOVWF  20
1141:  MOVLW  02
1142:  MOVWF  21
*
1214:  MOVLW  01
1215:  BSF    03.5
1216:  MOVWF  20
1217:  MOVLW  02
1218:  MOVWF  21
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
*
075B:  MOVLW  B8
075C:  BSF    03.6
075D:  MOVWF  0D
075E:  MOVLW  02
075F:  MOVWF  0F
0760:  BCF    03.6
0761:  CALL   6DE
*
07AD:  MOVLW  B8
07AE:  BSF    03.6
07AF:  MOVWF  0D
07B0:  MOVLW  02
07B1:  MOVWF  0F
07B2:  BCF    03.6
07B3:  CALL   6DE
*
0BF9:  MOVLW  B8
0BFA:  BSF    03.6
0BFB:  MOVWF  0D
0BFC:  MOVLW  02
0BFD:  MOVWF  0F
0BFE:  BCF    0A.3
0BFF:  BCF    03.6
0C00:  CALL   6DE
0C01:  BSF    0A.3
*
0C56:  MOVLW  B8
0C57:  BSF    03.6
0C58:  MOVWF  0D
0C59:  MOVLW  02
0C5A:  MOVWF  0F
0C5B:  BCF    0A.3
0C5C:  BCF    03.6
0C5D:  CALL   6DE
0C5E:  BSF    0A.3
*
0CCF:  MOVLW  B8
0CD0:  BSF    03.6
0CD1:  MOVWF  0D
0CD2:  MOVLW  02
0CD3:  MOVWF  0F
0CD4:  BCF    0A.3
0CD5:  BCF    03.6
0CD6:  CALL   6DE
0CD7:  BSF    0A.3
*
0D29:  MOVLW  B8
0D2A:  BSF    03.6
0D2B:  MOVWF  0D
0D2C:  MOVLW  02
0D2D:  MOVWF  0F
0D2E:  BCF    0A.3
0D2F:  BCF    03.6
0D30:  CALL   6DE
0D31:  BSF    0A.3
*
0DA4:  MOVLW  B8
0DA5:  BSF    03.6
0DA6:  MOVWF  0D
0DA7:  MOVLW  02
0DA8:  MOVWF  0F
0DA9:  BCF    0A.3
0DAA:  BCF    03.6
0DAB:  CALL   6DE
0DAC:  BSF    0A.3
*
0E01:  MOVLW  B8
0E02:  BSF    03.6
0E03:  MOVWF  0D
0E04:  MOVLW  02
0E05:  MOVWF  0F
0E06:  BCF    0A.3
0E07:  BCF    03.6
0E08:  CALL   6DE
0E09:  BSF    0A.3
*
0E64:  MOVLW  B8
0E65:  BSF    03.6
0E66:  MOVWF  0D
0E67:  MOVLW  02
0E68:  MOVWF  0F
0E69:  BCF    0A.3
0E6A:  BCF    03.6
0E6B:  CALL   6DE
0E6C:  BSF    0A.3
*
10F6:  MOVLW  B8
10F7:  BSF    03.6
10F8:  MOVWF  0D
10F9:  MOVLW  02
10FA:  MOVWF  0F
10FB:  BCF    0A.4
10FC:  BCF    03.6
10FD:  CALL   6DE
10FE:  BSF    0A.4
*
1157:  MOVLW  B8
1158:  BSF    03.6
1159:  MOVWF  0D
115A:  MOVLW  02
115B:  MOVWF  0F
115C:  BCF    0A.4
115D:  BCF    03.6
115E:  CALL   6DE
115F:  BSF    0A.4
*
122D:  MOVLW  B8
122E:  BSF    03.6
122F:  MOVWF  0D
1230:  MOVLW  02
1231:  MOVWF  0F
1232:  BCF    0A.4
1233:  BCF    03.6
1234:  CALL   6DE
1235:  BSF    0A.4
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
0BC3:  CLRF   72
0BC4:  CLRF   73
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0BC5:  MOVF   72,W
0BC6:  MOVWF  7B
0BC7:  MOVLW  0F
0BC8:  MOVWF  7C
0BC9:  BCF    0A.3
0BCA:  CALL   7D5
0BCB:  BSF    0A.3
0BCC:  MOVF   78,W
0BCD:  MOVWF  74
0BCE:  MOVLW  0C
0BCF:  MOVWF  7E
0BD0:  BCF    0A.3
0BD1:  CALL   65D
0BD2:  BSF    0A.3
0BD3:  MOVLW  C2
0BD4:  BSF    03.6
0BD5:  MOVWF  0D
0BD6:  MOVLW  00
0BD7:  MOVWF  0F
0BD8:  MOVF   74,W
0BD9:  ADDWF  0D,F
0BDA:  BTFSC  03.0
0BDB:  INCF   0F,F
0BDC:  BCF    0A.3
0BDD:  BCF    03.6
0BDE:  CALL   6B5
0BDF:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0C02:  MOVF   73,F
0C03:  BTFSS  03.2
0C04:  GOTO   497
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0C05:  BSF    03.5
0C06:  BSF    06.4
0C07:  BCF    03.5
0C08:  BTFSC  06.4
0C09:  GOTO   45F
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0C0A:  MOVLW  02
0C0B:  MOVWF  74
0C0C:  MOVLW  FA
0C0D:  BSF    03.5
0C0E:  MOVWF  20
0C0F:  BCF    0A.3
0C10:  BCF    03.5
0C11:  CALL   3F0
0C12:  BSF    0A.3
0C13:  DECFSZ 74,F
0C14:  GOTO   40C
....................          BEEP; 
0C15:  MOVLW  04
0C16:  MOVWF  7C
0C17:  MOVLW  B9
0C18:  MOVWF  7B
0C19:  CLRF   7E
0C1A:  MOVLW  14
0C1B:  MOVWF  7D
0C1C:  CALL   254
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0C1D:  INCF   72,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
0C1E:  MOVF   72,W
0C1F:  SUBWF  42,W
0C20:  BTFSS  03.0
....................             optSelected = 0; 
0C21:  CLRF   72
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0C22:  MOVF   72,W
0C23:  MOVWF  7B
0C24:  MOVLW  0F
0C25:  MOVWF  7C
0C26:  BCF    0A.3
0C27:  CALL   7D5
0C28:  BSF    0A.3
0C29:  MOVF   78,W
0C2A:  MOVWF  74
0C2B:  MOVLW  0C
0C2C:  MOVWF  7E
0C2D:  BCF    0A.3
0C2E:  CALL   65D
0C2F:  BSF    0A.3
0C30:  MOVLW  C2
0C31:  BSF    03.6
0C32:  MOVWF  0D
0C33:  MOVLW  00
0C34:  MOVWF  0F
0C35:  MOVF   74,W
0C36:  ADDWF  0D,F
0C37:  BTFSC  03.0
0C38:  INCF   0F,F
0C39:  BCF    0A.3
0C3A:  BCF    03.6
0C3B:  CALL   6B5
0C3C:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0C5F:  BSF    03.5
0C60:  BSF    06.5
0C61:  BCF    03.5
0C62:  BTFSC  06.5
0C63:  GOTO   496
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0C64:  MOVLW  02
0C65:  MOVWF  74
0C66:  MOVLW  FA
0C67:  BSF    03.5
0C68:  MOVWF  20
0C69:  BCF    0A.3
0C6A:  BCF    03.5
0C6B:  CALL   3F0
0C6C:  BSF    0A.3
0C6D:  DECFSZ 74,F
0C6E:  GOTO   466
....................          BEEP; 
0C6F:  MOVLW  04
0C70:  MOVWF  7C
0C71:  MOVLW  B9
0C72:  MOVWF  7B
0C73:  CLRF   7E
0C74:  MOVLW  14
0C75:  MOVWF  7D
0C76:  CALL   254
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
0C77:  MOVF   42,W
0C78:  SUBWF  72,W
0C79:  BTFSS  03.2
0C7A:  GOTO   47E
....................             exit = 1; 
0C7B:  MOVLW  01
0C7C:  MOVWF  73
....................          }else{ 
0C7D:  GOTO   496
....................             output_high(PIN_OUT[optSelected]); 
0C7E:  BCF    03.0
0C7F:  RLF    72,W
0C80:  ADDLW  2B
0C81:  MOVWF  04
0C82:  BCF    03.7
0C83:  INCF   04,F
0C84:  MOVF   00,W
0C85:  MOVWF  75
0C86:  DECF   04,F
0C87:  MOVF   00,W
0C88:  MOVWF  74
0C89:  MOVWF  76
0C8A:  MOVLW  01
0C8B:  MOVWF  7B
0C8C:  CLRF   7D
0C8D:  CLRF   7C
0C8E:  CALL   3A3
0C8F:  MOVF   74,W
0C90:  MOVWF  76
0C91:  CLRF   7B
0C92:  CLRF   7D
0C93:  MOVLW  80
0C94:  MOVWF  7C
0C95:  CALL   3A3
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0C96:  GOTO   402
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0C97:  MOVLW  00
0C98:  MOVWF  78
0C99:  BSF    0A.3
0C9A:  BCF    0A.4
0C9B:  GOTO   72B (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
0C9C:  CLRF   72
0C9D:  CLRF   73
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0C9E:  SWAPF  72,W
0C9F:  MOVWF  77
0CA0:  MOVLW  F0
0CA1:  ANDWF  77,F
0CA2:  MOVF   77,W
0CA3:  MOVWF  74
0CA4:  MOVLW  0C
0CA5:  MOVWF  7E
0CA6:  BCF    0A.3
0CA7:  CALL   65D
0CA8:  BSF    0A.3
0CA9:  MOVLW  58
0CAA:  BSF    03.6
0CAB:  MOVWF  0D
0CAC:  MOVLW  01
0CAD:  MOVWF  0F
0CAE:  MOVF   74,W
0CAF:  ADDWF  0D,F
0CB0:  BTFSC  03.0
0CB1:  INCF   0F,F
0CB2:  BCF    0A.3
0CB3:  BCF    03.6
0CB4:  CALL   6B5
0CB5:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0CD8:  MOVF   73,F
0CD9:  BTFSS  03.2
0CDA:  GOTO   569
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0CDB:  BSF    03.5
0CDC:  BSF    06.4
0CDD:  BCF    03.5
0CDE:  BTFSC  06.4
0CDF:  GOTO   532
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0CE0:  MOVLW  02
0CE1:  MOVWF  74
0CE2:  MOVLW  FA
0CE3:  BSF    03.5
0CE4:  MOVWF  20
0CE5:  BCF    0A.3
0CE6:  BCF    03.5
0CE7:  CALL   3F0
0CE8:  BSF    0A.3
0CE9:  DECFSZ 74,F
0CEA:  GOTO   4E2
....................          BEEP; 
0CEB:  MOVLW  04
0CEC:  MOVWF  7C
0CED:  MOVLW  B9
0CEE:  MOVWF  7B
0CEF:  CLRF   7E
0CF0:  MOVLW  14
0CF1:  MOVWF  7D
0CF2:  CALL   254
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0CF3:  INCF   72,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
0CF4:  MOVF   72,W
0CF5:  SUBWF  43,W
0CF6:  BTFSS  03.0
....................             optSelected = 0; 
0CF7:  CLRF   72
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0CF8:  SWAPF  72,W
0CF9:  MOVWF  77
0CFA:  MOVLW  F0
0CFB:  ANDWF  77,F
0CFC:  MOVF   77,W
0CFD:  MOVWF  74
0CFE:  MOVLW  0C
0CFF:  MOVWF  7E
0D00:  BCF    0A.3
0D01:  CALL   65D
0D02:  BSF    0A.3
0D03:  MOVLW  58
0D04:  BSF    03.6
0D05:  MOVWF  0D
0D06:  MOVLW  01
0D07:  MOVWF  0F
0D08:  MOVF   74,W
0D09:  ADDWF  0D,F
0D0A:  BTFSC  03.0
0D0B:  INCF   0F,F
0D0C:  BCF    0A.3
0D0D:  BCF    03.6
0D0E:  CALL   6B5
0D0F:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0D32:  BSF    03.5
0D33:  BSF    06.5
0D34:  BCF    03.5
0D35:  BTFSC  06.5
0D36:  GOTO   568
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0D37:  MOVLW  02
0D38:  MOVWF  74
0D39:  MOVLW  FA
0D3A:  BSF    03.5
0D3B:  MOVWF  20
0D3C:  BCF    0A.3
0D3D:  BCF    03.5
0D3E:  CALL   3F0
0D3F:  BSF    0A.3
0D40:  DECFSZ 74,F
0D41:  GOTO   539
....................          BEEP; 
0D42:  MOVLW  04
0D43:  MOVWF  7C
0D44:  MOVLW  B9
0D45:  MOVWF  7B
0D46:  CLRF   7E
0D47:  MOVLW  14
0D48:  MOVWF  7D
0D49:  CALL   254
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
0D4A:  MOVF   43,W
0D4B:  SUBWF  72,W
0D4C:  BTFSS  03.2
0D4D:  GOTO   551
....................             exit = 1; 
0D4E:  MOVLW  01
0D4F:  MOVWF  73
....................          }else{ 
0D50:  GOTO   568
....................             output_low(PIN_OUT[optSelected]); 
0D51:  BCF    03.0
0D52:  RLF    72,W
0D53:  ADDLW  2B
0D54:  MOVWF  04
0D55:  BCF    03.7
0D56:  INCF   04,F
0D57:  MOVF   00,W
0D58:  MOVWF  75
0D59:  DECF   04,F
0D5A:  MOVF   00,W
0D5B:  MOVWF  74
0D5C:  MOVWF  76
0D5D:  CLRF   7B
0D5E:  CLRF   7D
0D5F:  CLRF   7C
0D60:  CALL   3A3
0D61:  MOVF   74,W
0D62:  MOVWF  76
0D63:  CLRF   7B
0D64:  CLRF   7D
0D65:  MOVLW  80
0D66:  MOVWF  7C
0D67:  CALL   3A3
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0D68:  GOTO   4D8
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0D69:  MOVLW  00
0D6A:  MOVWF  78
0D6B:  BSF    0A.3
0D6C:  BCF    0A.4
0D6D:  GOTO   72F (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
0D6E:  CLRF   72
0D6F:  CLRF   73
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0D70:  MOVF   72,W
0D71:  MOVWF  7B
0D72:  MOVLW  11
0D73:  MOVWF  7C
0D74:  BCF    0A.3
0D75:  CALL   7D5
0D76:  BSF    0A.3
0D77:  MOVF   78,W
0D78:  MOVWF  74
0D79:  MOVLW  0C
0D7A:  MOVWF  7E
0D7B:  BCF    0A.3
0D7C:  CALL   65D
0D7D:  BSF    0A.3
0D7E:  MOVLW  F8
0D7F:  BSF    03.6
0D80:  MOVWF  0D
0D81:  MOVLW  01
0D82:  MOVWF  0F
0D83:  MOVF   74,W
0D84:  ADDWF  0D,F
0D85:  BTFSC  03.0
0D86:  INCF   0F,F
0D87:  BCF    0A.3
0D88:  BCF    03.6
0D89:  CALL   6B5
0D8A:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0DAD:  MOVF   73,F
0DAE:  BTFSS  03.2
0DAF:  GOTO   66E
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0DB0:  BSF    03.5
0DB1:  BSF    06.4
0DB2:  BCF    03.5
0DB3:  BTFSC  06.4
0DB4:  GOTO   60A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0DB5:  MOVLW  02
0DB6:  MOVWF  74
0DB7:  MOVLW  FA
0DB8:  BSF    03.5
0DB9:  MOVWF  20
0DBA:  BCF    0A.3
0DBB:  BCF    03.5
0DBC:  CALL   3F0
0DBD:  BSF    0A.3
0DBE:  DECFSZ 74,F
0DBF:  GOTO   5B7
....................          BEEP; 
0DC0:  MOVLW  04
0DC1:  MOVWF  7C
0DC2:  MOVLW  B9
0DC3:  MOVWF  7B
0DC4:  CLRF   7E
0DC5:  MOVLW  14
0DC6:  MOVWF  7D
0DC7:  CALL   254
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0DC8:  INCF   72,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
0DC9:  MOVF   72,W
0DCA:  SUBWF  44,W
0DCB:  BTFSS  03.0
....................             optSelected = 0; 
0DCC:  CLRF   72
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0DCD:  MOVF   72,W
0DCE:  MOVWF  7B
0DCF:  MOVLW  11
0DD0:  MOVWF  7C
0DD1:  BCF    0A.3
0DD2:  CALL   7D5
0DD3:  BSF    0A.3
0DD4:  MOVF   78,W
0DD5:  MOVWF  74
0DD6:  MOVLW  0C
0DD7:  MOVWF  7E
0DD8:  BCF    0A.3
0DD9:  CALL   65D
0DDA:  BSF    0A.3
0DDB:  MOVLW  F8
0DDC:  BSF    03.6
0DDD:  MOVWF  0D
0DDE:  MOVLW  01
0DDF:  MOVWF  0F
0DE0:  MOVF   74,W
0DE1:  ADDWF  0D,F
0DE2:  BTFSC  03.0
0DE3:  INCF   0F,F
0DE4:  BCF    0A.3
0DE5:  BCF    03.6
0DE6:  CALL   6B5
0DE7:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0E0A:  BSF    03.5
0E0B:  BSF    06.5
0E0C:  BCF    03.5
0E0D:  BTFSC  06.5
0E0E:  GOTO   66D
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0E0F:  MOVLW  02
0E10:  MOVWF  74
0E11:  MOVLW  FA
0E12:  BSF    03.5
0E13:  MOVWF  20
0E14:  BCF    0A.3
0E15:  BCF    03.5
0E16:  CALL   3F0
0E17:  BSF    0A.3
0E18:  DECFSZ 74,F
0E19:  GOTO   611
....................          BEEP; 
0E1A:  MOVLW  04
0E1B:  MOVWF  7C
0E1C:  MOVLW  B9
0E1D:  MOVWF  7B
0E1E:  CLRF   7E
0E1F:  MOVLW  14
0E20:  MOVWF  7D
0E21:  CALL   254
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
0E22:  MOVF   44,W
0E23:  SUBWF  72,W
0E24:  BTFSS  03.2
0E25:  GOTO   629
....................             exit = 1; 
0E26:  MOVLW  01
0E27:  MOVWF  73
....................          }else{ 
0E28:  GOTO   66D
....................             executeSetup(optSelected); 
0E29:  MOVF   72,W
0E2A:  MOVWF  74
0E2B:  BSF    0A.4
0E2C:  BCF    0A.3
0E2D:  GOTO   000
0E2E:  BCF    0A.4
0E2F:  BSF    0A.3
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0E30:  MOVF   72,W
0E31:  MOVWF  7B
0E32:  MOVLW  11
0E33:  MOVWF  7C
0E34:  BCF    0A.3
0E35:  CALL   7D5
0E36:  BSF    0A.3
0E37:  MOVF   78,W
0E38:  MOVWF  74
0E39:  MOVLW  0C
0E3A:  MOVWF  7E
0E3B:  BCF    0A.3
0E3C:  CALL   65D
0E3D:  BSF    0A.3
0E3E:  MOVLW  F8
0E3F:  BSF    03.6
0E40:  MOVWF  0D
0E41:  MOVLW  01
0E42:  MOVWF  0F
0E43:  MOVF   74,W
0E44:  ADDWF  0D,F
0E45:  BTFSC  03.0
0E46:  INCF   0F,F
0E47:  BCF    0A.3
0E48:  BCF    03.6
0E49:  CALL   6B5
0E4A:  BSF    0A.3
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
0E6D:  GOTO   5AD
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0E6E:  MOVLW  00
0E6F:  MOVWF  78
0E70:  BSF    0A.3
0E71:  BCF    0A.4
0E72:  GOTO   733 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................   switch(optSelect){ 
*
1000:  MOVF   74,W
1001:  ADDLW  FA
1002:  BTFSC  03.0
1003:  GOTO   287
1004:  ADDLW  06
1005:  GOTO   28A
....................       
....................      case OPT_SHOW_IP: 
....................         printf(lcd_putc, "\f192.168.0.1"); 
1006:  MOVLW  C1
1007:  BSF    03.6
1008:  MOVWF  0D
1009:  MOVLW  02
100A:  MOVWF  0F
100B:  BCF    0A.4
100C:  BCF    03.6
100D:  CALL   6DE
100E:  BSF    0A.4
....................         pressExit(); 
....................         break; 
*
1043:  GOTO   287
....................      case OPT_SHOW_SSID: 
....................         printf(lcd_putc, "\fC0G3_UNE"); 
1044:  MOVLW  C8
1045:  BSF    03.6
1046:  MOVWF  0D
1047:  MOVLW  02
1048:  MOVWF  0F
1049:  BCF    0A.4
104A:  BCF    03.6
104B:  CALL   6DE
104C:  BSF    0A.4
....................         pressExit();          
....................         break; 
*
1081:  GOTO   287
....................      case OPT_SHOW_KEY: 
....................         printf(lcd_putc, "\f1234Az!"); 
1082:  MOVLW  CD
1083:  BSF    03.6
1084:  MOVWF  0D
1085:  MOVLW  02
1086:  MOVWF  0F
1087:  BCF    0A.4
1088:  BCF    03.6
1089:  CALL   6DE
108A:  BSF    0A.4
....................         pressExit(); 
....................         break; 
*
10BF:  GOTO   287
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
....................         break; 
*
1237:  GOTO   287
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
1238:  BSF    03.5
1239:  BCF    08.3
123A:  MOVLW  08
123B:  BCF    03.5
123C:  XORWF  08,F
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
123D:  BTFSS  08.3
123E:  GOTO   249
....................            printf(lcd_putc, "\fBacklight On"); 
123F:  MOVLW  D2
1240:  BSF    03.6
1241:  MOVWF  0D
1242:  MOVLW  02
1243:  MOVWF  0F
1244:  BCF    0A.4
1245:  BCF    03.6
1246:  CALL   6DE
1247:  BSF    0A.4
....................         }else{ 
1248:  GOTO   252
....................            printf(lcd_putc, "\fBacklight Off"); 
1249:  MOVLW  D9
124A:  BSF    03.6
124B:  MOVWF  0D
124C:  MOVLW  02
124D:  MOVWF  0F
124E:  BCF    0A.4
124F:  BCF    03.6
1250:  CALL   6DE
1251:  BSF    0A.4
....................         } 
....................         pressExit(); 
....................         break; 
*
1286:  GOTO   287
....................      case OPT_EXIT: 
....................         break; 
....................   } 
1287:  BSF    0A.3
1288:  BCF    0A.4
1289:  GOTO   62E (RETURN)
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
*
10C0:  CLRF   75
10C1:  CLRF   76
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
10C2:  MOVF   75,W
10C3:  MOVWF  7B
10C4:  MOVLW  0E
10C5:  MOVWF  7C
10C6:  BCF    0A.4
10C7:  CALL   7D5
10C8:  BSF    0A.4
10C9:  MOVF   78,W
10CA:  MOVWF  7B
10CB:  MOVLW  0C
10CC:  MOVWF  7E
10CD:  BCF    0A.4
10CE:  CALL   65D
10CF:  BSF    0A.4
10D0:  MOVLW  6F
10D1:  BSF    03.6
10D2:  MOVWF  0D
10D3:  MOVLW  02
10D4:  MOVWF  0F
10D5:  MOVF   7B,W
10D6:  ADDWF  0D,F
10D7:  BTFSC  03.0
10D8:  INCF   0F,F
10D9:  BCF    0A.4
10DA:  BCF    03.6
10DB:  CALL   6B5
10DC:  BSF    0A.4
....................   showBottonMenu(); 
....................    
....................   while(!exit){ 
*
10FF:  MOVF   76,F
1100:  BTFSS  03.2
1101:  GOTO   237
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
1102:  BSF    03.5
1103:  BSF    06.4
1104:  BCF    03.5
1105:  BTFSC  06.4
1106:  GOTO   160
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
1107:  MOVLW  02
1108:  MOVWF  7B
1109:  MOVLW  FA
110A:  BSF    03.5
110B:  MOVWF  20
110C:  BCF    0A.4
110D:  BCF    03.5
110E:  CALL   3F0
110F:  BSF    0A.4
1110:  DECFSZ 7B,F
1111:  GOTO   109
....................         BEEP; 
1112:  MOVLW  04
1113:  MOVWF  7C
1114:  MOVLW  B9
1115:  MOVWF  7B
1116:  CLRF   7E
1117:  MOVLW  14
1118:  MOVWF  7D
1119:  BCF    0A.4
111A:  BSF    0A.3
111B:  CALL   254
111C:  BSF    0A.4
111D:  BCF    0A.3
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
111E:  INCF   75,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
111F:  MOVF   75,W
1120:  SUBWF  45,W
1121:  BTFSS  03.0
....................            optSelected = 0; 
1122:  CLRF   75
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
1123:  MOVF   75,W
1124:  MOVWF  7B
1125:  MOVLW  0E
1126:  MOVWF  7C
1127:  BCF    0A.4
1128:  CALL   7D5
1129:  BSF    0A.4
112A:  MOVF   78,W
112B:  MOVWF  7B
112C:  MOVLW  0C
112D:  MOVWF  7E
112E:  BCF    0A.4
112F:  CALL   65D
1130:  BSF    0A.4
1131:  MOVLW  6F
1132:  BSF    03.6
1133:  MOVWF  0D
1134:  MOVLW  02
1135:  MOVWF  0F
1136:  MOVF   7B,W
1137:  ADDWF  0D,F
1138:  BTFSC  03.0
1139:  INCF   0F,F
113A:  BCF    0A.4
113B:  BCF    03.6
113C:  CALL   6B5
113D:  BSF    0A.4
....................         showBottonMenu(); 
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
*
1160:  BSF    03.5
1161:  BSF    06.5
1162:  BCF    03.5
1163:  BTFSC  06.5
1164:  GOTO   236
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
1165:  MOVLW  02
1166:  MOVWF  7B
1167:  MOVLW  FA
1168:  BSF    03.5
1169:  MOVWF  20
116A:  BCF    0A.4
116B:  BCF    03.5
116C:  CALL   3F0
116D:  BSF    0A.4
116E:  DECFSZ 7B,F
116F:  GOTO   167
....................         BEEP; 
1170:  MOVLW  04
1171:  MOVWF  7C
1172:  MOVLW  B9
1173:  MOVWF  7B
1174:  CLRF   7E
1175:  MOVLW  14
1176:  MOVWF  7D
1177:  BCF    0A.4
1178:  BSF    0A.3
1179:  CALL   254
117A:  BSF    0A.4
117B:  BCF    0A.3
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
117C:  MOVF   45,W
117D:  SUBWF  75,W
117E:  BTFSS  03.2
117F:  GOTO   183
....................            exit = 1; 
1180:  MOVLW  01
1181:  MOVWF  76
....................         }else{ 
1182:  GOTO   236
....................            switch(optSelected){ 
1183:  MOVF   75,W
1184:  BTFSC  03.2
1185:  GOTO   18D
1186:  XORLW  01
1187:  BTFSC  03.2
1188:  GOTO   1A0
1189:  XORLW  03
118A:  BTFSC  03.2
118B:  GOTO   1B3
118C:  GOTO   1C5
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
118D:  MOVLW  E1
118E:  BSF    03.6
118F:  MOVWF  0D
1190:  MOVLW  02
1191:  MOVWF  0F
1192:  BCF    0A.4
1193:  BCF    03.6
1194:  CALL   60B
1195:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig Cliente"); 
1196:  MOVLW  EA
1197:  BSF    03.6
1198:  MOVWF  0D
1199:  MOVLW  02
119A:  MOVWF  0F
119B:  BCF    0A.4
119C:  BCF    03.6
119D:  CALL   6DE
119E:  BSF    0A.4
....................                  break; 
119F:  GOTO   1C5
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
11A0:  MOVLW  F2
11A1:  BSF    03.6
11A2:  MOVWF  0D
11A3:  MOVLW  02
11A4:  MOVWF  0F
11A5:  BCF    0A.4
11A6:  BCF    03.6
11A7:  CALL   60B
11A8:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig AP"); 
11A9:  MOVLW  FB
11AA:  BSF    03.6
11AB:  MOVWF  0D
11AC:  MOVLW  02
11AD:  MOVWF  0F
11AE:  BCF    0A.4
11AF:  BCF    03.6
11B0:  CALL   6DE
11B1:  BSF    0A.4
....................                  break; 
11B2:  GOTO   1C5
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
11B3:  MOVLW  01
11B4:  BSF    03.6
11B5:  MOVWF  0D
11B6:  MOVLW  03
11B7:  MOVWF  0F
11B8:  BCF    0A.4
11B9:  BCF    03.6
11BA:  CALL   60B
11BB:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
11BC:  MOVLW  0A
11BD:  BSF    03.6
11BE:  MOVWF  0D
11BF:  MOVLW  03
11C0:  MOVWF  0F
11C1:  BCF    0A.4
11C2:  BCF    03.6
11C3:  CALL   6DE
11C4:  BSF    0A.4
....................                  break; 
....................            } 
....................            pressExit(); 
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
*
11F9:  MOVF   75,W
11FA:  MOVWF  7B
11FB:  MOVLW  0E
11FC:  MOVWF  7C
11FD:  BCF    0A.4
11FE:  CALL   7D5
11FF:  BSF    0A.4
1200:  MOVF   78,W
1201:  MOVWF  7B
1202:  MOVLW  0C
1203:  MOVWF  7E
1204:  BCF    0A.4
1205:  CALL   65D
1206:  BSF    0A.4
1207:  MOVLW  6F
1208:  BSF    03.6
1209:  MOVWF  0D
120A:  MOVLW  02
120B:  MOVWF  0F
120C:  MOVF   7B,W
120D:  ADDWF  0D,F
120E:  BTFSC  03.0
120F:  INCF   0F,F
1210:  BCF    0A.4
1211:  BCF    03.6
1212:  CALL   6B5
1213:  BSF    0A.4
....................            showBottonMenu(); 
....................         } 
....................      } // Fin KEY_OK 
*
1236:  GOTO   0FF
....................   } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
.................... /******************************************** 
.................... #define  CMD_MODE    1 
.................... #define  CMD_DO_CONN 2 
.................... #define  CMD_CONN    3 
....................  
.................... /* Constantes de respuestas */ 
.................... //const char ESP8266_RESP_OK[4]             ={'O','K',0x0D,0x0A}; 
.................... //const char ESP8266_RESP_NoAP[5]           ={'N', 'o', ' ', 'A', 'P'}; 
.................... //const char ESP8266_RESP_CWJAP[7]          ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
.................... //const char ESP8266_RESP_Connected[9]      ={'C','O','N','N','E','C','T','E','D'}; 
.................... //const char ESP8266_RESP_FAIL[4]           ={'F', 'A', 'I', 'L'}; 
....................  
.................... /* Constantes de Captura Respuestas */ 
.................... const char ESP8266_RESP_START_STAIP[7]    ={'S','T','A','I','P',',','"'}; 
.................... const char ESP8266_RESP_STOP_STAIP[3]     ={'"',0x0D,0x0A}; 
....................  
.................... /* Declaracion de Funciones de comandos */ 
.................... void reset(void); 
.................... int  setupMode(char modeVal[]); 
.................... int  doConnected(); 
.................... int  setupConn(char SSIDAndKey[]); 
.................... int  setupServer(void); 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void waitRespOK(int buffer); 
.................... void waitRespNoAp(int buffer); 
.................... void waitRespCWJAP(int buffer); 
.................... void waitRespConnected(int buffer); 
.................... void waitRespFail(int buffer); 
.................... int  waitResp(void); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN = 0x00; 
.................... //int READY_RESP 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Ready_Resp         = 0; 
.................... int flag_Resp_Valid         = 0; 
.................... int flag_Resp_NoAp          = 0; 
.................... int flag_Resp_CWJAP         = 0; 
.................... int flag_Resp_Connected     = 0; 
.................... int flag_Resp_Fail          = 0; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp           = 0; 
.................... int flag_Pos_Resp_NoAp      = 0; 
.................... int flag_Pos_Resp_CWJAP     = 0; 
.................... int flag_Pos_Resp_Connected = 0; 
.................... int flag_Pos_Resp_Fail      = 0; 
....................  
.................... /*@TODO: Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar[]  = "1"; 
*
0EC8:  MOVLW  31
0EC9:  MOVWF  52
0ECA:  CLRF   53
.................... char  SSIDAndKey[]= {'"','U','N','E','_','C','0','6','E','"', 
....................                      ',', 
....................                      '"','0','0','9','8','6','3','4','4','2','0','0','7','7','1','"', 
....................                      0x0D,0x0A 
....................                     }; 
0ECB:  MOVLW  22
0ECC:  MOVWF  54
0ECD:  MOVLW  55
0ECE:  MOVWF  55
0ECF:  MOVLW  4E
0ED0:  MOVWF  56
0ED1:  MOVLW  45
0ED2:  MOVWF  57
0ED3:  MOVLW  5F
0ED4:  MOVWF  58
0ED5:  MOVLW  43
0ED6:  MOVWF  59
0ED7:  MOVLW  30
0ED8:  MOVWF  5A
0ED9:  MOVLW  36
0EDA:  MOVWF  5B
0EDB:  MOVLW  45
0EDC:  MOVWF  5C
0EDD:  MOVLW  22
0EDE:  MOVWF  5D
0EDF:  MOVLW  2C
0EE0:  MOVWF  5E
0EE1:  MOVLW  22
0EE2:  MOVWF  5F
0EE3:  MOVLW  30
0EE4:  MOVWF  60
0EE5:  MOVWF  61
0EE6:  MOVLW  39
0EE7:  MOVWF  62
0EE8:  MOVLW  38
0EE9:  MOVWF  63
0EEA:  MOVLW  36
0EEB:  MOVWF  64
0EEC:  MOVLW  33
0EED:  MOVWF  65
0EEE:  MOVLW  34
0EEF:  MOVWF  66
0EF0:  MOVWF  67
0EF1:  MOVLW  32
0EF2:  MOVWF  68
0EF3:  MOVLW  30
0EF4:  MOVWF  69
0EF5:  MOVWF  6A
0EF6:  MOVLW  37
0EF7:  MOVWF  6B
0EF8:  MOVWF  6C
0EF9:  MOVLW  31
0EFA:  MOVWF  6D
0EFB:  MOVLW  22
0EFC:  MOVWF  6E
0EFD:  MOVLW  0D
0EFE:  MOVWF  6F
0EFF:  MOVLW  0A
0F00:  MOVWF  70
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    char  modeWithoutConnect[] = "3"; 
*
0800:  MOVLW  33
0801:  MOVWF  72
0802:  CLRF   73
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    /**reset(); 
....................    delay_ms(2000);**/ 
....................  
....................    CMD_RUN =  setupMode(modeStar); 
0803:  CLRF   76
0804:  MOVLW  52
0805:  MOVWF  75
*
08AE:  MOVF   78,W
08AF:  MOVWF  46
....................    waitResp(); 
08B0:  BCF    0A.3
08B1:  CALL   5E5
08B2:  BSF    0A.3
....................  
....................    CMD_RUN =  doConnected(); 
*
08BE:  MOVF   78,W
08BF:  MOVWF  46
....................     
....................    resp = waitResp(); 
08C0:  BCF    0A.3
08C1:  CALL   5E5
08C2:  BSF    0A.3
08C3:  MOVF   78,W
08C4:  MOVWF  74
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
08C5:  MOVF   74,W
08C6:  SUBLW  02
08C7:  BTFSS  03.2
08C8:  GOTO   227
....................  
....................       // Lanza el comando para conectarce a la red 
....................       CMD_RUN = setupConn(SSIDAndKey); 
08C9:  CLRF   76
08CA:  MOVLW  54
08CB:  MOVWF  75
*
096B:  MOVF   78,W
096C:  BCF    03.5
096D:  MOVWF  46
....................       resp    = waitResp(); 
096E:  BCF    0A.3
096F:  CALL   5E5
0970:  BSF    0A.3
0971:  MOVF   78,W
0972:  MOVWF  74
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4){ 
0973:  MOVF   74,W
0974:  SUBLW  04
0975:  BTFSS  03.2
0976:  GOTO   227
....................          CMD_RUN =  setupMode(modeWithoutConnect); 
0977:  CLRF   76
0978:  MOVLW  72
0979:  MOVWF  75
*
0A22:  MOVF   78,W
0A23:  MOVWF  46
....................          waitResp(); 
0A24:  BCF    0A.3
0A25:  CALL   5E5
0A26:  BSF    0A.3
....................       } 
....................    } // Fin del if(doConnect) 
....................    
....................    /** @TODO: Rutina que se encarga de recibir datos desde ESP8266 **/ 
....................    setupServer(); 
*
0A51:  BSF    0A.3
0A52:  BCF    0A.4
0A53:  GOTO   71E (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
0361:  BCF    03.5
0362:  MOVF   46,W
0363:  XORLW  01
0364:  BTFSC  03.2
0365:  GOTO   36D
0366:  XORLW  03
0367:  BTFSC  03.2
0368:  GOTO   373
0369:  XORLW  01
036A:  BTFSC  03.2
036B:  GOTO   3AF
036C:  GOTO   3EB
....................             case CMD_MODE: 
....................                   waitRespOK(buffer); 
036D:  BSF    03.5
036E:  MOVF   3C,W
036F:  MOVWF  3D
0370:  BCF    03.5
0371:  CALL   33D
....................                   break; 
0372:  GOTO   3EC
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespNoAp(buffer); 
0373:  BSF    03.5
0374:  MOVF   3C,W
0375:  MOVWF  3D
....................                   waitRespCWJAP(buffer); 
*
038E:  BSF    03.5
038F:  MOVF   3C,W
0390:  MOVWF  3D
....................                   waitRespOK(buffer); 
*
03A9:  BSF    03.5
03AA:  MOVF   3C,W
03AB:  MOVWF  3D
03AC:  BCF    03.5
03AD:  CALL   33D
....................                   break; 
03AE:  GOTO   3EC
....................  
....................             case CMD_CONN: 
....................                   waitRespConnected(buffer); 
03AF:  BSF    03.5
03B0:  MOVF   3C,W
03B1:  MOVWF  3D
....................                   waitRespFail(buffer); 
*
03CA:  BSF    03.5
03CB:  MOVF   3C,W
03CC:  MOVWF  3D
....................                   waitRespOK(buffer); 
*
03E5:  BSF    03.5
03E6:  MOVF   3C,W
03E7:  MOVWF  3D
03E8:  BCF    03.5
03E9:  CALL   33D
....................                   break; 
03EA:  GOTO   3EC
....................              
....................             default: 
....................                   CMD_RUN = 0x00; 
03EB:  CLRF   46
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /******************************************************** 
.................... Reinicia el modulo ESP8266 
.................... *********************************************************/ 
.................... void reset(void) 
.................... { 
....................    fprintf(ESP8266, "AT+RST\r\n"); 
.................... } // fin de la funcion reset() 
....................  
.................... /******************************************************** 
....................  *  Configura el modo de funcionamiento 
....................  *  1-Cliente, 2-AccessPoint, 3-AP+STA  
.................... *********************************************************/ 
.................... int setupMode(char modeVal[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWMODE=%s\r\n",modeVal ); 
*
0806:  MOVLW  18
0807:  BSF    03.6
0808:  MOVWF  0D
0809:  MOVLW  03
080A:  MOVWF  0F
080B:  BCF    03.0
080C:  MOVLW  0A
080D:  MOVWF  7B
*
0886:  MOVF   75,W
0887:  MOVWF  04
0888:  BCF    03.7
0889:  BTFSC  76.0
088A:  BSF    03.7
*
08A3:  MOVLW  0D
08A4:  BCF    03.5
08A5:  BTFSS  0C.4
08A6:  GOTO   0A5
08A7:  MOVWF  19
08A8:  MOVLW  0A
08A9:  BTFSS  0C.4
08AA:  GOTO   0A9
08AB:  MOVWF  19
*
097A:  MOVLW  18
097B:  BSF    03.6
097C:  MOVWF  0D
097D:  MOVLW  03
097E:  MOVWF  0F
097F:  BCF    03.0
0980:  MOVLW  0A
0981:  MOVWF  7B
*
09FA:  MOVF   75,W
09FB:  MOVWF  04
09FC:  BCF    03.7
09FD:  BTFSC  76.0
09FE:  BSF    03.7
*
0A17:  MOVLW  0D
0A18:  BCF    03.5
0A19:  BTFSS  0C.4
0A1A:  GOTO   219
0A1B:  MOVWF  19
0A1C:  MOVLW  0A
0A1D:  BTFSS  0C.4
0A1E:  GOTO   21D
0A1F:  MOVWF  19
....................    return CMD_MODE; 
*
08AC:  MOVLW  01
08AD:  MOVWF  78
*
0A20:  MOVLW  01
0A21:  MOVWF  78
.................... } // fin de la funcion setupMode() 
....................  
.................... /******************************************************** 
....................  *  lanza el comando para verificar el estado de la 
....................  *  conexion a la red wifi  
.................... *********************************************************/ 
.................... int doConnected() 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
*
08B3:  MOVLW  20
08B4:  BSF    03.6
08B5:  MOVWF  0D
08B6:  MOVLW  03
08B7:  MOVWF  0F
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   60B
08BB:  BSF    0A.3
....................    return CMD_DO_CONN; 
08BC:  MOVLW  02
08BD:  MOVWF  78
.................... } 
....................  
.................... /******************************************************** 
....................  *  Conecta a la red wifi 
....................  *  AT+CWJAP="UNE_C06E","00986344200771" 
.................... *********************************************************/ 
.................... int setupConn(char SSID_And_Key[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP=%s",SSID_And_Key ); 
*
08CC:  MOVLW  26
08CD:  BSF    03.6
08CE:  MOVWF  0D
08CF:  MOVLW  03
08D0:  MOVWF  0F
08D1:  BCF    03.0
08D2:  MOVLW  09
08D3:  MOVWF  7B
*
094C:  MOVF   75,W
094D:  MOVWF  04
094E:  BCF    03.7
094F:  BTFSC  76.0
0950:  BSF    03.7
....................    return CMD_CONN; 
*
0969:  MOVLW  03
096A:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /******************************************************** 
....................  * Activa el modo multiconexion y modo servidor por el_ 
....................  * Puerto IP:80 
.................... *********************************************************/ 
.................... int setupServer(void) 
.................... { 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
*
0A27:  MOVLW  2C
0A28:  BSF    03.6
0A29:  MOVWF  0D
0A2A:  MOVLW  03
0A2B:  MOVWF  0F
0A2C:  BCF    0A.3
0A2D:  BCF    03.6
0A2E:  CALL   60B
0A2F:  BSF    0A.3
....................    delay_ms(1000); 
0A30:  MOVLW  04
0A31:  MOVWF  75
0A32:  MOVLW  FA
0A33:  BSF    03.5
0A34:  MOVWF  20
0A35:  BCF    0A.3
0A36:  BCF    03.5
0A37:  CALL   3F0
0A38:  BSF    0A.3
0A39:  DECFSZ 75,F
0A3A:  GOTO   232
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
0A3B:  MOVLW  33
0A3C:  BSF    03.6
0A3D:  MOVWF  0D
0A3E:  MOVLW  03
0A3F:  MOVWF  0F
0A40:  BCF    0A.3
0A41:  BCF    03.6
0A42:  CALL   60B
0A43:  BSF    0A.3
....................    delay_ms(1000); 
0A44:  MOVLW  04
0A45:  MOVWF  75
0A46:  MOVLW  FA
0A47:  BSF    03.5
0A48:  MOVWF  20
0A49:  BCF    0A.3
0A4A:  BCF    03.5
0A4B:  CALL   3F0
0A4C:  BSF    0A.3
0A4D:  DECFSZ 75,F
0A4E:  GOTO   246
....................    return CMD_CONN; 
0A4F:  MOVLW  03
0A50:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
05E5:  CLRF   75
.................... { 
....................    int ret=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(flag_Resp_Valid==0){ 
05E6:  MOVF   48,F
05E7:  BTFSS  03.2
05E8:  GOTO   607
....................     
....................       if(flag_Resp_CWJAP==1){ 
05E9:  DECFSZ 4A,W
05EA:  GOTO   5F0
....................       // Comando doConnected Conectado a la red 
....................          flag_Pos_Resp_CWJAP  = 0; 
05EB:  CLRF   4F
....................          flag_Resp_CWJAP      = 0; 
05EC:  CLRF   4A
....................          ret = 1; 
05ED:  MOVLW  01
05EE:  MOVWF  75
....................  
....................       } else if(flag_Resp_NoAp==1){ 
05EF:  GOTO   606
05F0:  DECFSZ 49,W
05F1:  GOTO   5F7
....................       // Comando doConnected No se ha asignado una red 
....................          flag_Pos_Resp_NoAp  = 0; 
05F2:  CLRF   4E
....................          flag_Resp_NoAp      = 0; 
05F3:  CLRF   49
....................          ret = 2; 
05F4:  MOVLW  02
05F5:  MOVWF  75
....................  
....................       } else if (flag_Resp_Connected==1){ 
05F6:  GOTO   606
05F7:  DECFSZ 4B,W
05F8:  GOTO   5FE
....................       // Comando setupConn Conexion establecida 
....................          flag_Pos_Resp_Connected = 0; 
05F9:  CLRF   50
....................          flag_Resp_Connected     = 0; 
05FA:  CLRF   4B
....................          ret = 3; 
05FB:  MOVLW  03
05FC:  MOVWF  75
....................  
....................       } else if(flag_Resp_Fail==1){ 
05FD:  GOTO   606
05FE:  DECFSZ 4C,W
05FF:  GOTO   606
....................       // Comando setupConn Fallo al intentar la Conexion 
....................       // Esta respuesta da como resultado un ERROR entonces 
....................       // Se rompe el ciclo de forma manual flag_Resp_Valid=1 
....................          flag_Pos_Resp_Fail   = 0; 
0600:  CLRF   51
....................          flag_Resp_Fail       = 0; 
0601:  CLRF   4C
....................          flag_Resp_Valid      = 1; 
0602:  MOVLW  01
0603:  MOVWF  48
....................          ret = 4; 
0604:  MOVLW  04
0605:  MOVWF  75
....................       } 
0606:  GOTO   5E6
....................    }; // Fin del loop 
....................    flag_Resp_Valid = 0; 
0607:  CLRF   48
....................    return ret; 
0608:  MOVF   75,W
0609:  MOVWF  78
060A:  RETURN
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
....................  
.................... void waitRespOK(int buffer) 
*
033D:  MOVLW  04
033E:  BSF    03.5
033F:  MOVWF  3E
.................... { 
....................    const char ESP8266_RESP_OK[4] ={'O','K',0x0D,0x0A}; 
....................    int lenResp = 4; 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_OK[flag_Pos_Resp]) 
0340:  BCF    03.5
0341:  MOVF   4D,W
0342:  CALL   051
0343:  MOVWF  78
0344:  BSF    03.5
0345:  SUBWF  3D,W
0346:  BTFSS  03.2
0347:  GOTO   356
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp++; 
0348:  BCF    03.5
0349:  INCF   4D,F
....................        
....................       if(flag_Pos_Resp==lenResp){ 
034A:  BSF    03.5
034B:  MOVF   3E,W
034C:  BCF    03.5
034D:  SUBWF  4D,W
034E:  BTFSS  03.2
034F:  GOTO   353
....................          // Respuesta es valida 
....................          flag_Resp_Valid   = 1; 
0350:  MOVLW  01
0351:  MOVWF  48
....................       }else{ 
0352:  GOTO   354
....................          // Reinicia la bandera para asegurar la integridad de la respesta 
....................          flag_Resp_Valid   = 0; 
0353:  CLRF   48
....................       } 
....................  
....................    }else{ 
0354:  GOTO   359
0355:  BSF    03.5
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       flag_Pos_Resp     = 0; 
0356:  BCF    03.5
0357:  CLRF   4D
....................       // Como esta funcion es el ultimo caracter recibido no es necesario mantener  
....................       // Activa la bandera flag_Resp_Valid 
....................       flag_Resp_Valid   = 0; 
0358:  CLRF   48
....................    } 
0359:  RETURN
.................... } // Fin de la funcion waitRespOK() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_NoAp (Sin conexion) 
.................... *********************************************************/ 
.................... void waitRespNoAp(int buffer) 
*
0376:  MOVLW  05
0377:  MOVWF  3E
.................... { 
....................    const char ESP8266_RESP_NoAP[5] ={'N', 'o', ' ', 'A', 'P'}; 
....................    int lenResp = 5; 
....................     
....................    if(buffer == ESP8266_RESP_NoAp[flag_Pos_Resp_NoAp] ) 
0378:  BCF    03.5
0379:  MOVF   4E,W
037A:  CALL   059
037B:  MOVWF  78
037C:  BSF    03.5
037D:  SUBWF  3D,W
037E:  BTFSS  03.2
037F:  GOTO   38C
....................    { 
....................       flag_Pos_Resp_NoAp++; 
0380:  BCF    03.5
0381:  INCF   4E,F
....................        
....................       if(flag_Pos_Resp_NoAp==lenResp){ 
0382:  BSF    03.5
0383:  MOVF   3E,W
0384:  BCF    03.5
0385:  SUBWF  4E,W
0386:  BTFSS  03.2
0387:  GOTO   38A
....................          // Respuesta es valida 
....................          flag_Resp_NoAp   = 1; 
0388:  MOVLW  01
0389:  MOVWF  49
....................       } 
....................    }else{ 
038A:  GOTO   38E
038B:  BSF    03.5
....................       // Reinicia el contador 
....................       flag_Pos_Resp_NoAp  = 0; 
038C:  BCF    03.5
038D:  CLRF   4E
....................    } 
.................... } // Fin de la funcion waitRespNoAp() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_CWJAP (Conectado) 
.................... *********************************************************/ 
.................... void waitRespCWJAP(int buffer) 
*
0391:  MOVLW  07
0392:  MOVWF  3E
.................... { 
....................    const char ESP8266_RESP_CWJAP[7] ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
....................    int lenResp = 7; 
....................  
....................    if(buffer == ESP8266_RESP_CWJAP[flag_Pos_Resp_CWJAP] ) 
0393:  BCF    03.5
0394:  MOVF   4F,W
0395:  CALL   062
0396:  MOVWF  78
0397:  BSF    03.5
0398:  SUBWF  3D,W
0399:  BTFSS  03.2
039A:  GOTO   3A7
....................    { 
....................       flag_Pos_Resp_CWJAP++; 
039B:  BCF    03.5
039C:  INCF   4F,F
....................        
....................       if(flag_Pos_Resp_CWJAP==lenResp){ 
039D:  BSF    03.5
039E:  MOVF   3E,W
039F:  BCF    03.5
03A0:  SUBWF  4F,W
03A1:  BTFSS  03.2
03A2:  GOTO   3A5
....................          // Respuesta es valida 
....................          flag_Resp_CWJAP   = 1; 
03A3:  MOVLW  01
03A4:  MOVWF  4A
....................       } 
....................    }else { 
03A5:  GOTO   3A9
03A6:  BSF    03.5
....................       // Reinicia el contador 
....................       flag_Pos_Resp_CWJAP = 0; 
03A7:  BCF    03.5
03A8:  CLRF   4F
....................    } 
....................     
.................... } // Fin de la funcion waitRespCWJAP() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "setupConn" 
....................  *    ESP8266_RESP_Connected (Conectado) 
.................... *********************************************************/ 
.................... void waitRespConnected(int buffer) 
*
03B2:  MOVLW  09
03B3:  MOVWF  3E
.................... { 
....................    const char ESP8266_RESP_Connected[9] ={'C','O','N','N','E','C','T','E','D'}; 
....................    int lenResp = 9; 
....................   
....................    if(buffer == ESP8266_RESP_Connected[flag_Pos_Resp_Connected] ) 
03B4:  BCF    03.5
03B5:  MOVF   50,W
03B6:  CALL   06D
03B7:  MOVWF  78
03B8:  BSF    03.5
03B9:  SUBWF  3D,W
03BA:  BTFSS  03.2
03BB:  GOTO   3C8
....................    { 
....................       flag_Pos_Resp_Connected++; 
03BC:  BCF    03.5
03BD:  INCF   50,F
....................        
....................       if(flag_Pos_Resp_Connected==lenResp){ 
03BE:  BSF    03.5
03BF:  MOVF   3E,W
03C0:  BCF    03.5
03C1:  SUBWF  50,W
03C2:  BTFSS  03.2
03C3:  GOTO   3C6
....................          // Respuesta es valida 
....................          flag_Resp_Connected   = 1; 
03C4:  MOVLW  01
03C5:  MOVWF  4B
....................       } 
....................    }else{ 
03C6:  GOTO   3CA
03C7:  BSF    03.5
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Connected = 0; 
03C8:  BCF    03.5
03C9:  CLRF   50
....................    } 
.................... } // Fin de la funcion waitRespConnected() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "setupConn" 
....................  *    ESP8266_RESP_FAIL (Fallo al intentar conectarse) 
.................... *********************************************************/ 
.................... void waitRespFail(int buffer) 
*
03CD:  MOVLW  04
03CE:  MOVWF  3E
.................... { 
....................    const char ESP8266_RESP_FAIL[4] ={'F', 'A', 'I', 'L'}; 
....................    int lenResp = 4; 
....................   
....................    if(buffer == ESP8266_RESP_FAIL[flag_Pos_Resp_Fail] ) 
03CF:  BCF    03.5
03D0:  MOVF   51,W
03D1:  CALL   07A
03D2:  MOVWF  78
03D3:  BSF    03.5
03D4:  SUBWF  3D,W
03D5:  BTFSS  03.2
03D6:  GOTO   3E3
....................    { 
....................       flag_Pos_Resp_Fail++; 
03D7:  BCF    03.5
03D8:  INCF   51,F
....................        
....................       if(flag_Pos_Resp_Fail==lenResp){ 
03D9:  BSF    03.5
03DA:  MOVF   3E,W
03DB:  BCF    03.5
03DC:  SUBWF  51,W
03DD:  BTFSS  03.2
03DE:  GOTO   3E1
....................          // Respuesta es valida 
....................          flag_Resp_Fail   = 1; 
03DF:  MOVLW  01
03E0:  MOVWF  4C
....................       } 
....................    }else{ 
03E1:  GOTO   3E5
03E2:  BSF    03.5
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Fail  = 0; 
03E3:  BCF    03.5
03E4:  CLRF   51
....................    } 
.................... } // Fin de la funcion waitRespFail() 
....................  
....................  
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
.................... { 
*
035A:  BTFSS  0C.5
035B:  GOTO   35A
035C:  MOVF   1A,W
035D:  BSF    03.5
035E:  MOVWF  3B
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
.................... } 
035F:  MOVF   3B,W
0360:  MOVWF  3C
*
03EC:  BCF    0C.5
03ED:  BCF    0A.3
03EE:  BCF    0A.4
03EF:  GOTO   02D
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
....................    { 
*
0E73:  MOVF   03,W
0E74:  ANDLW  1F
0E75:  MOVWF  03
0E76:  BSF    03.5
0E77:  BSF    03.6
0E78:  BSF    07.3
0E79:  MOVLW  08
0E7A:  BCF    03.6
0E7B:  MOVWF  19
0E7C:  MOVLW  02
0E7D:  MOVWF  1A
0E7E:  MOVLW  A6
0E7F:  MOVWF  18
0E80:  MOVLW  90
0E81:  BCF    03.5
0E82:  MOVWF  18
0E83:  BSF    03.5
0E84:  BCF    06.0
0E85:  BCF    03.5
0E86:  BSF    06.0
0E87:  MOVLW  02
0E88:  MOVWF  41
0E89:  MOVLW  08
0E8A:  MOVWF  42
0E8B:  MOVWF  43
0E8C:  MOVLW  05
0E8D:  MOVWF  44
0E8E:  MOVLW  03
0E8F:  MOVWF  45
0E90:  CLRF   46
0E91:  CLRF   47
0E92:  CLRF   48
0E93:  CLRF   49
0E94:  CLRF   4A
0E95:  CLRF   4B
0E96:  CLRF   4C
0E97:  CLRF   4D
0E98:  CLRF   4E
0E99:  CLRF   4F
0E9A:  CLRF   50
0E9B:  CLRF   51
0E9C:  CLRF   71
0E9D:  BSF    03.5
0E9E:  BSF    03.6
0E9F:  MOVF   09,W
0EA0:  ANDLW  C0
0EA1:  MOVWF  09
0EA2:  BCF    03.6
0EA3:  BCF    1F.4
0EA4:  BCF    1F.5
0EA5:  MOVLW  00
0EA6:  BSF    03.6
0EA7:  MOVWF  08
0EA8:  BCF    03.5
0EA9:  CLRF   07
0EAA:  CLRF   08
0EAB:  CLRF   09
0EAC:  BCF    03.7
....................        
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
....................        
*
0F01:  MOVLW  02
0F02:  MOVWF  72
0F03:  MOVLW  FA
0F04:  BSF    03.5
0F05:  MOVWF  20
0F06:  BCF    0A.3
0F07:  BCF    03.5
0F08:  CALL   3F0
0F09:  BSF    0A.3
0F0A:  DECFSZ 72,F
0F0B:  GOTO   703
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
....................       set_tris_b(0b00110010); 
0F0C:  MOVLW  30
0F0D:  BSF    03.5
0F0E:  MOVWF  15
0F0F:  BCF    01.7
....................       enable_interrupts(INT_RDA);  
0F10:  MOVLW  32
0F11:  MOVWF  06
....................       enable_interrupts(GLOBAL);  
0F12:  BSF    0C.5
....................  
0F13:  MOVLW  C0
0F14:  BCF    03.5
0F15:  IORWF  0B,F
....................       // Inicializa la LCD 
....................       lcd_init(); 
....................        
0F16:  BCF    0A.3
0F17:  GOTO   52D
0F18:  BSF    0A.3
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
....................  
0F19:  BSF    03.5
0F1A:  BCF    08.3
0F1B:  BCF    03.5
0F1C:  BSF    08.3
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
....................                  
0F1D:  GOTO   000
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
....................             // Menu principal 
0F1E:  MOVF   71,W
0F1F:  ADDLW  FC
0F20:  BTFSC  03.0
0F21:  GOTO   735
0F22:  ADDLW  04
0F23:  GOTO   737
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
....................                break; 
0F24:  BCF    0A.3
0F25:  GOTO   72E
0F26:  BSF    0A.3
0F27:  MOVF   78,W
0F28:  MOVWF  71
....................   
0F29:  GOTO   735
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
....................                break; 
0F2A:  GOTO   3C3
0F2B:  MOVF   78,W
0F2C:  MOVWF  71
....................   
0F2D:  GOTO   735
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
....................                break; 
0F2E:  GOTO   49C
0F2F:  MOVF   78,W
0F30:  MOVWF  71
....................  
0F31:  GOTO   735
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
....................                break; 
0F32:  GOTO   56E
0F33:  MOVF   78,W
0F34:  MOVWF  71
....................          } // Fin del Switch(menuActive) 
....................           
0F35:  GOTO   71E
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
....................  
0F36:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
