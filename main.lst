CCS PCM C Compiler, Version 5.015, 5967               06-dic.-17 23:52

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   5271 words (64%)
                           Largest free fragment is 2048
               RAM used:   151 (41%) at main() level
                           195 (53%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  14
0001:  MOVWF  0A
0002:  GOTO   454
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   37E
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  4F
0056:  RETLW  4B
0057:  RETLW  0D
0058:  RETLW  0A
0059:  BCF    0A.0
005A:  BCF    0A.1
005B:  BCF    0A.2
005C:  ADDWF  02,F
005D:  RETLW  4E
005E:  RETLW  6F
005F:  RETLW  20
0060:  RETLW  41
0061:  RETLW  50
0062:  BCF    0A.0
0063:  BCF    0A.1
0064:  BCF    0A.2
0065:  ADDWF  02,F
0066:  RETLW  2B
0067:  RETLW  43
0068:  RETLW  57
0069:  RETLW  4A
006A:  RETLW  41
006B:  RETLW  50
006C:  RETLW  3A
006D:  BCF    0A.0
006E:  BCF    0A.1
006F:  BCF    0A.2
0070:  ADDWF  02,F
0071:  RETLW  43
0072:  RETLW  4F
0073:  RETLW  4E
0074:  RETLW  4E
0075:  RETLW  45
0076:  RETLW  43
0077:  RETLW  54
0078:  RETLW  45
0079:  RETLW  44
007A:  BCF    0A.0
007B:  BCF    0A.1
007C:  BCF    0A.2
007D:  ADDWF  02,F
007E:  RETLW  46
007F:  RETLW  41
0080:  RETLW  49
0081:  RETLW  4C
0082:  BCF    0A.0
0083:  BCF    0A.1
0084:  BCF    0A.2
0085:  ADDWF  02,F
0086:  RETLW  2B
0087:  RETLW  49
0088:  RETLW  50
0089:  RETLW  44
008A:  RETLW  2C
008B:  BCF    0A.0
008C:  BCF    0A.1
008D:  BCF    0A.2
008E:  ADDWF  02,F
008F:  RETLW  43
0090:  RETLW  4D
0091:  RETLW  44
0092:  RETLW  3A
0093:  DATA 41,2A
0094:  DATA 2B,29
0095:  DATA 53,2A
0096:  DATA 0D,05
0097:  DATA 00,00
0098:  DATA 41,2A
0099:  DATA AB,21
009A:  DATA D7,26
009B:  DATA 4F,22
009C:  DATA C5,1E
009D:  DATA A5,39
009E:  DATA 0D,05
009F:  DATA 00,00
00A0:  DATA 41,2A
00A1:  DATA AB,21
00A2:  DATA 57,25
00A3:  DATA 41,28
00A4:  DATA BF,06
00A5:  DATA 0A,00
00A6:  DATA 41,2A
00A7:  DATA AB,21
00A8:  DATA 57,25
00A9:  DATA 41,28
00AA:  DATA BD,12
00AB:  DATA 73,00
00AC:  DATA 41,2A
00AD:  DATA AB,21
00AE:  DATA 49,28
00AF:  DATA CD,2A
00B0:  DATA D8,1E
00B1:  DATA B1,06
00B2:  DATA 0A,00
00B3:  DATA 41,2A
00B4:  DATA AB,21
00B5:  DATA 49,28
00B6:  DATA D3,22
00B7:  DATA 52,2B
00B8:  DATA 45,29
00B9:  DATA BD,18
00BA:  DATA 2C,1C
00BB:  DATA B0,06
00BC:  DATA 0A,00
00BD:  DATA 41,2A
00BE:  DATA AB,21
00BF:  DATA 49,28
00C0:  DATA D3,22
00C1:  DATA 4E,22
00C2:  DATA BD,12
00C3:  DATA 63,16
00C4:  DATA 31,19
00C5:  DATA 0D,05
00C6:  DATA 00,01
00C7:  DATA 41,2A
00C8:  DATA AB,21
00C9:  DATA 49,28
00CA:  DATA 43,26
00CB:  DATA CF,29
00CC:  DATA C5,1E
00CD:  DATA A5,31
00CE:  DATA 0D,05
00CF:  DATA 00,00
00D0:  RETLW  45
00D1:  RETLW  6E
00D2:  RETLW  63
00D3:  RETLW  65
00D4:  RETLW  6E
00D5:  RETLW  64
00D6:  RETLW  65
00D7:  RETLW  72
00D8:  RETLW  20
00D9:  RETLW  4D
00DA:  RETLW  61
00DB:  RETLW  6E
00DC:  RETLW  75
00DD:  RETLW  61
00DE:  RETLW  6C
00DF:  RETLW  00
00E0:  RETLW  41
00E1:  RETLW  70
00E2:  RETLW  61
00E3:  RETLW  67
00E4:  RETLW  61
00E5:  RETLW  64
00E6:  RETLW  6F
00E7:  RETLW  20
00E8:  RETLW  4D
00E9:  RETLW  61
00EA:  RETLW  6E
00EB:  RETLW  75
00EC:  RETLW  61
00ED:  RETLW  6C
00EE:  RETLW  20
00EF:  RETLW  00
00F0:  RETLW  43
00F1:  RETLW  6F
00F2:  RETLW  6E
00F3:  RETLW  66
00F4:  RETLW  69
00F5:  RETLW  67
00F6:  RETLW  75
00F7:  RETLW  72
00F8:  RETLW  61
00F9:  RETLW  63
00FA:  RETLW  69
00FB:  RETLW  6F
00FC:  RETLW  6E
00FD:  RETLW  20
00FE:  RETLW  20
00FF:  RETLW  00
0100:  RETLW  00
0101:  RETLW  00
0102:  RETLW  00
0103:  RETLW  00
0104:  RETLW  00
0105:  RETLW  00
0106:  RETLW  00
0107:  RETLW  00
0108:  RETLW  00
0109:  RETLW  00
010A:  RETLW  00
010B:  RETLW  00
010C:  RETLW  00
010D:  RETLW  00
010E:  RETLW  00
010F:  RETLW  00
0110:  RETLW  4F
0111:  RETLW  6E
0112:  RETLW  20
0113:  RETLW  2D
0114:  RETLW  3E
0115:  RETLW  20
0116:  RETLW  53
0117:  RETLW  61
0118:  RETLW  6C
0119:  RETLW  69
011A:  RETLW  64
011B:  RETLW  61
011C:  RETLW  20
011D:  RETLW  31
011E:  RETLW  00
011F:  RETLW  4F
0120:  RETLW  6E
0121:  RETLW  20
0122:  RETLW  2D
0123:  RETLW  3E
0124:  RETLW  20
0125:  RETLW  53
0126:  RETLW  61
0127:  RETLW  6C
0128:  RETLW  69
0129:  RETLW  64
012A:  RETLW  61
012B:  RETLW  20
012C:  RETLW  32
012D:  RETLW  00
012E:  RETLW  4F
012F:  RETLW  6E
0130:  RETLW  20
0131:  RETLW  2D
0132:  RETLW  3E
0133:  RETLW  20
0134:  RETLW  53
0135:  RETLW  61
0136:  RETLW  6C
0137:  RETLW  69
0138:  RETLW  64
0139:  RETLW  61
013A:  RETLW  20
013B:  RETLW  33
013C:  RETLW  00
013D:  RETLW  4F
013E:  RETLW  6E
013F:  RETLW  20
0140:  RETLW  2D
0141:  RETLW  3E
0142:  RETLW  20
0143:  RETLW  53
0144:  RETLW  61
0145:  RETLW  6C
0146:  RETLW  69
0147:  RETLW  64
0148:  RETLW  61
0149:  RETLW  20
014A:  RETLW  34
014B:  RETLW  00
014C:  RETLW  4F
014D:  RETLW  6E
014E:  RETLW  20
014F:  RETLW  2D
0150:  RETLW  3E
0151:  RETLW  20
0152:  RETLW  53
0153:  RETLW  61
0154:  RETLW  6C
0155:  RETLW  69
0156:  RETLW  64
0157:  RETLW  61
0158:  RETLW  20
0159:  RETLW  35
015A:  RETLW  00
015B:  RETLW  4F
015C:  RETLW  6E
015D:  RETLW  20
015E:  RETLW  2D
015F:  RETLW  3E
0160:  RETLW  20
0161:  RETLW  53
0162:  RETLW  61
0163:  RETLW  6C
0164:  RETLW  69
0165:  RETLW  64
0166:  RETLW  61
0167:  RETLW  20
0168:  RETLW  36
0169:  RETLW  00
016A:  RETLW  4F
016B:  RETLW  6E
016C:  RETLW  20
016D:  RETLW  2D
016E:  RETLW  3E
016F:  RETLW  20
0170:  RETLW  53
0171:  RETLW  61
0172:  RETLW  6C
0173:  RETLW  69
0174:  RETLW  64
0175:  RETLW  61
0176:  RETLW  20
0177:  RETLW  37
0178:  RETLW  00
0179:  RETLW  4F
017A:  RETLW  6E
017B:  RETLW  20
017C:  RETLW  2D
017D:  RETLW  3E
017E:  RETLW  20
017F:  RETLW  53
0180:  RETLW  61
0181:  RETLW  6C
0182:  RETLW  69
0183:  RETLW  64
0184:  RETLW  61
0185:  RETLW  20
0186:  RETLW  38
0187:  RETLW  00
0188:  RETLW  53
0189:  RETLW  41
018A:  RETLW  4C
018B:  RETLW  49
018C:  RETLW  52
018D:  RETLW  20
018E:  RETLW  20
018F:  RETLW  20
0190:  RETLW  20
0191:  RETLW  20
0192:  RETLW  20
0193:  RETLW  20
0194:  RETLW  20
0195:  RETLW  20
0196:  RETLW  00
0197:  RETLW  00
0198:  RETLW  00
0199:  RETLW  00
019A:  RETLW  00
019B:  RETLW  00
019C:  RETLW  00
019D:  RETLW  00
019E:  RETLW  00
019F:  RETLW  00
01A0:  RETLW  00
01A1:  RETLW  00
01A2:  RETLW  00
01A3:  RETLW  00
01A4:  RETLW  00
01A5:  RETLW  00
01A6:  RETLW  4F
01A7:  RETLW  66
01A8:  RETLW  66
01A9:  RETLW  20
01AA:  RETLW  2D
01AB:  RETLW  3E
01AC:  RETLW  20
01AD:  RETLW  53
01AE:  RETLW  61
01AF:  RETLW  6C
01B0:  RETLW  69
01B1:  RETLW  64
01B2:  RETLW  61
01B3:  RETLW  20
01B4:  RETLW  31
01B5:  RETLW  00
01B6:  RETLW  4F
01B7:  RETLW  66
01B8:  RETLW  66
01B9:  RETLW  20
01BA:  RETLW  2D
01BB:  RETLW  3E
01BC:  RETLW  20
01BD:  RETLW  53
01BE:  RETLW  61
01BF:  RETLW  6C
01C0:  RETLW  69
01C1:  RETLW  64
01C2:  RETLW  61
01C3:  RETLW  20
01C4:  RETLW  32
01C5:  RETLW  00
01C6:  RETLW  4F
01C7:  RETLW  66
01C8:  RETLW  66
01C9:  RETLW  20
01CA:  RETLW  2D
01CB:  RETLW  3E
01CC:  RETLW  20
01CD:  RETLW  53
01CE:  RETLW  61
01CF:  RETLW  6C
01D0:  RETLW  69
01D1:  RETLW  64
01D2:  RETLW  61
01D3:  RETLW  20
01D4:  RETLW  33
01D5:  RETLW  00
01D6:  RETLW  4F
01D7:  RETLW  66
01D8:  RETLW  66
01D9:  RETLW  20
01DA:  RETLW  2D
01DB:  RETLW  3E
01DC:  RETLW  20
01DD:  RETLW  53
01DE:  RETLW  61
01DF:  RETLW  6C
01E0:  RETLW  69
01E1:  RETLW  64
01E2:  RETLW  61
01E3:  RETLW  20
01E4:  RETLW  34
01E5:  RETLW  00
01E6:  RETLW  4F
01E7:  RETLW  66
01E8:  RETLW  66
01E9:  RETLW  20
01EA:  RETLW  2D
01EB:  RETLW  3E
01EC:  RETLW  20
01ED:  RETLW  53
01EE:  RETLW  61
01EF:  RETLW  6C
01F0:  RETLW  69
01F1:  RETLW  64
01F2:  RETLW  61
01F3:  RETLW  20
01F4:  RETLW  35
01F5:  RETLW  00
01F6:  RETLW  4F
01F7:  RETLW  66
01F8:  RETLW  66
01F9:  RETLW  20
01FA:  RETLW  2D
01FB:  RETLW  3E
01FC:  RETLW  20
01FD:  RETLW  53
01FE:  RETLW  61
01FF:  RETLW  6C
0200:  RETLW  69
0201:  RETLW  64
0202:  RETLW  61
0203:  RETLW  20
0204:  RETLW  36
0205:  RETLW  00
0206:  RETLW  4F
0207:  RETLW  66
0208:  RETLW  66
0209:  RETLW  20
020A:  RETLW  2D
020B:  RETLW  3E
020C:  RETLW  20
020D:  RETLW  53
020E:  RETLW  61
020F:  RETLW  6C
0210:  RETLW  69
0211:  RETLW  64
0212:  RETLW  61
0213:  RETLW  20
0214:  RETLW  37
0215:  RETLW  00
0216:  RETLW  4F
0217:  RETLW  66
0218:  RETLW  66
0219:  RETLW  20
021A:  RETLW  2D
021B:  RETLW  3E
021C:  RETLW  20
021D:  RETLW  53
021E:  RETLW  61
021F:  RETLW  6C
0220:  RETLW  69
0221:  RETLW  64
0222:  RETLW  61
0223:  RETLW  20
0224:  RETLW  38
0225:  RETLW  00
0226:  RETLW  53
0227:  RETLW  41
0228:  RETLW  4C
0229:  RETLW  49
022A:  RETLW  52
022B:  RETLW  20
022C:  RETLW  20
022D:  RETLW  20
022E:  RETLW  20
022F:  RETLW  20
0230:  RETLW  20
0231:  RETLW  20
0232:  RETLW  20
0233:  RETLW  20
0234:  RETLW  20
0235:  RETLW  00
0236:  RETLW  00
0237:  RETLW  00
0238:  RETLW  00
0239:  RETLW  00
023A:  RETLW  00
023B:  RETLW  00
023C:  RETLW  00
023D:  RETLW  00
023E:  RETLW  00
023F:  RETLW  00
0240:  RETLW  00
0241:  RETLW  00
0242:  RETLW  00
0243:  RETLW  00
0244:  RETLW  00
0245:  RETLW  00
0246:  RETLW  56
0247:  RETLW  45
0248:  RETLW  52
0249:  RETLW  20
024A:  RETLW  49
024B:  RETLW  50
024C:  RETLW  20
024D:  RETLW  20
024E:  RETLW  20
024F:  RETLW  20
0250:  RETLW  20
0251:  RETLW  20
0252:  RETLW  20
0253:  RETLW  20
0254:  RETLW  20
0255:  RETLW  20
0256:  RETLW  00
0257:  RETLW  56
0258:  RETLW  45
0259:  RETLW  52
025A:  RETLW  20
025B:  RETLW  53
025C:  RETLW  53
025D:  RETLW  49
025E:  RETLW  44
025F:  RETLW  20
0260:  RETLW  20
0261:  RETLW  20
0262:  RETLW  20
0263:  RETLW  20
0264:  RETLW  20
0265:  RETLW  20
0266:  RETLW  20
0267:  RETLW  00
0268:  RETLW  56
0269:  RETLW  45
026A:  RETLW  52
026B:  RETLW  20
026C:  RETLW  4B
026D:  RETLW  45
026E:  RETLW  59
026F:  RETLW  20
0270:  RETLW  20
0271:  RETLW  20
0272:  RETLW  20
0273:  RETLW  20
0274:  RETLW  20
0275:  RETLW  20
0276:  RETLW  20
0277:  RETLW  20
0278:  RETLW  00
0279:  RETLW  43
027A:  RETLW  6F
027B:  RETLW  6E
027C:  RETLW  66
027D:  RETLW  20
027E:  RETLW  41
027F:  RETLW  63
0280:  RETLW  63
0281:  RETLW  65
0282:  RETLW  73
0283:  RETLW  73
0284:  RETLW  6F
0285:  RETLW  20
0286:  RETLW  52
0287:  RETLW  65
0288:  RETLW  64
0289:  RETLW  00
028A:  RETLW  4F
028B:  RETLW  6E
028C:  RETLW  2F
028D:  RETLW  4F
028E:  RETLW  66
028F:  RETLW  66
0290:  RETLW  20
0291:  RETLW  42
0292:  RETLW  61
0293:  RETLW  63
0294:  RETLW  6B
0295:  RETLW  6C
0296:  RETLW  69
0297:  RETLW  67
0298:  RETLW  68
0299:  RETLW  74
029A:  RETLW  00
029B:  RETLW  53
029C:  RETLW  41
029D:  RETLW  4C
029E:  RETLW  49
029F:  RETLW  52
02A0:  RETLW  20
02A1:  RETLW  20
02A2:  RETLW  20
02A3:  RETLW  20
02A4:  RETLW  20
02A5:  RETLW  20
02A6:  RETLW  20
02A7:  RETLW  20
02A8:  RETLW  20
02A9:  RETLW  20
02AA:  RETLW  20
02AB:  RETLW  00
02AC:  RETLW  00
02AD:  RETLW  00
02AE:  RETLW  00
02AF:  RETLW  00
02B0:  RETLW  00
02B1:  RETLW  00
02B2:  RETLW  00
02B3:  RETLW  00
02B4:  RETLW  00
02B5:  RETLW  00
02B6:  RETLW  00
02B7:  RETLW  00
02B8:  RETLW  00
02B9:  RETLW  00
02BA:  RETLW  00
02BB:  RETLW  00
02BC:  RETLW  00
02BD:  RETLW  45
02BE:  RETLW  73
02BF:  RETLW  74
02C0:  RETLW  61
02C1:  RETLW  63
02C2:  RETLW  69
02C3:  RETLW  6F
02C4:  RETLW  6E
02C5:  RETLW  20
02C6:  RETLW  20
02C7:  RETLW  20
02C8:  RETLW  20
02C9:  RETLW  20
02CA:  RETLW  00
02CB:  RETLW  41
02CC:  RETLW  63
02CD:  RETLW  63
02CE:  RETLW  65
02CF:  RETLW  73
02D0:  RETLW  73
02D1:  RETLW  20
02D2:  RETLW  50
02D3:  RETLW  6F
02D4:  RETLW  69
02D5:  RETLW  6E
02D6:  RETLW  74
02D7:  RETLW  20
02D8:  RETLW  00
02D9:  RETLW  45
02DA:  RETLW  73
02DB:  RETLW  74
02DC:  RETLW  61
02DD:  RETLW  63
02DE:  RETLW  69
02DF:  RETLW  6F
02E0:  RETLW  6E
02E1:  RETLW  20
02E2:  RETLW  2B
02E3:  RETLW  20
02E4:  RETLW  41
02E5:  RETLW  50
02E6:  RETLW  00
02E7:  RETLW  53
02E8:  RETLW  41
02E9:  RETLW  4C
02EA:  RETLW  49
02EB:  RETLW  52
02EC:  RETLW  20
02ED:  RETLW  20
02EE:  RETLW  20
02EF:  RETLW  20
02F0:  RETLW  20
02F1:  RETLW  20
02F2:  RETLW  20
02F3:  RETLW  20
02F4:  RETLW  00
02F5:  RETLW  00
02F6:  RETLW  00
02F7:  RETLW  00
02F8:  RETLW  00
02F9:  RETLW  00
02FA:  RETLW  00
02FB:  RETLW  00
02FC:  RETLW  00
02FD:  RETLW  00
02FE:  RETLW  00
02FF:  RETLW  00
0300:  RETLW  00
0301:  RETLW  00
0302:  RETLW  00
0303:  DATA D3,20
0304:  DATA CC,24
0305:  DATA 52,00
0306:  DATA DB,29
0307:  DATA C9,23
0308:  DATA 5D,10
0309:  DATA 20,10
030A:  DATA 20,10
030B:  DATA A0,2D
030C:  DATA 45,27
030D:  DATA D4,2E
030E:  DATA 00,00
030F:  DATA 8C,18
0310:  DATA 39,19
0311:  DATA AE,18
0312:  DATA 36,1C
0313:  DATA 2E,18
0314:  DATA AE,18
0315:  DATA 00,01
0316:  DATA 8C,21
0317:  DATA B0,23
0318:  DATA B3,2F
0319:  DATA 55,27
031A:  DATA 45,00
031B:  DATA 8C,18
031C:  DATA B2,19
031D:  DATA B4,20
031E:  DATA FA,10
031F:  DATA 00,01
0320:  DATA 0C,21
0321:  DATA E1,31
0322:  DATA 6B,36
0323:  DATA E9,33
0324:  DATA 68,3A
0325:  DATA A0,27
0326:  DATA 6E,00
0327:  DATA 0C,21
0328:  DATA E1,31
0329:  DATA 6B,36
032A:  DATA E9,33
032B:  DATA 68,3A
032C:  DATA A0,27
032D:  DATA 66,33
032E:  DATA 00,01
032F:  DATA 41,2A
0330:  DATA AB,21
0331:  DATA D7,26
0332:  DATA 4F,22
0333:  DATA C5,2F
0334:  DATA C4,22
0335:  DATA C6,1E
0336:  DATA B1,06
0337:  DATA 0A,00
0338:  DATA 8C,21
0339:  DATA 6F,37
033A:  DATA E6,34
033B:  DATA 67,10
033C:  DATA 43,36
033D:  DATA E9,32
033E:  DATA 6E,3A
033F:  DATA 65,00
0340:  DATA 41,2A
0341:  DATA AB,21
0342:  DATA D7,26
0343:  DATA 4F,22
0344:  DATA C5,2F
0345:  DATA C4,22
0346:  DATA C6,1E
0347:  DATA B2,06
0348:  DATA 0A,00
0349:  DATA 8C,21
034A:  DATA 6F,37
034B:  DATA E6,34
034C:  DATA 67,10
034D:  DATA 41,28
034E:  DATA 00,01
034F:  DATA 41,2A
0350:  DATA AB,21
0351:  DATA D7,26
0352:  DATA 4F,22
0353:  DATA C5,2F
0354:  DATA C4,22
0355:  DATA C6,1E
0356:  DATA B3,06
0357:  DATA 0A,00
0358:  DATA 8C,21
0359:  DATA 6F,37
035A:  DATA E6,34
035B:  DATA 67,10
035C:  DATA 43,36
035D:  DATA E9,32
035E:  DATA 6E,3A
035F:  DATA E5,20
0360:  DATA 50,00
*
069A:  MOVF   0B,W
069B:  BSF    03.5
069C:  MOVWF  6C
069D:  BCF    03.5
069E:  BCF    0B.7
069F:  BSF    03.5
06A0:  BSF    03.6
06A1:  BSF    0C.7
06A2:  BSF    0C.0
06A3:  NOP
06A4:  NOP
06A5:  BCF    03.6
06A6:  BTFSS  6C.7
06A7:  GOTO   6AB
06A8:  BCF    03.5
06A9:  BSF    0B.7
06AA:  BSF    03.5
06AB:  BTFSC  03.0
06AC:  GOTO   6E5
06AD:  BCF    03.5
06AE:  BSF    03.6
06AF:  MOVF   0C,W
06B0:  ANDLW  7F
06B1:  BSF    03.5
06B2:  BCF    03.6
06B3:  MOVWF  6C
06B4:  BCF    03.5
06B5:  BSF    03.6
06B6:  MOVF   0D,W
06B7:  BSF    03.5
06B8:  BCF    03.6
06B9:  MOVWF  6D
06BA:  BCF    03.5
06BB:  BSF    03.6
06BC:  MOVF   0F,W
06BD:  BSF    03.5
06BE:  BCF    03.6
06BF:  MOVWF  6E
06C0:  MOVF   6C,W
06C1:  BCF    03.5
06C2:  BTFSS  0C.4
06C3:  GOTO   6C2
06C4:  MOVWF  19
06C5:  BSF    03.5
06C6:  MOVF   6D,W
06C7:  BCF    03.5
06C8:  BSF    03.6
06C9:  MOVWF  0D
06CA:  BSF    03.5
06CB:  BCF    03.6
06CC:  MOVF   6E,W
06CD:  BCF    03.5
06CE:  BSF    03.6
06CF:  MOVWF  0F
06D0:  BCF    03.6
06D1:  MOVF   0B,W
06D2:  BSF    03.5
06D3:  MOVWF  6F
06D4:  BCF    03.5
06D5:  BCF    0B.7
06D6:  BSF    03.5
06D7:  BSF    03.6
06D8:  BSF    0C.7
06D9:  BSF    0C.0
06DA:  NOP
06DB:  NOP
06DC:  BCF    03.6
06DD:  BTFSS  6F.7
06DE:  GOTO   6E2
06DF:  BCF    03.5
06E0:  BSF    0B.7
06E1:  BSF    03.5
06E2:  DECFSZ 6B,F
06E3:  GOTO   6E5
06E4:  GOTO   714
06E5:  BCF    03.5
06E6:  BSF    03.6
06E7:  RLF    0C,W
06E8:  RLF    0E,W
06E9:  ANDLW  7F
06EA:  BSF    03.5
06EB:  BCF    03.6
06EC:  MOVWF  6C
06ED:  BCF    03.5
06EE:  BSF    03.6
06EF:  MOVF   0D,W
06F0:  BSF    03.5
06F1:  BCF    03.6
06F2:  MOVWF  6D
06F3:  BCF    03.5
06F4:  BSF    03.6
06F5:  MOVF   0F,W
06F6:  BSF    03.5
06F7:  BCF    03.6
06F8:  MOVWF  6E
06F9:  MOVF   6C,W
06FA:  BCF    03.5
06FB:  BTFSS  0C.4
06FC:  GOTO   6FB
06FD:  MOVWF  19
06FE:  BSF    03.5
06FF:  MOVF   6D,W
0700:  BCF    03.5
0701:  BSF    03.6
0702:  MOVWF  0D
0703:  BSF    03.5
0704:  BCF    03.6
0705:  MOVF   6E,W
0706:  BCF    03.5
0707:  BSF    03.6
0708:  MOVWF  0F
0709:  INCF   0D,F
070A:  BTFSC  03.2
070B:  INCF   0F,F
070C:  BCF    03.0
070D:  BSF    03.5
070E:  BCF    03.6
070F:  DECFSZ 6B,F
0710:  GOTO   712
0711:  GOTO   714
0712:  BCF    03.5
0713:  GOTO   69A
0714:  BCF    03.5
0715:  RETURN
*
0749:  MOVF   0B,W
074A:  BSF    03.5
074B:  MOVWF  5B
074C:  BCF    03.5
074D:  BCF    0B.7
074E:  BSF    03.5
074F:  BSF    03.6
0750:  BSF    0C.7
0751:  BSF    0C.0
0752:  NOP
0753:  NOP
0754:  BCF    03.6
0755:  BTFSS  5B.7
0756:  GOTO   75A
0757:  BCF    03.5
0758:  BSF    0B.7
0759:  BSF    03.5
075A:  BCF    03.5
075B:  BSF    03.6
075C:  MOVF   0C,W
075D:  ANDLW  7F
075E:  BTFSC  03.2
075F:  GOTO   7BD
0760:  BSF    03.5
0761:  BCF    03.6
0762:  MOVWF  5B
0763:  BCF    03.5
0764:  BSF    03.6
0765:  MOVF   0D,W
0766:  BSF    03.5
0767:  BCF    03.6
0768:  MOVWF  5C
0769:  BCF    03.5
076A:  BSF    03.6
076B:  MOVF   0F,W
076C:  BSF    03.5
076D:  BCF    03.6
076E:  MOVWF  5D
076F:  MOVF   5B,W
0770:  BCF    03.5
0771:  BTFSS  0C.4
0772:  GOTO   771
0773:  MOVWF  19
0774:  BSF    03.5
0775:  MOVF   5C,W
0776:  BCF    03.5
0777:  BSF    03.6
0778:  MOVWF  0D
0779:  BSF    03.5
077A:  BCF    03.6
077B:  MOVF   5D,W
077C:  BCF    03.5
077D:  BSF    03.6
077E:  MOVWF  0F
077F:  BCF    03.6
0780:  MOVF   0B,W
0781:  BSF    03.5
0782:  MOVWF  5E
0783:  BCF    03.5
0784:  BCF    0B.7
0785:  BSF    03.5
0786:  BSF    03.6
0787:  BSF    0C.7
0788:  BSF    0C.0
0789:  NOP
078A:  NOP
078B:  BCF    03.6
078C:  BTFSS  5E.7
078D:  GOTO   791
078E:  BCF    03.5
078F:  BSF    0B.7
0790:  BSF    03.5
0791:  BCF    03.5
0792:  BSF    03.6
0793:  RLF    0C,W
0794:  RLF    0E,W
0795:  ANDLW  7F
0796:  BTFSC  03.2
0797:  GOTO   7BD
0798:  BSF    03.5
0799:  BCF    03.6
079A:  MOVWF  5B
079B:  BCF    03.5
079C:  BSF    03.6
079D:  MOVF   0D,W
079E:  BSF    03.5
079F:  BCF    03.6
07A0:  MOVWF  5C
07A1:  BCF    03.5
07A2:  BSF    03.6
07A3:  MOVF   0F,W
07A4:  BSF    03.5
07A5:  BCF    03.6
07A6:  MOVWF  5D
07A7:  MOVF   5B,W
07A8:  BCF    03.5
07A9:  BTFSS  0C.4
07AA:  GOTO   7A9
07AB:  MOVWF  19
07AC:  BSF    03.5
07AD:  MOVF   5C,W
07AE:  BCF    03.5
07AF:  BSF    03.6
07B0:  MOVWF  0D
07B1:  BSF    03.5
07B2:  BCF    03.6
07B3:  MOVF   5D,W
07B4:  BCF    03.5
07B5:  BSF    03.6
07B6:  MOVWF  0F
07B7:  INCF   0D,F
07B8:  BTFSC  03.2
07B9:  INCF   0F,F
07BA:  BCF    03.6
07BB:  GOTO   749
07BC:  BSF    03.6
07BD:  BCF    03.6
07BE:  RETURN
07BF:  MOVF   0B,W
07C0:  BSF    03.5
07C1:  MOVWF  5C
07C2:  BCF    03.5
07C3:  BCF    0B.7
07C4:  BSF    03.5
07C5:  BSF    03.6
07C6:  BSF    0C.7
07C7:  BSF    0C.0
07C8:  NOP
07C9:  NOP
07CA:  BCF    03.6
07CB:  BTFSS  5C.7
07CC:  GOTO   7D0
07CD:  BCF    03.5
07CE:  BSF    0B.7
07CF:  BSF    03.5
07D0:  BCF    03.5
07D1:  BSF    03.6
07D2:  MOVF   0C,F
07D3:  BTFSC  03.2
07D4:  GOTO   7FA
07D5:  MOVF   0D,W
07D6:  BSF    03.5
07D7:  BCF    03.6
07D8:  MOVWF  5C
07D9:  BCF    03.5
07DA:  BSF    03.6
07DB:  MOVF   0F,W
07DC:  BSF    03.5
07DD:  BCF    03.6
07DE:  MOVWF  5D
07DF:  BCF    03.5
07E0:  BSF    03.6
07E1:  MOVF   0C,W
07E2:  BSF    03.5
07E3:  BCF    03.6
07E4:  MOVWF  5E
07E5:  BSF    0A.3
07E6:  BCF    03.5
07E7:  CALL   118
07E8:  BCF    0A.3
07E9:  BSF    03.5
07EA:  MOVF   5C,W
07EB:  BCF    03.5
07EC:  BSF    03.6
07ED:  MOVWF  0D
07EE:  BSF    03.5
07EF:  BCF    03.6
07F0:  MOVF   5D,W
07F1:  BCF    03.5
07F2:  BSF    03.6
07F3:  MOVWF  0F
07F4:  INCF   0D,F
07F5:  BTFSC  03.2
07F6:  INCF   0F,F
07F7:  BCF    03.6
07F8:  GOTO   7BF
07F9:  BSF    03.6
07FA:  BCF    03.6
07FB:  RETURN
*
081C:  MOVF   00,F
081D:  BTFSC  03.2
081E:  GOTO   037
081F:  CLRF   6C
0820:  MOVF   04,W
0821:  MOVWF  6B
0822:  BCF    6C.0
0823:  BTFSC  03.7
0824:  BSF    6C.0
0825:  MOVF   00,W
0826:  BCF    03.5
0827:  BTFSS  0C.4
0828:  GOTO   027
0829:  MOVWF  19
082A:  BSF    03.5
082B:  MOVF   6B,W
082C:  MOVWF  04
082D:  BCF    03.7
082E:  BTFSC  6C.0
082F:  BSF    03.7
0830:  INCF   04,F
0831:  BTFSS  03.2
0832:  GOTO   036
0833:  BCF    03.5
0834:  INCF   05,F
0835:  BSF    03.5
0836:  GOTO   01C
*
0876:  MOVF   00,F
0877:  BTFSC  03.2
0878:  GOTO   091
0879:  CLRF   6C
087A:  MOVF   04,W
087B:  MOVWF  6B
087C:  BCF    6C.0
087D:  BTFSC  03.7
087E:  BSF    6C.0
087F:  MOVF   00,W
0880:  BCF    03.5
0881:  BTFSS  0C.4
0882:  GOTO   081
0883:  MOVWF  19
0884:  BSF    03.5
0885:  MOVF   6B,W
0886:  MOVWF  04
0887:  BCF    03.7
0888:  BTFSC  6C.0
0889:  BSF    03.7
088A:  INCF   04,F
088B:  BTFSS  03.2
088C:  GOTO   090
088D:  BCF    03.5
088E:  INCF   05,F
088F:  BSF    03.5
0890:  GOTO   076
*
08B8:  MOVF   00,F
08B9:  BTFSC  03.2
08BA:  GOTO   0D3
08BB:  CLRF   6C
08BC:  MOVF   04,W
08BD:  MOVWF  6B
08BE:  BCF    6C.0
08BF:  BTFSC  03.7
08C0:  BSF    6C.0
08C1:  MOVF   00,W
08C2:  BCF    03.5
08C3:  BTFSS  0C.4
08C4:  GOTO   0C3
08C5:  MOVWF  19
08C6:  BSF    03.5
08C7:  MOVF   6B,W
08C8:  MOVWF  04
08C9:  BCF    03.7
08CA:  BTFSC  6C.0
08CB:  BSF    03.7
08CC:  INCF   04,F
08CD:  BTFSS  03.2
08CE:  GOTO   0D2
08CF:  BCF    03.5
08D0:  INCF   05,F
08D1:  BSF    03.5
08D2:  GOTO   0B8
*
097E:  MOVF   0B,W
097F:  BSF    03.5
0980:  MOVWF  5B
0981:  BCF    03.5
0982:  BCF    0B.7
0983:  BSF    03.5
0984:  BSF    03.6
0985:  BSF    0C.7
0986:  BSF    0C.0
0987:  NOP
0988:  NOP
0989:  BCF    03.6
098A:  BTFSS  5B.7
098B:  GOTO   18F
098C:  BCF    03.5
098D:  BSF    0B.7
098E:  BSF    03.5
098F:  BCF    03.5
0990:  BSF    03.6
0991:  MOVF   0C,W
0992:  ANDLW  7F
0993:  BTFSC  03.2
0994:  GOTO   1F0
0995:  BSF    03.5
0996:  BCF    03.6
0997:  MOVWF  5B
0998:  BCF    03.5
0999:  BSF    03.6
099A:  MOVF   0D,W
099B:  BSF    03.5
099C:  BCF    03.6
099D:  MOVWF  5C
099E:  BCF    03.5
099F:  BSF    03.6
09A0:  MOVF   0F,W
09A1:  BSF    03.5
09A2:  BCF    03.6
09A3:  MOVWF  5D
09A4:  MOVF   5B,W
09A5:  MOVWF  5E
09A6:  BCF    03.5
09A7:  CALL   118
09A8:  BSF    03.5
09A9:  MOVF   5C,W
09AA:  BCF    03.5
09AB:  BSF    03.6
09AC:  MOVWF  0D
09AD:  BSF    03.5
09AE:  BCF    03.6
09AF:  MOVF   5D,W
09B0:  BCF    03.5
09B1:  BSF    03.6
09B2:  MOVWF  0F
09B3:  BCF    03.6
09B4:  MOVF   0B,W
09B5:  BSF    03.5
09B6:  MOVWF  5E
09B7:  BCF    03.5
09B8:  BCF    0B.7
09B9:  BSF    03.5
09BA:  BSF    03.6
09BB:  BSF    0C.7
09BC:  BSF    0C.0
09BD:  NOP
09BE:  NOP
09BF:  BCF    03.6
09C0:  BTFSS  5E.7
09C1:  GOTO   1C5
09C2:  BCF    03.5
09C3:  BSF    0B.7
09C4:  BSF    03.5
09C5:  BCF    03.5
09C6:  BSF    03.6
09C7:  RLF    0C,W
09C8:  RLF    0E,W
09C9:  ANDLW  7F
09CA:  BTFSC  03.2
09CB:  GOTO   1F0
09CC:  BSF    03.5
09CD:  BCF    03.6
09CE:  MOVWF  5B
09CF:  BCF    03.5
09D0:  BSF    03.6
09D1:  MOVF   0D,W
09D2:  BSF    03.5
09D3:  BCF    03.6
09D4:  MOVWF  5C
09D5:  BCF    03.5
09D6:  BSF    03.6
09D7:  MOVF   0F,W
09D8:  BSF    03.5
09D9:  BCF    03.6
09DA:  MOVWF  5D
09DB:  MOVF   5B,W
09DC:  MOVWF  5E
09DD:  BCF    03.5
09DE:  CALL   118
09DF:  BSF    03.5
09E0:  MOVF   5C,W
09E1:  BCF    03.5
09E2:  BSF    03.6
09E3:  MOVWF  0D
09E4:  BSF    03.5
09E5:  BCF    03.6
09E6:  MOVF   5D,W
09E7:  BCF    03.5
09E8:  BSF    03.6
09E9:  MOVWF  0F
09EA:  INCF   0D,F
09EB:  BTFSC  03.2
09EC:  INCF   0F,F
09ED:  BCF    03.6
09EE:  GOTO   17E
09EF:  BSF    03.6
09F0:  BCF    03.6
09F1:  RETURN
09F2:  BSF    03.5
09F3:  MOVF   6D,W
09F4:  ANDLW  07
09F5:  MOVWF  77
09F6:  RRF    6D,W
09F7:  MOVWF  78
09F8:  RRF    78,F
09F9:  RRF    78,F
09FA:  MOVLW  1F
09FB:  ANDWF  78,F
09FC:  MOVF   78,W
09FD:  BCF    03.5
09FE:  BSF    03.6
09FF:  ADDWF  10,W
0A00:  MOVWF  04
0A01:  BCF    03.7
0A02:  BTFSC  11.0
0A03:  BSF    03.7
0A04:  CLRF   78
0A05:  INCF   78,F
0A06:  INCF   77,F
0A07:  GOTO   209
0A08:  RLF    78,F
0A09:  DECFSZ 77,F
0A0A:  GOTO   208
0A0B:  BSF    03.5
0A0C:  BCF    03.6
0A0D:  MOVF   6E,F
0A0E:  BTFSC  03.2
0A0F:  GOTO   213
0A10:  MOVF   78,W
0A11:  IORWF  00,F
0A12:  GOTO   216
0A13:  COMF   78,F
0A14:  MOVF   78,W
0A15:  ANDWF  00,F
0A16:  BCF    03.5
0A17:  RETURN
*
0AC4:  MOVF   00,F
0AC5:  BTFSC  03.2
0AC6:  GOTO   2E1
0AC7:  BSF    03.5
0AC8:  CLRF   6C
0AC9:  MOVF   04,W
0ACA:  MOVWF  6B
0ACB:  BCF    6C.0
0ACC:  BTFSC  03.7
0ACD:  BSF    6C.0
0ACE:  MOVF   00,W
0ACF:  BCF    03.5
0AD0:  BTFSS  0C.4
0AD1:  GOTO   2D0
0AD2:  MOVWF  19
0AD3:  BSF    03.5
0AD4:  MOVF   6B,W
0AD5:  MOVWF  04
0AD6:  BCF    03.7
0AD7:  BTFSC  6C.0
0AD8:  BSF    03.7
0AD9:  INCF   04,F
0ADA:  BTFSS  03.2
0ADB:  GOTO   2DF
0ADC:  BCF    03.5
0ADD:  INCF   05,F
0ADE:  BSF    03.5
0ADF:  BCF    03.5
0AE0:  GOTO   2C4
*
0B61:  BTFSC  03.1
0B62:  GOTO   366
0B63:  MOVLW  14
0B64:  MOVWF  04
0B65:  BSF    03.7
0B66:  CLRF   77
0B67:  CLRF   78
0B68:  CLRF   79
0B69:  CLRF   7A
0B6A:  CLRF   14
0B6B:  CLRF   15
0B6C:  CLRF   16
0B6D:  CLRF   17
0B6E:  MOVF   13,W
0B6F:  IORWF  12,W
0B70:  IORWF  11,W
0B71:  IORWF  10,W
0B72:  BTFSC  03.2
0B73:  GOTO   3A8
0B74:  MOVLW  20
0B75:  MOVWF  18
0B76:  BCF    03.0
0B77:  BSF    03.5
0B78:  BCF    03.6
0B79:  RLF    69,F
0B7A:  RLF    6A,F
0B7B:  RLF    6B,F
0B7C:  RLF    6C,F
0B7D:  BCF    03.5
0B7E:  BSF    03.6
0B7F:  RLF    14,F
0B80:  RLF    15,F
0B81:  RLF    16,F
0B82:  RLF    17,F
0B83:  MOVF   13,W
0B84:  SUBWF  17,W
0B85:  BTFSS  03.2
0B86:  GOTO   391
0B87:  MOVF   12,W
0B88:  SUBWF  16,W
0B89:  BTFSS  03.2
0B8A:  GOTO   391
0B8B:  MOVF   11,W
0B8C:  SUBWF  15,W
0B8D:  BTFSS  03.2
0B8E:  GOTO   391
0B8F:  MOVF   10,W
0B90:  SUBWF  14,W
0B91:  BTFSS  03.0
0B92:  GOTO   3A2
0B93:  MOVF   10,W
0B94:  SUBWF  14,F
0B95:  MOVF   11,W
0B96:  BTFSS  03.0
0B97:  INCFSZ 11,W
0B98:  SUBWF  15,F
0B99:  MOVF   12,W
0B9A:  BTFSS  03.0
0B9B:  INCFSZ 12,W
0B9C:  SUBWF  16,F
0B9D:  MOVF   13,W
0B9E:  BTFSS  03.0
0B9F:  INCFSZ 13,W
0BA0:  SUBWF  17,F
0BA1:  BSF    03.0
0BA2:  RLF    77,F
0BA3:  RLF    78,F
0BA4:  RLF    79,F
0BA5:  RLF    7A,F
0BA6:  DECFSZ 18,F
0BA7:  GOTO   376
0BA8:  MOVF   14,W
0BA9:  MOVWF  00
0BAA:  INCF   04,F
0BAB:  MOVF   15,W
0BAC:  MOVWF  00
0BAD:  INCF   04,F
0BAE:  MOVF   16,W
0BAF:  MOVWF  00
0BB0:  INCF   04,F
0BB1:  MOVF   17,W
0BB2:  MOVWF  00
*
0BCC:  MOVLW  20
0BCD:  MOVWF  18
0BCE:  CLRF   14
0BCF:  CLRF   15
0BD0:  CLRF   16
0BD1:  CLRF   17
0BD2:  BSF    03.5
0BD3:  BCF    03.6
0BD4:  MOVF   6C,W
0BD5:  MOVWF  7A
0BD6:  MOVF   6B,W
0BD7:  MOVWF  79
0BD8:  MOVF   6A,W
0BD9:  MOVWF  78
0BDA:  MOVF   69,W
0BDB:  MOVWF  77
0BDC:  BCF    03.0
0BDD:  BTFSS  77.0
0BDE:  GOTO   3F1
0BDF:  BCF    03.5
0BE0:  BSF    03.6
0BE1:  MOVF   10,W
0BE2:  ADDWF  14,F
0BE3:  MOVF   11,W
0BE4:  BTFSC  03.0
0BE5:  INCFSZ 11,W
0BE6:  ADDWF  15,F
0BE7:  MOVF   12,W
0BE8:  BTFSC  03.0
0BE9:  INCFSZ 12,W
0BEA:  ADDWF  16,F
0BEB:  MOVF   13,W
0BEC:  BTFSC  03.0
0BED:  INCFSZ 13,W
0BEE:  ADDWF  17,F
0BEF:  BSF    03.5
0BF0:  BCF    03.6
0BF1:  BCF    03.5
0BF2:  BSF    03.6
0BF3:  RRF    17,F
0BF4:  RRF    16,F
0BF5:  RRF    15,F
0BF6:  RRF    14,F
0BF7:  RRF    7A,F
0BF8:  RRF    79,F
0BF9:  RRF    78,F
0BFA:  RRF    77,F
0BFB:  DECFSZ 18,F
0BFC:  GOTO   3FE
0BFD:  GOTO   401
0BFE:  BSF    03.5
0BFF:  BCF    03.6
0C00:  GOTO   3DC
*
0D60:  CLRF   77
0D61:  CLRF   78
0D62:  BSF    03.5
0D63:  MOVF   5B,W
0D64:  BCF    03.0
0D65:  BTFSC  5C.0
0D66:  ADDWF  77,F
0D67:  RRF    77,F
0D68:  RRF    78,F
0D69:  BTFSC  5C.1
0D6A:  ADDWF  77,F
0D6B:  RRF    77,F
0D6C:  RRF    78,F
0D6D:  BTFSC  5C.2
0D6E:  ADDWF  77,F
0D6F:  RRF    77,F
0D70:  RRF    78,F
0D71:  BTFSC  5C.3
0D72:  ADDWF  77,F
0D73:  RRF    77,F
0D74:  RRF    78,F
0D75:  BTFSC  5C.4
0D76:  ADDWF  77,F
0D77:  RRF    77,F
0D78:  RRF    78,F
0D79:  BTFSC  5C.5
0D7A:  ADDWF  77,F
0D7B:  RRF    77,F
0D7C:  RRF    78,F
0D7D:  BTFSC  5C.6
0D7E:  ADDWF  77,F
0D7F:  RRF    77,F
0D80:  RRF    78,F
0D81:  BTFSC  5C.7
0D82:  ADDWF  77,F
0D83:  RRF    77,F
0D84:  RRF    78,F
0D85:  BCF    03.5
0D86:  RETURN
*
130A:  BSF    0A.0
130B:  BSF    0A.1
130C:  BCF    0A.2
130D:  ADDWF  02,F
130E:  GOTO   008
130F:  GOTO   052
1310:  GOTO   09C
1311:  GOTO   0E6
1312:  GOTO   2A6
1313:  GOTO   303
*
1537:  BSF    0A.0
1538:  BCF    0A.1
1539:  BSF    0A.2
153A:  ADDWF  02,F
153B:  GOTO   514
153C:  GOTO   51D
153D:  GOTO   526
153E:  GOTO   52F
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20000000) 
*
04A1:  MOVLW  EB
04A2:  MOVWF  04
04A3:  BCF    03.7
04A4:  MOVF   00,W
04A5:  BTFSC  03.2
04A6:  GOTO   4B4
04A7:  MOVLW  06
04A8:  MOVWF  78
04A9:  CLRF   77
04AA:  DECFSZ 77,F
04AB:  GOTO   4AA
04AC:  DECFSZ 78,F
04AD:  GOTO   4A9
04AE:  MOVLW  7B
04AF:  MOVWF  77
04B0:  DECFSZ 77,F
04B1:  GOTO   4B0
04B2:  DECFSZ 00,F
04B3:  GOTO   4A7
04B4:  RETURN
*
0C1B:  MOVLW  03
0C1C:  SUBWF  6A,F
0C1D:  BTFSS  03.0
0C1E:  GOTO   429
0C1F:  MOVLW  EA
0C20:  MOVWF  04
0C21:  BCF    03.7
0C22:  MOVF   00,W
0C23:  BTFSC  03.2
0C24:  GOTO   429
0C25:  GOTO   427
0C26:  GOTO   427
0C27:  DECFSZ 00,F
0C28:  GOTO   426
*
0C2C:  MOVLW  03
0C2D:  SUBWF  6A,F
0C2E:  BTFSS  03.0
0C2F:  GOTO   43A
0C30:  MOVLW  EA
0C31:  MOVWF  04
0C32:  BCF    03.7
0C33:  MOVF   00,W
0C34:  BTFSC  03.2
0C35:  GOTO   43A
0C36:  GOTO   438
0C37:  GOTO   438
0C38:  DECFSZ 00,F
0C39:  GOTO   437
*
0C4C:  MOVLW  03
0C4D:  SUBWF  6A,F
0C4E:  BTFSS  03.0
0C4F:  GOTO   45A
0C50:  MOVLW  EA
0C51:  MOVWF  04
0C52:  BCF    03.7
0C53:  MOVF   00,W
0C54:  BTFSC  03.2
0C55:  GOTO   45A
0C56:  GOTO   458
0C57:  GOTO   458
0C58:  DECFSZ 00,F
0C59:  GOTO   457
*
0C5D:  MOVLW  03
0C5E:  SUBWF  6A,F
0C5F:  BTFSS  03.0
0C60:  GOTO   46B
0C61:  MOVLW  EA
0C62:  MOVWF  04
0C63:  BCF    03.7
0C64:  MOVF   00,W
0C65:  BTFSC  03.2
0C66:  GOTO   46B
0C67:  GOTO   469
0C68:  GOTO   469
0C69:  DECFSZ 00,F
0C6A:  GOTO   468
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
*
1497:  MOVLW  4A
1498:  BCF    03.6
1499:  MOVWF  2B
149A:  CLRF   2C
149B:  MOVLW  49
149C:  MOVWF  2D
149D:  CLRF   2E
149E:  MOVLW  48
149F:  MOVWF  2F
14A0:  CLRF   30
14A1:  MOVLW  2C
14A2:  MOVWF  31
14A3:  CLRF   32
14A4:  MOVLW  28
14A5:  MOVWF  33
14A6:  CLRF   34
14A7:  MOVLW  29
14A8:  MOVWF  35
14A9:  CLRF   36
14AA:  MOVLW  2A
14AB:  MOVWF  37
14AC:  CLRF   38
14AD:  MOVLW  2B
14AE:  MOVWF  39
14AF:  CLRF   3A
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
14B0:  CLRF   3B
14B1:  CLRF   3C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
04BD:  BSF    08.4
....................    output_float(LCD_DATA5); 
04BE:  BSF    08.5
....................    output_float(LCD_DATA6); 
04BF:  BSF    08.6
....................    output_float(LCD_DATA7); 
04C0:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
04C1:  BCF    03.5
04C2:  BSF    08.1
04C3:  BSF    03.5
04C4:  BCF    08.1
....................    delay_cycles(1); 
04C5:  NOP
....................    lcd_output_enable(1); 
04C6:  BCF    03.5
04C7:  BSF    08.0
04C8:  BSF    03.5
04C9:  BCF    08.0
....................    delay_cycles(1); 
04CA:  NOP
....................    high = lcd_read_nibble(); 
*
04FB:  MOVF   78,W
04FC:  MOVWF  66
....................        
....................    lcd_output_enable(0); 
04FD:  BCF    03.5
04FE:  BCF    08.0
04FF:  BSF    03.5
0500:  BCF    08.0
....................    delay_cycles(1); 
0501:  NOP
....................    lcd_output_enable(1); 
0502:  BCF    03.5
0503:  BSF    08.0
0504:  BSF    03.5
0505:  BCF    08.0
....................    delay_us(1); 
0506:  GOTO   507
0507:  GOTO   508
0508:  NOP
....................    low = lcd_read_nibble(); 
*
0539:  MOVF   78,W
053A:  MOVWF  65
....................        
....................    lcd_output_enable(0); 
053B:  BCF    03.5
053C:  BCF    08.0
053D:  BSF    03.5
053E:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
053F:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0540:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0541:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0542:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0543:  SWAPF  66,W
0544:  MOVWF  77
0545:  MOVLW  F0
0546:  ANDWF  77,F
0547:  MOVF   77,W
0548:  IORWF  65,W
0549:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
04CB:  CLRF   67
*
0509:  CLRF   67
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
04CC:  BSF    08.4
04CD:  MOVLW  00
04CE:  BCF    03.5
04CF:  BTFSC  08.4
04D0:  MOVLW  01
04D1:  BSF    03.5
04D2:  IORWF  67,F
*
050A:  BSF    08.4
050B:  MOVLW  00
050C:  BCF    03.5
050D:  BTFSC  08.4
050E:  MOVLW  01
050F:  BSF    03.5
0510:  IORWF  67,F
....................    n |= input(LCD_DATA5) << 1; 
*
04D3:  BSF    08.5
04D4:  MOVLW  00
04D5:  BCF    03.5
04D6:  BTFSC  08.5
04D7:  MOVLW  01
04D8:  MOVWF  77
04D9:  BCF    03.0
04DA:  RLF    77,F
04DB:  MOVF   77,W
04DC:  BSF    03.5
04DD:  IORWF  67,F
*
0511:  BSF    08.5
0512:  MOVLW  00
0513:  BCF    03.5
0514:  BTFSC  08.5
0515:  MOVLW  01
0516:  MOVWF  77
0517:  BCF    03.0
0518:  RLF    77,F
0519:  MOVF   77,W
051A:  BSF    03.5
051B:  IORWF  67,F
....................    n |= input(LCD_DATA6) << 2; 
*
04DE:  BSF    08.6
04DF:  MOVLW  00
04E0:  BCF    03.5
04E1:  BTFSC  08.6
04E2:  MOVLW  01
04E3:  MOVWF  77
04E4:  RLF    77,F
04E5:  RLF    77,F
04E6:  MOVLW  FC
04E7:  ANDWF  77,F
04E8:  MOVF   77,W
04E9:  BSF    03.5
04EA:  IORWF  67,F
*
051C:  BSF    08.6
051D:  MOVLW  00
051E:  BCF    03.5
051F:  BTFSC  08.6
0520:  MOVLW  01
0521:  MOVWF  77
0522:  RLF    77,F
0523:  RLF    77,F
0524:  MOVLW  FC
0525:  ANDWF  77,F
0526:  MOVF   77,W
0527:  BSF    03.5
0528:  IORWF  67,F
....................    n |= input(LCD_DATA7) << 3; 
*
04EB:  BSF    08.7
04EC:  MOVLW  00
04ED:  BCF    03.5
04EE:  BTFSC  08.7
04EF:  MOVLW  01
04F0:  MOVWF  77
04F1:  RLF    77,F
04F2:  RLF    77,F
04F3:  RLF    77,F
04F4:  MOVLW  F8
04F5:  ANDWF  77,F
04F6:  MOVF   77,W
04F7:  BSF    03.5
04F8:  IORWF  67,F
*
0529:  BSF    08.7
052A:  MOVLW  00
052B:  BCF    03.5
052C:  BTFSC  08.7
052D:  MOVLW  01
052E:  MOVWF  77
052F:  RLF    77,F
0530:  RLF    77,F
0531:  RLF    77,F
0532:  MOVLW  F8
0533:  ANDWF  77,F
0534:  MOVF   77,W
0535:  BSF    03.5
0536:  IORWF  67,F
....................     
....................    return(n); 
*
04F9:  MOVF   67,W
04FA:  MOVWF  78
*
0537:  MOVF   67,W
0538:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0569:  BTFSC  66.0
056A:  GOTO   56F
056B:  BCF    03.5
056C:  BCF    08.4
056D:  GOTO   571
056E:  BSF    03.5
056F:  BCF    03.5
0570:  BSF    08.4
0571:  BSF    03.5
0572:  BCF    08.4
*
05A5:  BTFSC  66.0
05A6:  GOTO   5AB
05A7:  BCF    03.5
05A8:  BCF    08.4
05A9:  GOTO   5AD
05AA:  BSF    03.5
05AB:  BCF    03.5
05AC:  BSF    08.4
05AD:  BSF    03.5
05AE:  BCF    08.4
*
0607:  BTFSC  66.0
0608:  GOTO   60D
0609:  BCF    03.5
060A:  BCF    08.4
060B:  GOTO   60F
060C:  BSF    03.5
060D:  BCF    03.5
060E:  BSF    08.4
060F:  BSF    03.5
0610:  BCF    08.4
*
0647:  BTFSC  66.0
0648:  GOTO   64D
0649:  BCF    03.5
064A:  BCF    08.4
064B:  GOTO   64F
064C:  BSF    03.5
064D:  BCF    03.5
064E:  BSF    08.4
064F:  BSF    03.5
0650:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
*
0573:  BTFSC  66.1
0574:  GOTO   579
0575:  BCF    03.5
0576:  BCF    08.5
0577:  GOTO   57B
0578:  BSF    03.5
0579:  BCF    03.5
057A:  BSF    08.5
057B:  BSF    03.5
057C:  BCF    08.5
*
05AF:  BTFSC  66.1
05B0:  GOTO   5B5
05B1:  BCF    03.5
05B2:  BCF    08.5
05B3:  GOTO   5B7
05B4:  BSF    03.5
05B5:  BCF    03.5
05B6:  BSF    08.5
05B7:  BSF    03.5
05B8:  BCF    08.5
*
0611:  BTFSC  66.1
0612:  GOTO   617
0613:  BCF    03.5
0614:  BCF    08.5
0615:  GOTO   619
0616:  BSF    03.5
0617:  BCF    03.5
0618:  BSF    08.5
0619:  BSF    03.5
061A:  BCF    08.5
*
0651:  BTFSC  66.1
0652:  GOTO   657
0653:  BCF    03.5
0654:  BCF    08.5
0655:  GOTO   659
0656:  BSF    03.5
0657:  BCF    03.5
0658:  BSF    08.5
0659:  BSF    03.5
065A:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
*
057D:  BTFSC  66.2
057E:  GOTO   583
057F:  BCF    03.5
0580:  BCF    08.6
0581:  GOTO   585
0582:  BSF    03.5
0583:  BCF    03.5
0584:  BSF    08.6
0585:  BSF    03.5
0586:  BCF    08.6
*
05B9:  BTFSC  66.2
05BA:  GOTO   5BF
05BB:  BCF    03.5
05BC:  BCF    08.6
05BD:  GOTO   5C1
05BE:  BSF    03.5
05BF:  BCF    03.5
05C0:  BSF    08.6
05C1:  BSF    03.5
05C2:  BCF    08.6
*
061B:  BTFSC  66.2
061C:  GOTO   621
061D:  BCF    03.5
061E:  BCF    08.6
061F:  GOTO   623
0620:  BSF    03.5
0621:  BCF    03.5
0622:  BSF    08.6
0623:  BSF    03.5
0624:  BCF    08.6
*
065B:  BTFSC  66.2
065C:  GOTO   661
065D:  BCF    03.5
065E:  BCF    08.6
065F:  GOTO   663
0660:  BSF    03.5
0661:  BCF    03.5
0662:  BSF    08.6
0663:  BSF    03.5
0664:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
*
0587:  BTFSC  66.3
0588:  GOTO   58D
0589:  BCF    03.5
058A:  BCF    08.7
058B:  GOTO   58F
058C:  BSF    03.5
058D:  BCF    03.5
058E:  BSF    08.7
058F:  BSF    03.5
0590:  BCF    08.7
*
05C3:  BTFSC  66.3
05C4:  GOTO   5C9
05C5:  BCF    03.5
05C6:  BCF    08.7
05C7:  GOTO   5CB
05C8:  BSF    03.5
05C9:  BCF    03.5
05CA:  BSF    08.7
05CB:  BSF    03.5
05CC:  BCF    08.7
*
0625:  BTFSC  66.3
0626:  GOTO   62B
0627:  BCF    03.5
0628:  BCF    08.7
0629:  GOTO   62D
062A:  BSF    03.5
062B:  BCF    03.5
062C:  BSF    08.7
062D:  BSF    03.5
062E:  BCF    08.7
*
0665:  BTFSC  66.3
0666:  GOTO   66B
0667:  BCF    03.5
0668:  BCF    08.7
0669:  GOTO   66D
066A:  BSF    03.5
066B:  BCF    03.5
066C:  BSF    08.7
066D:  BSF    03.5
066E:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
*
0591:  NOP
*
05CD:  NOP
*
062F:  NOP
*
066F:  NOP
....................    lcd_output_enable(1); 
*
0592:  BCF    03.5
0593:  BSF    08.0
0594:  BSF    03.5
0595:  BCF    08.0
*
05CE:  BCF    03.5
05CF:  BSF    08.0
05D0:  BSF    03.5
05D1:  BCF    08.0
*
0630:  BCF    03.5
0631:  BSF    08.0
0632:  BSF    03.5
0633:  BCF    08.0
*
0670:  BCF    03.5
0671:  BSF    08.0
0672:  BSF    03.5
0673:  BCF    08.0
....................    delay_us(2); 
*
0596:  MOVLW  02
0597:  MOVWF  77
0598:  DECFSZ 77,F
0599:  GOTO   598
059A:  GOTO   59B
059B:  NOP
*
05D2:  MOVLW  02
05D3:  MOVWF  77
05D4:  DECFSZ 77,F
05D5:  GOTO   5D4
05D6:  GOTO   5D7
05D7:  NOP
*
0634:  MOVLW  02
0635:  MOVWF  77
0636:  DECFSZ 77,F
0637:  GOTO   636
0638:  GOTO   639
0639:  NOP
*
0674:  MOVLW  02
0675:  MOVWF  77
0676:  DECFSZ 77,F
0677:  GOTO   676
0678:  GOTO   679
0679:  NOP
....................    lcd_output_enable(0); 
*
059C:  BCF    03.5
059D:  BCF    08.0
059E:  BSF    03.5
059F:  BCF    08.0
*
05D8:  BCF    03.5
05D9:  BCF    08.0
05DA:  BSF    03.5
05DB:  BCF    08.0
*
063A:  BCF    03.5
063B:  BCF    08.0
063C:  BSF    03.5
063D:  BCF    08.0
*
067A:  BCF    03.5
067B:  BCF    08.0
067C:  BSF    03.5
067D:  BCF    08.0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
04B5:  BSF    03.5
04B6:  BCF    08.0
....................    lcd_rs_tris(); 
04B7:  BCF    08.2
....................    lcd_rw_tris(); 
04B8:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
04B9:  BCF    03.5
04BA:  BCF    08.2
04BB:  BSF    03.5
04BC:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
054A:  MOVF   78,W
054B:  MOVWF  65
054C:  BTFSC  65.7
054D:  GOTO   4BD
....................    lcd_output_rs(address); 
054E:  MOVF   63,F
054F:  BTFSS  03.2
0550:  GOTO   555
0551:  BCF    03.5
0552:  BCF    08.2
0553:  GOTO   557
0554:  BSF    03.5
0555:  BCF    03.5
0556:  BSF    08.2
0557:  BSF    03.5
0558:  BCF    08.2
....................    delay_cycles(1); 
0559:  NOP
....................    lcd_output_rw(0); 
055A:  BCF    03.5
055B:  BCF    08.1
055C:  BSF    03.5
055D:  BCF    08.1
....................    delay_cycles(1); 
055E:  NOP
....................    lcd_output_enable(0); 
055F:  BCF    03.5
0560:  BCF    08.0
0561:  BSF    03.5
0562:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
0563:  SWAPF  64,W
0564:  MOVWF  65
0565:  MOVLW  0F
0566:  ANDWF  65,F
0567:  MOVF   65,W
0568:  MOVWF  66
....................    lcd_send_nibble(n & 0xf); 
*
05A0:  MOVF   64,W
05A1:  ANDLW  0F
05A2:  MOVWF  65
05A3:  MOVF   65,W
05A4:  MOVWF  66
*
05DC:  BCF    03.5
05DD:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
05DE:  MOVLW  28
05DF:  BSF    03.5
05E0:  MOVWF  57
05E1:  MOVLW  0C
05E2:  MOVWF  58
05E3:  MOVLW  01
05E4:  MOVWF  59
05E5:  MOVLW  06
05E6:  MOVWF  5A
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
05E7:  BCF    03.5
05E8:  BCF    08.0
05E9:  BSF    03.5
05EA:  BCF    08.0
....................    lcd_output_rs(0); 
05EB:  BCF    03.5
05EC:  BCF    08.2
05ED:  BSF    03.5
05EE:  BCF    08.2
....................    lcd_output_rw(0); 
05EF:  BCF    03.5
05F0:  BCF    08.1
05F1:  BSF    03.5
05F2:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
05F3:  BCF    08.4
....................    output_drive(LCD_DATA5); 
05F4:  BCF    08.5
....................    output_drive(LCD_DATA6); 
05F5:  BCF    08.6
....................    output_drive(LCD_DATA7); 
05F6:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
05F7:  BCF    08.0
....................    lcd_rs_tris(); 
05F8:  BCF    08.2
....................    lcd_rw_tris(); 
05F9:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
05FA:  MOVLW  0F
05FB:  MOVWF  6B
05FC:  BCF    03.5
05FD:  CALL   4A1
....................    for(i=1;i<=3;++i) 
05FE:  MOVLW  01
05FF:  BSF    03.5
0600:  MOVWF  56
0601:  MOVF   56,W
0602:  SUBLW  03
0603:  BTFSS  03.0
0604:  GOTO   645
....................    { 
....................        lcd_send_nibble(3); 
0605:  MOVLW  03
0606:  MOVWF  66
....................        delay_ms(5); 
*
063E:  MOVLW  05
063F:  MOVWF  6B
0640:  BCF    03.5
0641:  CALL   4A1
0642:  BSF    03.5
0643:  INCF   56,F
0644:  GOTO   601
....................    } 
....................     
....................    lcd_send_nibble(2); 
0645:  MOVLW  02
0646:  MOVWF  66
....................    delay_ms(5); 
*
067E:  MOVLW  05
067F:  MOVWF  6B
0680:  BCF    03.5
0681:  CALL   4A1
....................    for(i=0;i<=3;++i) 
0682:  BSF    03.5
0683:  CLRF   56
0684:  MOVF   56,W
0685:  SUBLW  03
0686:  BTFSS  03.0
0687:  GOTO   696
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0688:  MOVLW  D7
0689:  ADDWF  56,W
068A:  MOVWF  04
068B:  BCF    03.7
068C:  MOVF   00,W
068D:  MOVWF  5B
068E:  CLRF   63
068F:  MOVF   5B,W
0690:  MOVWF  64
0691:  BCF    03.5
0692:  CALL   4B5
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0693:  BSF    03.5
0694:  INCF   56,F
0695:  GOTO   684
0696:  BCF    03.5
0697:  BCF    0A.3
0698:  BSF    0A.4
0699:  GOTO   502 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
092C:  DECFSZ 60,W
092D:  GOTO   12F
092E:  GOTO   132
*
0956:  DECFSZ 60,W
0957:  GOTO   159
0958:  GOTO   15C
*
0CBD:  DECFSZ 60,W
0CBE:  GOTO   4C0
0CBF:  GOTO   4C3
*
0D1E:  DECFSZ 60,W
0D1F:  GOTO   521
0D20:  GOTO   524
*
0DAD:  DECFSZ 60,W
0DAE:  GOTO   5B0
0DAF:  GOTO   5B3
*
0E11:  DECFSZ 60,W
0E12:  GOTO   614
0E13:  GOTO   617
*
0E98:  DECFSZ 60,W
0E99:  GOTO   69B
0E9A:  GOTO   69E
*
0EF9:  DECFSZ 60,W
0EFA:  GOTO   6FC
0EFB:  GOTO   6FF
*
1018:  DECFSZ 60,W
1019:  GOTO   01B
101A:  GOTO   01E
*
1062:  DECFSZ 60,W
1063:  GOTO   065
1064:  GOTO   068
*
10AC:  DECFSZ 60,W
10AD:  GOTO   0AF
10AE:  GOTO   0B2
*
1114:  DECFSZ 60,W
1115:  GOTO   117
1116:  GOTO   11A
*
118C:  DECFSZ 60,W
118D:  GOTO   18F
118E:  GOTO   192
*
1220:  DECFSZ 60,W
1221:  GOTO   223
1222:  GOTO   226
*
1284:  DECFSZ 60,W
1285:  GOTO   287
1286:  GOTO   28A
*
12C9:  DECFSZ 60,W
12CA:  GOTO   2CC
12CB:  GOTO   2CF
*
1347:  DECFSZ 60,W
1348:  GOTO   34A
1349:  GOTO   34D
*
13B8:  DECFSZ 60,W
13B9:  GOTO   3BB
13BA:  GOTO   3BE
*
142D:  DECFSZ 60,W
142E:  GOTO   430
142F:  GOTO   433
....................       address=LCD_LINE_TWO; 
*
092F:  MOVLW  40
0930:  MOVWF  61
0931:  GOTO   133
*
0959:  MOVLW  40
095A:  MOVWF  61
095B:  GOTO   15D
*
0CC0:  MOVLW  40
0CC1:  MOVWF  61
0CC2:  GOTO   4C4
*
0D21:  MOVLW  40
0D22:  MOVWF  61
0D23:  GOTO   525
*
0DB0:  MOVLW  40
0DB1:  MOVWF  61
0DB2:  GOTO   5B4
*
0E14:  MOVLW  40
0E15:  MOVWF  61
0E16:  GOTO   618
*
0E9B:  MOVLW  40
0E9C:  MOVWF  61
0E9D:  GOTO   69F
*
0EFC:  MOVLW  40
0EFD:  MOVWF  61
0EFE:  GOTO   700
*
101B:  MOVLW  40
101C:  MOVWF  61
101D:  GOTO   01F
*
1065:  MOVLW  40
1066:  MOVWF  61
1067:  GOTO   069
*
10AF:  MOVLW  40
10B0:  MOVWF  61
10B1:  GOTO   0B3
*
1117:  MOVLW  40
1118:  MOVWF  61
1119:  GOTO   11B
*
118F:  MOVLW  40
1190:  MOVWF  61
1191:  GOTO   193
*
1223:  MOVLW  40
1224:  MOVWF  61
1225:  GOTO   227
*
1287:  MOVLW  40
1288:  MOVWF  61
1289:  GOTO   28B
*
12CC:  MOVLW  40
12CD:  MOVWF  61
12CE:  GOTO   2D0
*
134A:  MOVLW  40
134B:  MOVWF  61
134C:  GOTO   34E
*
13BB:  MOVLW  40
13BC:  MOVWF  61
13BD:  GOTO   3BF
*
1430:  MOVLW  40
1431:  MOVWF  61
1432:  GOTO   434
....................    else 
....................       address=0; 
*
0932:  CLRF   61
*
095C:  CLRF   61
*
0CC3:  CLRF   61
*
0D24:  CLRF   61
*
0DB3:  CLRF   61
*
0E17:  CLRF   61
*
0E9E:  CLRF   61
*
0EFF:  CLRF   61
*
101E:  CLRF   61
*
1068:  CLRF   61
*
10B2:  CLRF   61
*
111A:  CLRF   61
*
1192:  CLRF   61
*
1226:  CLRF   61
*
128A:  CLRF   61
*
12CF:  CLRF   61
*
134D:  CLRF   61
*
13BE:  CLRF   61
*
1433:  CLRF   61
....................       
....................    address+=x-1; 
*
0933:  MOVLW  01
0934:  SUBWF  5F,W
0935:  ADDWF  61,F
*
095D:  MOVLW  01
095E:  SUBWF  5F,W
095F:  ADDWF  61,F
*
0CC4:  MOVLW  01
0CC5:  SUBWF  5F,W
0CC6:  ADDWF  61,F
*
0D25:  MOVLW  01
0D26:  SUBWF  5F,W
0D27:  ADDWF  61,F
*
0DB4:  MOVLW  01
0DB5:  SUBWF  5F,W
0DB6:  ADDWF  61,F
*
0E18:  MOVLW  01
0E19:  SUBWF  5F,W
0E1A:  ADDWF  61,F
*
0E9F:  MOVLW  01
0EA0:  SUBWF  5F,W
0EA1:  ADDWF  61,F
*
0F00:  MOVLW  01
0F01:  SUBWF  5F,W
0F02:  ADDWF  61,F
*
101F:  MOVLW  01
1020:  SUBWF  5F,W
1021:  ADDWF  61,F
*
1069:  MOVLW  01
106A:  SUBWF  5F,W
106B:  ADDWF  61,F
*
10B3:  MOVLW  01
10B4:  SUBWF  5F,W
10B5:  ADDWF  61,F
*
111B:  MOVLW  01
111C:  SUBWF  5F,W
111D:  ADDWF  61,F
*
1193:  MOVLW  01
1194:  SUBWF  5F,W
1195:  ADDWF  61,F
*
1227:  MOVLW  01
1228:  SUBWF  5F,W
1229:  ADDWF  61,F
*
128B:  MOVLW  01
128C:  SUBWF  5F,W
128D:  ADDWF  61,F
*
12D0:  MOVLW  01
12D1:  SUBWF  5F,W
12D2:  ADDWF  61,F
*
134E:  MOVLW  01
134F:  SUBWF  5F,W
1350:  ADDWF  61,F
*
13BF:  MOVLW  01
13C0:  SUBWF  5F,W
13C1:  ADDWF  61,F
*
1434:  MOVLW  01
1435:  SUBWF  5F,W
1436:  ADDWF  61,F
....................    lcd_send_byte(0,0x80|address); 
*
0936:  MOVF   61,W
0937:  IORLW  80
0938:  MOVWF  62
0939:  CLRF   63
093A:  MOVF   62,W
093B:  MOVWF  64
093C:  BCF    0A.3
093D:  BCF    03.5
093E:  CALL   4B5
093F:  BSF    0A.3
*
0960:  MOVF   61,W
0961:  IORLW  80
0962:  MOVWF  62
0963:  CLRF   63
0964:  MOVF   62,W
0965:  MOVWF  64
0966:  BCF    0A.3
0967:  BCF    03.5
0968:  CALL   4B5
0969:  BSF    0A.3
*
0CC7:  MOVF   61,W
0CC8:  IORLW  80
0CC9:  MOVWF  62
0CCA:  CLRF   63
0CCB:  MOVF   62,W
0CCC:  MOVWF  64
0CCD:  BCF    0A.3
0CCE:  BCF    03.5
0CCF:  CALL   4B5
0CD0:  BSF    0A.3
*
0D28:  MOVF   61,W
0D29:  IORLW  80
0D2A:  MOVWF  62
0D2B:  CLRF   63
0D2C:  MOVF   62,W
0D2D:  MOVWF  64
0D2E:  BCF    0A.3
0D2F:  BCF    03.5
0D30:  CALL   4B5
0D31:  BSF    0A.3
*
0DB7:  MOVF   61,W
0DB8:  IORLW  80
0DB9:  MOVWF  62
0DBA:  CLRF   63
0DBB:  MOVF   62,W
0DBC:  MOVWF  64
0DBD:  BCF    0A.3
0DBE:  BCF    03.5
0DBF:  CALL   4B5
0DC0:  BSF    0A.3
*
0E1B:  MOVF   61,W
0E1C:  IORLW  80
0E1D:  MOVWF  62
0E1E:  CLRF   63
0E1F:  MOVF   62,W
0E20:  MOVWF  64
0E21:  BCF    0A.3
0E22:  BCF    03.5
0E23:  CALL   4B5
0E24:  BSF    0A.3
*
0EA2:  MOVF   61,W
0EA3:  IORLW  80
0EA4:  MOVWF  62
0EA5:  CLRF   63
0EA6:  MOVF   62,W
0EA7:  MOVWF  64
0EA8:  BCF    0A.3
0EA9:  BCF    03.5
0EAA:  CALL   4B5
0EAB:  BSF    0A.3
*
0F03:  MOVF   61,W
0F04:  IORLW  80
0F05:  MOVWF  62
0F06:  CLRF   63
0F07:  MOVF   62,W
0F08:  MOVWF  64
0F09:  BCF    0A.3
0F0A:  BCF    03.5
0F0B:  CALL   4B5
0F0C:  BSF    0A.3
*
1022:  MOVF   61,W
1023:  IORLW  80
1024:  MOVWF  62
1025:  CLRF   63
1026:  MOVF   62,W
1027:  MOVWF  64
1028:  BCF    0A.4
1029:  BCF    03.5
102A:  CALL   4B5
102B:  BSF    0A.4
*
106C:  MOVF   61,W
106D:  IORLW  80
106E:  MOVWF  62
106F:  CLRF   63
1070:  MOVF   62,W
1071:  MOVWF  64
1072:  BCF    0A.4
1073:  BCF    03.5
1074:  CALL   4B5
1075:  BSF    0A.4
*
10B6:  MOVF   61,W
10B7:  IORLW  80
10B8:  MOVWF  62
10B9:  CLRF   63
10BA:  MOVF   62,W
10BB:  MOVWF  64
10BC:  BCF    0A.4
10BD:  BCF    03.5
10BE:  CALL   4B5
10BF:  BSF    0A.4
*
111E:  MOVF   61,W
111F:  IORLW  80
1120:  MOVWF  62
1121:  CLRF   63
1122:  MOVF   62,W
1123:  MOVWF  64
1124:  BCF    0A.4
1125:  BCF    03.5
1126:  CALL   4B5
1127:  BSF    0A.4
*
1196:  MOVF   61,W
1197:  IORLW  80
1198:  MOVWF  62
1199:  CLRF   63
119A:  MOVF   62,W
119B:  MOVWF  64
119C:  BCF    0A.4
119D:  BCF    03.5
119E:  CALL   4B5
119F:  BSF    0A.4
*
122A:  MOVF   61,W
122B:  IORLW  80
122C:  MOVWF  62
122D:  CLRF   63
122E:  MOVF   62,W
122F:  MOVWF  64
1230:  BCF    0A.4
1231:  BCF    03.5
1232:  CALL   4B5
1233:  BSF    0A.4
*
128E:  MOVF   61,W
128F:  IORLW  80
1290:  MOVWF  62
1291:  CLRF   63
1292:  MOVF   62,W
1293:  MOVWF  64
1294:  BCF    0A.4
1295:  BCF    03.5
1296:  CALL   4B5
1297:  BSF    0A.4
*
12D3:  MOVF   61,W
12D4:  IORLW  80
12D5:  MOVWF  62
12D6:  CLRF   63
12D7:  MOVF   62,W
12D8:  MOVWF  64
12D9:  BCF    0A.4
12DA:  BCF    03.5
12DB:  CALL   4B5
12DC:  BSF    0A.4
*
1351:  MOVF   61,W
1352:  IORLW  80
1353:  MOVWF  62
1354:  CLRF   63
1355:  MOVF   62,W
1356:  MOVWF  64
1357:  BCF    0A.4
1358:  BCF    03.5
1359:  CALL   4B5
135A:  BSF    0A.4
*
13C2:  MOVF   61,W
13C3:  IORLW  80
13C4:  MOVWF  62
13C5:  CLRF   63
13C6:  MOVF   62,W
13C7:  MOVWF  64
13C8:  BCF    0A.4
13C9:  BCF    03.5
13CA:  CALL   4B5
13CB:  BSF    0A.4
*
1437:  MOVF   61,W
1438:  IORLW  80
1439:  MOVWF  62
143A:  CLRF   63
143B:  MOVF   62,W
143C:  MOVWF  64
143D:  BCF    0A.4
143E:  BCF    03.5
143F:  CALL   4B5
1440:  BSF    0A.4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
0918:  BSF    03.5
0919:  MOVF   5E,W
091A:  XORLW  07
091B:  BCF    03.5
091C:  BTFSC  03.2
091D:  GOTO   128
091E:  XORLW  0B
091F:  BTFSC  03.2
0920:  GOTO   141
0921:  XORLW  06
0922:  BTFSC  03.2
0923:  GOTO   151
0924:  XORLW  02
0925:  BTFSC  03.2
0926:  GOTO   16B
0927:  GOTO   174
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0928:  MOVLW  01
0929:  BSF    03.5
092A:  MOVWF  5F
092B:  MOVWF  60
*
0940:  GOTO   17D
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0941:  BSF    03.5
0942:  CLRF   63
0943:  MOVLW  01
0944:  MOVWF  64
0945:  BCF    0A.3
0946:  BCF    03.5
0947:  CALL   4B5
0948:  BSF    0A.3
....................                      delay_ms(2); 
0949:  MOVLW  02
094A:  BSF    03.5
094B:  MOVWF  6B
094C:  BCF    0A.3
094D:  BCF    03.5
094E:  CALL   4A1
094F:  BSF    0A.3
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0950:  GOTO   17D
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0951:  MOVLW  01
0952:  BSF    03.5
0953:  MOVWF  5F
0954:  MOVLW  02
0955:  MOVWF  60
*
096A:  GOTO   17D
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
096B:  BSF    03.5
096C:  CLRF   63
096D:  MOVLW  10
096E:  MOVWF  64
096F:  BCF    0A.3
0970:  BCF    03.5
0971:  CALL   4B5
0972:  BSF    0A.3
0973:  GOTO   17D
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0974:  MOVLW  01
0975:  BSF    03.5
0976:  MOVWF  63
0977:  MOVF   5E,W
0978:  MOVWF  64
0979:  BCF    0A.3
097A:  BCF    03.5
097B:  CALL   4B5
097C:  BSF    0A.3
....................      #endif 
....................    } 
097D:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
0B2B:  BSF    03.5
0B2C:  CLRF   60
0B2D:  CLRF   5F
0B2E:  CLRF   62
0B2F:  CLRF   61
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
0B30:  MOVF   5C,F
0B31:  BTFSS  03.2
0B32:  GOTO   337
0B33:  MOVF   5B,W
0B34:  SUBLW  13
0B35:  BTFSC  03.0
0B36:  GOTO   498
0B37:  MOVF   5C,W
0B38:  SUBLW  4E
0B39:  BTFSS  03.0
0B3A:  GOTO   498
0B3B:  BTFSS  03.2
0B3C:  GOTO   341
0B3D:  MOVF   5B,W
0B3E:  SUBLW  20
0B3F:  BTFSS  03.0
0B40:  GOTO   498
....................       tmp=100000; 
0B41:  CLRF   68
0B42:  MOVLW  01
0B43:  MOVWF  67
0B44:  MOVLW  86
0B45:  MOVWF  66
0B46:  MOVLW  A0
0B47:  MOVWF  65
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
0B48:  BCF    03.1
0B49:  MOVF   68,W
0B4A:  MOVWF  6C
0B4B:  MOVF   67,W
0B4C:  MOVWF  6B
0B4D:  MOVF   66,W
0B4E:  MOVWF  6A
0B4F:  MOVF   65,W
0B50:  MOVWF  69
0B51:  BCF    03.5
0B52:  BSF    03.6
0B53:  CLRF   13
0B54:  CLRF   12
0B55:  BSF    03.5
0B56:  BCF    03.6
0B57:  MOVF   5C,W
0B58:  BCF    03.5
0B59:  BSF    03.6
0B5A:  MOVWF  11
0B5B:  BSF    03.5
0B5C:  BCF    03.6
0B5D:  MOVF   5B,W
0B5E:  BCF    03.5
0B5F:  BSF    03.6
0B60:  MOVWF  10
*
0BB3:  MOVF   7A,W
0BB4:  BSF    03.5
0BB5:  BCF    03.6
0BB6:  MOVWF  68
0BB7:  MOVF   79,W
0BB8:  MOVWF  67
0BB9:  MOVF   78,W
0BBA:  MOVWF  66
0BBB:  MOVF   77,W
0BBC:  MOVWF  65
....................       tmp*=5;    
0BBD:  MOVF   68,W
0BBE:  MOVWF  6C
0BBF:  MOVF   67,W
0BC0:  MOVWF  6B
0BC1:  MOVF   66,W
0BC2:  MOVWF  6A
0BC3:  MOVF   65,W
0BC4:  MOVWF  69
0BC5:  BCF    03.5
0BC6:  BSF    03.6
0BC7:  CLRF   13
0BC8:  CLRF   12
0BC9:  CLRF   11
0BCA:  MOVLW  05
0BCB:  MOVWF  10
*
0C01:  MOVF   7A,W
0C02:  BSF    03.5
0C03:  BCF    03.6
0C04:  MOVWF  68
0C05:  MOVF   79,W
0C06:  MOVWF  67
0C07:  MOVF   78,W
0C08:  MOVWF  66
0C09:  MOVF   77,W
0C0A:  MOVWF  65
....................       uS=tmp; 
0C0B:  MOVF   66,W
0C0C:  MOVWF  64
0C0D:  MOVF   65,W
0C0E:  MOVWF  63
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
0C0F:  BCF    06.2
0C10:  BCF    03.5
0C11:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0C12:  BSF    03.5
0C13:  MOVF   64,W
0C14:  MOVWF  69
0C15:  INCF   69,F
0C16:  DECF   69,F
0C17:  BTFSC  03.2
0C18:  GOTO   42A
0C19:  MOVLW  FF
0C1A:  MOVWF  6A
*
0C29:  GOTO   416
0C2A:  MOVF   63,W
0C2B:  MOVWF  6A
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
0C3A:  MOVF   63,W
0C3B:  ADDWF  61,F
0C3C:  MOVF   64,W
0C3D:  BTFSC  03.0
0C3E:  INCFSZ 64,W
0C3F:  ADDWF  62,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0C40:  BCF    06.2
0C41:  BCF    03.5
0C42:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
0C43:  BSF    03.5
0C44:  MOVF   64,W
0C45:  MOVWF  69
0C46:  INCF   69,F
0C47:  DECF   69,F
0C48:  BTFSC  03.2
0C49:  GOTO   45B
0C4A:  MOVLW  FF
0C4B:  MOVWF  6A
*
0C5A:  GOTO   447
0C5B:  MOVF   63,W
0C5C:  MOVWF  6A
....................          CiclosL+=(uS);          //  
*
0C6B:  MOVF   63,W
0C6C:  ADDWF  61,F
0C6D:  MOVF   64,W
0C6E:  BTFSC  03.0
0C6F:  INCFSZ 64,W
0C70:  ADDWF  62,F
....................          CiclosL+=25;            // Compensador. 
0C71:  MOVLW  19
0C72:  ADDWF  61,F
0C73:  BTFSC  03.0
0C74:  INCF   62,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
0C75:  MOVF   62,W
0C76:  SUBLW  02
0C77:  BTFSC  03.0
0C78:  GOTO   48E
0C79:  XORLW  FF
0C7A:  BTFSS  03.2
0C7B:  GOTO   480
0C7C:  MOVF   61,W
0C7D:  SUBLW  E7
0C7E:  BTFSC  03.0
0C7F:  GOTO   48E
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0C80:  MOVLW  E8
0C81:  SUBWF  61,F
0C82:  MOVLW  03
0C83:  BTFSS  03.0
0C84:  MOVLW  04
0C85:  SUBWF  62,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0C86:  INCF   5F,F
0C87:  BTFSC  03.2
0C88:  INCF   60,F
....................             CiclosL+=25;         // Compensador. 
0C89:  MOVLW  19
0C8A:  ADDWF  61,F
0C8B:  BTFSC  03.0
0C8C:  INCF   62,F
0C8D:  GOTO   475
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
0C8E:  MOVF   60,W
0C8F:  SUBWF  5E,W
0C90:  BTFSS  03.0
0C91:  GOTO   498
0C92:  BTFSS  03.2
0C93:  GOTO   40F
0C94:  MOVF   5D,W
0C95:  SUBWF  5F,W
0C96:  BTFSS  03.0
0C97:  GOTO   40F
....................                                          // tiempo indicado. 
....................    } 
0C98:  BCF    03.5
0C99:  RETURN
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/esp8266.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... #define  CMD_MODE    1 
.................... #define  CMD_DO_CONN 2 
.................... #define  CMD_CONN    3 
....................  
.................... /* Constantes de Captura Respuestas */ 
.................... //const char ESP8266_RESP_START_STAIP[7]    ={'S','T','A','I','P',',','"'}; 
.................... //const char ESP8266_RESP_STOP_STAIP[3]     ={'"',0x0D,0x0A}; 
....................  
.................... /* Declaracion de Funciones de comandos */ 
.................... void reset(void); 
.................... int  setupMode(char modeVal[]); 
.................... int  doConnected(); 
.................... int  setupConn(char SSIDAndKey[]); 
.................... int  setupServer(void); 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void waitRespOK(int buffer); 
.................... void waitRespNoAp(int buffer); 
.................... void waitRespCWJAP(int buffer); 
.................... void waitRespConnected(int buffer); 
.................... void waitRespFail(int buffer); 
.................... int  waitResp(void); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int READY_RESP = 0x00; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... //int flag_Ready_Resp         = 0; 
.................... int flag_Resp_Valid         = 0; 
.................... int flag_Resp_NoAp          = 0; 
.................... int flag_Resp_CWJAP         = 0; 
.................... int flag_Resp_Connected     = 0; 
.................... int flag_Resp_Fail          = 0; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp           = 0; 
.................... int flag_Pos_Resp_NoAp      = 0; 
.................... int flag_Pos_Resp_CWJAP     = 0; 
.................... int flag_Pos_Resp_Connected = 0; 
.................... int flag_Pos_Resp_Fail      = 0; 
....................  
.................... /*@TODO: Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar[]  = "1"; 
*
14B2:  MOVLW  31
14B3:  MOVWF  4D
14B4:  CLRF   4E
.................... char  SSIDAndKey[]= {'"','U','N','E','_','C','0','6','E','"', 
....................                      ',', 
....................                      '"','0','0','9','8','6','3','4','4','2','0','0','7','7','1','"', 
....................                      0x0D,0x0A 
....................                     }; 
14B5:  MOVLW  22
14B6:  MOVWF  4F
14B7:  MOVLW  55
14B8:  MOVWF  50
14B9:  MOVLW  4E
14BA:  MOVWF  51
14BB:  MOVLW  45
14BC:  MOVWF  52
14BD:  MOVLW  5F
14BE:  MOVWF  53
14BF:  MOVLW  43
14C0:  MOVWF  54
14C1:  MOVLW  30
14C2:  MOVWF  55
14C3:  MOVLW  36
14C4:  MOVWF  56
14C5:  MOVLW  45
14C6:  MOVWF  57
14C7:  MOVLW  22
14C8:  MOVWF  58
14C9:  MOVLW  2C
14CA:  MOVWF  59
14CB:  MOVLW  22
14CC:  MOVWF  5A
14CD:  MOVLW  30
14CE:  MOVWF  5B
14CF:  MOVWF  5C
14D0:  MOVLW  39
14D1:  MOVWF  5D
14D2:  MOVLW  38
14D3:  MOVWF  5E
14D4:  MOVLW  36
14D5:  MOVWF  5F
14D6:  MOVLW  33
14D7:  MOVWF  60
14D8:  MOVLW  34
14D9:  MOVWF  61
14DA:  MOVWF  62
14DB:  MOVLW  32
14DC:  MOVWF  63
14DD:  MOVLW  30
14DE:  MOVWF  64
14DF:  MOVWF  65
14E0:  MOVLW  37
14E1:  MOVWF  66
14E2:  MOVWF  67
14E3:  MOVLW  31
14E4:  MOVWF  68
14E5:  MOVLW  22
14E6:  MOVWF  69
14E7:  MOVLW  0D
14E8:  MOVWF  6A
14E9:  MOVLW  0A
14EA:  MOVWF  6B
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    char  modeWithoutConnect[] = "3"; 
*
0800:  MOVLW  33
0801:  BSF    03.5
0802:  MOVWF  56
0803:  CLRF   57
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    /**reset(); 
....................    delay_ms(2000);**/ 
....................  
....................    CMD_RUN =  setupMode(modeStar); 
0804:  CLRF   5A
0805:  MOVLW  4D
0806:  MOVWF  59
*
0842:  MOVF   78,W
0843:  MOVWF  41
....................    waitResp(); 
0844:  BCF    0A.3
0845:  CALL   716
0846:  BSF    0A.3
....................  
....................    CMD_RUN =  doConnected(); 
*
0852:  MOVF   78,W
0853:  MOVWF  41
....................     
....................    resp = waitResp(); 
0854:  BCF    0A.3
0855:  CALL   716
0856:  BSF    0A.3
0857:  MOVF   78,W
0858:  BSF    03.5
0859:  MOVWF  58
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
085A:  MOVF   58,W
085B:  SUBLW  02
085C:  BTFSS  03.2
085D:  GOTO   0E4
....................  
....................       // Lanza el comando para conectarce a la red 
....................       CMD_RUN = setupConn(SSIDAndKey); 
085E:  CLRF   5A
085F:  MOVLW  4F
0860:  MOVWF  59
*
0893:  MOVF   78,W
0894:  BCF    03.5
0895:  MOVWF  41
....................       resp    = waitResp(); 
0896:  BCF    0A.3
0897:  CALL   716
0898:  BSF    0A.3
0899:  MOVF   78,W
089A:  BSF    03.5
089B:  MOVWF  58
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4){ 
089C:  MOVF   58,W
089D:  SUBLW  04
089E:  BTFSS  03.2
089F:  GOTO   0E4
....................          CMD_RUN =  setupMode(modeWithoutConnect); 
08A0:  CLRF   5A
08A1:  MOVLW  D6
08A2:  MOVWF  59
*
08DE:  MOVF   78,W
08DF:  MOVWF  41
....................          waitResp(); 
08E0:  BCF    0A.3
08E1:  CALL   716
08E2:  BSF    0A.3
08E3:  BSF    03.5
....................       } 
....................    } // Fin del if(doConnect) 
....................    
....................    /** @TODO: Rutina que se encarga de recibir datos desde ESP8266 **/ 
....................    setupServer(); 
....................    READY_RESP = 1; 
*
0912:  MOVLW  01
0913:  BCF    03.5
0914:  MOVWF  42
0915:  BCF    0A.3
0916:  BSF    0A.4
0917:  GOTO   50A (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
038A:  BCF    03.6
038B:  MOVF   41,W
038C:  XORLW  01
038D:  BTFSC  03.2
038E:  GOTO   396
038F:  XORLW  03
0390:  BTFSC  03.2
0391:  GOTO   39C
0392:  XORLW  01
0393:  BTFSC  03.2
0394:  GOTO   3D8
0395:  GOTO   414
....................             case CMD_MODE: 
....................                   waitRespOK(buffer); 
0396:  BSF    03.6
0397:  MOVF   1E,W
0398:  MOVWF  1F
0399:  BCF    03.6
039A:  CALL   361
....................                   break; 
039B:  GOTO   415
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespNoAp(buffer); 
039C:  BSF    03.6
039D:  MOVF   1E,W
039E:  MOVWF  1F
....................                   waitRespCWJAP(buffer); 
*
03B7:  BSF    03.6
03B8:  MOVF   1E,W
03B9:  MOVWF  1F
....................                   waitRespOK(buffer); 
*
03D2:  BSF    03.6
03D3:  MOVF   1E,W
03D4:  MOVWF  1F
03D5:  BCF    03.6
03D6:  CALL   361
....................                   break; 
03D7:  GOTO   415
....................  
....................             case CMD_CONN: 
....................                   waitRespConnected(buffer); 
03D8:  BSF    03.6
03D9:  MOVF   1E,W
03DA:  MOVWF  1F
....................                   waitRespFail(buffer); 
*
03F3:  BSF    03.6
03F4:  MOVF   1E,W
03F5:  MOVWF  1F
....................                   waitRespOK(buffer); 
*
040E:  BSF    03.6
040F:  MOVF   1E,W
0410:  MOVWF  1F
0411:  BCF    03.6
0412:  CALL   361
....................                   break; 
0413:  GOTO   415
....................              
....................             default: 
....................                   CMD_RUN = 0x00; 
0414:  CLRF   41
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /******************************************************** 
.................... Reinicia el modulo ESP8266 
.................... *********************************************************/ 
.................... void reset(void) 
.................... { 
....................    fprintf(ESP8266, "AT+RST\r\n"); 
.................... } // fin de la funcion reset() 
....................  
.................... /******************************************************** 
....................  *  Configura el modo de funcionamiento 
....................  *  1-Cliente, 2-AccessPoint, 3-AP+STA  
.................... *********************************************************/ 
.................... int setupMode(char modeVal[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWMODE=%s\r\n",modeVal ); 
*
0807:  MOVLW  98
0808:  BCF    03.5
0809:  BSF    03.6
080A:  MOVWF  0D
080B:  MOVLW  00
080C:  MOVWF  0F
080D:  BCF    03.0
080E:  MOVLW  0A
080F:  BSF    03.5
0810:  BCF    03.6
0811:  MOVWF  6B
0812:  BCF    0A.3
0813:  BCF    03.5
0814:  CALL   69A
0815:  BSF    0A.3
0816:  BSF    03.5
0817:  MOVF   59,W
0818:  MOVWF  04
0819:  BCF    03.7
081A:  BTFSC  5A.0
081B:  BSF    03.7
*
0837:  MOVLW  0D
0838:  BCF    03.5
0839:  BTFSS  0C.4
083A:  GOTO   039
083B:  MOVWF  19
083C:  MOVLW  0A
083D:  BTFSS  0C.4
083E:  GOTO   03D
083F:  MOVWF  19
*
08A3:  MOVLW  98
08A4:  BCF    03.5
08A5:  BSF    03.6
08A6:  MOVWF  0D
08A7:  MOVLW  00
08A8:  MOVWF  0F
08A9:  BCF    03.0
08AA:  MOVLW  0A
08AB:  BSF    03.5
08AC:  BCF    03.6
08AD:  MOVWF  6B
08AE:  BCF    0A.3
08AF:  BCF    03.5
08B0:  CALL   69A
08B1:  BSF    0A.3
08B2:  BSF    03.5
08B3:  MOVF   59,W
08B4:  MOVWF  04
08B5:  BCF    03.7
08B6:  BTFSC  5A.0
08B7:  BSF    03.7
*
08D3:  MOVLW  0D
08D4:  BCF    03.5
08D5:  BTFSS  0C.4
08D6:  GOTO   0D5
08D7:  MOVWF  19
08D8:  MOVLW  0A
08D9:  BTFSS  0C.4
08DA:  GOTO   0D9
08DB:  MOVWF  19
....................    return CMD_MODE; 
*
0840:  MOVLW  01
0841:  MOVWF  78
*
08DC:  MOVLW  01
08DD:  MOVWF  78
.................... } // fin de la funcion setupMode() 
....................  
.................... /******************************************************** 
....................  *  lanza el comando para verificar el estado de la 
....................  *  conexion a la red wifi  
.................... *********************************************************/ 
.................... int doConnected() 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
*
0847:  MOVLW  A0
0848:  BSF    03.6
0849:  MOVWF  0D
084A:  MOVLW  00
084B:  MOVWF  0F
084C:  BCF    0A.3
084D:  BCF    03.6
084E:  CALL   749
084F:  BSF    0A.3
....................    return CMD_DO_CONN; 
0850:  MOVLW  02
0851:  MOVWF  78
.................... } 
....................  
.................... /******************************************************** 
....................  *  Conecta a la red wifi 
....................  *  AT+CWJAP="UNE_C06E","00986344200771" 
.................... *********************************************************/ 
.................... int setupConn(char SSID_And_Key[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP=%s",SSID_And_Key ); 
*
0861:  MOVLW  A6
0862:  BCF    03.5
0863:  BSF    03.6
0864:  MOVWF  0D
0865:  MOVLW  00
0866:  MOVWF  0F
0867:  BCF    03.0
0868:  MOVLW  09
0869:  BSF    03.5
086A:  BCF    03.6
086B:  MOVWF  6B
086C:  BCF    0A.3
086D:  BCF    03.5
086E:  CALL   69A
086F:  BSF    0A.3
0870:  BSF    03.5
0871:  MOVF   59,W
0872:  MOVWF  04
0873:  BCF    03.7
0874:  BTFSC  5A.0
0875:  BSF    03.7
....................    return CMD_CONN; 
*
0891:  MOVLW  03
0892:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /******************************************************** 
....................  * Activa el modo multiconexion y modo servidor por el_ 
....................  * Puerto IP:80 
.................... *********************************************************/ 
.................... int setupServer(void) 
.................... { 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
*
08E4:  MOVLW  AC
08E5:  BCF    03.5
08E6:  BSF    03.6
08E7:  MOVWF  0D
08E8:  MOVLW  00
08E9:  MOVWF  0F
08EA:  BCF    0A.3
08EB:  BCF    03.6
08EC:  CALL   749
08ED:  BSF    0A.3
....................    delay_ms(1000); 
08EE:  MOVLW  04
08EF:  BSF    03.5
08F0:  MOVWF  59
08F1:  MOVLW  FA
08F2:  MOVWF  6B
08F3:  BCF    0A.3
08F4:  BCF    03.5
08F5:  CALL   4A1
08F6:  BSF    0A.3
08F7:  BSF    03.5
08F8:  DECFSZ 59,F
08F9:  GOTO   0F1
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
08FA:  MOVLW  B3
08FB:  BCF    03.5
08FC:  BSF    03.6
08FD:  MOVWF  0D
08FE:  MOVLW  00
08FF:  MOVWF  0F
0900:  BCF    0A.3
0901:  BCF    03.6
0902:  CALL   749
0903:  BSF    0A.3
....................    delay_ms(1000); 
0904:  MOVLW  04
0905:  BSF    03.5
0906:  MOVWF  59
0907:  MOVLW  FA
0908:  MOVWF  6B
0909:  BCF    0A.3
090A:  BCF    03.5
090B:  CALL   4A1
090C:  BSF    0A.3
090D:  BSF    03.5
090E:  DECFSZ 59,F
090F:  GOTO   107
....................    return CMD_CONN; 
0910:  MOVLW  03
0911:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
0716:  BSF    03.5
0717:  CLRF   59
.................... { 
....................    int ret=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(flag_Resp_Valid==0){ 
0718:  BCF    03.5
0719:  MOVF   43,F
071A:  BTFSS  03.2
071B:  GOTO   742
....................     
....................       if(flag_Resp_CWJAP==1){ 
071C:  DECFSZ 45,W
071D:  GOTO   725
....................       // Comando doConnected Conectado a la red 
....................          flag_Pos_Resp_CWJAP  = 0; 
071E:  CLRF   4A
....................          flag_Resp_CWJAP      = 0; 
071F:  CLRF   45
....................          ret = 1; 
0720:  MOVLW  01
0721:  BSF    03.5
0722:  MOVWF  59
....................  
....................       } else if(flag_Resp_NoAp==1){ 
0723:  GOTO   740
0724:  BCF    03.5
0725:  DECFSZ 44,W
0726:  GOTO   72E
....................       // Comando doConnected No se ha asignado una red 
....................          flag_Pos_Resp_NoAp  = 0; 
0727:  CLRF   49
....................          flag_Resp_NoAp      = 0; 
0728:  CLRF   44
....................          ret = 2; 
0729:  MOVLW  02
072A:  BSF    03.5
072B:  MOVWF  59
....................  
....................       } else if (flag_Resp_Connected==1){ 
072C:  GOTO   740
072D:  BCF    03.5
072E:  DECFSZ 46,W
072F:  GOTO   737
....................       // Comando setupConn Conexion establecida 
....................          flag_Pos_Resp_Connected = 0; 
0730:  CLRF   4B
....................          flag_Resp_Connected     = 0; 
0731:  CLRF   46
....................          ret = 3; 
0732:  MOVLW  03
0733:  BSF    03.5
0734:  MOVWF  59
....................  
....................       } else if(flag_Resp_Fail==1){ 
0735:  GOTO   740
0736:  BCF    03.5
0737:  DECFSZ 47,W
0738:  GOTO   741
....................       // Comando setupConn Fallo al intentar la Conexion 
....................       // Esta respuesta da como resultado un ERROR entonces 
....................       // Se rompe el ciclo de forma manual flag_Resp_Valid=1 
....................          flag_Pos_Resp_Fail   = 0; 
0739:  CLRF   4C
....................          flag_Resp_Fail       = 0; 
073A:  CLRF   47
....................          flag_Resp_Valid      = 1; 
073B:  MOVLW  01
073C:  MOVWF  43
....................          ret = 4; 
073D:  MOVLW  04
073E:  BSF    03.5
073F:  MOVWF  59
0740:  BCF    03.5
....................       } 
0741:  GOTO   719
....................    }; // Fin del loop 
....................    flag_Resp_Valid = 0; 
0742:  CLRF   43
....................    CMD_RUN = 0x00; 
0743:  CLRF   41
....................    return ret; 
0744:  BSF    03.5
0745:  MOVF   59,W
0746:  MOVWF  78
0747:  BCF    03.5
0748:  RETURN
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
....................  
.................... void waitRespOK(int buffer) 
*
0361:  MOVLW  04
0362:  BSF    03.6
0363:  MOVWF  20
.................... { 
....................    const char ESP8266_RESP_OK[4] ={'O','K',0x0D,0x0A}; 
....................    int lenResp = 4; 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_OK[flag_Pos_Resp]) 
0364:  BCF    03.6
0365:  MOVF   48,W
0366:  CALL   051
0367:  MOVWF  78
0368:  BSF    03.6
0369:  SUBWF  1F,W
036A:  BTFSS  03.2
036B:  GOTO   37A
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp++; 
036C:  BCF    03.6
036D:  INCF   48,F
....................        
....................       if(flag_Pos_Resp==lenResp){ 
036E:  BSF    03.6
036F:  MOVF   20,W
0370:  BCF    03.6
0371:  SUBWF  48,W
0372:  BTFSS  03.2
0373:  GOTO   377
....................          // Respuesta es valida 
....................          flag_Resp_Valid   = 1; 
0374:  MOVLW  01
0375:  MOVWF  43
....................       }else{ 
0376:  GOTO   378
....................          // Reinicia la bandera para asegurar la integridad de la respesta 
....................          flag_Resp_Valid   = 0; 
0377:  CLRF   43
....................       } 
....................  
....................    }else{ 
0378:  GOTO   37D
0379:  BSF    03.6
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       flag_Pos_Resp     = 0; 
037A:  BCF    03.6
037B:  CLRF   48
....................       // Como esta funcion es el ultimo caracter recibido no es necesario mantener  
....................       // Activa la bandera flag_Resp_Valid 
....................       flag_Resp_Valid   = 0; 
037C:  CLRF   43
....................    } 
037D:  RETURN
.................... } // Fin de la funcion waitRespOK() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_NoAp (Sin conexion) 
.................... *********************************************************/ 
.................... void waitRespNoAp(int buffer) 
*
039F:  MOVLW  05
03A0:  MOVWF  20
.................... { 
....................    const char ESP8266_RESP_NoAP[5] ={'N', 'o', ' ', 'A', 'P'}; 
....................    int lenResp = 5; 
....................     
....................    if(buffer == ESP8266_RESP_NoAp[flag_Pos_Resp_NoAp] ) 
03A1:  BCF    03.6
03A2:  MOVF   49,W
03A3:  CALL   059
03A4:  MOVWF  78
03A5:  BSF    03.6
03A6:  SUBWF  1F,W
03A7:  BTFSS  03.2
03A8:  GOTO   3B5
....................    { 
....................       flag_Pos_Resp_NoAp++; 
03A9:  BCF    03.6
03AA:  INCF   49,F
....................        
....................       if(flag_Pos_Resp_NoAp==lenResp){ 
03AB:  BSF    03.6
03AC:  MOVF   20,W
03AD:  BCF    03.6
03AE:  SUBWF  49,W
03AF:  BTFSS  03.2
03B0:  GOTO   3B3
....................          // Respuesta es valida 
....................          flag_Resp_NoAp   = 1; 
03B1:  MOVLW  01
03B2:  MOVWF  44
....................       } 
....................    }else{ 
03B3:  GOTO   3B7
03B4:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_NoAp  = 0; 
03B5:  BCF    03.6
03B6:  CLRF   49
....................    } 
.................... } // Fin de la funcion waitRespNoAp() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "doConnected" 
....................  *    ESP8266_RESP_CWJAP (Conectado) 
.................... *********************************************************/ 
.................... void waitRespCWJAP(int buffer) 
*
03BA:  MOVLW  07
03BB:  MOVWF  20
.................... { 
....................    const char ESP8266_RESP_CWJAP[7] ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
....................    int lenResp = 7; 
....................  
....................    if(buffer == ESP8266_RESP_CWJAP[flag_Pos_Resp_CWJAP] ) 
03BC:  BCF    03.6
03BD:  MOVF   4A,W
03BE:  CALL   062
03BF:  MOVWF  78
03C0:  BSF    03.6
03C1:  SUBWF  1F,W
03C2:  BTFSS  03.2
03C3:  GOTO   3D0
....................    { 
....................       flag_Pos_Resp_CWJAP++; 
03C4:  BCF    03.6
03C5:  INCF   4A,F
....................        
....................       if(flag_Pos_Resp_CWJAP==lenResp){ 
03C6:  BSF    03.6
03C7:  MOVF   20,W
03C8:  BCF    03.6
03C9:  SUBWF  4A,W
03CA:  BTFSS  03.2
03CB:  GOTO   3CE
....................          // Respuesta es valida 
....................          flag_Resp_CWJAP   = 1; 
03CC:  MOVLW  01
03CD:  MOVWF  45
....................       } 
....................    }else { 
03CE:  GOTO   3D2
03CF:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_CWJAP = 0; 
03D0:  BCF    03.6
03D1:  CLRF   4A
....................    } 
....................     
.................... } // Fin de la funcion waitRespCWJAP() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "setupConn" 
....................  *    ESP8266_RESP_Connected (Conectado) 
.................... *********************************************************/ 
.................... void waitRespConnected(int buffer) 
*
03DB:  MOVLW  09
03DC:  MOVWF  20
.................... { 
....................    const char ESP8266_RESP_Connected[9] ={'C','O','N','N','E','C','T','E','D'}; 
....................    int lenResp = 9; 
....................   
....................    if(buffer == ESP8266_RESP_Connected[flag_Pos_Resp_Connected] ) 
03DD:  BCF    03.6
03DE:  MOVF   4B,W
03DF:  CALL   06D
03E0:  MOVWF  78
03E1:  BSF    03.6
03E2:  SUBWF  1F,W
03E3:  BTFSS  03.2
03E4:  GOTO   3F1
....................    { 
....................       flag_Pos_Resp_Connected++; 
03E5:  BCF    03.6
03E6:  INCF   4B,F
....................        
....................       if(flag_Pos_Resp_Connected==lenResp){ 
03E7:  BSF    03.6
03E8:  MOVF   20,W
03E9:  BCF    03.6
03EA:  SUBWF  4B,W
03EB:  BTFSS  03.2
03EC:  GOTO   3EF
....................          // Respuesta es valida 
....................          flag_Resp_Connected   = 1; 
03ED:  MOVLW  01
03EE:  MOVWF  46
....................       } 
....................    }else{ 
03EF:  GOTO   3F3
03F0:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Connected = 0; 
03F1:  BCF    03.6
03F2:  CLRF   4B
....................    } 
.................... } // Fin de la funcion waitRespConnected() 
....................  
.................... /******************************************************** 
....................  *    Espera por la respuesta del comando "setupConn" 
....................  *    ESP8266_RESP_FAIL (Fallo al intentar conectarse) 
.................... *********************************************************/ 
.................... void waitRespFail(int buffer) 
*
03F6:  MOVLW  04
03F7:  MOVWF  20
.................... { 
....................    const char ESP8266_RESP_FAIL[4] ={'F', 'A', 'I', 'L'}; 
....................    int lenResp = 4; 
....................   
....................    if(buffer == ESP8266_RESP_FAIL[flag_Pos_Resp_Fail] ) 
03F8:  BCF    03.6
03F9:  MOVF   4C,W
03FA:  CALL   07A
03FB:  MOVWF  78
03FC:  BSF    03.6
03FD:  SUBWF  1F,W
03FE:  BTFSS  03.2
03FF:  GOTO   40C
....................    { 
....................       flag_Pos_Resp_Fail++; 
0400:  BCF    03.6
0401:  INCF   4C,F
....................        
....................       if(flag_Pos_Resp_Fail==lenResp){ 
0402:  BSF    03.6
0403:  MOVF   20,W
0404:  BCF    03.6
0405:  SUBWF  4C,W
0406:  BTFSS  03.2
0407:  GOTO   40A
....................          // Respuesta es valida 
....................          flag_Resp_Fail   = 1; 
0408:  MOVLW  01
0409:  MOVWF  47
....................       } 
....................    }else{ 
040A:  GOTO   40E
040B:  BSF    03.6
....................       // Reinicia el contador 
....................       flag_Pos_Resp_Fail  = 0; 
040C:  BCF    03.6
040D:  CLRF   4C
....................    } 
.................... } // Fin de la funcion waitRespFail() 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... /******************************************\ 
.................... *   Formato de comando en la respuesta:    * 
.................... *   INICIO:COMANDO:DATOS:<-(FIN)           * 
.................... *   e.g. CMD:CMD_SSID_AND_PASS,DATA:       * 
.................... \******************************************/ 
....................  
.................... /* 
.................... +-----------------------------------------------+  
.................... |      ****  CMD:OP,[op][port]:                 | 
.................... |-----------------------------------------------|      
.................... |> Realiaza Operaciones en el Puerto de Salida  | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,[1|0][0-7]:                       | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      op:    1   -> Encender                   | 
.................... |             0   -> Apagar                     | 
.................... |      port:  0-7 -> No. del puerto.            | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,10:  Enciende el PORT 0        |  
.................... +-----------------------------------------------| 
.................... */ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio recepcion de request,  
.................... y retorna el ID de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
041A:  MOVLW  05
041B:  MOVWF  20
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
041C:  DECFSZ 73,W
041D:  GOTO   430
....................        
....................       if(buffer!=','){ 
041E:  MOVF   1E,W
041F:  SUBLW  2C
0420:  BTFSS  03.2
0421:  GOTO   425
0422:  MOVF   1F,F
0423:  BTFSC  03.2
0424:  GOTO   42D
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
0425:  MOVLW  6C
0426:  ADDWF  7B,W
0427:  MOVWF  04
0428:  BCF    03.7
0429:  MOVF   1E,W
042A:  MOVWF  00
....................          flag_Pos_Resp_IPD++; 
042B:  INCF   7B,F
....................       }else{ 
042C:  GOTO   42F
....................          flag_Pos_Resp_IPD       = 0x00; 
042D:  CLRF   7B
....................          flag_Resp_IPD           = 0x00; 
042E:  CLRF   73
....................       } 
....................    }else{ 
042F:  GOTO   445
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
0430:  MOVF   7B,W
0431:  BCF    03.6
0432:  CALL   082
0433:  MOVWF  78
0434:  BSF    03.6
0435:  SUBWF  1E,W
0436:  BTFSS  03.2
0437:  GOTO   444
0438:  MOVF   1F,F
0439:  BTFSS  03.2
043A:  GOTO   444
....................       { 
....................          flag_Pos_Resp_IPD++; 
043B:  INCF   7B,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
043C:  MOVF   20,W
043D:  SUBWF  7B,W
043E:  BTFSS  03.2
043F:  GOTO   443
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
0440:  MOVLW  01
0441:  MOVWF  73
....................             flag_Pos_Resp_IPD = 0; 
0442:  CLRF   7B
....................          } 
....................       }else{ 
0443:  GOTO   445
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
0444:  CLRF   7B
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio comando,  
.................... y retorna el Comando enviado, Activa la bandera 
.................... de recepcion de datos 
.................... *********************************************************/ 
....................  
.................... void ESP8266_Get_CMD(char buffer[]){ 
*
0448:  MOVLW  04
0449:  MOVWF  20
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
044A:  DECFSZ 72,W
044B:  GOTO   460
....................     
....................       if(buffer!=','){ 
044C:  MOVF   1E,W
044D:  SUBLW  2C
044E:  BTFSS  03.2
044F:  GOTO   453
0450:  MOVF   1F,F
0451:  BTFSC  03.2
0452:  GOTO   45B
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
0453:  MOVLW  6E
0454:  ADDWF  76,W
0455:  MOVWF  04
0456:  BCF    03.7
0457:  MOVF   1E,W
0458:  MOVWF  00
....................          flag_Pos_Resp_CMD++; 
0459:  INCF   76,F
....................       }else{         
045A:  GOTO   45F
....................          flag_Pos_Resp_CMD = 0x00; 
045B:  CLRF   76
....................          flag_Resp_CMD     = 0x00; 
045C:  CLRF   72
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
045D:  MOVLW  01
045E:  MOVWF  74
....................       } 
....................        
....................    }else{ 
045F:  GOTO   475
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
0460:  MOVF   76,W
0461:  BCF    03.6
0462:  CALL   08B
0463:  MOVWF  78
0464:  BSF    03.6
0465:  SUBWF  1E,W
0466:  BTFSS  03.2
0467:  GOTO   474
0468:  MOVF   1F,F
0469:  BTFSS  03.2
046A:  GOTO   474
....................       { 
....................          flag_Pos_Resp_CMD++; 
046B:  INCF   76,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
046C:  MOVF   20,W
046D:  SUBWF  76,W
046E:  BTFSS  03.2
046F:  GOTO   473
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
0470:  MOVLW  01
0471:  MOVWF  72
....................             flag_Pos_Resp_CMD = 0; 
0472:  CLRF   76
....................          } 
....................       }else{ 
0473:  GOTO   475
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
0474:  CLRF   76
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion Verifica si la bandera de recepcion de datos esta 
.................... activa y almacena los datos entrantes en el arreglo 
.................... DATA_COMMAND, Finaliza la captura de caracteres cuando 
.................... encuentra el caracter ":". 
.................... Envia al ESP8266 el fin de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
*
0478:  DECFSZ 74,W
0479:  GOTO   49C
....................       if(buffer!=':'){ 
047A:  MOVF   1E,W
047B:  SUBLW  3A
047C:  BTFSS  03.2
047D:  GOTO   481
047E:  MOVF   1F,F
047F:  BTFSC  03.2
0480:  GOTO   498
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
0481:  MOVLW  A0
0482:  ADDWF  7C,W
0483:  MOVWF  04
0484:  BCF    03.7
0485:  MOVF   1E,W
0486:  MOVWF  00
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
0487:  CLRF   71
0488:  MOVF   7C,W
0489:  MOVWF  70
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
048A:  MOVF   7C,F
048B:  BTFSS  03.2
048C:  GOTO   496
048D:  MOVF   1E,W
048E:  SUBLW  2C
048F:  BTFSS  03.2
0490:  GOTO   496
0491:  MOVF   1F,F
0492:  BTFSS  03.2
0493:  GOTO   496
....................             flag_Pos_Resp_Data=0; 
0494:  CLRF   7C
....................          }else{ 
0495:  GOTO   497
....................             flag_Pos_Resp_Data++; 
0496:  INCF   7C,F
....................          } 
....................           
....................       }else{ 
0497:  GOTO   49C
....................          flag_Pos_Resp_Data      = 0x00; 
0498:  CLRF   7C
....................          flag_Resp_StartGetData  = 0x00; 
0499:  CLRF   74
....................          flag_Resp_Ready         = 1; 
049A:  MOVLW  01
049B:  MOVWF  75
049C:  BCF    03.6
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
.................... } 
....................  
.................... int run_command_wifi(void){ 
*
0A18:  BSF    03.5
0A19:  CLRF   5B
0A1A:  CLRF   5C
....................    int8 ret = 0, optSelected = 0; 
....................    char ESP8266_Resp[13] = {'{','"','c','m','d','"',':','"','o','k','"','}'}; 
0A1B:  MOVLW  7B
0A1C:  MOVWF  5D
0A1D:  MOVLW  22
0A1E:  MOVWF  5E
0A1F:  MOVLW  63
0A20:  MOVWF  5F
0A21:  MOVLW  6D
0A22:  MOVWF  60
0A23:  MOVLW  64
0A24:  MOVWF  61
0A25:  MOVLW  22
0A26:  MOVWF  62
0A27:  MOVLW  3A
0A28:  MOVWF  63
0A29:  MOVLW  22
0A2A:  MOVWF  64
0A2B:  MOVLW  6F
0A2C:  MOVWF  65
0A2D:  MOVLW  6B
0A2E:  MOVWF  66
0A2F:  MOVLW  22
0A30:  MOVWF  67
0A31:  MOVLW  7D
0A32:  MOVWF  68
0A33:  CLRF   69
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
0A34:  DECFSZ 75,W
0A35:  GOTO   327
....................        
....................       // Accede a las Salidas  
....................       /** CMD:OP,[0|1][0-7]: **/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
0A36:  BCF    03.5
0A37:  MOVF   6E,W
0A38:  SUBLW  4F
0A39:  BTFSS  03.2
0A3A:  GOTO   290
0A3B:  MOVF   6F,W
0A3C:  SUBLW  50
0A3D:  BTFSS  03.2
0A3E:  GOTO   290
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
0A3F:  MOVLW  30
0A40:  BSF    03.5
0A41:  SUBWF  21,W
0A42:  MOVWF  5C
....................           
....................          switch(DATA_COMMAND[0]){ 
0A43:  MOVF   20,W
0A44:  XORLW  30
0A45:  BCF    03.5
0A46:  BTFSC  03.2
0A47:  GOTO   24C
0A48:  XORLW  01
0A49:  BTFSC  03.2
0A4A:  GOTO   26C
0A4B:  GOTO   28C
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
0A4C:  BCF    03.0
0A4D:  BSF    03.5
0A4E:  RLF    5C,W
0A4F:  ADDLW  2B
0A50:  MOVWF  04
0A51:  BCF    03.7
0A52:  INCF   04,F
0A53:  MOVF   00,W
0A54:  MOVWF  6C
0A55:  DECF   04,F
0A56:  MOVF   00,W
0A57:  MOVWF  6B
0A58:  MOVWF  6D
0A59:  CLRF   6E
0A5A:  BCF    03.5
0A5B:  BSF    03.6
0A5C:  CLRF   11
0A5D:  CLRF   10
0A5E:  BCF    03.6
0A5F:  CALL   1F2
0A60:  BSF    03.5
0A61:  MOVF   6B,W
0A62:  MOVWF  6D
0A63:  CLRF   6E
0A64:  BCF    03.5
0A65:  BSF    03.6
0A66:  CLRF   11
0A67:  MOVLW  80
0A68:  MOVWF  10
0A69:  BCF    03.6
0A6A:  CALL   1F2
....................                break; 
0A6B:  GOTO   28C
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
0A6C:  BCF    03.0
0A6D:  BSF    03.5
0A6E:  RLF    5C,W
0A6F:  ADDLW  2B
0A70:  MOVWF  04
0A71:  BCF    03.7
0A72:  INCF   04,F
0A73:  MOVF   00,W
0A74:  MOVWF  6C
0A75:  DECF   04,F
0A76:  MOVF   00,W
0A77:  MOVWF  6B
0A78:  MOVWF  6D
0A79:  MOVLW  01
0A7A:  MOVWF  6E
0A7B:  BCF    03.5
0A7C:  BSF    03.6
0A7D:  CLRF   11
0A7E:  CLRF   10
0A7F:  BCF    03.6
0A80:  CALL   1F2
0A81:  BSF    03.5
0A82:  MOVF   6B,W
0A83:  MOVWF  6D
0A84:  CLRF   6E
0A85:  BCF    03.5
0A86:  BSF    03.6
0A87:  CLRF   11
0A88:  MOVLW  80
0A89:  MOVWF  10
0A8A:  BCF    03.6
0A8B:  CALL   1F2
....................                break; 
....................          } 
....................           
....................          ret = 1; 
0A8C:  MOVLW  01
0A8D:  BSF    03.5
0A8E:  MOVWF  5B
0A8F:  BCF    03.5
....................       } // Fin comando OP 
....................        
....................       // Reinicia el buffer 
....................       flag_Resp_Ready  = 0x00; 
0A90:  CLRF   75
....................       LEN_DATA_COMMAND = 0x00; 
0A91:  CLRF   71
0A92:  CLRF   70
....................        
....................       // Responde la solicitud 
....................       delay_ms(20); 
0A93:  MOVLW  14
0A94:  BSF    03.5
0A95:  MOVWF  6B
0A96:  BCF    0A.3
0A97:  BCF    03.5
0A98:  CALL   4A1
0A99:  BSF    0A.3
....................       fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0A9A:  MOVLW  BD
0A9B:  BSF    03.6
0A9C:  MOVWF  0D
0A9D:  MOVLW  00
0A9E:  MOVWF  0F
0A9F:  BCF    03.0
0AA0:  MOVLW  0B
0AA1:  BSF    03.5
0AA2:  BCF    03.6
0AA3:  MOVWF  6B
0AA4:  BCF    0A.3
0AA5:  BCF    03.5
0AA6:  CALL   69A
0AA7:  BSF    0A.3
0AA8:  MOVF   6C,W
0AA9:  BTFSS  0C.4
0AAA:  GOTO   2A9
0AAB:  MOVWF  19
0AAC:  MOVLW  C3
0AAD:  BSF    03.6
0AAE:  MOVWF  0D
0AAF:  MOVLW  00
0AB0:  MOVWF  0F
0AB1:  BSF    03.0
0AB2:  MOVLW  05
0AB3:  BSF    03.5
0AB4:  BCF    03.6
0AB5:  MOVWF  6B
0AB6:  BCF    0A.3
0AB7:  BCF    03.5
0AB8:  CALL   69A
0AB9:  BSF    0A.3
....................       delay_ms(50); 
0ABA:  MOVLW  32
0ABB:  BSF    03.5
0ABC:  MOVWF  6B
0ABD:  BCF    0A.3
0ABE:  BCF    03.5
0ABF:  CALL   4A1
0AC0:  BSF    0A.3
....................       fprintf(ESP8266, "%s\r\n",ESP8266_Resp); 
0AC1:  MOVLW  DD
0AC2:  MOVWF  04
0AC3:  BCF    03.7
*
0AE1:  MOVLW  0D
0AE2:  BTFSS  0C.4
0AE3:  GOTO   2E2
0AE4:  MOVWF  19
0AE5:  MOVLW  0A
0AE6:  BTFSS  0C.4
0AE7:  GOTO   2E6
0AE8:  MOVWF  19
....................       delay_ms(100); 
0AE9:  MOVLW  64
0AEA:  BSF    03.5
0AEB:  MOVWF  6B
0AEC:  BCF    0A.3
0AED:  BCF    03.5
0AEE:  CALL   4A1
0AEF:  BSF    0A.3
....................       fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0AF0:  MOVLW  C7
0AF1:  BSF    03.6
0AF2:  MOVWF  0D
0AF3:  MOVLW  00
0AF4:  MOVWF  0F
0AF5:  BCF    03.0
0AF6:  MOVLW  0C
0AF7:  BSF    03.5
0AF8:  BCF    03.6
0AF9:  MOVWF  6B
0AFA:  BCF    0A.3
0AFB:  BCF    03.5
0AFC:  CALL   69A
0AFD:  BSF    0A.3
0AFE:  MOVF   6C,W
0AFF:  BTFSS  0C.4
0B00:  GOTO   2FF
0B01:  MOVWF  19
0B02:  MOVLW  0D
0B03:  BTFSS  0C.4
0B04:  GOTO   303
0B05:  MOVWF  19
0B06:  MOVLW  0A
0B07:  BTFSS  0C.4
0B08:  GOTO   307
0B09:  MOVWF  19
....................        
....................       // Limpia el buffer 
....................       for(int idx=0;idx<=LEN_DATA_COMMAND;idx++){ 
0B0A:  BSF    03.5
0B0B:  CLRF   6A
0B0C:  MOVF   71,F
0B0D:  BTFSS  03.2
0B0E:  GOTO   313
0B0F:  MOVF   6A,W
0B10:  SUBWF  70,W
0B11:  BTFSS  03.0
0B12:  GOTO   31C
....................          DATA_COMMAND[idx] ==0x00; 
0B13:  MOVLW  A0
0B14:  ADDWF  6A,W
0B15:  MOVWF  04
0B16:  BCF    03.7
0B17:  MOVF   00,F
0B18:  BTFSS  03.2
0B19:  MOVLW  00
0B1A:  INCF   6A,F
0B1B:  GOTO   30C
....................       } 
....................       COMMAND[0]        ==0x00; 
0B1C:  BCF    03.5
0B1D:  MOVF   6E,F
0B1E:  BTFSS  03.2
0B1F:  MOVLW  00
....................       COMMAND[1]        ==0x00; 
0B20:  MOVF   6F,F
0B21:  BTFSS  03.2
0B22:  MOVLW  00
....................       ID_CONNETION[0]   ==0x00; 
0B23:  MOVF   6C,F
0B24:  BTFSS  03.2
0B25:  MOVLW  00
0B26:  BSF    03.5
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return ret; 
0B27:  MOVF   5B,W
0B28:  MOVWF  78
0B29:  BCF    03.5
0B2A:  RETURN
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_IP     0 
....................   #define OPT_SHOW_SSID   1 
....................   #define OPT_SHOW_KEY    2 
....................   #define OPT_MODE_AP     3 
....................   #define OPT_BACKLIGH    4 
....................   #define OPT_EXIT        5 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[7][17]    =  { {"VER IP          "}, 
....................                                         {"VER SSID        "}, 
....................                                         {"VER KEY         "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacion     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 5; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
0C9A:  BSF    03.5
0C9B:  CLRF   56
0C9C:  CLRF   57
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0C9D:  SWAPF  56,W
0C9E:  MOVWF  77
0C9F:  MOVLW  F0
0CA0:  ANDWF  77,F
0CA1:  MOVF   77,W
0CA2:  MOVWF  58
0CA3:  MOVLW  0C
0CA4:  MOVWF  5E
0CA5:  BCF    03.5
0CA6:  CALL   118
0CA7:  MOVLW  D0
0CA8:  BSF    03.6
0CA9:  MOVWF  0D
0CAA:  MOVLW  00
0CAB:  MOVWF  0F
0CAC:  BSF    03.5
0CAD:  BCF    03.6
0CAE:  MOVF   58,W
0CAF:  BCF    03.5
0CB0:  BSF    03.6
0CB1:  ADDWF  0D,F
0CB2:  BTFSC  03.0
0CB3:  INCF   0F,F
0CB4:  BCF    0A.3
0CB5:  BCF    03.6
0CB6:  CALL   7BF
0CB7:  BSF    0A.3
....................    showBottonMenu(); 
....................    while(!exit){ 
*
0CD8:  BSF    03.5
0CD9:  MOVF   57,F
0CDA:  BTFSS  03.2
0CDB:  GOTO   559
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
0CDC:  BCF    03.5
0CDD:  CALL   218
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0CDE:  BSF    03.5
0CDF:  BSF    06.4
0CE0:  BCF    03.5
0CE1:  BTFSC  06.4
0CE2:  GOTO   539
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0CE3:  MOVLW  02
0CE4:  BSF    03.5
0CE5:  MOVWF  58
0CE6:  MOVLW  FA
0CE7:  MOVWF  6B
0CE8:  BCF    0A.3
0CE9:  BCF    03.5
0CEA:  CALL   4A1
0CEB:  BSF    0A.3
0CEC:  BSF    03.5
0CED:  DECFSZ 58,F
0CEE:  GOTO   4E6
....................          BEEP; 
0CEF:  MOVLW  04
0CF0:  MOVWF  5C
0CF1:  MOVLW  B9
0CF2:  MOVWF  5B
0CF3:  CLRF   5E
0CF4:  MOVLW  14
0CF5:  MOVWF  5D
0CF6:  BCF    03.5
0CF7:  CALL   32B
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0CF8:  BSF    03.5
0CF9:  INCF   56,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
0CFA:  MOVF   56,W
0CFB:  SUBWF  7D,W
0CFC:  BTFSS  03.0
....................             optSelected = 0; 
0CFD:  CLRF   56
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0CFE:  SWAPF  56,W
0CFF:  MOVWF  77
0D00:  MOVLW  F0
0D01:  ANDWF  77,F
0D02:  MOVF   77,W
0D03:  MOVWF  58
0D04:  MOVLW  0C
0D05:  MOVWF  5E
0D06:  BCF    03.5
0D07:  CALL   118
0D08:  MOVLW  D0
0D09:  BSF    03.6
0D0A:  MOVWF  0D
0D0B:  MOVLW  00
0D0C:  MOVWF  0F
0D0D:  BSF    03.5
0D0E:  BCF    03.6
0D0F:  MOVF   58,W
0D10:  BCF    03.5
0D11:  BSF    03.6
0D12:  ADDWF  0D,F
0D13:  BTFSC  03.0
0D14:  INCF   0F,F
0D15:  BCF    0A.3
0D16:  BCF    03.6
0D17:  CALL   7BF
0D18:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0D39:  BSF    03.5
0D3A:  BSF    06.5
0D3B:  BCF    03.5
0D3C:  BTFSC  06.5
0D3D:  GOTO   557
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0D3E:  MOVLW  02
0D3F:  BSF    03.5
0D40:  MOVWF  58
0D41:  MOVLW  FA
0D42:  MOVWF  6B
0D43:  BCF    0A.3
0D44:  BCF    03.5
0D45:  CALL   4A1
0D46:  BSF    0A.3
0D47:  BSF    03.5
0D48:  DECFSZ 58,F
0D49:  GOTO   541
....................          BEEP; 
0D4A:  MOVLW  04
0D4B:  MOVWF  5C
0D4C:  MOVLW  B9
0D4D:  MOVWF  5B
0D4E:  CLRF   5E
0D4F:  MOVLW  14
0D50:  MOVWF  5D
0D51:  BCF    03.5
0D52:  CALL   32B
....................          // Rompe el Loop 
....................          exit = 1; 
0D53:  MOVLW  01
0D54:  BSF    03.5
0D55:  MOVWF  57
0D56:  BCF    03.5
....................       } // Fin KEY_OK 
0D57:  GOTO   4D8
0D58:  BSF    03.5
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
0D59:  MOVLW  01
0D5A:  ADDWF  56,W
0D5B:  MOVWF  78
0D5C:  BCF    03.5
0D5D:  BCF    0A.3
0D5E:  BSF    0A.4
0D5F:  GOTO   517 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
1013:  MOVLW  0C
1014:  BSF    03.5
1015:  MOVWF  5F
1016:  MOVLW  02
1017:  MOVWF  60
*
105D:  MOVLW  0C
105E:  BSF    03.5
105F:  MOVWF  5F
1060:  MOVLW  02
1061:  MOVWF  60
*
10A7:  MOVLW  0C
10A8:  BSF    03.5
10A9:  MOVWF  5F
10AA:  MOVLW  02
10AB:  MOVWF  60
*
121B:  MOVLW  0C
121C:  BSF    03.5
121D:  MOVWF  5F
121E:  MOVLW  02
121F:  MOVWF  60
*
12C4:  MOVLW  0C
12C5:  BSF    03.5
12C6:  MOVWF  5F
12C7:  MOVLW  02
12C8:  MOVWF  60
....................   printf(lcd_putc, "SALIR"); 
*
102C:  MOVLW  03
102D:  BSF    03.6
102E:  MOVWF  0D
102F:  MOVLW  03
1030:  MOVWF  0F
1031:  BCF    0A.4
1032:  BSF    0A.3
1033:  BCF    03.6
1034:  CALL   17E
1035:  BSF    0A.4
1036:  BCF    0A.3
*
1076:  MOVLW  03
1077:  BSF    03.6
1078:  MOVWF  0D
1079:  MOVLW  03
107A:  MOVWF  0F
107B:  BCF    0A.4
107C:  BSF    0A.3
107D:  BCF    03.6
107E:  CALL   17E
107F:  BSF    0A.4
1080:  BCF    0A.3
*
10C0:  MOVLW  03
10C1:  BSF    03.6
10C2:  MOVWF  0D
10C3:  MOVLW  03
10C4:  MOVWF  0F
10C5:  BCF    0A.4
10C6:  BSF    0A.3
10C7:  BCF    03.6
10C8:  CALL   17E
10C9:  BSF    0A.4
10CA:  BCF    0A.3
*
1234:  MOVLW  03
1235:  BSF    03.6
1236:  MOVWF  0D
1237:  MOVLW  03
1238:  MOVWF  0F
1239:  BCF    0A.4
123A:  BSF    0A.3
123B:  BCF    03.6
123C:  CALL   17E
123D:  BSF    0A.4
123E:  BCF    0A.3
*
12DD:  MOVLW  03
12DE:  BSF    03.6
12DF:  MOVWF  0D
12E0:  MOVLW  03
12E1:  MOVWF  0F
12E2:  BCF    0A.4
12E3:  BSF    0A.3
12E4:  BCF    03.6
12E5:  CALL   17E
12E6:  BSF    0A.4
12E7:  BCF    0A.3
....................    
....................   while(1){ 
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
*
1037:  BCF    0A.4
1038:  BSF    0A.3
1039:  CALL   218
103A:  BSF    0A.4
103B:  BCF    0A.3
*
1081:  BCF    0A.4
1082:  BSF    0A.3
1083:  CALL   218
1084:  BSF    0A.4
1085:  BCF    0A.3
*
10CB:  BCF    0A.4
10CC:  BSF    0A.3
10CD:  CALL   218
10CE:  BSF    0A.4
10CF:  BCF    0A.3
*
123F:  BCF    0A.4
1240:  BSF    0A.3
1241:  CALL   218
1242:  BSF    0A.4
1243:  BCF    0A.3
*
12E8:  BCF    0A.4
12E9:  BSF    0A.3
12EA:  CALL   218
12EB:  BSF    0A.4
12EC:  BCF    0A.3
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
*
103C:  BSF    03.5
103D:  BSF    06.5
103E:  BCF    03.5
103F:  BTFSC  06.5
1040:  GOTO   04F
*
1086:  BSF    03.5
1087:  BSF    06.5
1088:  BCF    03.5
1089:  BTFSC  06.5
108A:  GOTO   099
*
10D0:  BSF    03.5
10D1:  BSF    06.5
10D2:  BCF    03.5
10D3:  BTFSC  06.5
10D4:  GOTO   0E3
*
1244:  BSF    03.5
1245:  BSF    06.5
1246:  BCF    03.5
1247:  BTFSC  06.5
1248:  GOTO   257
*
12ED:  BSF    03.5
12EE:  BSF    06.5
12EF:  BCF    03.5
12F0:  BTFSC  06.5
12F1:  GOTO   300
....................            // Elimina el rebote 
....................            delay_ms(500); 
*
1041:  MOVLW  02
1042:  BSF    03.5
1043:  MOVWF  5B
1044:  MOVLW  FA
1045:  MOVWF  6B
1046:  BCF    0A.4
1047:  BCF    03.5
1048:  CALL   4A1
1049:  BSF    0A.4
104A:  BSF    03.5
104B:  DECFSZ 5B,F
104C:  GOTO   044
*
108B:  MOVLW  02
108C:  BSF    03.5
108D:  MOVWF  5B
108E:  MOVLW  FA
108F:  MOVWF  6B
1090:  BCF    0A.4
1091:  BCF    03.5
1092:  CALL   4A1
1093:  BSF    0A.4
1094:  BSF    03.5
1095:  DECFSZ 5B,F
1096:  GOTO   08E
*
10D5:  MOVLW  02
10D6:  BSF    03.5
10D7:  MOVWF  5B
10D8:  MOVLW  FA
10D9:  MOVWF  6B
10DA:  BCF    0A.4
10DB:  BCF    03.5
10DC:  CALL   4A1
10DD:  BSF    0A.4
10DE:  BSF    03.5
10DF:  DECFSZ 5B,F
10E0:  GOTO   0D8
*
1249:  MOVLW  02
124A:  BSF    03.5
124B:  MOVWF  5B
124C:  MOVLW  FA
124D:  MOVWF  6B
124E:  BCF    0A.4
124F:  BCF    03.5
1250:  CALL   4A1
1251:  BSF    0A.4
1252:  BSF    03.5
1253:  DECFSZ 5B,F
1254:  GOTO   24C
*
12F2:  MOVLW  02
12F3:  BSF    03.5
12F4:  MOVWF  5B
12F5:  MOVLW  FA
12F6:  MOVWF  6B
12F7:  BCF    0A.4
12F8:  BCF    03.5
12F9:  CALL   4A1
12FA:  BSF    0A.4
12FB:  BSF    03.5
12FC:  DECFSZ 5B,F
12FD:  GOTO   2F5
....................            break; 
*
104D:  GOTO   051
104E:  BCF    03.5
*
1097:  GOTO   09B
1098:  BCF    03.5
*
10E1:  GOTO   0E5
10E2:  BCF    03.5
*
1255:  GOTO   259
1256:  BCF    03.5
*
12FE:  GOTO   302
12FF:  BCF    03.5
....................      } 
*
104F:  GOTO   037
1050:  BSF    03.5
*
1099:  GOTO   081
109A:  BSF    03.5
*
10E3:  GOTO   0CB
10E4:  BSF    03.5
*
1257:  GOTO   23F
1258:  BSF    03.5
*
1300:  GOTO   2E8
1301:  BSF    03.5
....................   } 
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
0CB8:  MOVLW  01
0CB9:  BSF    03.5
0CBA:  MOVWF  5F
0CBB:  MOVLW  02
0CBC:  MOVWF  60
*
0D19:  MOVLW  01
0D1A:  BSF    03.5
0D1B:  MOVWF  5F
0D1C:  MOVLW  02
0D1D:  MOVWF  60
*
0DA8:  MOVLW  01
0DA9:  BSF    03.5
0DAA:  MOVWF  5F
0DAB:  MOVLW  02
0DAC:  MOVWF  60
*
0E0C:  MOVLW  01
0E0D:  BSF    03.5
0E0E:  MOVWF  5F
0E0F:  MOVLW  02
0E10:  MOVWF  60
*
0E93:  MOVLW  01
0E94:  BSF    03.5
0E95:  MOVWF  5F
0E96:  MOVLW  02
0E97:  MOVWF  60
*
0EF4:  MOVLW  01
0EF5:  BSF    03.5
0EF6:  MOVWF  5F
0EF7:  MOVLW  02
0EF8:  MOVWF  60
*
110F:  MOVLW  01
1110:  BSF    03.5
1111:  MOVWF  5F
1112:  MOVLW  02
1113:  MOVWF  60
*
1187:  MOVLW  01
1188:  BSF    03.5
1189:  MOVWF  5F
118A:  MOVLW  02
118B:  MOVWF  60
*
127F:  MOVLW  01
1280:  BSF    03.5
1281:  MOVWF  5F
1282:  MOVLW  02
1283:  MOVWF  60
*
1342:  MOVLW  01
1343:  BSF    03.5
1344:  MOVWF  5F
1345:  MOVLW  02
1346:  MOVWF  60
*
13B3:  MOVLW  01
13B4:  BSF    03.5
13B5:  MOVWF  5F
13B6:  MOVLW  02
13B7:  MOVWF  60
*
1428:  MOVLW  01
1429:  BSF    03.5
142A:  MOVWF  5F
142B:  MOVLW  02
142C:  MOVWF  60
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
*
0CD1:  MOVLW  06
0CD2:  BSF    03.6
0CD3:  MOVWF  0D
0CD4:  MOVLW  03
0CD5:  MOVWF  0F
0CD6:  BCF    03.6
0CD7:  CALL   17E
*
0D32:  MOVLW  06
0D33:  BSF    03.6
0D34:  MOVWF  0D
0D35:  MOVLW  03
0D36:  MOVWF  0F
0D37:  BCF    03.6
0D38:  CALL   17E
*
0DC1:  MOVLW  06
0DC2:  BSF    03.6
0DC3:  MOVWF  0D
0DC4:  MOVLW  03
0DC5:  MOVWF  0F
0DC6:  BCF    03.6
0DC7:  CALL   17E
*
0E25:  MOVLW  06
0E26:  BSF    03.6
0E27:  MOVWF  0D
0E28:  MOVLW  03
0E29:  MOVWF  0F
0E2A:  BCF    03.6
0E2B:  CALL   17E
*
0EAC:  MOVLW  06
0EAD:  BSF    03.6
0EAE:  MOVWF  0D
0EAF:  MOVLW  03
0EB0:  MOVWF  0F
0EB1:  BCF    03.6
0EB2:  CALL   17E
*
0F0D:  MOVLW  06
0F0E:  BSF    03.6
0F0F:  MOVWF  0D
0F10:  MOVLW  03
0F11:  MOVWF  0F
0F12:  BCF    03.6
0F13:  CALL   17E
*
1128:  MOVLW  06
1129:  BSF    03.6
112A:  MOVWF  0D
112B:  MOVLW  03
112C:  MOVWF  0F
112D:  BCF    0A.4
112E:  BSF    0A.3
112F:  BCF    03.6
1130:  CALL   17E
1131:  BSF    0A.4
1132:  BCF    0A.3
*
11A0:  MOVLW  06
11A1:  BSF    03.6
11A2:  MOVWF  0D
11A3:  MOVLW  03
11A4:  MOVWF  0F
11A5:  BCF    0A.4
11A6:  BSF    0A.3
11A7:  BCF    03.6
11A8:  CALL   17E
11A9:  BSF    0A.4
11AA:  BCF    0A.3
*
1298:  MOVLW  06
1299:  BSF    03.6
129A:  MOVWF  0D
129B:  MOVLW  03
129C:  MOVWF  0F
129D:  BCF    0A.4
129E:  BSF    0A.3
129F:  BCF    03.6
12A0:  CALL   17E
12A1:  BSF    0A.4
12A2:  BCF    0A.3
12A3:  BSF    03.5
*
135B:  MOVLW  06
135C:  BSF    03.6
135D:  MOVWF  0D
135E:  MOVLW  03
135F:  MOVWF  0F
1360:  BCF    0A.4
1361:  BSF    0A.3
1362:  BCF    03.6
1363:  CALL   17E
1364:  BSF    0A.4
1365:  BCF    0A.3
*
13CC:  MOVLW  06
13CD:  BSF    03.6
13CE:  MOVWF  0D
13CF:  MOVLW  03
13D0:  MOVWF  0F
13D1:  BCF    0A.4
13D2:  BSF    0A.3
13D3:  BCF    03.6
13D4:  CALL   17E
13D5:  BSF    0A.4
13D6:  BCF    0A.3
*
1441:  MOVLW  06
1442:  BSF    03.6
1443:  MOVWF  0D
1444:  MOVLW  03
1445:  MOVWF  0F
1446:  BCF    0A.4
1447:  BSF    0A.3
1448:  BCF    03.6
1449:  CALL   17E
144A:  BSF    0A.4
144B:  BCF    0A.3
144C:  BSF    03.5
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
0D87:  BSF    03.5
0D88:  CLRF   56
0D89:  CLRF   57
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0D8A:  MOVF   56,W
0D8B:  MOVWF  5B
0D8C:  MOVLW  0F
0D8D:  MOVWF  5C
0D8E:  BCF    03.5
0D8F:  CALL   560
0D90:  MOVF   78,W
0D91:  BSF    03.5
0D92:  MOVWF  58
0D93:  MOVLW  0C
0D94:  MOVWF  5E
0D95:  BCF    03.5
0D96:  CALL   118
0D97:  MOVLW  10
0D98:  BSF    03.6
0D99:  MOVWF  0D
0D9A:  MOVLW  01
0D9B:  MOVWF  0F
0D9C:  BSF    03.5
0D9D:  BCF    03.6
0D9E:  MOVF   58,W
0D9F:  BCF    03.5
0DA0:  BSF    03.6
0DA1:  ADDWF  0D,F
0DA2:  BTFSC  03.0
0DA3:  INCF   0F,F
0DA4:  BCF    0A.3
0DA5:  BCF    03.6
0DA6:  CALL   7BF
0DA7:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0DC8:  BSF    03.5
0DC9:  MOVF   57,F
0DCA:  BTFSS  03.2
0DCB:  GOTO   66F
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
0DCC:  BCF    03.5
0DCD:  CALL   218
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0DCE:  BSF    03.5
0DCF:  BSF    06.4
0DD0:  BCF    03.5
0DD1:  BTFSC  06.4
0DD2:  GOTO   62C
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0DD3:  MOVLW  02
0DD4:  BSF    03.5
0DD5:  MOVWF  58
0DD6:  MOVLW  FA
0DD7:  MOVWF  6B
0DD8:  BCF    0A.3
0DD9:  BCF    03.5
0DDA:  CALL   4A1
0DDB:  BSF    0A.3
0DDC:  BSF    03.5
0DDD:  DECFSZ 58,F
0DDE:  GOTO   5D6
....................          BEEP; 
0DDF:  MOVLW  04
0DE0:  MOVWF  5C
0DE1:  MOVLW  B9
0DE2:  MOVWF  5B
0DE3:  CLRF   5E
0DE4:  MOVLW  14
0DE5:  MOVWF  5D
0DE6:  BCF    03.5
0DE7:  CALL   32B
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0DE8:  BSF    03.5
0DE9:  INCF   56,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
0DEA:  MOVF   56,W
0DEB:  SUBWF  7E,W
0DEC:  BTFSS  03.0
....................             optSelected = 0; 
0DED:  CLRF   56
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0DEE:  MOVF   56,W
0DEF:  MOVWF  5B
0DF0:  MOVLW  0F
0DF1:  MOVWF  5C
0DF2:  BCF    03.5
0DF3:  CALL   560
0DF4:  MOVF   78,W
0DF5:  BSF    03.5
0DF6:  MOVWF  58
0DF7:  MOVLW  0C
0DF8:  MOVWF  5E
0DF9:  BCF    03.5
0DFA:  CALL   118
0DFB:  MOVLW  10
0DFC:  BSF    03.6
0DFD:  MOVWF  0D
0DFE:  MOVLW  01
0DFF:  MOVWF  0F
0E00:  BSF    03.5
0E01:  BCF    03.6
0E02:  MOVF   58,W
0E03:  BCF    03.5
0E04:  BSF    03.6
0E05:  ADDWF  0D,F
0E06:  BTFSC  03.0
0E07:  INCF   0F,F
0E08:  BCF    0A.3
0E09:  BCF    03.6
0E0A:  CALL   7BF
0E0B:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0E2C:  BSF    03.5
0E2D:  BSF    06.5
0E2E:  BCF    03.5
0E2F:  BTFSC  06.5
0E30:  GOTO   66D
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0E31:  MOVLW  02
0E32:  BSF    03.5
0E33:  MOVWF  58
0E34:  MOVLW  FA
0E35:  MOVWF  6B
0E36:  BCF    0A.3
0E37:  BCF    03.5
0E38:  CALL   4A1
0E39:  BSF    0A.3
0E3A:  BSF    03.5
0E3B:  DECFSZ 58,F
0E3C:  GOTO   634
....................          BEEP; 
0E3D:  MOVLW  04
0E3E:  MOVWF  5C
0E3F:  MOVLW  B9
0E40:  MOVWF  5B
0E41:  CLRF   5E
0E42:  MOVLW  14
0E43:  MOVWF  5D
0E44:  BCF    03.5
0E45:  CALL   32B
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
0E46:  MOVF   7E,W
0E47:  BSF    03.5
0E48:  SUBWF  56,W
0E49:  BTFSS  03.2
0E4A:  GOTO   64E
....................             exit = 1; 
0E4B:  MOVLW  01
0E4C:  MOVWF  57
....................          }else{ 
0E4D:  GOTO   66E
....................             output_high(PIN_OUT[optSelected]); 
0E4E:  BCF    03.0
0E4F:  RLF    56,W
0E50:  ADDLW  2B
0E51:  MOVWF  04
0E52:  BCF    03.7
0E53:  INCF   04,F
0E54:  MOVF   00,W
0E55:  MOVWF  59
0E56:  DECF   04,F
0E57:  MOVF   00,W
0E58:  MOVWF  58
0E59:  MOVWF  6D
0E5A:  MOVLW  01
0E5B:  MOVWF  6E
0E5C:  BCF    03.5
0E5D:  BSF    03.6
0E5E:  CLRF   11
0E5F:  CLRF   10
0E60:  BCF    03.6
0E61:  CALL   1F2
0E62:  BSF    03.5
0E63:  MOVF   58,W
0E64:  MOVWF  6D
0E65:  CLRF   6E
0E66:  BCF    03.5
0E67:  BSF    03.6
0E68:  CLRF   11
0E69:  MOVLW  80
0E6A:  MOVWF  10
0E6B:  BCF    03.6
0E6C:  CALL   1F2
0E6D:  BSF    03.5
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0E6E:  GOTO   5C9
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0E6F:  MOVLW  00
0E70:  MOVWF  78
0E71:  BCF    03.5
0E72:  BCF    0A.3
0E73:  BSF    0A.4
0E74:  GOTO   520 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
0E75:  BSF    03.5
0E76:  CLRF   56
0E77:  CLRF   57
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0E78:  SWAPF  56,W
0E79:  MOVWF  77
0E7A:  MOVLW  F0
0E7B:  ANDWF  77,F
0E7C:  MOVF   77,W
0E7D:  MOVWF  58
0E7E:  MOVLW  0C
0E7F:  MOVWF  5E
0E80:  BCF    03.5
0E81:  CALL   118
0E82:  MOVLW  A6
0E83:  BSF    03.6
0E84:  MOVWF  0D
0E85:  MOVLW  01
0E86:  MOVWF  0F
0E87:  BSF    03.5
0E88:  BCF    03.6
0E89:  MOVF   58,W
0E8A:  BCF    03.5
0E8B:  BSF    03.6
0E8C:  ADDWF  0D,F
0E8D:  BTFSC  03.0
0E8E:  INCF   0F,F
0E8F:  BCF    0A.3
0E90:  BCF    03.6
0E91:  CALL   7BF
0E92:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0EB3:  BSF    03.5
0EB4:  MOVF   57,F
0EB5:  BTFSS  03.2
0EB6:  GOTO   756
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
0EB7:  BCF    03.5
0EB8:  CALL   218
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0EB9:  BSF    03.5
0EBA:  BSF    06.4
0EBB:  BCF    03.5
0EBC:  BTFSC  06.4
0EBD:  GOTO   714
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0EBE:  MOVLW  02
0EBF:  BSF    03.5
0EC0:  MOVWF  58
0EC1:  MOVLW  FA
0EC2:  MOVWF  6B
0EC3:  BCF    0A.3
0EC4:  BCF    03.5
0EC5:  CALL   4A1
0EC6:  BSF    0A.3
0EC7:  BSF    03.5
0EC8:  DECFSZ 58,F
0EC9:  GOTO   6C1
....................          BEEP; 
0ECA:  MOVLW  04
0ECB:  MOVWF  5C
0ECC:  MOVLW  B9
0ECD:  MOVWF  5B
0ECE:  CLRF   5E
0ECF:  MOVLW  14
0ED0:  MOVWF  5D
0ED1:  BCF    03.5
0ED2:  CALL   32B
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0ED3:  BSF    03.5
0ED4:  INCF   56,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
0ED5:  MOVF   56,W
0ED6:  SUBWF  52,W
0ED7:  BTFSS  03.0
....................             optSelected = 0; 
0ED8:  CLRF   56
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0ED9:  SWAPF  56,W
0EDA:  MOVWF  77
0EDB:  MOVLW  F0
0EDC:  ANDWF  77,F
0EDD:  MOVF   77,W
0EDE:  MOVWF  58
0EDF:  MOVLW  0C
0EE0:  MOVWF  5E
0EE1:  BCF    03.5
0EE2:  CALL   118
0EE3:  MOVLW  A6
0EE4:  BSF    03.6
0EE5:  MOVWF  0D
0EE6:  MOVLW  01
0EE7:  MOVWF  0F
0EE8:  BSF    03.5
0EE9:  BCF    03.6
0EEA:  MOVF   58,W
0EEB:  BCF    03.5
0EEC:  BSF    03.6
0EED:  ADDWF  0D,F
0EEE:  BTFSC  03.0
0EEF:  INCF   0F,F
0EF0:  BCF    0A.3
0EF1:  BCF    03.6
0EF2:  CALL   7BF
0EF3:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0F14:  BSF    03.5
0F15:  BSF    06.5
0F16:  BCF    03.5
0F17:  BTFSC  06.5
0F18:  GOTO   754
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0F19:  MOVLW  02
0F1A:  BSF    03.5
0F1B:  MOVWF  58
0F1C:  MOVLW  FA
0F1D:  MOVWF  6B
0F1E:  BCF    0A.3
0F1F:  BCF    03.5
0F20:  CALL   4A1
0F21:  BSF    0A.3
0F22:  BSF    03.5
0F23:  DECFSZ 58,F
0F24:  GOTO   71C
....................          BEEP; 
0F25:  MOVLW  04
0F26:  MOVWF  5C
0F27:  MOVLW  B9
0F28:  MOVWF  5B
0F29:  CLRF   5E
0F2A:  MOVLW  14
0F2B:  MOVWF  5D
0F2C:  BCF    03.5
0F2D:  CALL   32B
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
0F2E:  BSF    03.5
0F2F:  MOVF   52,W
0F30:  SUBWF  56,W
0F31:  BTFSS  03.2
0F32:  GOTO   736
....................             exit = 1; 
0F33:  MOVLW  01
0F34:  MOVWF  57
....................          }else{ 
0F35:  GOTO   755
....................             output_low(PIN_OUT[optSelected]); 
0F36:  BCF    03.0
0F37:  RLF    56,W
0F38:  ADDLW  2B
0F39:  MOVWF  04
0F3A:  BCF    03.7
0F3B:  INCF   04,F
0F3C:  MOVF   00,W
0F3D:  MOVWF  59
0F3E:  DECF   04,F
0F3F:  MOVF   00,W
0F40:  MOVWF  58
0F41:  MOVWF  6D
0F42:  CLRF   6E
0F43:  BCF    03.5
0F44:  BSF    03.6
0F45:  CLRF   11
0F46:  CLRF   10
0F47:  BCF    03.6
0F48:  CALL   1F2
0F49:  BSF    03.5
0F4A:  MOVF   58,W
0F4B:  MOVWF  6D
0F4C:  CLRF   6E
0F4D:  BCF    03.5
0F4E:  BSF    03.6
0F4F:  CLRF   11
0F50:  MOVLW  80
0F51:  MOVWF  10
0F52:  BCF    03.6
0F53:  CALL   1F2
0F54:  BSF    03.5
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0F55:  GOTO   6B4
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0F56:  MOVLW  00
0F57:  MOVWF  78
0F58:  BCF    03.5
0F59:  BCF    0A.3
0F5A:  BSF    0A.4
0F5B:  GOTO   529 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
....................  
....................    /******************************************** 
....................    *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................    *********************************************/ 
....................    run_command_wifi(); 
*
1314:  BCF    0A.4
1315:  BSF    0A.3
1316:  CALL   218
1317:  BSF    0A.4
1318:  BCF    0A.3
....................    /********************************************/ 
....................     
....................    int optSelected = 0; 
....................    int exit = 0; 
1319:  BSF    03.5
131A:  CLRF   56
131B:  CLRF   57
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
131C:  MOVF   56,W
131D:  MOVWF  5B
131E:  MOVLW  11
131F:  MOVWF  5C
1320:  BCF    0A.4
1321:  BSF    0A.3
1322:  BCF    03.5
1323:  CALL   560
1324:  BSF    0A.4
1325:  BCF    0A.3
1326:  MOVF   78,W
1327:  BSF    03.5
1328:  MOVWF  58
1329:  MOVLW  0C
132A:  MOVWF  5E
132B:  BCF    0A.4
132C:  BSF    0A.3
132D:  BCF    03.5
132E:  CALL   118
132F:  BSF    0A.4
1330:  BCF    0A.3
1331:  MOVLW  46
1332:  BSF    03.6
1333:  MOVWF  0D
1334:  MOVLW  02
1335:  MOVWF  0F
1336:  BSF    03.5
1337:  BCF    03.6
1338:  MOVF   58,W
1339:  BCF    03.5
133A:  BSF    03.6
133B:  ADDWF  0D,F
133C:  BTFSC  03.0
133D:  INCF   0F,F
133E:  BCF    0A.4
133F:  BCF    03.6
1340:  CALL   7BF
1341:  BSF    0A.4
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1366:  BSF    03.5
1367:  MOVF   57,F
1368:  BTFSS  03.2
1369:  GOTO   44E
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
136A:  BSF    06.4
136B:  BCF    03.5
136C:  BTFSC  06.4
136D:  GOTO   3D7
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
136E:  MOVLW  02
136F:  BSF    03.5
1370:  MOVWF  58
1371:  MOVLW  FA
1372:  MOVWF  6B
1373:  BCF    0A.4
1374:  BCF    03.5
1375:  CALL   4A1
1376:  BSF    0A.4
1377:  BSF    03.5
1378:  DECFSZ 58,F
1379:  GOTO   371
....................          BEEP; 
137A:  MOVLW  04
137B:  MOVWF  5C
137C:  MOVLW  B9
137D:  MOVWF  5B
137E:  CLRF   5E
137F:  MOVLW  14
1380:  MOVWF  5D
1381:  BCF    0A.4
1382:  BSF    0A.3
1383:  BCF    03.5
1384:  CALL   32B
1385:  BSF    0A.4
1386:  BCF    0A.3
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
1387:  BSF    03.5
1388:  INCF   56,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
1389:  MOVF   56,W
138A:  SUBWF  53,W
138B:  BTFSS  03.0
....................             optSelected = 0; 
138C:  CLRF   56
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
138D:  MOVF   56,W
138E:  MOVWF  5B
138F:  MOVLW  11
1390:  MOVWF  5C
1391:  BCF    0A.4
1392:  BSF    0A.3
1393:  BCF    03.5
1394:  CALL   560
1395:  BSF    0A.4
1396:  BCF    0A.3
1397:  MOVF   78,W
1398:  BSF    03.5
1399:  MOVWF  58
139A:  MOVLW  0C
139B:  MOVWF  5E
139C:  BCF    0A.4
139D:  BSF    0A.3
139E:  BCF    03.5
139F:  CALL   118
13A0:  BSF    0A.4
13A1:  BCF    0A.3
13A2:  MOVLW  46
13A3:  BSF    03.6
13A4:  MOVWF  0D
13A5:  MOVLW  02
13A6:  MOVWF  0F
13A7:  BSF    03.5
13A8:  BCF    03.6
13A9:  MOVF   58,W
13AA:  BCF    03.5
13AB:  BSF    03.6
13AC:  ADDWF  0D,F
13AD:  BTFSC  03.0
13AE:  INCF   0F,F
13AF:  BCF    0A.4
13B0:  BCF    03.6
13B1:  CALL   7BF
13B2:  BSF    0A.4
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
13D7:  BSF    03.5
13D8:  BSF    06.5
13D9:  BCF    03.5
13DA:  BTFSC  06.5
13DB:  GOTO   44C
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
13DC:  MOVLW  02
13DD:  BSF    03.5
13DE:  MOVWF  58
13DF:  MOVLW  FA
13E0:  MOVWF  6B
13E1:  BCF    0A.4
13E2:  BCF    03.5
13E3:  CALL   4A1
13E4:  BSF    0A.4
13E5:  BSF    03.5
13E6:  DECFSZ 58,F
13E7:  GOTO   3DF
....................          BEEP; 
13E8:  MOVLW  04
13E9:  MOVWF  5C
13EA:  MOVLW  B9
13EB:  MOVWF  5B
13EC:  CLRF   5E
13ED:  MOVLW  14
13EE:  MOVWF  5D
13EF:  BCF    0A.4
13F0:  BSF    0A.3
13F1:  BCF    03.5
13F2:  CALL   32B
13F3:  BSF    0A.4
13F4:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
13F5:  BSF    03.5
13F6:  MOVF   53,W
13F7:  SUBWF  56,W
13F8:  BTFSS  03.2
13F9:  GOTO   3FD
....................             exit = 1; 
13FA:  MOVLW  01
13FB:  MOVWF  57
....................          }else{ 
13FC:  GOTO   44D
....................             executeSetup(optSelected); 
13FD:  MOVF   56,W
13FE:  MOVWF  58
13FF:  BCF    03.5
1400:  GOTO   000
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
1401:  BSF    03.5
1402:  MOVF   56,W
1403:  MOVWF  5B
1404:  MOVLW  11
1405:  MOVWF  5C
1406:  BCF    0A.4
1407:  BSF    0A.3
1408:  BCF    03.5
1409:  CALL   560
140A:  BSF    0A.4
140B:  BCF    0A.3
140C:  MOVF   78,W
140D:  BSF    03.5
140E:  MOVWF  58
140F:  MOVLW  0C
1410:  MOVWF  5E
1411:  BCF    0A.4
1412:  BSF    0A.3
1413:  BCF    03.5
1414:  CALL   118
1415:  BSF    0A.4
1416:  BCF    0A.3
1417:  MOVLW  46
1418:  BSF    03.6
1419:  MOVWF  0D
141A:  MOVLW  02
141B:  MOVWF  0F
141C:  BSF    03.5
141D:  BCF    03.6
141E:  MOVF   58,W
141F:  BCF    03.5
1420:  BSF    03.6
1421:  ADDWF  0D,F
1422:  BTFSC  03.0
1423:  INCF   0F,F
1424:  BCF    0A.4
1425:  BCF    03.6
1426:  CALL   7BF
1427:  BSF    0A.4
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
144D:  GOTO   367
....................    } // FIN While Infinito 
....................  
....................    return 0; 
144E:  MOVLW  00
144F:  MOVWF  78
1450:  BCF    03.5
1451:  BCF    0A.3
1452:  BSF    0A.4
1453:  GOTO   530 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................   switch(optSelect){ 
*
1000:  BSF    03.5
1001:  MOVF   58,W
1002:  ADDLW  FA
1003:  BTFSC  03.0
1004:  GOTO   306
1005:  ADDLW  06
1006:  BCF    03.5
1007:  GOTO   30A
....................       
....................      case OPT_SHOW_IP: 
....................         printf(lcd_putc, "\f192.168.0.1"); 
1008:  MOVLW  0F
1009:  BSF    03.6
100A:  MOVWF  0D
100B:  MOVLW  03
100C:  MOVWF  0F
100D:  BCF    0A.4
100E:  BSF    0A.3
100F:  BCF    03.6
1010:  CALL   17E
1011:  BSF    0A.4
1012:  BCF    0A.3
....................         pressExit(); 
....................         break; 
*
1051:  GOTO   306
....................      case OPT_SHOW_SSID: 
....................         printf(lcd_putc, "\fC0G3_UNE"); 
1052:  MOVLW  16
1053:  BSF    03.6
1054:  MOVWF  0D
1055:  MOVLW  03
1056:  MOVWF  0F
1057:  BCF    0A.4
1058:  BSF    0A.3
1059:  BCF    03.6
105A:  CALL   17E
105B:  BSF    0A.4
105C:  BCF    0A.3
....................         pressExit();          
....................         break; 
*
109B:  GOTO   306
....................      case OPT_SHOW_KEY: 
....................         printf(lcd_putc, "\f1234Az!"); 
109C:  MOVLW  1B
109D:  BSF    03.6
109E:  MOVWF  0D
109F:  MOVLW  03
10A0:  MOVWF  0F
10A1:  BCF    0A.4
10A2:  BSF    0A.3
10A3:  BCF    03.6
10A4:  CALL   17E
10A5:  BSF    0A.4
10A6:  BCF    0A.3
....................         pressExit(); 
....................         break; 
*
10E5:  GOTO   306
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
....................         break; 
*
12A5:  GOTO   306
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
12A6:  BSF    03.5
12A7:  BCF    08.3
12A8:  MOVLW  08
12A9:  BCF    03.5
12AA:  XORWF  08,F
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
12AB:  BTFSS  08.3
12AC:  GOTO   2B9
....................            printf(lcd_putc, "\fBacklight On"); 
12AD:  MOVLW  20
12AE:  BSF    03.6
12AF:  MOVWF  0D
12B0:  MOVLW  03
12B1:  MOVWF  0F
12B2:  BCF    0A.4
12B3:  BSF    0A.3
12B4:  BCF    03.6
12B5:  CALL   17E
12B6:  BSF    0A.4
12B7:  BCF    0A.3
....................         }else{ 
12B8:  GOTO   2C4
....................            printf(lcd_putc, "\fBacklight Off"); 
12B9:  MOVLW  27
12BA:  BSF    03.6
12BB:  MOVWF  0D
12BC:  MOVLW  03
12BD:  MOVWF  0F
12BE:  BCF    0A.4
12BF:  BSF    0A.3
12C0:  BCF    03.6
12C1:  CALL   17E
12C2:  BSF    0A.4
12C3:  BCF    0A.3
....................         } 
....................         pressExit(); 
....................         break; 
*
1302:  GOTO   306
....................      case OPT_EXIT: 
....................         break; 
1303:  BSF    03.5
1304:  GOTO   306
1305:  BSF    03.5
....................   } 
1306:  BCF    03.5
1307:  BCF    0A.3
1308:  BSF    0A.4
1309:  GOTO   401 (RETURN)
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
*
10E6:  BSF    03.5
10E7:  CLRF   59
10E8:  CLRF   5A
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
10E9:  MOVF   59,W
10EA:  MOVWF  5B
10EB:  MOVLW  0E
10EC:  MOVWF  5C
10ED:  BCF    0A.4
10EE:  BSF    0A.3
10EF:  BCF    03.5
10F0:  CALL   560
10F1:  BSF    0A.4
10F2:  BCF    0A.3
10F3:  MOVF   78,W
10F4:  BSF    03.5
10F5:  MOVWF  5B
10F6:  MOVLW  0C
10F7:  MOVWF  5E
10F8:  BCF    0A.4
10F9:  BSF    0A.3
10FA:  BCF    03.5
10FB:  CALL   118
10FC:  BSF    0A.4
10FD:  BCF    0A.3
10FE:  MOVLW  BD
10FF:  BSF    03.6
1100:  MOVWF  0D
1101:  MOVLW  02
1102:  MOVWF  0F
1103:  BSF    03.5
1104:  BCF    03.6
1105:  MOVF   5B,W
1106:  BCF    03.5
1107:  BSF    03.6
1108:  ADDWF  0D,F
1109:  BTFSC  03.0
110A:  INCF   0F,F
110B:  BCF    0A.4
110C:  BCF    03.6
110D:  CALL   7BF
110E:  BSF    0A.4
....................   showBottonMenu(); 
....................    
....................   while(!exit){ 
*
1133:  BSF    03.5
1134:  MOVF   5A,F
1135:  BTFSS  03.2
1136:  GOTO   2A5
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
1137:  BCF    0A.4
1138:  BSF    0A.3
1139:  BCF    03.5
113A:  CALL   218
113B:  BSF    0A.4
113C:  BCF    0A.3
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
113D:  BSF    03.5
113E:  BSF    06.4
113F:  BCF    03.5
1140:  BTFSC  06.4
1141:  GOTO   1AB
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
1142:  MOVLW  02
1143:  BSF    03.5
1144:  MOVWF  5B
1145:  MOVLW  FA
1146:  MOVWF  6B
1147:  BCF    0A.4
1148:  BCF    03.5
1149:  CALL   4A1
114A:  BSF    0A.4
114B:  BSF    03.5
114C:  DECFSZ 5B,F
114D:  GOTO   145
....................         BEEP; 
114E:  MOVLW  04
114F:  MOVWF  5C
1150:  MOVLW  B9
1151:  MOVWF  5B
1152:  CLRF   5E
1153:  MOVLW  14
1154:  MOVWF  5D
1155:  BCF    0A.4
1156:  BSF    0A.3
1157:  BCF    03.5
1158:  CALL   32B
1159:  BSF    0A.4
115A:  BCF    0A.3
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
115B:  BSF    03.5
115C:  INCF   59,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
115D:  MOVF   59,W
115E:  SUBWF  54,W
115F:  BTFSS  03.0
....................            optSelected = 0; 
1160:  CLRF   59
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
1161:  MOVF   59,W
1162:  MOVWF  5B
1163:  MOVLW  0E
1164:  MOVWF  5C
1165:  BCF    0A.4
1166:  BSF    0A.3
1167:  BCF    03.5
1168:  CALL   560
1169:  BSF    0A.4
116A:  BCF    0A.3
116B:  MOVF   78,W
116C:  BSF    03.5
116D:  MOVWF  5B
116E:  MOVLW  0C
116F:  MOVWF  5E
1170:  BCF    0A.4
1171:  BSF    0A.3
1172:  BCF    03.5
1173:  CALL   118
1174:  BSF    0A.4
1175:  BCF    0A.3
1176:  MOVLW  BD
1177:  BSF    03.6
1178:  MOVWF  0D
1179:  MOVLW  02
117A:  MOVWF  0F
117B:  BSF    03.5
117C:  BCF    03.6
117D:  MOVF   5B,W
117E:  BCF    03.5
117F:  BSF    03.6
1180:  ADDWF  0D,F
1181:  BTFSC  03.0
1182:  INCF   0F,F
1183:  BCF    0A.4
1184:  BCF    03.6
1185:  CALL   7BF
1186:  BSF    0A.4
....................         showBottonMenu(); 
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
*
11AB:  BSF    03.5
11AC:  BSF    06.5
11AD:  BCF    03.5
11AE:  BTFSC  06.5
11AF:  GOTO   2A3
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
11B0:  MOVLW  02
11B1:  BSF    03.5
11B2:  MOVWF  5B
11B3:  MOVLW  FA
11B4:  MOVWF  6B
11B5:  BCF    0A.4
11B6:  BCF    03.5
11B7:  CALL   4A1
11B8:  BSF    0A.4
11B9:  BSF    03.5
11BA:  DECFSZ 5B,F
11BB:  GOTO   1B3
....................         BEEP; 
11BC:  MOVLW  04
11BD:  MOVWF  5C
11BE:  MOVLW  B9
11BF:  MOVWF  5B
11C0:  CLRF   5E
11C1:  MOVLW  14
11C2:  MOVWF  5D
11C3:  BCF    0A.4
11C4:  BSF    0A.3
11C5:  BCF    03.5
11C6:  CALL   32B
11C7:  BSF    0A.4
11C8:  BCF    0A.3
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
11C9:  BSF    03.5
11CA:  MOVF   54,W
11CB:  SUBWF  59,W
11CC:  BTFSS  03.2
11CD:  GOTO   1D1
....................            exit = 1; 
11CE:  MOVLW  01
11CF:  MOVWF  5A
....................         }else{ 
11D0:  GOTO   2A4
....................            switch(optSelected){ 
11D1:  MOVF   59,W
11D2:  XORLW  00
11D3:  BCF    03.5
11D4:  BTFSC  03.2
11D5:  GOTO   1DD
11D6:  XORLW  01
11D7:  BTFSC  03.2
11D8:  GOTO   1F2
11D9:  XORLW  03
11DA:  BTFSC  03.2
11DB:  GOTO   207
11DC:  GOTO   21B
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
11DD:  MOVLW  2F
11DE:  BSF    03.6
11DF:  MOVWF  0D
11E0:  MOVLW  03
11E1:  MOVWF  0F
11E2:  BCF    0A.4
11E3:  BCF    03.6
11E4:  CALL   749
11E5:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig Cliente"); 
11E6:  MOVLW  38
11E7:  BSF    03.6
11E8:  MOVWF  0D
11E9:  MOVLW  03
11EA:  MOVWF  0F
11EB:  BCF    0A.4
11EC:  BSF    0A.3
11ED:  BCF    03.6
11EE:  CALL   17E
11EF:  BSF    0A.4
11F0:  BCF    0A.3
....................                  break; 
11F1:  GOTO   21B
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
11F2:  MOVLW  40
11F3:  BSF    03.6
11F4:  MOVWF  0D
11F5:  MOVLW  03
11F6:  MOVWF  0F
11F7:  BCF    0A.4
11F8:  BCF    03.6
11F9:  CALL   749
11FA:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig AP"); 
11FB:  MOVLW  49
11FC:  BSF    03.6
11FD:  MOVWF  0D
11FE:  MOVLW  03
11FF:  MOVWF  0F
1200:  BCF    0A.4
1201:  BSF    0A.3
1202:  BCF    03.6
1203:  CALL   17E
1204:  BSF    0A.4
1205:  BCF    0A.3
....................                  break; 
1206:  GOTO   21B
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
1207:  MOVLW  4F
1208:  BSF    03.6
1209:  MOVWF  0D
120A:  MOVLW  03
120B:  MOVWF  0F
120C:  BCF    0A.4
120D:  BCF    03.6
120E:  CALL   749
120F:  BSF    0A.4
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
1210:  MOVLW  58
1211:  BSF    03.6
1212:  MOVWF  0D
1213:  MOVLW  03
1214:  MOVWF  0F
1215:  BCF    0A.4
1216:  BSF    0A.3
1217:  BCF    03.6
1218:  CALL   17E
1219:  BSF    0A.4
121A:  BCF    0A.3
....................                  break; 
....................            } 
....................            pressExit(); 
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
*
1259:  MOVF   59,W
125A:  MOVWF  5B
125B:  MOVLW  0E
125C:  MOVWF  5C
125D:  BCF    0A.4
125E:  BSF    0A.3
125F:  BCF    03.5
1260:  CALL   560
1261:  BSF    0A.4
1262:  BCF    0A.3
1263:  MOVF   78,W
1264:  BSF    03.5
1265:  MOVWF  5B
1266:  MOVLW  0C
1267:  MOVWF  5E
1268:  BCF    0A.4
1269:  BSF    0A.3
126A:  BCF    03.5
126B:  CALL   118
126C:  BSF    0A.4
126D:  BCF    0A.3
126E:  MOVLW  BD
126F:  BSF    03.6
1270:  MOVWF  0D
1271:  MOVLW  02
1272:  MOVWF  0F
1273:  BSF    03.5
1274:  BCF    03.6
1275:  MOVF   5B,W
1276:  BCF    03.5
1277:  BSF    03.6
1278:  ADDWF  0D,F
1279:  BTFSC  03.0
127A:  INCF   0F,F
127B:  BCF    0A.4
127C:  BCF    03.6
127D:  CALL   7BF
127E:  BSF    0A.4
....................            showBottonMenu(); 
....................         } 
....................      } // Fin KEY_OK 
*
12A4:  GOTO   134
....................   } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
....................  
.................... /******************************************** 
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
037E:  BTFSS  0C.5
037F:  GOTO   37E
0380:  MOVF   1A,W
0381:  BSF    03.6
0382:  MOVWF  1D
.................... { 
....................    int buffer = getc(); 
....................    if(READY_RESP==0){ 
0383:  BCF    03.6
0384:  MOVF   42,F
0385:  BTFSS  03.2
0386:  GOTO   416
....................       ESP8266_PROCCESS_RESPONSE(buffer); 
0387:  BSF    03.6
0388:  MOVF   1D,W
0389:  MOVWF  1E
....................    }else{ 
*
0415:  GOTO   49D
....................       ESP8266_Get_IPD(buffer); 
0416:  BSF    03.6
0417:  CLRF   1F
0418:  MOVF   1D,W
0419:  MOVWF  1E
....................       ESP8266_Get_CMD(buffer); 
*
0445:  CLRF   1F
0446:  MOVF   1D,W
0447:  MOVWF  1E
....................       ESP8266_Get_Data(buffer); 
*
0475:  CLRF   1F
0476:  MOVF   1D,W
0477:  MOVWF  1E
....................    } 
*
049D:  BCF    0C.5
049E:  BCF    0A.3
049F:  BCF    0A.4
04A0:  GOTO   02D
.................... } 
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
*
1454:  MOVF   03,W
1455:  ANDLW  1F
1456:  MOVWF  03
1457:  BSF    03.5
1458:  BSF    03.6
1459:  BSF    07.3
145A:  MOVLW  08
145B:  BCF    03.6
145C:  MOVWF  19
145D:  MOVLW  02
145E:  MOVWF  1A
145F:  MOVLW  A6
1460:  MOVWF  18
1461:  MOVLW  90
1462:  BCF    03.5
1463:  MOVWF  18
1464:  BSF    03.5
1465:  BCF    06.0
1466:  BCF    03.5
1467:  BSF    06.0
1468:  CLRF   41
1469:  CLRF   42
146A:  CLRF   43
146B:  CLRF   44
146C:  CLRF   45
146D:  CLRF   46
146E:  CLRF   47
146F:  CLRF   48
1470:  CLRF   49
1471:  CLRF   4A
1472:  CLRF   4B
1473:  CLRF   4C
1474:  CLRF   71
1475:  CLRF   70
1476:  CLRF   72
1477:  CLRF   73
1478:  CLRF   74
1479:  CLRF   75
147A:  CLRF   76
147B:  CLRF   7B
147C:  CLRF   7C
147D:  MOVLW  02
147E:  MOVWF  7D
147F:  MOVLW  08
1480:  MOVWF  7E
1481:  BSF    03.5
1482:  MOVWF  52
1483:  MOVLW  05
1484:  MOVWF  53
1485:  MOVLW  03
1486:  MOVWF  54
1487:  CLRF   55
1488:  BSF    03.6
1489:  MOVF   09,W
148A:  ANDLW  C0
148B:  MOVWF  09
148C:  BCF    03.6
148D:  BCF    1F.4
148E:  BCF    1F.5
148F:  MOVLW  00
1490:  BSF    03.6
1491:  MOVWF  08
1492:  BCF    03.5
1493:  CLRF   07
1494:  CLRF   08
1495:  CLRF   09
1496:  BCF    03.7
....................    { 
....................        
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
*
14EB:  MOVLW  02
14EC:  BSF    03.5
14ED:  MOVWF  56
14EE:  MOVLW  FA
14EF:  MOVWF  6B
14F0:  BCF    0A.4
14F1:  BCF    03.5
14F2:  CALL   4A1
14F3:  BSF    0A.4
14F4:  BSF    03.5
14F5:  DECFSZ 56,F
14F6:  GOTO   4EE
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
14F7:  MOVLW  30
14F8:  MOVWF  15
14F9:  BCF    01.7
....................       set_tris_b(0b00110010); 
14FA:  MOVLW  32
14FB:  MOVWF  06
....................       enable_interrupts(INT_RDA);  
14FC:  BSF    0C.5
....................       enable_interrupts(GLOBAL);  
14FD:  MOVLW  C0
14FE:  BCF    03.5
14FF:  IORWF  0B,F
....................  
....................       // Inicializa la LCD 
....................       lcd_init(); 
1500:  BCF    0A.4
1501:  GOTO   5DE
1502:  BSF    0A.4
....................        
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
1503:  BSF    03.5
1504:  BCF    08.3
1505:  BCF    03.5
1506:  BSF    08.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
1507:  BCF    0A.4
1508:  BSF    0A.3
1509:  GOTO   000
150A:  BSF    0A.4
150B:  BCF    0A.3
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
150C:  BSF    03.5
150D:  MOVF   55,W
150E:  ADDLW  FC
150F:  BTFSC  03.0
1510:  GOTO   535
1511:  ADDLW  04
1512:  BCF    03.5
1513:  GOTO   537
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
1514:  BCF    0A.4
1515:  BSF    0A.3
1516:  GOTO   49A
1517:  BSF    0A.4
1518:  BCF    0A.3
1519:  MOVF   78,W
151A:  BSF    03.5
151B:  MOVWF  55
....................                break; 
151C:  GOTO   535
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
151D:  BCF    0A.4
151E:  BSF    0A.3
151F:  GOTO   587
1520:  BSF    0A.4
1521:  BCF    0A.3
1522:  MOVF   78,W
1523:  BSF    03.5
1524:  MOVWF  55
....................                break; 
1525:  GOTO   535
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
1526:  BCF    0A.4
1527:  BSF    0A.3
1528:  GOTO   675
1529:  BSF    0A.4
152A:  BCF    0A.3
152B:  MOVF   78,W
152C:  BSF    03.5
152D:  MOVWF  55
....................                break; 
152E:  GOTO   535
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
152F:  GOTO   314
1530:  MOVF   78,W
1531:  BSF    03.5
1532:  MOVWF  55
....................                break; 
1533:  GOTO   535
1534:  BSF    03.5
....................          } // Fin del Switch(menuActive) 
1535:  GOTO   50D
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
1536:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
