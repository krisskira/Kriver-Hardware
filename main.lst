CCS PCH C Compiler, Version 5.015, 5967               18-dic.-17 21:23

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   9686 bytes (15%)
                           Largest free fragment is 55846
               RAM used:   251 (6%) at main() level
                           322 (8%) worst case
               Stack used: 14 locations (10 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   246C
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  F9D.5
0004A:  GOTO   0054
0004E:  BTFSC  F9E.5
00050:  GOTO   0C0C
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... #include "header/config.h" 
.................... #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
00096:  MOVFF  FF2,0D
0009A:  BCF    FF2.7
0009C:  CLRF   FF7
0009E:  ADDLW  B0
000A0:  MOVWF  FF6
000A2:  MOVLW  00
000A4:  ADDWFC FF7,F
000A6:  TBLRD*+
000A8:  MOVF   FF5,W
000AA:  BTFSC  0D.7
000AC:  BSF    FF2.7
000AE:  RETURN 0
000B0:  DATA 22,7C
000B2:  DATA 21,7C
000B4:  DATA 20,7C
000B6:  DATA 04,7C
000B8:  DATA 00,7C
000BA:  DATA 01,7C
000BC:  DATA 02,7C
000BE:  DATA 03,7C
000C0:  CLRF   FF7
000C2:  ADDLW  D0
000C4:  MOVWF  FF6
000C6:  MOVLW  00
000C8:  ADDWFC FF7,F
000CA:  TBLRD*+
000CC:  MOVF   FF5,W
000CE:  RETURN 0
000D0:  DATA 2B,49
000D2:  DATA 50,44
000D4:  DATA 2C,00
000D6:  CLRF   FF7
000D8:  ADDLW  E6
000DA:  MOVWF  FF6
000DC:  MOVLW  00
000DE:  ADDWFC FF7,F
000E0:  TBLRD*+
000E2:  MOVF   FF5,W
000E4:  RETURN 0
000E6:  DATA 43,4D
000E8:  DATA 44,3A
000EA:  CLRF   FF7
000EC:  ADDLW  FA
000EE:  MOVWF  FF6
000F0:  MOVLW  00
000F2:  ADDWFC FF7,F
000F4:  TBLRD*+
000F6:  MOVF   FF5,W
000F8:  RETURN 0
000FA:  DATA 4F,4B
000FC:  DATA 0D,0A
000FE:  DATA 00,00
00100:  CLRF   FF7
00102:  ADDLW  10
00104:  MOVWF  FF6
00106:  MOVLW  01
00108:  ADDWFC FF7,F
0010A:  TBLRD*+
0010C:  MOVF   FF5,W
0010E:  RETURN 0
00110:  DATA 4E,6F
00112:  DATA 20,41
00114:  DATA 70,00
00116:  CLRF   FF7
00118:  ADDLW  26
0011A:  MOVWF  FF6
0011C:  MOVLW  01
0011E:  ADDWFC FF7,F
00120:  TBLRD*+
00122:  MOVF   FF5,W
00124:  RETURN 0
00126:  DATA 2B,43
00128:  DATA 57,4A
0012A:  DATA 41,50
0012C:  DATA 3A,00
0012E:  CLRF   FF7
00130:  ADDLW  3E
00132:  MOVWF  FF6
00134:  MOVLW  01
00136:  ADDWFC FF7,F
00138:  TBLRD*+
0013A:  MOVF   FF5,W
0013C:  RETURN 0
0013E:  DATA 43,4F
00140:  DATA 4E,4E
00142:  DATA 45,43
00144:  DATA 54,45
00146:  DATA 44,00
00148:  CLRF   FF7
0014A:  ADDLW  58
0014C:  MOVWF  FF6
0014E:  MOVLW  01
00150:  ADDWFC FF7,F
00152:  TBLRD*+
00154:  MOVF   FF5,W
00156:  RETURN 0
00158:  DATA 46,41
0015A:  DATA 49,4C
0015C:  DATA 00,00
0015E:  DATA 41,54
00160:  DATA 2B,43
00162:  DATA 49,50
00164:  DATA 53,45
00166:  DATA 4E,44
00168:  DATA 3D,25
0016A:  DATA 63,2C
0016C:  DATA 31,32
0016E:  DATA 0D,0A
00170:  DATA 00,00
00172:  DATA 41,54
00174:  DATA 2B,43
00176:  DATA 49,50
00178:  DATA 43,4C
0017A:  DATA 4F,53
0017C:  DATA 45,3D
0017E:  DATA 25,63
00180:  DATA 0D,0A
00182:  DATA 00,00
00184:  DATA 41,54
00186:  DATA 2B,43
00188:  DATA 57,51
0018A:  DATA 41,50
0018C:  DATA 0A,0D
0018E:  DATA 00,00
00190:  DATA 41,54
00192:  DATA 2B,43
00194:  DATA 49,50
00196:  DATA 53,45
00198:  DATA 4E,44
0019A:  DATA 3D,25
0019C:  DATA 63,2C
0019E:  DATA 31,32
001A0:  DATA 0D,0A
001A2:  DATA 00,00
001A4:  DATA 41,54
001A6:  DATA 2B,43
001A8:  DATA 49,50
001AA:  DATA 43,4C
001AC:  DATA 4F,53
001AE:  DATA 45,3D
001B0:  DATA 25,63
001B2:  DATA 0D,0A
001B4:  DATA 00,00
001B6:  DATA 41,54
001B8:  DATA 2B,43
001BA:  DATA 57,53
001BC:  DATA 41,50
001BE:  DATA 5F,44
001C0:  DATA 45,46
001C2:  DATA 3D,25
001C4:  DATA 73,2C
001C6:  DATA 31,2C
001C8:  DATA 34,0D
001CA:  DATA 0A,00
001CC:  DATA 41,54
001CE:  DATA 2B,43
001D0:  DATA 49,50
001D2:  DATA 53,45
001D4:  DATA 4E,44
001D6:  DATA 3D,25
001D8:  DATA 63,2C
001DA:  DATA 31,32
001DC:  DATA 0D,0A
001DE:  DATA 00,00
001E0:  DATA 41,54
001E2:  DATA 2B,43
001E4:  DATA 49,50
001E6:  DATA 43,4C
001E8:  DATA 4F,53
001EA:  DATA 45,3D
001EC:  DATA 25,63
001EE:  DATA 0D,0A
001F0:  DATA 00,00
001F2:  DATA 41,54
001F4:  DATA 2B,43
001F6:  DATA 49,50
001F8:  DATA 53,45
001FA:  DATA 4E,44
001FC:  DATA 3D,25
001FE:  DATA 63,2C
00200:  DATA 31,37
00202:  DATA 0D,0A
00204:  DATA 00,00
00206:  DATA 41,54
00208:  DATA 2B,43
0020A:  DATA 49,50
0020C:  DATA 43,4C
0020E:  DATA 4F,53
00210:  DATA 45,3D
00212:  DATA 25,63
00214:  DATA 0D,0A
00216:  DATA 00,00
00218:  DATA 41,54
0021A:  DATA 2B,43
0021C:  DATA 49,50
0021E:  DATA 53,45
00220:  DATA 4E,44
00222:  DATA 3D,25
00224:  DATA 63,2C
00226:  DATA 31,32
00228:  DATA 0D,0A
0022A:  DATA 00,00
0022C:  DATA 41,54
0022E:  DATA 2B,43
00230:  DATA 49,50
00232:  DATA 43,4C
00234:  DATA 4F,53
00236:  DATA 45,3D
00238:  DATA 25,63
0023A:  DATA 0D,0A
0023C:  DATA 00,00
0023E:  DATA 41,54
00240:  DATA 2B,52
00242:  DATA 53,54
00244:  DATA 0D,0A
00246:  DATA 00,00
00248:  DATA 41,54
0024A:  DATA 2B,43
0024C:  DATA 57,4D
0024E:  DATA 4F,44
00250:  DATA 45,3D
00252:  DATA 25,63
00254:  DATA 0D,0A
00256:  DATA 00,00
00258:  DATA 41,54
0025A:  DATA 2B,43
0025C:  DATA 57,4A
0025E:  DATA 41,50
00260:  DATA 3F,0D
00262:  DATA 0A,00
00264:  DATA 41,54
00266:  DATA 2B,43
00268:  DATA 57,4A
0026A:  DATA 41,50
0026C:  DATA 3D,25
0026E:  DATA 73,00
00270:  DATA 41,54
00272:  DATA 2B,43
00274:  DATA 57,4D
00276:  DATA 4F,44
00278:  DATA 45,3D
0027A:  DATA 25,63
0027C:  DATA 0D,0A
0027E:  DATA 00,00
00280:  DATA 41,54
00282:  DATA 2B,43
00284:  DATA 49,50
00286:  DATA 4D,55
00288:  DATA 58,3D
0028A:  DATA 31,0D
0028C:  DATA 0A,00
0028E:  DATA 41,54
00290:  DATA 2B,43
00292:  DATA 49,50
00294:  DATA 53,45
00296:  DATA 52,56
00298:  DATA 45,52
0029A:  DATA 3D,31
0029C:  DATA 2C,38
0029E:  DATA 30,0D
002A0:  DATA 0A,00
002A2:  DATA 45,6E
002A4:  DATA 63,65
002A6:  DATA 6E,64
002A8:  DATA 65,72
002AA:  DATA 20,4D
002AC:  DATA 61,6E
002AE:  DATA 75,61
002B0:  DATA 6C,00
002B2:  DATA 41,70
002B4:  DATA 61,67
002B6:  DATA 61,64
002B8:  DATA 6F,20
002BA:  DATA 4D,61
002BC:  DATA 6E,75
002BE:  DATA 61,6C
002C0:  DATA 20,00
002C2:  DATA 43,6F
002C4:  DATA 6E,66
002C6:  DATA 69,67
002C8:  DATA 75,72
002CA:  DATA 61,63
002CC:  DATA 69,6F
002CE:  DATA 6E,20
002D0:  DATA 20,00
002D2:  DATA 00,00
002D4:  DATA 00,00
002D6:  DATA 00,00
002D8:  DATA 00,00
002DA:  DATA 00,00
002DC:  DATA 00,00
002DE:  DATA 00,00
002E0:  DATA 00,00
002E2:  DATA 4F,6E
002E4:  DATA 20,2D
002E6:  DATA 3E,20
002E8:  DATA 53,61
002EA:  DATA 6C,69
002EC:  DATA 64,61
002EE:  DATA 20,31
002F0:  DATA 00,4F
002F2:  DATA 6E,20
002F4:  DATA 2D,3E
002F6:  DATA 20,53
002F8:  DATA 61,6C
002FA:  DATA 69,64
002FC:  DATA 61,20
002FE:  DATA 32,00
00300:  DATA 4F,6E
00302:  DATA 20,2D
00304:  DATA 3E,20
00306:  DATA 53,61
00308:  DATA 6C,69
0030A:  DATA 64,61
0030C:  DATA 20,33
0030E:  DATA 00,4F
00310:  DATA 6E,20
00312:  DATA 2D,3E
00314:  DATA 20,53
00316:  DATA 61,6C
00318:  DATA 69,64
0031A:  DATA 61,20
0031C:  DATA 34,00
0031E:  DATA 4F,6E
00320:  DATA 20,2D
00322:  DATA 3E,20
00324:  DATA 53,61
00326:  DATA 6C,69
00328:  DATA 64,61
0032A:  DATA 20,35
0032C:  DATA 00,4F
0032E:  DATA 6E,20
00330:  DATA 2D,3E
00332:  DATA 20,53
00334:  DATA 61,6C
00336:  DATA 69,64
00338:  DATA 61,20
0033A:  DATA 36,00
0033C:  DATA 4F,6E
0033E:  DATA 20,2D
00340:  DATA 3E,20
00342:  DATA 53,61
00344:  DATA 6C,69
00346:  DATA 64,61
00348:  DATA 20,37
0034A:  DATA 00,4F
0034C:  DATA 6E,20
0034E:  DATA 2D,3E
00350:  DATA 20,53
00352:  DATA 61,6C
00354:  DATA 69,64
00356:  DATA 61,20
00358:  DATA 38,00
0035A:  DATA 53,41
0035C:  DATA 4C,49
0035E:  DATA 52,20
00360:  DATA 20,20
00362:  DATA 20,20
00364:  DATA 20,20
00366:  DATA 20,20
00368:  DATA 00,00
0036A:  DATA 00,00
0036C:  DATA 00,00
0036E:  DATA 00,00
00370:  DATA 00,00
00372:  DATA 00,00
00374:  DATA 00,00
00376:  DATA 00,00
00378:  DATA 4F,66
0037A:  DATA 66,20
0037C:  DATA 2D,3E
0037E:  DATA 20,53
00380:  DATA 61,6C
00382:  DATA 69,64
00384:  DATA 61,20
00386:  DATA 31,00
00388:  DATA 4F,66
0038A:  DATA 66,20
0038C:  DATA 2D,3E
0038E:  DATA 20,53
00390:  DATA 61,6C
00392:  DATA 69,64
00394:  DATA 61,20
00396:  DATA 32,00
00398:  DATA 4F,66
0039A:  DATA 66,20
0039C:  DATA 2D,3E
0039E:  DATA 20,53
003A0:  DATA 61,6C
003A2:  DATA 69,64
003A4:  DATA 61,20
003A6:  DATA 33,00
003A8:  DATA 4F,66
003AA:  DATA 66,20
003AC:  DATA 2D,3E
003AE:  DATA 20,53
003B0:  DATA 61,6C
003B2:  DATA 69,64
003B4:  DATA 61,20
003B6:  DATA 34,00
003B8:  DATA 4F,66
003BA:  DATA 66,20
003BC:  DATA 2D,3E
003BE:  DATA 20,53
003C0:  DATA 61,6C
003C2:  DATA 69,64
003C4:  DATA 61,20
003C6:  DATA 35,00
003C8:  DATA 4F,66
003CA:  DATA 66,20
003CC:  DATA 2D,3E
003CE:  DATA 20,53
003D0:  DATA 61,6C
003D2:  DATA 69,64
003D4:  DATA 61,20
003D6:  DATA 36,00
003D8:  DATA 4F,66
003DA:  DATA 66,20
003DC:  DATA 2D,3E
003DE:  DATA 20,53
003E0:  DATA 61,6C
003E2:  DATA 69,64
003E4:  DATA 61,20
003E6:  DATA 37,00
003E8:  DATA 4F,66
003EA:  DATA 66,20
003EC:  DATA 2D,3E
003EE:  DATA 20,53
003F0:  DATA 61,6C
003F2:  DATA 69,64
003F4:  DATA 61,20
003F6:  DATA 38,00
003F8:  DATA 53,41
003FA:  DATA 4C,49
003FC:  DATA 52,20
003FE:  DATA 20,20
00400:  DATA 20,20
00402:  DATA 20,20
00404:  DATA 20,20
00406:  DATA 20,00
00408:  DATA 00,00
0040A:  DATA 00,00
0040C:  DATA 00,00
0040E:  DATA 00,00
00410:  DATA 00,00
00412:  DATA 00,00
00414:  DATA 00,00
00416:  DATA 00,00
00418:  DATA 45,53
0041A:  DATA 54,41
0041C:  DATA 43,49
0041E:  DATA 4F,4E
00420:  DATA 20,49
00422:  DATA 50,20
00424:  DATA 20,20
00426:  DATA 20,20
00428:  DATA 00,45
0042A:  DATA 53,54
0042C:  DATA 41,43
0042E:  DATA 49,4F
00430:  DATA 4E,20
00432:  DATA 53,53
00434:  DATA 49,44
00436:  DATA 20,20
00438:  DATA 20,00
0043A:  DATA 41,50
0043C:  DATA 20,53
0043E:  DATA 53,49
00440:  DATA 44,20
00442:  DATA 20,20
00444:  DATA 20,20
00446:  DATA 20,20
00448:  DATA 20,20
0044A:  DATA 00,41
0044C:  DATA 50,20
0044E:  DATA 4B,45
00450:  DATA 59,20
00452:  DATA 20,20
00454:  DATA 20,20
00456:  DATA 20,20
00458:  DATA 20,20
0045A:  DATA 20,00
0045C:  DATA 41,50
0045E:  DATA 20,49
00460:  DATA 50,20
00462:  DATA 20,20
00464:  DATA 20,20
00466:  DATA 20,20
00468:  DATA 20,20
0046A:  DATA 20,20
0046C:  DATA 00,43
0046E:  DATA 6F,6E
00470:  DATA 66,20
00472:  DATA 41,63
00474:  DATA 63,65
00476:  DATA 73,73
00478:  DATA 6F,20
0047A:  DATA 52,65
0047C:  DATA 64,00
0047E:  DATA 4F,6E
00480:  DATA 2F,4F
00482:  DATA 66,66
00484:  DATA 20,42
00486:  DATA 61,63
00488:  DATA 6B,6C
0048A:  DATA 69,67
0048C:  DATA 68,74
0048E:  DATA 00,53
00490:  DATA 41,4C
00492:  DATA 49,52
00494:  DATA 20,20
00496:  DATA 20,20
00498:  DATA 20,20
0049A:  DATA 20,20
0049C:  DATA 20,20
0049E:  DATA 20,00
004A0:  DATA 00,00
004A2:  DATA 00,00
004A4:  DATA 00,00
004A6:  DATA 00,00
004A8:  DATA 00,00
004AA:  DATA 00,00
004AC:  DATA 00,00
004AE:  DATA 00,00
004B0:  DATA 00,00
004B2:  DATA 45,73
004B4:  DATA 74,61
004B6:  DATA 63,69
004B8:  DATA F3,6E
004BA:  DATA 20,20
004BC:  DATA 20,20
004BE:  DATA 20,00
004C0:  DATA 41,63
004C2:  DATA 63,65
004C4:  DATA 73,73
004C6:  DATA 20,50
004C8:  DATA 6F,69
004CA:  DATA 6E,74
004CC:  DATA 20,00
004CE:  DATA 45,73
004D0:  DATA 74,61
004D2:  DATA 63,69
004D4:  DATA 6F,6E
004D6:  DATA 20,2B
004D8:  DATA 20,41
004DA:  DATA 50,00
004DC:  DATA 53,41
004DE:  DATA 4C,49
004E0:  DATA 52,20
004E2:  DATA 20,20
004E4:  DATA 20,20
004E6:  DATA 20,20
004E8:  DATA 20,00
004EA:  DATA 00,00
004EC:  DATA 00,00
004EE:  DATA 00,00
004F0:  DATA 00,00
004F2:  DATA 00,00
004F4:  DATA 00,00
004F6:  DATA 00,00
004F8:  DATA 53,41
004FA:  DATA 4C,49
004FC:  DATA 52,00
004FE:  DATA 5B,53
00500:  DATA 49,47
00502:  DATA 5D,20
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,5B
0050A:  DATA 45,4E
0050C:  DATA 54,5D
0050E:  DATA 00,00
00510:  DATA 41,54
00512:  DATA 2B,43
00514:  DATA 49,46
00516:  DATA 53,52
00518:  DATA 0D,0A
0051A:  DATA 00,00
0051C:  DATA 0C,43
0051E:  DATA 61,72
00520:  DATA 67,61
00522:  DATA 6E,64
00524:  DATA 6F,2E
00526:  DATA 2E,2E
00528:  DATA 00,00
0052A:  DATA 41,54
0052C:  DATA 2B,43
0052E:  DATA 49,46
00530:  DATA 53,52
00532:  DATA 0D,0A
00534:  DATA 00,00
00536:  DATA 0C,43
00538:  DATA 61,72
0053A:  DATA 67,61
0053C:  DATA 6E,64
0053E:  DATA 6F,2E
00540:  DATA 2E,2E
00542:  DATA 00,00
00544:  DATA 41,54
00546:  DATA 2B,43
00548:  DATA 57,4A
0054A:  DATA 41,50
0054C:  DATA 3F,0D
0054E:  DATA 0A,00
00550:  DATA 0C,43
00552:  DATA 61,72
00554:  DATA 67,61
00556:  DATA 6E,64
00558:  DATA 6F,2E
0055A:  DATA 2E,2E
0055C:  DATA 00,00
0055E:  DATA 0C,44
00560:  DATA 65,73
00562:  DATA 68,61
00564:  DATA 62,69
00566:  DATA 6C,69
00568:  DATA 74,61
0056A:  DATA 64,6F
0056C:  DATA 00,00
0056E:  DATA 41,54
00570:  DATA 2B,43
00572:  DATA 57,53
00574:  DATA 41,50
00576:  DATA 3F,0D
00578:  DATA 0A,00
0057A:  DATA 0C,43
0057C:  DATA 61,72
0057E:  DATA 67,61
00580:  DATA 6E,64
00582:  DATA 6F,2E
00584:  DATA 2E,2E
00586:  DATA 00,00
00588:  DATA 0C,44
0058A:  DATA 65,73
0058C:  DATA 68,61
0058E:  DATA 62,69
00590:  DATA 6C,69
00592:  DATA 74,61
00594:  DATA 64,6F
00596:  DATA 00,00
00598:  DATA 41,54
0059A:  DATA 2B,43
0059C:  DATA 57,53
0059E:  DATA 41,50
005A0:  DATA 3F,0D
005A2:  DATA 0A,00
005A4:  DATA 0C,43
005A6:  DATA 61,72
005A8:  DATA 67,61
005AA:  DATA 6E,64
005AC:  DATA 6F,2E
005AE:  DATA 2E,2E
005B0:  DATA 00,00
005B2:  DATA 0C,44
005B4:  DATA 65,73
005B6:  DATA 68,61
005B8:  DATA 62,69
005BA:  DATA 6C,69
005BC:  DATA 74,61
005BE:  DATA 64,6F
005C0:  DATA 00,00
005C2:  DATA 0C,42
005C4:  DATA 61,63
005C6:  DATA 6B,6C
005C8:  DATA 69,67
005CA:  DATA 68,74
005CC:  DATA 20,4F
005CE:  DATA 6E,00
005D0:  DATA 0C,42
005D2:  DATA 61,63
005D4:  DATA 6B,6C
005D6:  DATA 69,67
005D8:  DATA 68,74
005DA:  DATA 20,4F
005DC:  DATA 66,66
005DE:  DATA 00,00
005E0:  DATA 41,54
005E2:  DATA 2B,43
005E4:  DATA 57,4D
005E6:  DATA 4F,44
005E8:  DATA 45,5F
005EA:  DATA 44,45
005EC:  DATA 46,3D
005EE:  DATA 31,0D
005F0:  DATA 0A,00
005F2:  DATA 0C,43
005F4:  DATA 6F,6E
005F6:  DATA 66,69
005F8:  DATA 67,20
005FA:  DATA 43,6C
005FC:  DATA 69,65
005FE:  DATA 6E,74
00600:  DATA 65,00
00602:  DATA 41,54
00604:  DATA 2B,43
00606:  DATA 57,4D
00608:  DATA 4F,44
0060A:  DATA 45,5F
0060C:  DATA 44,45
0060E:  DATA 46,3D
00610:  DATA 32,0D
00612:  DATA 0A,00
00614:  DATA 0C,43
00616:  DATA 6F,6E
00618:  DATA 66,69
0061A:  DATA 67,20
0061C:  DATA 41,50
0061E:  DATA 00,00
00620:  DATA 41,54
00622:  DATA 2B,43
00624:  DATA 57,4D
00626:  DATA 4F,44
00628:  DATA 45,5F
0062A:  DATA 44,45
0062C:  DATA 46,3D
0062E:  DATA 33,0D
00630:  DATA 0A,00
00632:  DATA 0C,43
00634:  DATA 6F,6E
00636:  DATA 66,69
00638:  DATA 67,20
0063A:  DATA 43,6C
0063C:  DATA 69,65
0063E:  DATA 6E,74
00640:  DATA 65,41
00642:  DATA 50,00
*
00836:  ADDWF  FE8,W
00838:  CLRF   FF7
0083A:  RLCF   FF7,F
0083C:  ADDLW  51
0083E:  MOVWF  FF6
00840:  MOVLW  08
00842:  ADDWFC FF7,F
00844:  TBLRD*-
00846:  MOVF   FF5,W
00848:  MOVWF  FFA
0084A:  TBLRD*
0084C:  MOVF   FF5,W
0084E:  MOVWF  FF9
00850:  DATA 5A,06
00852:  DATA B2,06
00854:  DATA 88,06
00856:  DATA DC,06
00858:  DATA 06,07
*
00906:  ADDWF  FE8,W
00908:  CLRF   FF7
0090A:  RLCF   FF7,F
0090C:  ADDLW  21
0090E:  MOVWF  FF6
00910:  MOVLW  09
00912:  ADDWFC FF7,F
00914:  TBLRD*-
00916:  MOVF   FF5,W
00918:  MOVWF  FFA
0091A:  TBLRD*
0091C:  MOVF   FF5,W
0091E:  MOVWF  FF9
00920:  DATA FA,08
00922:  DATA FA,08
00924:  DATA FA,08
00926:  DATA FA,08
00928:  DATA FA,08
*
009A0:  ADDWF  FE8,W
009A2:  CLRF   FF7
009A4:  RLCF   FF7,F
009A6:  ADDLW  BB
009A8:  MOVWF  FF6
009AA:  MOVLW  09
009AC:  ADDWFC FF7,F
009AE:  TBLRD*-
009B0:  MOVF   FF5,W
009B2:  MOVWF  FFA
009B4:  TBLRD*
009B6:  MOVF   FF5,W
009B8:  MOVWF  FF9
009BA:  DATA 94,09
009BC:  DATA 94,09
009BE:  DATA 94,09
009C0:  DATA 94,09
*
00C24:  DATA 0C,43
00C26:  DATA 6F,6E
00C28:  DATA 66,69
00C2A:  DATA 67,75
00C2C:  DATA 72,61
00C2E:  DATA 6E,64
00C30:  DATA 6F,2E
00C32:  DATA 2E,2E
00C34:  DATA 00,00
*
00ECE:  TBLRD*+
00ED0:  MOVF   FF5,F
00ED2:  BZ    0EEC
00ED4:  MOVFF  FF6,100
00ED8:  MOVFF  FF7,101
00EDC:  MOVFF  FF5,102
00EE0:  RCALL  0E62
00EE2:  MOVFF  100,FF6
00EE6:  MOVFF  101,FF7
00EEA:  BRA    0ECE
00EEC:  RETURN 0
00EEE:  TBLRD*+
00EF0:  MOVF   FF5,F
00EF2:  BZ    0F0E
00EF4:  MOVFF  FF6,125
00EF8:  MOVFF  FF7,126
00EFC:  MOVF   FF5,W
00EFE:  BTFSS  F9E.4
00F00:  BRA    0EFE
00F02:  MOVWF  FAD
00F04:  MOVFF  125,FF6
00F08:  MOVFF  126,FF7
00F0C:  BRA    0EEE
00F0E:  RETURN 0
00F10:  TBLRD*+
00F12:  MOVFF  FF6,126
00F16:  MOVFF  FF7,127
00F1A:  MOVF   FF5,W
00F1C:  BTFSS  F9E.4
00F1E:  BRA    0F1C
00F20:  MOVWF  FAD
00F22:  MOVFF  126,FF6
00F26:  MOVFF  127,FF7
00F2A:  MOVLB  1
00F2C:  DECFSZ x25,F
00F2E:  BRA    0F32
00F30:  BRA    0F36
00F32:  MOVLB  0
00F34:  BRA    0F10
00F36:  MOVLB  0
00F38:  RETURN 0
*
01042:  MOVF   FEF,F
01044:  BZ    1066
01046:  MOVFF  FEA,126
0104A:  MOVFF  FE9,125
0104E:  MOVF   FEF,W
01050:  BTFSS  F9E.4
01052:  BRA    1050
01054:  MOVWF  FAD
01056:  MOVFF  126,FEA
0105A:  MOVFF  125,FE9
0105E:  INCF   FE9,F
01060:  BTFSC  FD8.2
01062:  INCF   FEA,F
01064:  BRA    1042
01066:  RETURN 0
*
01288:  MOVLB  1
0128A:  MOVF   x27,W
0128C:  ANDLW  07
0128E:  MOVWF  00
01290:  RRCF   x27,W
01292:  MOVWF  01
01294:  RRCF   01,F
01296:  RRCF   01,F
01298:  MOVLW  1F
0129A:  ANDWF  01,F
0129C:  MOVF   01,W
0129E:  ADDWF  x29,W
012A0:  MOVWF  FE9
012A2:  MOVLW  00
012A4:  ADDWFC x2A,W
012A6:  MOVWF  FEA
012A8:  CLRF   01
012AA:  INCF   01,F
012AC:  INCF   00,F
012AE:  BRA    12B2
012B0:  RLCF   01,F
012B2:  DECFSZ 00,F
012B4:  BRA    12B0
012B6:  MOVF   x28,F
012B8:  BZ    12C0
012BA:  MOVF   01,W
012BC:  IORWF  FEF,F
012BE:  BRA    12C6
012C0:  COMF   01,F
012C2:  MOVF   01,W
012C4:  ANDWF  FEF,F
012C6:  MOVLB  0
012C8:  RETURN 0
*
01940:  BTFSC  FD8.1
01942:  BRA    194C
01944:  MOVLW  01
01946:  MOVWF  FEA
01948:  MOVLW  15
0194A:  MOVWF  FE9
0194C:  CLRF   00
0194E:  CLRF   01
01950:  CLRF   02
01952:  CLRF   03
01954:  MOVLB  1
01956:  CLRF   x15
01958:  CLRF   x16
0195A:  CLRF   x17
0195C:  CLRF   x18
0195E:  MOVF   x14,W
01960:  IORWF  x13,W
01962:  IORWF  x12,W
01964:  IORWF  x11,W
01966:  BZ    19C0
01968:  MOVLW  20
0196A:  MOVWF  x19
0196C:  BCF    FD8.0
0196E:  RLCF   x0D,F
01970:  RLCF   x0E,F
01972:  RLCF   x0F,F
01974:  RLCF   x10,F
01976:  RLCF   x15,F
01978:  RLCF   x16,F
0197A:  RLCF   x17,F
0197C:  RLCF   x18,F
0197E:  MOVF   x14,W
01980:  SUBWF  x18,W
01982:  BNZ   1994
01984:  MOVF   x13,W
01986:  SUBWF  x17,W
01988:  BNZ   1994
0198A:  MOVF   x12,W
0198C:  SUBWF  x16,W
0198E:  BNZ   1994
01990:  MOVF   x11,W
01992:  SUBWF  x15,W
01994:  BNC   19B4
01996:  MOVF   x11,W
01998:  SUBWF  x15,F
0199A:  MOVF   x12,W
0199C:  BTFSS  FD8.0
0199E:  INCFSZ x12,W
019A0:  SUBWF  x16,F
019A2:  MOVF   x13,W
019A4:  BTFSS  FD8.0
019A6:  INCFSZ x13,W
019A8:  SUBWF  x17,F
019AA:  MOVF   x14,W
019AC:  BTFSS  FD8.0
019AE:  INCFSZ x14,W
019B0:  SUBWF  x18,F
019B2:  BSF    FD8.0
019B4:  RLCF   00,F
019B6:  RLCF   01,F
019B8:  RLCF   02,F
019BA:  RLCF   03,F
019BC:  DECFSZ x19,F
019BE:  BRA    196C
019C0:  MOVFF  115,FEF
019C4:  MOVFF  116,FEC
019C8:  MOVFF  117,FEC
019CC:  MOVFF  118,FEC
019D0:  MOVLB  0
019D2:  GOTO   1AB6 (RETURN)
019D6:  MOVLB  1
019D8:  CLRF   x15
019DA:  CLRF   x16
019DC:  MOVLW  01
019DE:  MOVWF  x17
019E0:  CLRF   FDA
019E2:  CLRF   FD9
019E4:  MOVWF  x1A
019E6:  MOVLW  0D
019E8:  MOVWF  x19
019EA:  MOVLW  01
019EC:  MOVWF  FEA
019EE:  MOVLW  11
019F0:  MOVWF  FE9
019F2:  MOVFF  11A,FE2
019F6:  MOVFF  119,FE1
019FA:  MOVFF  117,118
019FE:  BCF    FD8.0
01A00:  MOVF   FE5,W
01A02:  MULWF  FEE
01A04:  MOVF   FF3,W
01A06:  ADDWFC x15,F
01A08:  MOVF   FF4,W
01A0A:  ADDWFC x16,F
01A0C:  DECFSZ x18,F
01A0E:  BRA    19FE
01A10:  MOVFF  115,FDE
01A14:  MOVFF  116,115
01A18:  CLRF   x16
01A1A:  BTFSC  FD8.0
01A1C:  INCF   x16,F
01A1E:  INCF   x19,F
01A20:  BTFSC  FD8.2
01A22:  INCF   x1A,F
01A24:  INCF   x17,F
01A26:  MOVF   x17,W
01A28:  SUBLW  05
01A2A:  BNZ   19EA
01A2C:  MOVLB  0
01A2E:  GOTO   1AE6 (RETURN)
*
01F02:  MOVF   FEF,F
01F04:  BZ    1F26
01F06:  MOVFF  FEA,FE
01F0A:  MOVFF  FE9,FD
01F0E:  MOVFF  FEF,102
01F12:  CALL   0E62
01F16:  MOVFF  FE,FEA
01F1A:  MOVFF  FD,FE9
01F1E:  INCF   FE9,F
01F20:  BTFSC  FD8.2
01F22:  INCF   FEA,F
01F24:  BRA    1F02
01F26:  RETURN 0
*
02314:  MOVFF  FF2,0D
02318:  BCF    FF2.7
0231A:  ADDWF  FE8,W
0231C:  CLRF   FF7
0231E:  RLCF   FF7,F
02320:  ADDLW  39
02322:  MOVWF  FF6
02324:  MOVLW  23
02326:  ADDWFC FF7,F
02328:  TBLRD*-
0232A:  MOVF   FF5,W
0232C:  MOVWF  FFA
0232E:  TBLRD*
02330:  MOVF   FF5,W
02332:  BTFSC  0D.7
02334:  BSF    FF2.7
02336:  MOVWF  FF9
02338:  DATA C4,21
0233A:  DATA FC,21
0233C:  DATA 48,22
0233E:  DATA 94,22
02340:  DATA 8C,21
02342:  DATA E0,22
02344:  DATA E4,22
02346:  DATA 08,23
*
025AE:  MOVFF  FF2,0D
025B2:  BCF    FF2.7
025B4:  ADDWF  FE8,W
025B6:  CLRF   FF7
025B8:  RLCF   FF7,F
025BA:  ADDLW  D3
025BC:  MOVWF  FF6
025BE:  MOVLW  25
025C0:  ADDWFC FF7,F
025C2:  TBLRD*-
025C4:  MOVF   FF5,W
025C6:  MOVWF  FFA
025C8:  TBLRD*
025CA:  MOVF   FF5,W
025CC:  BTFSC  0D.7
025CE:  BSF    FF2.7
025D0:  MOVWF  FF9
025D2:  DATA 88,25
025D4:  DATA 92,25
025D6:  DATA 9C,25
025D8:  DATA A4,25
....................  
.................... #list 
....................  
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20M) 
*
00C36:  MOVLW  01
00C38:  MOVWF  FEA
00C3A:  MOVLW  26
00C3C:  MOVWF  FE9
00C3E:  MOVF   FEF,W
00C40:  BZ    0C5C
00C42:  MOVLW  06
00C44:  MOVWF  01
00C46:  CLRF   00
00C48:  DECFSZ 00,F
00C4A:  BRA    0C48
00C4C:  DECFSZ 01,F
00C4E:  BRA    0C46
00C50:  MOVLW  7B
00C52:  MOVWF  00
00C54:  DECFSZ 00,F
00C56:  BRA    0C54
00C58:  DECFSZ FEF,F
00C5A:  BRA    0C42
00C5C:  RETURN 0
*
01A32:  MOVLW  03
01A34:  MOVLB  1
01A36:  SUBWF  x0E,F
01A38:  BNC   1A4E
01A3A:  MOVLW  01
01A3C:  MOVWF  FEA
01A3E:  MOVLW  0E
01A40:  MOVWF  FE9
01A42:  MOVF   FEF,W
01A44:  BZ    1A4E
01A46:  BRA    1A4A
01A48:  BRA    1A4A
01A4A:  DECFSZ FEF,F
01A4C:  BRA    1A48
01A4E:  MOVLB  0
01A50:  RETURN 0
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... const int16 PIN_OUT[8]={ 
....................                         PIN_E2, 
....................                         PIN_E1, 
....................                         PIN_E0, 
....................                         PIN_A4, 
....................                         PIN_A0, 
....................                         PIN_A1, 
....................                         PIN_A2, 
....................                         PIN_A3 
....................                         }; 
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00D00:  BSF    F95.4
....................    output_float(LCD_DATA5); 
00D02:  BSF    F95.5
....................    output_float(LCD_DATA6); 
00D04:  BSF    F95.6
....................    output_float(LCD_DATA7); 
00D06:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00D08:  BSF    F8C.1
00D0A:  BCF    F95.1
....................    delay_cycles(1); 
00D0C:  NOP   
....................    lcd_output_enable(1); 
00D0E:  BSF    F8C.0
00D10:  BCF    F95.0
....................    delay_cycles(1); 
00D12:  NOP   
....................    high = lcd_read_nibble(); 
00D14:  RCALL  0CAA
00D16:  MOVFF  01,10A
....................        
....................    lcd_output_enable(0); 
00D1A:  BCF    F8C.0
00D1C:  BCF    F95.0
....................    delay_cycles(1); 
00D1E:  NOP   
....................    lcd_output_enable(1); 
00D20:  BSF    F8C.0
00D22:  BCF    F95.0
....................    delay_us(1); 
00D24:  BRA    0D26
00D26:  BRA    0D28
00D28:  NOP   
....................    low = lcd_read_nibble(); 
00D2A:  RCALL  0CAA
00D2C:  MOVFF  01,109
....................        
....................    lcd_output_enable(0); 
00D30:  BCF    F8C.0
00D32:  BCF    F95.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00D34:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00D36:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00D38:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00D3A:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00D3C:  MOVLB  1
00D3E:  SWAPF  x0A,W
00D40:  MOVWF  00
00D42:  MOVLW  F0
00D44:  ANDWF  00,F
00D46:  MOVF   00,W
00D48:  IORWF  x09,W
00D4A:  MOVWF  01
00D4C:  MOVLB  0
00D4E:  GOTO   0D5E (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00CAA:  MOVLB  1
00CAC:  CLRF   x0B
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00CAE:  BSF    F95.4
00CB0:  MOVLW  00
00CB2:  BTFSC  F83.4
00CB4:  MOVLW  01
00CB6:  IORWF  x0B,F
....................    n |= input(LCD_DATA5) << 1; 
00CB8:  BSF    F95.5
00CBA:  MOVLW  00
00CBC:  BTFSC  F83.5
00CBE:  MOVLW  01
00CC0:  MOVWF  00
00CC2:  BCF    FD8.0
00CC4:  RLCF   00,F
00CC6:  MOVF   00,W
00CC8:  IORWF  x0B,F
....................    n |= input(LCD_DATA6) << 2; 
00CCA:  BSF    F95.6
00CCC:  MOVLW  00
00CCE:  BTFSC  F83.6
00CD0:  MOVLW  01
00CD2:  MOVWF  00
00CD4:  RLCF   00,F
00CD6:  RLCF   00,F
00CD8:  MOVLW  FC
00CDA:  ANDWF  00,F
00CDC:  MOVF   00,W
00CDE:  IORWF  x0B,F
....................    n |= input(LCD_DATA7) << 3; 
00CE0:  BSF    F95.7
00CE2:  MOVLW  00
00CE4:  BTFSC  F83.7
00CE6:  MOVLW  01
00CE8:  MOVWF  00
00CEA:  RLCF   00,F
00CEC:  RLCF   00,F
00CEE:  RLCF   00,F
00CF0:  MOVLW  F8
00CF2:  ANDWF  00,F
00CF4:  MOVF   00,W
00CF6:  IORWF  x0B,F
....................     
....................    return(n); 
00CF8:  MOVFF  10B,01
....................   #else 
00CFC:  MOVLB  0
00CFE:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00C5E:  MOVLB  1
00C60:  BTFSC  x0A.0
00C62:  BRA    0C68
00C64:  BCF    F8C.4
00C66:  BRA    0C6A
00C68:  BSF    F8C.4
00C6A:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00C6C:  BTFSC  x0A.1
00C6E:  BRA    0C74
00C70:  BCF    F8C.5
00C72:  BRA    0C76
00C74:  BSF    F8C.5
00C76:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00C78:  BTFSC  x0A.2
00C7A:  BRA    0C80
00C7C:  BCF    F8C.6
00C7E:  BRA    0C82
00C80:  BSF    F8C.6
00C82:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00C84:  BTFSC  x0A.3
00C86:  BRA    0C8C
00C88:  BCF    F8C.7
00C8A:  BRA    0C8E
00C8C:  BSF    F8C.7
00C8E:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00C90:  NOP   
....................    lcd_output_enable(1); 
00C92:  BSF    F8C.0
00C94:  BCF    F95.0
....................    delay_us(2); 
00C96:  MOVLW  02
00C98:  MOVWF  00
00C9A:  DECFSZ 00,F
00C9C:  BRA    0C9A
00C9E:  BRA    0CA0
00CA0:  NOP   
....................    lcd_output_enable(0); 
00CA2:  BCF    F8C.0
00CA4:  BCF    F95.0
00CA6:  MOVLB  0
00CA8:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00D52:  BCF    F95.0
....................    lcd_rs_tris(); 
00D54:  BCF    F95.2
....................    lcd_rw_tris(); 
00D56:  BCF    F95.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00D58:  BCF    F8C.2
00D5A:  BCF    F95.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
00D5C:  BRA    0D00
00D5E:  MOVFF  01,109
00D62:  MOVLB  1
00D64:  BTFSS  01.7
00D66:  BRA    0D6C
00D68:  MOVLB  0
00D6A:  BRA    0D5C
....................    lcd_output_rs(address); 
00D6C:  MOVF   x07,F
00D6E:  BNZ   0D74
00D70:  BCF    F8C.2
00D72:  BRA    0D76
00D74:  BSF    F8C.2
00D76:  BCF    F95.2
....................    delay_cycles(1); 
00D78:  NOP   
....................    lcd_output_rw(0); 
00D7A:  BCF    F8C.1
00D7C:  BCF    F95.1
....................    delay_cycles(1); 
00D7E:  NOP   
....................    lcd_output_enable(0); 
00D80:  BCF    F8C.0
00D82:  BCF    F95.0
....................    lcd_send_nibble(n >> 4); 
00D84:  SWAPF  x08,W
00D86:  MOVWF  x09
00D88:  MOVLW  0F
00D8A:  ANDWF  x09,F
00D8C:  MOVFF  109,10A
00D90:  MOVLB  0
00D92:  RCALL  0C5E
....................    lcd_send_nibble(n & 0xf); 
00D94:  MOVLB  1
00D96:  MOVF   x08,W
00D98:  ANDLW  0F
00D9A:  MOVWF  x09
00D9C:  MOVWF  x0A
00D9E:  MOVLB  0
00DA0:  RCALL  0C5E
00DA2:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00DA4:  MOVLW  28
00DA6:  MOVWF  xFB
00DA8:  MOVLW  0C
00DAA:  MOVWF  xFC
00DAC:  MOVLW  01
00DAE:  MOVWF  xFD
00DB0:  MOVLW  06
00DB2:  MOVWF  xFE
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00DB4:  BCF    F8C.0
00DB6:  BCF    F95.0
....................    lcd_output_rs(0); 
00DB8:  BCF    F8C.2
00DBA:  BCF    F95.2
....................    lcd_output_rw(0); 
00DBC:  BCF    F8C.1
00DBE:  BCF    F95.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00DC0:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00DC2:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00DC4:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00DC6:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00DC8:  BCF    F95.0
....................    lcd_rs_tris(); 
00DCA:  BCF    F95.2
....................    lcd_rw_tris(); 
00DCC:  BCF    F95.1
....................  #endif 
....................      
....................    delay_ms(15); 
00DCE:  MOVLW  0F
00DD0:  MOVLB  1
00DD2:  MOVWF  x26
00DD4:  MOVLB  0
00DD6:  RCALL  0C36
....................    for(i=1;i<=3;++i) 
00DD8:  MOVLW  01
00DDA:  MOVWF  xFA
00DDC:  MOVF   xFA,W
00DDE:  SUBLW  03
00DE0:  BNC   0DFA
....................    { 
....................        lcd_send_nibble(3); 
00DE2:  MOVLW  03
00DE4:  MOVLB  1
00DE6:  MOVWF  x0A
00DE8:  MOVLB  0
00DEA:  RCALL  0C5E
....................        delay_ms(5); 
00DEC:  MOVLW  05
00DEE:  MOVLB  1
00DF0:  MOVWF  x26
00DF2:  MOVLB  0
00DF4:  RCALL  0C36
00DF6:  INCF   xFA,F
00DF8:  BRA    0DDC
....................    } 
....................     
....................    lcd_send_nibble(2); 
00DFA:  MOVLW  02
00DFC:  MOVLB  1
00DFE:  MOVWF  x0A
00E00:  MOVLB  0
00E02:  RCALL  0C5E
....................    delay_ms(5); 
00E04:  MOVLW  05
00E06:  MOVLB  1
00E08:  MOVWF  x26
00E0A:  MOVLB  0
00E0C:  RCALL  0C36
....................    for(i=0;i<=3;++i) 
00E0E:  CLRF   xFA
00E10:  MOVF   xFA,W
00E12:  SUBLW  03
00E14:  BNC   0E38
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00E16:  CLRF   03
00E18:  MOVF   xFA,W
00E1A:  ADDLW  FB
00E1C:  MOVWF  FE9
00E1E:  MOVLW  00
00E20:  ADDWFC 03,W
00E22:  MOVWF  FEA
00E24:  MOVFF  FEF,FF
00E28:  MOVLB  1
00E2A:  CLRF   x07
00E2C:  MOVFF  FF,108
00E30:  MOVLB  0
00E32:  RCALL  0D52
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00E34:  INCF   xFA,F
00E36:  BRA    0E10
00E38:  GOTO   2568 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00E3C:  MOVLB  1
00E3E:  DECFSZ x04,W
00E40:  BRA    0E44
00E42:  BRA    0E4A
....................       address=LCD_LINE_TWO; 
00E44:  MOVLW  40
00E46:  MOVWF  x05
00E48:  BRA    0E4C
....................    else 
....................       address=0; 
00E4A:  CLRF   x05
....................       
....................    address+=x-1; 
00E4C:  MOVLW  01
00E4E:  SUBWF  x03,W
00E50:  ADDWF  x05,F
....................    lcd_send_byte(0,0x80|address); 
00E52:  MOVF   x05,W
00E54:  IORLW  80
00E56:  MOVWF  x06
00E58:  CLRF   x07
00E5A:  MOVWF  x08
00E5C:  MOVLB  0
00E5E:  RCALL  0D52
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00E60:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00E62:  MOVLB  1
00E64:  MOVF   x02,W
00E66:  XORLW  07
00E68:  MOVLB  0
00E6A:  BZ    0E7A
00E6C:  XORLW  0B
00E6E:  BZ    0E88
00E70:  XORLW  06
00E72:  BZ    0EA0
00E74:  XORLW  02
00E76:  BZ    0EB0
00E78:  BRA    0EBE
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00E7A:  MOVLW  01
00E7C:  MOVLB  1
00E7E:  MOVWF  x03
00E80:  MOVWF  x04
00E82:  MOVLB  0
00E84:  RCALL  0E3C
00E86:  BRA    0ECC
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
00E88:  MOVLB  1
00E8A:  CLRF   x07
00E8C:  MOVLW  01
00E8E:  MOVWF  x08
00E90:  MOVLB  0
00E92:  RCALL  0D52
....................                      delay_ms(2); 
00E94:  MOVLW  02
00E96:  MOVLB  1
00E98:  MOVWF  x26
00E9A:  MOVLB  0
00E9C:  RCALL  0C36
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
00E9E:  BRA    0ECC
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00EA0:  MOVLW  01
00EA2:  MOVLB  1
00EA4:  MOVWF  x03
00EA6:  MOVLW  02
00EA8:  MOVWF  x04
00EAA:  MOVLB  0
00EAC:  RCALL  0E3C
00EAE:  BRA    0ECC
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00EB0:  MOVLB  1
00EB2:  CLRF   x07
00EB4:  MOVLW  10
00EB6:  MOVWF  x08
00EB8:  MOVLB  0
00EBA:  RCALL  0D52
00EBC:  BRA    0ECC
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
00EBE:  MOVLW  01
00EC0:  MOVLB  1
00EC2:  MOVWF  x07
00EC4:  MOVFF  102,108
00EC8:  MOVLB  0
00ECA:  RCALL  0D52
....................      #endif 
....................    } 
00ECC:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
01A52:  MOVLB  1
01A54:  CLRF   x04
01A56:  CLRF   x03
01A58:  CLRF   x06
01A5A:  CLRF   x05
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
01A5C:  MOVF   x00,F
01A5E:  BNZ   1A6C
01A60:  MOVLB  0
01A62:  MOVF   xFF,W
01A64:  SUBLW  13
01A66:  BTFSC  FD8.0
01A68:  BRA    1BA4
01A6A:  MOVLB  1
01A6C:  MOVF   x00,W
01A6E:  SUBLW  4E
01A70:  BTFSC  FD8.0
01A72:  BRA    1A78
01A74:  MOVLB  0
01A76:  BRA    1BA4
01A78:  BNZ   1A86
01A7A:  MOVLB  0
01A7C:  MOVF   xFF,W
01A7E:  SUBLW  20
01A80:  BTFSS  FD8.0
01A82:  BRA    1BA4
01A84:  MOVLB  1
....................       tmp=100000; 
01A86:  CLRF   x0C
01A88:  MOVLW  01
01A8A:  MOVWF  x0B
01A8C:  MOVLW  86
01A8E:  MOVWF  x0A
01A90:  MOVLW  A0
01A92:  MOVWF  x09
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
01A94:  BCF    FD8.1
01A96:  MOVFF  10C,110
01A9A:  MOVFF  10B,10F
01A9E:  MOVFF  10A,10E
01AA2:  MOVFF  109,10D
01AA6:  CLRF   x14
01AA8:  CLRF   x13
01AAA:  MOVFF  100,112
01AAE:  MOVFF  FF,111
01AB2:  MOVLB  0
01AB4:  BRA    1940
01AB6:  MOVFF  03,10C
01ABA:  MOVFF  02,10B
01ABE:  MOVFF  01,10A
01AC2:  MOVFF  00,109
....................       tmp*=5;    
01AC6:  MOVFF  10C,110
01ACA:  MOVFF  10B,10F
01ACE:  MOVFF  10A,10E
01AD2:  MOVFF  109,10D
01AD6:  MOVLB  1
01AD8:  CLRF   x14
01ADA:  CLRF   x13
01ADC:  CLRF   x12
01ADE:  MOVLW  05
01AE0:  MOVWF  x11
01AE2:  MOVLB  0
01AE4:  BRA    19D6
01AE6:  MOVFF  03,10C
01AEA:  MOVFF  02,10B
01AEE:  MOVFF  01,10A
01AF2:  MOVFF  00,109
....................       uS=tmp; 
01AF6:  MOVFF  10A,108
01AFA:  MOVFF  109,107
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
01AFE:  BCF    F93.2
01B00:  BSF    F8A.2
....................          delay_us(uS);           // con los retardos mientras 
01B02:  MOVFF  108,10D
01B06:  MOVLB  1
01B08:  INCF   x0D,F
01B0A:  DECF   x0D,F
01B0C:  BTFSC  FD8.2
01B0E:  BRA    1B1A
01B10:  SETF   x0E
01B12:  MOVLB  0
01B14:  RCALL  1A32
01B16:  MOVLB  1
01B18:  BRA    1B0A
01B1A:  MOVFF  107,10E
01B1E:  MOVLB  0
01B20:  RCALL  1A32
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
01B22:  MOVLB  1
01B24:  MOVF   x07,W
01B26:  ADDWF  x05,F
01B28:  MOVF   x08,W
01B2A:  ADDWFC x06,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
01B2C:  BCF    F93.2
01B2E:  BCF    F8A.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
01B30:  MOVFF  108,10D
01B34:  INCF   x0D,F
01B36:  DECF   x0D,F
01B38:  BTFSC  FD8.2
01B3A:  BRA    1B46
01B3C:  SETF   x0E
01B3E:  MOVLB  0
01B40:  RCALL  1A32
01B42:  MOVLB  1
01B44:  BRA    1B36
01B46:  MOVFF  107,10E
01B4A:  MOVLB  0
01B4C:  RCALL  1A32
....................          CiclosL+=(uS);          //  
01B4E:  MOVLB  1
01B50:  MOVF   x07,W
01B52:  ADDWF  x05,F
01B54:  MOVF   x08,W
01B56:  ADDWFC x06,F
....................          CiclosL+=25;            // Compensador. 
01B58:  MOVLW  19
01B5A:  ADDWF  x05,F
01B5C:  MOVLW  00
01B5E:  ADDWFC x06,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
01B60:  MOVF   x06,W
01B62:  SUBLW  02
01B64:  BC    1B88
01B66:  XORLW  FF
01B68:  BNZ   1B70
01B6A:  MOVF   x05,W
01B6C:  SUBLW  E7
01B6E:  BC    1B88
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
01B70:  MOVLW  E8
01B72:  SUBWF  x05,F
01B74:  MOVLW  03
01B76:  SUBWFB x06,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
01B78:  INCF   x03,F
01B7A:  BTFSC  FD8.2
01B7C:  INCF   x04,F
....................             CiclosL+=25;         // Compensador. 
01B7E:  MOVLW  19
01B80:  ADDWF  x05,F
01B82:  MOVLW  00
01B84:  ADDWFC x06,F
01B86:  BRA    1B60
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
01B88:  MOVF   x04,W
01B8A:  SUBWF  x02,W
01B8C:  BNC   1BA2
01B8E:  BTFSC  FD8.2
01B90:  BRA    1B96
01B92:  MOVLB  0
01B94:  BRA    1AFE
01B96:  MOVF   x01,W
01B98:  SUBWF  x03,W
01B9A:  BTFSC  FD8.0
01B9C:  BRA    1BA2
01B9E:  MOVLB  0
01BA0:  BRA    1AFE
01BA2:  MOVLB  0
....................                                          // tiempo indicado. 
....................    } 
01BA4:  RETURN 0
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /***************************************************************** 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... ****************************************************************** 
....................  
.................... ******************************************** 
.................... *   Formato de comando en la respuesta:    * 
.................... *   INICIO:COMANDO:DATOS:<-(FIN)           * 
.................... *   e.g. CMD:CMD_SSID_AND_PASS,DATA:       * 
.................... ******************************************** 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:OP,[op][port]:                 | 
.................... |-----------------------------------------------| 
.................... |> Realiaza Operaciones en el Puerto de Salida  | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,[1|0][0-7]:                       | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      op:    1   -> Encender                   | 
.................... |             0   -> Apagar                     | 
.................... |      port:  0-7 -> No. del puerto.            | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,10:  Enciende el PORT 0        | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NC,"SSID","KEY":               | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el SSID y Key de la    | 
.................... |  Red donde se conectara.                      | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NC,"SSID","KEY":                     | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      SSID:  "Nombre de la Red."               | 
.................... |                                               | 
.................... |      KEY:   "Clave."                          | 
.................... |                                               | 
.................... |** @e.g. CMD:NC,"myRed","12345678":            | 
.................... | Intentara conectarse y almacenar en la eeprom | 
.................... | al nombre de la red con key pasados como      | 
.................... | parametro.                                    | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:AP,"SSID","KEY":               | 
.................... |-----------------------------------------------| 
.................... |> Setea directamenete en el ESP8266 el SSID y  | 
.................... |  el Key de la Red en modo AccessPoint         | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:AP,"SSID","KEY":                     | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      SSID:  "Nombre de la Red."               | 
.................... |                                               | 
.................... |      KEY:   "Clave."                          | 
.................... |                                               | 
.................... |** @e.g. CMD:AP,"myRed","12345678":            | 
.................... | Establece en la memoria del ESP8266 el SSID   | 
.................... | de la red AP con key pasados como parametro.  | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NM,[ModeConection]:            | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el modo de la conexion | 
.................... |                                               | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NM,[1|2|3]:                          | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      ModeConection:  "1" -> STA               | 
.................... |                      "2" -> AP                | 
.................... |                      "3" -> STA/AP            | 
.................... |                                               | 
.................... |** @e.g. CMD:NM,3:                             | 
.................... |                                               | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:OS,0:                          | 
.................... |-----------------------------------------------| 
.................... |> Retorna el estado de las salidas del Port    | 
.................... |  En una cadena separada por comas, el ultimo  | 
.................... |  valor hace referencia al modo de funcionami. | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,0:                                | 
.................... |                                               | 
.................... |   @Param: "0" -> No usado                     | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,0:                             | 
.................... |    Ret: 0,0,0,0,0,0,0,0,3                     | 
.................... +-----------------------------------------------+ 
.................... */ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio recepcion de request,  
.................... y retorna el ID de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
00A04:  MOVLW  05
00A06:  MOVLB  1
00A08:  MOVWF  x34
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
00A0A:  DECFSZ 55,W
00A0C:  BRA    0A34
....................        
....................       if(buffer!=','){ 
00A0E:  MOVF   x32,W
00A10:  SUBLW  2C
00A12:  BNZ   0A18
00A14:  MOVF   x33,F
00A16:  BZ    0A2E
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
00A18:  CLRF   03
00A1A:  MOVF   59,W
00A1C:  ADDLW  1C
00A1E:  MOVWF  FE9
00A20:  MOVLW  00
00A22:  ADDWFC 03,W
00A24:  MOVWF  FEA
00A26:  MOVFF  132,FEF
....................          flag_Pos_Resp_IPD++; 
00A2A:  INCF   59,F
....................       }else{ 
00A2C:  BRA    0A32
....................          flag_Pos_Resp_IPD       = 0x00; 
00A2E:  CLRF   59
....................          flag_Resp_IPD           = 0x00; 
00A30:  CLRF   55
....................       } 
....................    }else{ 
00A32:  BRA    0A66
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
00A34:  CLRF   03
00A36:  MOVF   59,W
00A38:  MOVFF  FF2,135
00A3C:  BCF    FF2.7
00A3E:  MOVLB  0
00A40:  CALL   00C0
00A44:  MOVLB  1
00A46:  BTFSC  x35.7
00A48:  BSF    FF2.7
00A4A:  MOVWF  01
00A4C:  SUBWF  x32,W
00A4E:  BNZ   0A64
00A50:  MOVF   x33,F
00A52:  BNZ   0A64
....................       { 
....................          flag_Pos_Resp_IPD++; 
00A54:  INCF   59,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
00A56:  MOVF   x34,W
00A58:  SUBWF  59,W
00A5A:  BNZ   0A62
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
00A5C:  MOVLW  01
00A5E:  MOVWF  55
....................             flag_Pos_Resp_IPD = 0; 
00A60:  CLRF   59
....................          } 
....................       }else{ 
00A62:  BRA    0A66
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
00A64:  CLRF   59
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00A66:  MOVLB  0
00A68:  GOTO   0BEE (RETURN)
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
.................... Funcion Busca la cadena de inicio comando,  
.................... y retorna el Comando enviado, Activa la bandera 
.................... de recepcion de datos 
.................... *********************************************************/ 
....................  
.................... void ESP8266_Get_CMD(char buffer[]){ 
00A6C:  MOVLW  04
00A6E:  MOVLB  1
00A70:  MOVWF  x34
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
00A72:  DECFSZ 54,W
00A74:  BRA    0AA0
....................     
....................       if(buffer!=','){ 
00A76:  MOVF   x32,W
00A78:  SUBLW  2C
00A7A:  BNZ   0A80
00A7C:  MOVF   x33,F
00A7E:  BZ    0A96
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
00A80:  CLRF   03
00A82:  MOVF   58,W
00A84:  ADDLW  1E
00A86:  MOVWF  FE9
00A88:  MOVLW  00
00A8A:  ADDWFC 03,W
00A8C:  MOVWF  FEA
00A8E:  MOVFF  132,FEF
....................          flag_Pos_Resp_CMD++; 
00A92:  INCF   58,F
....................       }else{         
00A94:  BRA    0A9E
....................          flag_Pos_Resp_CMD = 0x00; 
00A96:  CLRF   58
....................          flag_Resp_CMD     = 0x00; 
00A98:  CLRF   54
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
00A9A:  MOVLW  01
00A9C:  MOVWF  56
....................       } 
....................        
....................    }else{ 
00A9E:  BRA    0AD2
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
00AA0:  CLRF   03
00AA2:  MOVF   58,W
00AA4:  MOVFF  FF2,135
00AA8:  BCF    FF2.7
00AAA:  MOVLB  0
00AAC:  CALL   00D6
00AB0:  MOVLB  1
00AB2:  BTFSC  x35.7
00AB4:  BSF    FF2.7
00AB6:  MOVWF  01
00AB8:  SUBWF  x32,W
00ABA:  BNZ   0AD0
00ABC:  MOVF   x33,F
00ABE:  BNZ   0AD0
....................       { 
....................          flag_Pos_Resp_CMD++; 
00AC0:  INCF   58,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
00AC2:  MOVF   x34,W
00AC4:  SUBWF  58,W
00AC6:  BNZ   0ACE
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
00AC8:  MOVLW  01
00ACA:  MOVWF  54
....................             flag_Pos_Resp_CMD = 0; 
00ACC:  CLRF   58
....................          } 
....................       }else{ 
00ACE:  BRA    0AD2
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
00AD0:  CLRF   58
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00AD2:  MOVLB  0
00AD4:  GOTO   0BFA (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion Verifica si la bandera de recepcion de datos esta 
.................... activa y almacena los datos entrantes en el arreglo 
.................... DATA_COMMAND, Finaliza la captura de caracteres cuando 
.................... encuentra el caracter ":". 
.................... Envia al ESP8266 el fin de la conexion 
.................... *********************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
00AD8:  DECFSZ 56,W
00ADA:  BRA    0B1E
....................       if(buffer!=':'){ 
00ADC:  MOVLB  1
00ADE:  MOVF   x32,W
00AE0:  SUBLW  3A
00AE2:  BNZ   0AE8
00AE4:  MOVF   x33,F
00AE6:  BZ    0B16
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
00AE8:  CLRF   03
00AEA:  MOVF   5A,W
00AEC:  ADDLW  20
00AEE:  MOVWF  FE9
00AF0:  MOVLW  00
00AF2:  ADDWFC 03,W
00AF4:  MOVWF  FEA
00AF6:  MOVFF  132,FEF
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
00AFA:  CLRF   53
00AFC:  MOVFF  5A,52
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
00B00:  MOVF   5A,F
00B02:  BNZ   0B12
00B04:  MOVF   x32,W
00B06:  SUBLW  2C
00B08:  BNZ   0B12
00B0A:  MOVF   x33,F
00B0C:  BNZ   0B12
....................             flag_Pos_Resp_Data=0; 
00B0E:  CLRF   5A
....................          }else{ 
00B10:  BRA    0B14
....................             flag_Pos_Resp_Data++; 
00B12:  INCF   5A,F
....................          } 
....................           
....................       }else{ 
00B14:  BRA    0B1E
....................          flag_Pos_Resp_Data      = 0x00; 
00B16:  CLRF   5A
....................          flag_Resp_StartGetData  = 0x00; 
00B18:  CLRF   56
....................          flag_Resp_Ready         = 1; 
00B1A:  MOVLW  01
00B1C:  MOVWF  57
00B1E:  MOVLB  0
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
00B20:  GOTO   0C06 (RETURN)
.................... } 
....................  
.................... int run_command_wifi(void){ 
*
012CA:  CLRF   xFF
012CC:  MOVLB  1
012CE:  CLRF   x00
012D0:  MOVLW  01
012D2:  MOVWF  x01
....................    int8 ret = 0, optSelected  = 0, respReq =  1; 
....................    char ESP8266_Resp[13]      = {"{\"cmd\":\"ok\"}"}; 
012D4:  MOVLW  7B
012D6:  MOVWF  x02
012D8:  MOVLW  22
012DA:  MOVWF  x03
012DC:  MOVLW  63
012DE:  MOVWF  x04
012E0:  MOVLW  6D
012E2:  MOVWF  x05
012E4:  MOVLW  64
012E6:  MOVWF  x06
012E8:  MOVLW  22
012EA:  MOVWF  x07
012EC:  MOVLW  3A
012EE:  MOVWF  x08
012F0:  MOVLW  22
012F2:  MOVWF  x09
012F4:  MOVLW  6F
012F6:  MOVWF  x0A
012F8:  MOVLW  6B
012FA:  MOVWF  x0B
012FC:  MOVLW  22
012FE:  MOVWF  x0C
01300:  MOVLW  7D
01302:  MOVWF  x0D
01304:  CLRF   x0E
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
01306:  DECFSZ 57,W
01308:  BRA    1938
....................        
....................       /************************** 
....................       *** Accede a las Salidas ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
0130A:  MOVF   1E,W
0130C:  SUBLW  4F
0130E:  BNZ   13C8
01310:  MOVF   1F,W
01312:  SUBLW  50
01314:  BNZ   13C8
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
01316:  MOVLW  30
01318:  SUBWF  21,W
0131A:  MOVWF  x00
....................           
....................          switch(DATA_COMMAND[0]){ 
0131C:  MOVF   20,W
0131E:  XORLW  30
01320:  MOVLB  0
01322:  BZ    132A
01324:  XORLW  01
01326:  BZ    1376
01328:  BRA    13C2
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
0132A:  BCF    FD8.0
0132C:  MOVLB  1
0132E:  RLCF   x00,W
01330:  CLRF   03
01332:  MOVFF  FF2,124
01336:  BCF    FF2.7
01338:  MOVLB  0
0133A:  CALL   0096
0133E:  TBLRD*+
01340:  MOVFF  FF5,03
01344:  MOVLB  1
01346:  BTFSC  x24.7
01348:  BSF    FF2.7
0134A:  MOVWF  x24
0134C:  MOVFF  03,125
01350:  MOVWF  x27
01352:  CLRF   x28
01354:  MOVLW  0F
01356:  MOVWF  x2A
01358:  MOVLW  89
0135A:  MOVWF  x29
0135C:  MOVLB  0
0135E:  RCALL  1288
01360:  MOVFF  124,127
01364:  MOVLB  1
01366:  CLRF   x28
01368:  MOVLW  0F
0136A:  MOVWF  x2A
0136C:  MOVLW  92
0136E:  MOVWF  x29
01370:  MOVLB  0
01372:  RCALL  1288
....................                break; 
01374:  BRA    13C2
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
01376:  BCF    FD8.0
01378:  MOVLB  1
0137A:  RLCF   x00,W
0137C:  CLRF   03
0137E:  MOVFF  FF2,124
01382:  BCF    FF2.7
01384:  MOVLB  0
01386:  CALL   0096
0138A:  TBLRD*+
0138C:  MOVFF  FF5,03
01390:  MOVLB  1
01392:  BTFSC  x24.7
01394:  BSF    FF2.7
01396:  MOVWF  x24
01398:  MOVFF  03,125
0139C:  MOVWF  x27
0139E:  MOVLW  01
013A0:  MOVWF  x28
013A2:  MOVLW  0F
013A4:  MOVWF  x2A
013A6:  MOVLW  89
013A8:  MOVWF  x29
013AA:  MOVLB  0
013AC:  RCALL  1288
013AE:  MOVFF  124,127
013B2:  MOVLB  1
013B4:  CLRF   x28
013B6:  MOVLW  0F
013B8:  MOVWF  x2A
013BA:  MOVLW  92
013BC:  MOVWF  x29
013BE:  MOVLB  0
013C0:  RCALL  1288
....................                break; 
....................          } 
....................           
....................          ret = 1; 
013C2:  MOVLW  01
013C4:  MOVWF  xFF
013C6:  MOVLB  1
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
013C8:  MOVF   1E,W
013CA:  SUBLW  4E
013CC:  BTFSS  FD8.2
013CE:  BRA    159E
013D0:  MOVF   1F,W
013D2:  SUBLW  43
013D4:  BTFSS  FD8.2
013D6:  BRA    159E
....................       { 
....................          // Borra la eeprom para almacenar las nuevas credenciales 
....................          for(int idxRSTNC=1;idxRSTNC<=31;idxRSTNC++){ 
013D8:  MOVLW  01
013DA:  MOVWF  x0F
013DC:  MOVF   x0F,W
013DE:  SUBLW  1F
013E0:  BNC   141C
....................             write_eeprom(idxRSTNC,0xFF); 
013E2:  MOVF   FF2,W
013E4:  MOVWF  00
013E6:  BCF    FF2.7
013E8:  CLRF   FAA
013EA:  MOVFF  10F,FA9
013EE:  SETF   FA8
013F0:  BCF    FA6.6
013F2:  BCF    FA6.7
013F4:  BSF    FA6.2
013F6:  MOVLB  F
013F8:  MOVLW  55
013FA:  MOVWF  FA7
013FC:  MOVLW  AA
013FE:  MOVWF  FA7
01400:  BSF    FA6.1
01402:  BTFSC  FA6.1
01404:  BRA    1402
01406:  BCF    FA6.2
01408:  MOVF   00,W
0140A:  IORWF  FF2,F
....................             delay_ms(10); 
0140C:  MOVLW  0A
0140E:  MOVLB  1
01410:  MOVWF  x26
01412:  MOVLB  0
01414:  RCALL  0C36
01416:  MOVLB  1
01418:  INCF   x0F,F
0141A:  BRA    13DC
....................          } 
....................           
....................          // Guarda las nuevas credenciales 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
0141C:  CLRF   x10
0141E:  MOVF   53,F
01420:  BNZ   1428
01422:  MOVF   x10,W
01424:  SUBWF  52,W
01426:  BNC   147E
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
01428:  MOVLW  01
0142A:  ADDWF  x10,W
0142C:  MOVWF  x24
0142E:  CLRF   03
01430:  MOVF   x10,W
01432:  ADDLW  20
01434:  MOVWF  FE9
01436:  MOVLW  00
01438:  ADDWFC 03,W
0143A:  MOVWF  FEA
0143C:  MOVFF  FEF,125
01440:  MOVF   FF2,W
01442:  MOVWF  00
01444:  BCF    FF2.7
01446:  CLRF   FAA
01448:  MOVFF  124,FA9
0144C:  MOVFF  125,FA8
01450:  BCF    FA6.6
01452:  BCF    FA6.7
01454:  BSF    FA6.2
01456:  MOVLB  F
01458:  MOVLW  55
0145A:  MOVWF  FA7
0145C:  MOVLW  AA
0145E:  MOVWF  FA7
01460:  BSF    FA6.1
01462:  BTFSC  FA6.1
01464:  BRA    1462
01466:  BCF    FA6.2
01468:  MOVF   00,W
0146A:  IORWF  FF2,F
....................             delay_ms(10); 
0146C:  MOVLW  0A
0146E:  MOVLB  1
01470:  MOVWF  x26
01472:  MOVLB  0
01474:  CALL   0C36
01478:  MOVLB  1
0147A:  INCF   x10,F
0147C:  BRA    141E
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
0147E:  MOVLW  01
01480:  ADDWF  x10,W
01482:  MOVWF  x24
01484:  MOVF   FF2,W
01486:  MOVWF  00
01488:  BCF    FF2.7
0148A:  CLRF   FAA
0148C:  MOVFF  124,FA9
01490:  MOVLW  0D
01492:  MOVWF  FA8
01494:  BCF    FA6.6
01496:  BCF    FA6.7
01498:  BSF    FA6.2
0149A:  MOVLB  F
0149C:  MOVLW  55
0149E:  MOVWF  FA7
014A0:  MOVLW  AA
014A2:  MOVWF  FA7
014A4:  BSF    FA6.1
014A6:  BTFSC  FA6.1
014A8:  BRA    14A6
014AA:  BCF    FA6.2
014AC:  MOVF   00,W
014AE:  IORWF  FF2,F
....................          delay_ms(10); 
014B0:  MOVLW  0A
014B2:  MOVLB  1
014B4:  MOVWF  x26
014B6:  MOVLB  0
014B8:  CALL   0C36
....................          write_eeprom(idxNC+2,0x0A); 
014BC:  MOVLW  02
014BE:  MOVLB  1
014C0:  ADDWF  x10,W
014C2:  MOVWF  x24
014C4:  MOVF   FF2,W
014C6:  MOVWF  00
014C8:  BCF    FF2.7
014CA:  CLRF   FAA
014CC:  MOVFF  124,FA9
014D0:  MOVLW  0A
014D2:  MOVWF  FA8
014D4:  BCF    FA6.6
014D6:  BCF    FA6.7
014D8:  BSF    FA6.2
014DA:  MOVLB  F
014DC:  MOVLW  55
014DE:  MOVWF  FA7
014E0:  MOVLW  AA
014E2:  MOVWF  FA7
014E4:  BSF    FA6.1
014E6:  BTFSC  FA6.1
014E8:  BRA    14E6
014EA:  BCF    FA6.2
014EC:  MOVF   00,W
014EE:  IORWF  FF2,F
....................          delay_ms(10); 
014F0:  MOVLW  0A
014F2:  MOVLB  1
014F4:  MOVWF  x26
014F6:  MOVLB  0
014F8:  CALL   0C36
....................  
....................          // Responde la solicitud 
....................          //delay_ms(30); 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
014FC:  MOVLW  5E
014FE:  MOVWF  FF6
01500:  MOVLW  01
01502:  MOVWF  FF7
01504:  MOVLW  0B
01506:  MOVLB  1
01508:  MOVWF  x25
0150A:  MOVLB  0
0150C:  RCALL  0F10
0150E:  MOVF   1C,W
01510:  BTFSS  F9E.4
01512:  BRA    1510
01514:  MOVWF  FAD
01516:  MOVLW  6B
01518:  MOVWF  FF6
0151A:  MOVLW  01
0151C:  MOVWF  FF7
0151E:  MOVLW  05
01520:  MOVLB  1
01522:  MOVWF  x25
01524:  MOVLB  0
01526:  RCALL  0F10
....................          delay_ms(60); 
01528:  MOVLW  3C
0152A:  MOVLB  1
0152C:  MOVWF  x26
0152E:  MOVLB  0
01530:  CALL   0C36
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
01534:  MOVLW  01
01536:  MOVWF  FEA
01538:  MOVLW  02
0153A:  MOVWF  FE9
0153C:  RCALL  1042
....................          delay_ms(110); 
0153E:  MOVLW  6E
01540:  MOVLB  1
01542:  MOVWF  x26
01544:  MOVLB  0
01546:  CALL   0C36
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0154A:  MOVLW  72
0154C:  MOVWF  FF6
0154E:  MOVLW  01
01550:  MOVWF  FF7
01552:  MOVLW  0C
01554:  MOVLB  1
01556:  MOVWF  x25
01558:  MOVLB  0
0155A:  RCALL  0F10
0155C:  MOVF   1C,W
0155E:  BTFSS  F9E.4
01560:  BRA    155E
01562:  MOVWF  FAD
01564:  MOVLW  0D
01566:  BTFSS  F9E.4
01568:  BRA    1566
0156A:  MOVWF  FAD
0156C:  MOVLW  0A
0156E:  BTFSS  F9E.4
01570:  BRA    156E
01572:  MOVWF  FAD
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
01574:  MOVLW  84
01576:  MOVWF  FF6
01578:  MOVLW  01
0157A:  MOVWF  FF7
0157C:  RCALL  0EEE
....................          delay_ms(1000); 
0157E:  MOVLW  04
01580:  MOVLB  1
01582:  MOVWF  x24
01584:  MOVLW  FA
01586:  MOVWF  x26
01588:  MOVLB  0
0158A:  CALL   0C36
0158E:  MOVLB  1
01590:  DECFSZ x24,F
01592:  BRA    1584
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
01594:  RESET
....................          ret = 1; 
01596:  MOVLW  01
01598:  MOVLB  0
0159A:  MOVWF  xFF
0159C:  MOVLB  1
....................       } // Fin comando NC 
....................        
....................       /********************************** 
....................       *** Cambia el SSID y Key del AP  ** 
....................       *** CMD:AP,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='A' && 
....................          COMMAND[1]=='P') 
0159E:  MOVF   1E,W
015A0:  SUBLW  41
015A2:  BNZ   1680
015A4:  MOVF   1F,W
015A6:  SUBLW  50
015A8:  BNZ   1680
....................       { 
....................          // Responde la solicitud 
....................          //delay_ms(30); 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
015AA:  MOVLW  90
015AC:  MOVWF  FF6
015AE:  MOVLW  01
015B0:  MOVWF  FF7
015B2:  MOVLW  0B
015B4:  MOVWF  x25
015B6:  MOVLB  0
015B8:  RCALL  0F10
015BA:  MOVF   1C,W
015BC:  BTFSS  F9E.4
015BE:  BRA    15BC
015C0:  MOVWF  FAD
015C2:  MOVLW  9D
015C4:  MOVWF  FF6
015C6:  MOVLW  01
015C8:  MOVWF  FF7
015CA:  MOVLW  05
015CC:  MOVLB  1
015CE:  MOVWF  x25
015D0:  MOVLB  0
015D2:  RCALL  0F10
....................          delay_ms(60); 
015D4:  MOVLW  3C
015D6:  MOVLB  1
015D8:  MOVWF  x26
015DA:  MOVLB  0
015DC:  CALL   0C36
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
015E0:  MOVLW  01
015E2:  MOVWF  FEA
015E4:  MOVLW  02
015E6:  MOVWF  FE9
015E8:  RCALL  1042
....................          delay_ms(110); 
015EA:  MOVLW  6E
015EC:  MOVLB  1
015EE:  MOVWF  x26
015F0:  MOVLB  0
015F2:  CALL   0C36
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
015F6:  MOVLW  A4
015F8:  MOVWF  FF6
015FA:  MOVLW  01
015FC:  MOVWF  FF7
015FE:  MOVLW  0C
01600:  MOVLB  1
01602:  MOVWF  x25
01604:  MOVLB  0
01606:  RCALL  0F10
01608:  MOVF   1C,W
0160A:  BTFSS  F9E.4
0160C:  BRA    160A
0160E:  MOVWF  FAD
01610:  MOVLW  0D
01612:  BTFSS  F9E.4
01614:  BRA    1612
01616:  MOVWF  FAD
01618:  MOVLW  0A
0161A:  BTFSS  F9E.4
0161C:  BRA    161A
0161E:  MOVWF  FAD
....................           
....................          delay_ms(1500); 
01620:  MOVLW  06
01622:  MOVLB  1
01624:  MOVWF  x24
01626:  MOVLW  FA
01628:  MOVWF  x26
0162A:  MOVLB  0
0162C:  CALL   0C36
01630:  MOVLB  1
01632:  DECFSZ x24,F
01634:  BRA    1626
....................          fprintf(ESP8266, "AT+CWSAP_DEF=%s,1,4\r\n",DATA_COMMAND); 
01636:  MOVLW  B6
01638:  MOVWF  FF6
0163A:  MOVLW  01
0163C:  MOVWF  FF7
0163E:  MOVLW  0D
01640:  MOVWF  x25
01642:  MOVLB  0
01644:  RCALL  0F10
01646:  CLRF   FEA
01648:  MOVLW  20
0164A:  MOVWF  FE9
0164C:  RCALL  1042
0164E:  MOVLW  C5
01650:  MOVWF  FF6
01652:  MOVLW  01
01654:  MOVWF  FF7
01656:  MOVLW  06
01658:  MOVLB  1
0165A:  MOVWF  x25
0165C:  MOVLB  0
0165E:  RCALL  0F10
....................          delay_ms(1000); 
01660:  MOVLW  04
01662:  MOVLB  1
01664:  MOVWF  x24
01666:  MOVLW  FA
01668:  MOVWF  x26
0166A:  MOVLB  0
0166C:  CALL   0C36
01670:  MOVLB  1
01672:  DECFSZ x24,F
01674:  BRA    1666
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
01676:  RESET
....................          ret = 1; 
01678:  MOVLW  01
0167A:  MOVLB  0
0167C:  MOVWF  xFF
0167E:  MOVLB  1
....................       } // Fin comando AP 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
01680:  MOVF   1E,W
01682:  SUBLW  4E
01684:  BNZ   1750
01686:  MOVF   1F,W
01688:  SUBLW  4D
0168A:  BNZ   1750
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
0168C:  MOVF   FF2,W
0168E:  MOVWF  00
01690:  BCF    FF2.7
01692:  CLRF   FAA
01694:  CLRF   FA9
01696:  MOVFF  20,FA8
0169A:  BCF    FA6.6
0169C:  BCF    FA6.7
0169E:  BSF    FA6.2
016A0:  MOVLB  F
016A2:  MOVLW  55
016A4:  MOVWF  FA7
016A6:  MOVLW  AA
016A8:  MOVWF  FA7
016AA:  BSF    FA6.1
016AC:  BTFSC  FA6.1
016AE:  BRA    16AC
016B0:  BCF    FA6.2
016B2:  MOVF   00,W
016B4:  IORWF  FF2,F
....................          delay_ms(10); 
016B6:  MOVLW  0A
016B8:  MOVLB  1
016BA:  MOVWF  x26
016BC:  MOVLB  0
016BE:  CALL   0C36
....................           
....................          // Responde la solicitud 
....................          delay_ms(20); 
016C2:  MOVLW  14
016C4:  MOVLB  1
016C6:  MOVWF  x26
016C8:  MOVLB  0
016CA:  CALL   0C36
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
016CE:  MOVLW  CC
016D0:  MOVWF  FF6
016D2:  MOVLW  01
016D4:  MOVWF  FF7
016D6:  MOVLW  0B
016D8:  MOVLB  1
016DA:  MOVWF  x25
016DC:  MOVLB  0
016DE:  RCALL  0F10
016E0:  MOVF   1C,W
016E2:  BTFSS  F9E.4
016E4:  BRA    16E2
016E6:  MOVWF  FAD
016E8:  MOVLW  D9
016EA:  MOVWF  FF6
016EC:  MOVLW  01
016EE:  MOVWF  FF7
016F0:  MOVLW  05
016F2:  MOVLB  1
016F4:  MOVWF  x25
016F6:  MOVLB  0
016F8:  RCALL  0F10
....................          delay_ms(50); 
016FA:  MOVLW  32
016FC:  MOVLB  1
016FE:  MOVWF  x26
01700:  MOVLB  0
01702:  CALL   0C36
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
01706:  MOVLW  01
01708:  MOVWF  FEA
0170A:  MOVLW  02
0170C:  MOVWF  FE9
0170E:  RCALL  1042
....................          delay_ms(100); 
01710:  MOVLW  64
01712:  MOVLB  1
01714:  MOVWF  x26
01716:  MOVLB  0
01718:  CALL   0C36
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0171C:  MOVLW  E0
0171E:  MOVWF  FF6
01720:  MOVLW  01
01722:  MOVWF  FF7
01724:  MOVLW  0C
01726:  MOVLB  1
01728:  MOVWF  x25
0172A:  MOVLB  0
0172C:  CALL   0F10
01730:  MOVF   1C,W
01732:  BTFSS  F9E.4
01734:  BRA    1732
01736:  MOVWF  FAD
01738:  MOVLW  0D
0173A:  BTFSS  F9E.4
0173C:  BRA    173A
0173E:  MOVWF  FAD
01740:  MOVLW  0A
01742:  BTFSS  F9E.4
01744:  BRA    1742
01746:  MOVWF  FAD
....................           
....................          // Reinicia el dispositivo 
....................          reset_cpu(); 
01748:  RESET
....................           
....................          ret = 1; 
0174A:  MOVLW  01
0174C:  MOVWF  xFF
0174E:  MOVLB  1
....................       } // Fin comando OP 
....................        
....................       /********************************* 
....................       *** Optiene el estado de Puerto ** 
....................       *** CMD:OS,0:                   ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='S') 
01750:  MOVF   1E,W
01752:  SUBLW  4F
01754:  BTFSS  FD8.2
01756:  BRA    187C
01758:  MOVF   1F,W
0175A:  SUBLW  53
0175C:  BTFSS  FD8.2
0175E:  BRA    187C
....................       { 
....................          char  response[18]; 
....................           
....................          response[0]  = input_state(PIN_OUT[0])+ 48; 
01760:  MOVLW  00
01762:  BTFSC  F84.2
01764:  MOVLW  01
01766:  ADDLW  30
01768:  MOVWF  x11
....................          response[1]  = ','; 
0176A:  MOVLW  2C
0176C:  MOVWF  x12
....................          response[2]  = input_state(PIN_OUT[1])+ 48; 
0176E:  MOVLW  00
01770:  BTFSC  F84.1
01772:  MOVLW  01
01774:  ADDLW  30
01776:  MOVWF  x13
....................          response[3]  = ','; 
01778:  MOVLW  2C
0177A:  MOVWF  x14
....................          response[4]  = input_state(PIN_OUT[2])+ 48; 
0177C:  MOVLW  00
0177E:  BTFSC  F84.0
01780:  MOVLW  01
01782:  ADDLW  30
01784:  MOVWF  x15
....................          response[5]  = ','; 
01786:  MOVLW  2C
01788:  MOVWF  x16
....................          response[6]  = input_state(PIN_OUT[3])+ 48; 
0178A:  MOVLW  00
0178C:  BTFSC  F80.4
0178E:  MOVLW  01
01790:  ADDLW  30
01792:  MOVWF  x17
....................          response[7]  = ','; 
01794:  MOVLW  2C
01796:  MOVWF  x18
....................          response[8]  = input_state(PIN_OUT[4])+ 48; 
01798:  MOVLW  00
0179A:  BTFSC  F80.0
0179C:  MOVLW  01
0179E:  ADDLW  30
017A0:  MOVWF  x19
....................          response[9]  = ','; 
017A2:  MOVLW  2C
017A4:  MOVWF  x1A
....................          response[10] = input_state(PIN_OUT[5])+ 48; 
017A6:  MOVLW  00
017A8:  BTFSC  F80.1
017AA:  MOVLW  01
017AC:  ADDLW  30
017AE:  MOVWF  x1B
....................          response[11] = ','; 
017B0:  MOVLW  2C
017B2:  MOVWF  x1C
....................          response[12] = input_state(PIN_OUT[6])+ 48; 
017B4:  MOVLW  00
017B6:  BTFSC  F80.2
017B8:  MOVLW  01
017BA:  ADDLW  30
017BC:  MOVWF  x1D
....................          response[13] = ','; 
017BE:  MOVLW  2C
017C0:  MOVWF  x1E
....................          response[14] = input_state(PIN_OUT[7])+ 48; 
017C2:  MOVLW  00
017C4:  BTFSC  F80.3
017C6:  MOVLW  01
017C8:  ADDLW  30
017CA:  MOVWF  x1F
....................          response[15] = ','; 
017CC:  MOVLW  2C
017CE:  MOVWF  x20
....................          response[16] = read_eeprom(0x00); 
017D0:  MOVFF  FF2,124
017D4:  BCF    FF2.7
017D6:  CLRF   FAA
017D8:  CLRF   FA9
017DA:  BCF    FA6.6
017DC:  BCF    FA6.7
017DE:  BSF    FA6.0
017E0:  MOVF   FA8,W
017E2:  BTFSC  x24.7
017E4:  BSF    FF2.7
017E6:  MOVWF  x21
....................          // Responde la solicitud 
....................          delay_ms(20); 
017E8:  MOVLW  14
017EA:  MOVWF  x26
017EC:  MOVLB  0
017EE:  CALL   0C36
....................          fprintf(ESP8266, "AT+CIPSEND=%c,17\r\n",ID_CONNETION[0]); 
017F2:  MOVLW  F2
017F4:  MOVWF  FF6
017F6:  MOVLW  01
017F8:  MOVWF  FF7
017FA:  MOVLW  0B
017FC:  MOVLB  1
017FE:  MOVWF  x25
01800:  MOVLB  0
01802:  CALL   0F10
01806:  MOVF   1C,W
01808:  BTFSS  F9E.4
0180A:  BRA    1808
0180C:  MOVWF  FAD
0180E:  MOVLW  FF
01810:  MOVWF  FF6
01812:  MOVLW  01
01814:  MOVWF  FF7
01816:  MOVLW  05
01818:  MOVLB  1
0181A:  MOVWF  x25
0181C:  MOVLB  0
0181E:  CALL   0F10
....................          delay_ms(50); 
01822:  MOVLW  32
01824:  MOVLB  1
01826:  MOVWF  x26
01828:  MOVLB  0
0182A:  CALL   0C36
....................          fprintf(ESP8266, "%s",response); 
0182E:  MOVLW  01
01830:  MOVWF  FEA
01832:  MOVLW  11
01834:  MOVWF  FE9
01836:  RCALL  1042
....................          delay_ms(100); 
01838:  MOVLW  64
0183A:  MOVLB  1
0183C:  MOVWF  x26
0183E:  MOVLB  0
01840:  CALL   0C36
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01844:  MOVLW  06
01846:  MOVWF  FF6
01848:  MOVLW  02
0184A:  MOVWF  FF7
0184C:  MOVLW  0C
0184E:  MOVLB  1
01850:  MOVWF  x25
01852:  MOVLB  0
01854:  CALL   0F10
01858:  MOVF   1C,W
0185A:  BTFSS  F9E.4
0185C:  BRA    185A
0185E:  MOVWF  FAD
01860:  MOVLW  0D
01862:  BTFSS  F9E.4
01864:  BRA    1862
01866:  MOVWF  FAD
01868:  MOVLW  0A
0186A:  BTFSS  F9E.4
0186C:  BRA    186A
0186E:  MOVWF  FAD
....................           
....................          respReq=0; 
01870:  MOVLB  1
01872:  CLRF   x01
....................          ret = 1; 
01874:  MOVLW  01
01876:  MOVLB  0
01878:  MOVWF  xFF
0187A:  MOVLB  1
....................       } // Fin comando OS 
....................        
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................       if(respReq==1){ 
0187C:  DECFSZ x01,W
0187E:  BRA    190C
....................          // Responde la solicitud 
....................          delay_ms(20); 
01880:  MOVLW  14
01882:  MOVWF  x26
01884:  MOVLB  0
01886:  CALL   0C36
....................          fprintf(ESP8266, "AT+CIPSEND=%c,12\r\n",ID_CONNETION[0]); 
0188A:  MOVLW  18
0188C:  MOVWF  FF6
0188E:  MOVLW  02
01890:  MOVWF  FF7
01892:  MOVLW  0B
01894:  MOVLB  1
01896:  MOVWF  x25
01898:  MOVLB  0
0189A:  CALL   0F10
0189E:  MOVF   1C,W
018A0:  BTFSS  F9E.4
018A2:  BRA    18A0
018A4:  MOVWF  FAD
018A6:  MOVLW  25
018A8:  MOVWF  FF6
018AA:  MOVLW  02
018AC:  MOVWF  FF7
018AE:  MOVLW  05
018B0:  MOVLB  1
018B2:  MOVWF  x25
018B4:  MOVLB  0
018B6:  CALL   0F10
....................          delay_ms(50); 
018BA:  MOVLW  32
018BC:  MOVLB  1
018BE:  MOVWF  x26
018C0:  MOVLB  0
018C2:  CALL   0C36
....................          fprintf(ESP8266, "%s",ESP8266_Resp); 
018C6:  MOVLW  01
018C8:  MOVWF  FEA
018CA:  MOVLW  02
018CC:  MOVWF  FE9
018CE:  CALL   1042
....................          delay_ms(100); 
018D2:  MOVLW  64
018D4:  MOVLB  1
018D6:  MOVWF  x26
018D8:  MOVLB  0
018DA:  CALL   0C36
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
018DE:  MOVLW  2C
018E0:  MOVWF  FF6
018E2:  MOVLW  02
018E4:  MOVWF  FF7
018E6:  MOVLW  0C
018E8:  MOVLB  1
018EA:  MOVWF  x25
018EC:  MOVLB  0
018EE:  CALL   0F10
018F2:  MOVF   1C,W
018F4:  BTFSS  F9E.4
018F6:  BRA    18F4
018F8:  MOVWF  FAD
018FA:  MOVLW  0D
018FC:  BTFSS  F9E.4
018FE:  BRA    18FC
01900:  MOVWF  FAD
01902:  MOVLW  0A
01904:  BTFSS  F9E.4
01906:  BRA    1904
01908:  MOVWF  FAD
0190A:  MOVLB  1
....................       } 
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
0190C:  CLRF   x23
0190E:  MOVF   53,F
01910:  BNZ   1918
01912:  MOVF   x23,W
01914:  SUBWF  52,W
01916:  BNC   192C
....................          DATA_COMMAND[idxCb] = 0x00; 
01918:  CLRF   03
0191A:  MOVF   x23,W
0191C:  ADDLW  20
0191E:  MOVWF  FE9
01920:  MOVLW  00
01922:  ADDWFC 03,W
01924:  MOVWF  FEA
01926:  CLRF   FEF
01928:  INCF   x23,F
0192A:  BRA    190E
....................       } 
....................       COMMAND[0]       = 0x00; 
0192C:  CLRF   1E
....................       COMMAND[1]       = 0x00; 
0192E:  CLRF   1F
....................       ID_CONNETION[0]  = 0x00; 
01930:  CLRF   1C
....................        
....................       // Reinicia el buffer 
....................       flag_Resp_Ready  = 0x00; 
01932:  CLRF   57
....................       LEN_DATA_COMMAND = 0x00; 
01934:  CLRF   53
01936:  CLRF   52
....................        
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return ret; 
01938:  MOVLB  0
0193A:  MOVFF  FF,01
0193E:  RETURN 0
.................... } 
....................  
.................... #include "header/esp8266.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... #define  CMD_MODE                   1 
.................... #define  CMD_DO_CONN                2 
.................... #define  CMD_CONN                   3 
.................... #define  READY_RESPONSE_WIFI        4  
.................... #define  CMD_GET_IP_FROM_MENU       5 
.................... #define  CMD_GET_AP_INFO_FROM_MENU  6 
.................... #define  CMD_GET_STA_INFO_FROM_MENU 7 
....................  
.................... /* Key flag responses */ 
.................... const int   Valid      = 0; 
.................... const int   CWJAP      = 1; 
.................... const int   NoAp       = 2; 
.................... const int   Connected  = 3; 
.................... const int   Fail       = 4; 
.................... const int   Error      = 5; 
....................  
.................... //#define  END_CMD_GET_IP       2 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void getIP(int buffer); 
.................... void getAPInfo(int buffer); 
.................... void getSTAInfo(int buffer); 
.................... int  waitResp(void); 
.................... void waitRespMajor(int buffer,int flag_resp); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int resp_Pos   = 1; 
.................... int resp_Flag  = 0; 
.................... int countResp  = 5;     //Conteo de Respuestas esperadas 
....................  
.................... char buffer_flag_Resp[2][6]   =   
.................... { 
....................    {0,0,0,0,0,0}, // Flag_Responses Command valid 
....................    {0,0,0,0,0,0}  // Flag_Pos_Responses 
.................... }; 
....................  
.................... char buffer_Resp_CMD[5][16]   = 
.................... { 
....................    {"0.0.0.0"},   // IP    AP 
....................    {"0.0.0.0"},   // IP    STA 
....................    {""},          // SSID  AP 
....................    {"KEY"},       // Key   AP 
....................    {"SSID"}       // SSID  STA 
.................... }; 
....................  
.................... int flag_Resp_Get_IP_CMD = 0; 
.................... int flag_Pos_Get_IP_CMD  = 0; 
....................  
.................... int flag_Resp_Get_AP_Info_CMD = 0; 
.................... int flag_Pos_Get_AP_Info_CMD  = 0; 
....................  
.................... int flag_Resp_Get_STA_Info_CMD = 0; 
.................... int flag_Pos_Get_STA_Info_CMD  = 0; 
....................  
.................... /*Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    fprintf(ESP8266, "AT+RST\r\n"); 
*
01068:  MOVLW  3E
0106A:  MOVWF  FF6
0106C:  MOVLW  02
0106E:  MOVWF  FF7
01070:  RCALL  0EEE
....................    delay_ms(2000); 
01072:  MOVLW  08
01074:  MOVWF  xFC
01076:  MOVLW  FA
01078:  MOVLB  1
0107A:  MOVWF  x26
0107C:  MOVLB  0
0107E:  RCALL  0C36
01080:  DECFSZ xFC,F
01082:  BRA    1076
....................     
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
01084:  MOVFF  FF2,FC
01088:  BCF    FF2.7
0108A:  CLRF   FAA
0108C:  CLRF   FA9
0108E:  BCF    FA6.6
01090:  BCF    FA6.7
01092:  BSF    FA6.0
01094:  MOVF   FA8,W
01096:  BTFSC  xFC.7
01098:  BSF    FF2.7
0109A:  MOVWF  xC1
....................    delay_ms(10); 
0109C:  MOVLW  0A
0109E:  MOVLB  1
010A0:  MOVWF  x26
010A2:  MOVLB  0
010A4:  RCALL  0C36
....................    switch(modeStar){ 
010A6:  MOVF   xC1,W
010A8:  XORLW  31
010AA:  BZ    10B6
010AC:  XORLW  03
010AE:  BZ    10B6
010B0:  XORLW  01
010B2:  BZ    10B6
010B4:  BRA    10B8
....................       case '1': 
....................       case '2': 
....................       case '3': 
....................          break; 
010B6:  BRA    10F0
....................       default: 
....................          write_eeprom(0x00,'3'); 
010B8:  MOVF   FF2,W
010BA:  MOVWF  00
010BC:  BCF    FF2.7
010BE:  CLRF   FAA
010C0:  CLRF   FA9
010C2:  MOVLW  33
010C4:  MOVWF  FA8
010C6:  BCF    FA6.6
010C8:  BCF    FA6.7
010CA:  BSF    FA6.2
010CC:  MOVLB  F
010CE:  MOVLW  55
010D0:  MOVWF  FA7
010D2:  MOVLW  AA
010D4:  MOVWF  FA7
010D6:  BSF    FA6.1
010D8:  BTFSC  FA6.1
010DA:  BRA    10D8
010DC:  BCF    FA6.2
010DE:  MOVF   00,W
010E0:  IORWF  FF2,F
....................          delay_ms(10); 
010E2:  MOVLW  0A
010E4:  MOVLB  1
010E6:  MOVWF  x26
010E8:  MOVLB  0
010EA:  RCALL  0C36
....................          modeStar = '3'; 
010EC:  MOVLW  33
010EE:  MOVWF  xC1
....................          break; 
....................    } 
....................    // Lanza el comando para configurar el modo de conexion 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeStar); 
010F0:  MOVLW  48
010F2:  MOVWF  FF6
010F4:  MOVLW  02
010F6:  MOVWF  FF7
010F8:  MOVLW  0A
010FA:  MOVLB  1
010FC:  MOVWF  x25
010FE:  MOVLB  0
01100:  RCALL  0F10
01102:  MOVF   xC1,W
01104:  BTFSS  F9E.4
01106:  BRA    1104
01108:  MOVWF  FAD
0110A:  MOVLW  0D
0110C:  BTFSS  F9E.4
0110E:  BRA    110C
01110:  MOVWF  FAD
01112:  MOVLW  0A
01114:  BTFSS  F9E.4
01116:  BRA    1114
01118:  MOVWF  FAD
....................    CMD_RUN =  CMD_MODE;  
0111A:  MOVLW  01
0111C:  MOVWF  5B
....................     
....................    // Espera por la respuesta OK del modulo 
....................    delay_ms(50); 
0111E:  MOVLW  32
01120:  MOVLB  1
01122:  MOVWF  x26
01124:  MOVLB  0
01126:  RCALL  0C36
....................     
....................    // Lanza el comando para verificar si elmodulo ya se encuentra conectado 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
01128:  MOVLW  58
0112A:  MOVWF  FF6
0112C:  MOVLW  02
0112E:  MOVWF  FF7
01130:  RCALL  0EEE
....................    CMD_RUN =  CMD_DO_CONN; 
01132:  MOVLW  02
01134:  MOVWF  5B
....................  
....................    resp = waitResp(); 
01136:  RCALL  0F3A
01138:  MOVFF  01,FA
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
0113C:  MOVF   xFA,W
0113E:  SUBLW  02
01140:  BTFSS  FD8.2
01142:  BRA    122E
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
01144:  CLRF   xFB
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
01146:  CLRF   03
01148:  MOVF   xFB,W
0114A:  ADDLW  C2
0114C:  MOVWF  FE9
0114E:  MOVLW  00
01150:  ADDWFC 03,W
01152:  MOVWF  FEA
01154:  MOVF   FEF,W
01156:  SUBLW  0A
01158:  BZ    11C4
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
0115A:  CLRF   03
0115C:  MOVF   xFB,W
0115E:  ADDLW  C2
01160:  MOVWF  FE9
01162:  MOVLW  00
01164:  ADDWFC 03,W
01166:  MOVWF  FEA
01168:  MOVLW  01
0116A:  ADDWF  xFB,W
0116C:  MOVWF  xFE
0116E:  MOVFF  FF2,FF
01172:  BCF    FF2.7
01174:  CLRF   FAA
01176:  MOVFF  FE,FA9
0117A:  BCF    FA6.6
0117C:  BCF    FA6.7
0117E:  BSF    FA6.0
01180:  MOVF   FA8,W
01182:  BTFSC  xFF.7
01184:  BSF    FF2.7
01186:  MOVWF  FEF
....................          delay_ms(10); 
01188:  MOVLW  0A
0118A:  MOVLB  1
0118C:  MOVWF  x26
0118E:  MOVLB  0
01190:  RCALL  0C36
....................          if(SSIDAndKey[idxRE]==0xFF){ 
01192:  CLRF   03
01194:  MOVF   xFB,W
01196:  ADDLW  C2
01198:  MOVWF  FE9
0119A:  MOVLW  00
0119C:  ADDWFC 03,W
0119E:  MOVWF  FEA
011A0:  INCFSZ FEF,W
011A2:  BRA    11AA
....................             resp = 5; 
011A4:  MOVLW  05
011A6:  MOVWF  xFA
....................             break; 
011A8:  BRA    11C4
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
011AA:  CLRF   03
011AC:  MOVF   xFB,W
011AE:  ADDLW  C2
011B0:  MOVWF  FE9
011B2:  MOVLW  00
011B4:  ADDWFC 03,W
011B6:  MOVWF  FEA
011B8:  MOVF   FEF,W
011BA:  SUBLW  0A
011BC:  BNZ   11C0
....................             break; 
011BE:  BRA    11C4
....................          } 
....................          idxRE++; 
011C0:  INCF   xFB,F
011C2:  BRA    1146
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
011C4:  MOVF   xFA,W
011C6:  SUBLW  05
011C8:  BZ    11EE
....................          fprintf(ESP8266, "AT+CWJAP=%s",SSIDAndKey);     /** AT+CWJAP="UNE_C06E","00986344200771" **/ 
011CA:  MOVLW  64
011CC:  MOVWF  FF6
011CE:  MOVLW  02
011D0:  MOVWF  FF7
011D2:  MOVLW  09
011D4:  MOVLB  1
011D6:  MOVWF  x25
011D8:  MOVLB  0
011DA:  RCALL  0F10
011DC:  CLRF   FEA
011DE:  MOVLW  C2
011E0:  MOVWF  FE9
011E2:  RCALL  1042
....................          CMD_RUN = CMD_CONN; 
011E4:  MOVLW  03
011E6:  MOVWF  5B
....................          resp    = waitResp(); 
011E8:  RCALL  0F3A
011EA:  MOVFF  01,FA
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
011EE:  MOVF   xFA,W
011F0:  SUBLW  04
011F2:  BZ    11FA
011F4:  MOVF   xFA,W
011F6:  SUBLW  05
011F8:  BNZ   122E
....................          fprintf(ESP8266, "AT+CWMODE=%c\r\n","3"); 
011FA:  MOVLW  70
011FC:  MOVWF  FF6
011FE:  MOVLW  02
01200:  MOVWF  FF7
01202:  MOVLW  0A
01204:  MOVLB  1
01206:  MOVWF  x25
01208:  MOVLB  0
0120A:  RCALL  0F10
0120C:  MOVLB  4
0120E:  MOVF   xBE,W
01210:  BTFSS  F9E.4
01212:  BRA    1210
01214:  MOVWF  FAD
01216:  MOVLW  0D
01218:  BTFSS  F9E.4
0121A:  BRA    1218
0121C:  MOVWF  FAD
0121E:  MOVLW  0A
01220:  BTFSS  F9E.4
01222:  BRA    1220
01224:  MOVWF  FAD
....................          CMD_RUN = CMD_MODE; 
01226:  MOVLW  01
01228:  MOVWF  5B
....................          waitResp(); 
0122A:  MOVLB  0
0122C:  RCALL  0F3A
....................       } 
....................    } // Fin del if(doConnect) 
....................  
....................    // Configura el modulo como server 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
0122E:  MOVLW  80
01230:  MOVWF  FF6
01232:  MOVLW  02
01234:  MOVWF  FF7
01236:  RCALL  0EEE
....................    delay_ms(1000); 
01238:  MOVLW  04
0123A:  MOVWF  xFC
0123C:  MOVLW  FA
0123E:  MOVLB  1
01240:  MOVWF  x26
01242:  MOVLB  0
01244:  RCALL  0C36
01246:  DECFSZ xFC,F
01248:  BRA    123C
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
0124A:  MOVLW  8E
0124C:  MOVWF  FF6
0124E:  MOVLW  02
01250:  MOVWF  FF7
01252:  RCALL  0EEE
....................    delay_ms(1000); 
01254:  MOVLW  04
01256:  MOVWF  xFC
01258:  MOVLW  FA
0125A:  MOVLB  1
0125C:  MOVWF  x26
0125E:  MOVLB  0
01260:  RCALL  0C36
01262:  DECFSZ xFC,F
01264:  BRA    1258
....................     
....................    CMD_RUN = READY_RESPONSE_WIFI; 
01266:  MOVLW  04
01268:  MOVWF  5B
0126A:  GOTO   257C (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
00B24:  MOVF   5B,W
00B26:  XORLW  01
00B28:  BZ    0B44
00B2A:  XORLW  03
00B2C:  BZ    0B52
00B2E:  XORLW  01
00B30:  BZ    0B7C
00B32:  XORLW  06
00B34:  BZ    0BA6
00B36:  XORLW  03
00B38:  BZ    0BBA
00B3A:  XORLW  01
00B3C:  BZ    0BCE
00B3E:  XORLW  03
00B40:  BZ    0BE2
00B42:  BRA    0BE2
....................             case CMD_MODE: 
....................                   waitRespMajor(buffer,Valid); 
00B44:  MOVFF  131,132
00B48:  MOVLB  1
00B4A:  CLRF   x33
00B4C:  MOVLB  0
00B4E:  RCALL  0644
....................                   break; 
00B50:  BRA    0C08
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespMajor(buffer,NoAp); 
00B52:  MOVFF  131,132
00B56:  MOVLW  02
00B58:  MOVLB  1
00B5A:  MOVWF  x33
00B5C:  MOVLB  0
00B5E:  RCALL  0644
....................                   waitRespMajor(buffer,CWJAP); 
00B60:  MOVFF  131,132
00B64:  MOVLW  01
00B66:  MOVLB  1
00B68:  MOVWF  x33
00B6A:  MOVLB  0
00B6C:  RCALL  0644
....................                   waitRespMajor(buffer,Valid); 
00B6E:  MOVFF  131,132
00B72:  MOVLB  1
00B74:  CLRF   x33
00B76:  MOVLB  0
00B78:  RCALL  0644
....................                   break; 
00B7A:  BRA    0C08
....................  
....................             case CMD_CONN: 
....................                   waitRespMajor(buffer,Connected); 
00B7C:  MOVFF  131,132
00B80:  MOVLW  03
00B82:  MOVLB  1
00B84:  MOVWF  x33
00B86:  MOVLB  0
00B88:  RCALL  0644
....................                   waitRespMajor(buffer,Fail); 
00B8A:  MOVFF  131,132
00B8E:  MOVLW  04
00B90:  MOVLB  1
00B92:  MOVWF  x33
00B94:  MOVLB  0
00B96:  RCALL  0644
....................                   waitRespMajor(buffer,Valid); 
00B98:  MOVFF  131,132
00B9C:  MOVLB  1
00B9E:  CLRF   x33
00BA0:  MOVLB  0
00BA2:  RCALL  0644
....................                   break; 
00BA4:  BRA    0C08
....................              
....................             case CMD_GET_IP_FROM_MENU: 
....................                   getIP(buffer); 
00BA6:  MOVFF  131,132
00BAA:  BRA    085A
....................                   waitRespMajor(buffer,Valid); 
00BAC:  MOVFF  131,132
00BB0:  MOVLB  1
00BB2:  CLRF   x33
00BB4:  MOVLB  0
00BB6:  RCALL  0644
....................                   break; 
00BB8:  BRA    0C08
....................                    
....................             case CMD_GET_AP_INFO_FROM_MENU: 
....................                   getAPInfo(buffer); 
00BBA:  MOVFF  131,132
00BBE:  BRA    092A
....................                   waitRespMajor(buffer,Valid); 
00BC0:  MOVFF  131,132
00BC4:  MOVLB  1
00BC6:  CLRF   x33
00BC8:  MOVLB  0
00BCA:  RCALL  0644
....................                   break; 
00BCC:  BRA    0C08
....................              
....................             case CMD_GET_STA_INFO_FROM_MENU: 
....................                   getSTAInfo(buffer); 
00BCE:  MOVFF  131,132
00BD2:  BRA    09C2
....................                   waitRespMajor(buffer,Valid); 
00BD4:  MOVFF  131,132
00BD8:  MOVLB  1
00BDA:  CLRF   x33
00BDC:  MOVLB  0
00BDE:  RCALL  0644
....................                   break; 
00BE0:  BRA    0C08
....................                    
....................             case READY_RESPONSE_WIFI: 
....................             default: 
....................                   ESP8266_Get_IPD(buffer); 
00BE2:  MOVLB  1
00BE4:  CLRF   x33
00BE6:  MOVFF  131,132
00BEA:  MOVLB  0
00BEC:  BRA    0A04
....................                   ESP8266_Get_CMD(buffer); 
00BEE:  MOVLB  1
00BF0:  CLRF   x33
00BF2:  MOVFF  131,132
00BF6:  MOVLB  0
00BF8:  BRA    0A6C
....................                   ESP8266_Get_Data(buffer); 
00BFA:  MOVLB  1
00BFC:  CLRF   x33
00BFE:  MOVFF  131,132
00C02:  MOVLB  0
00C04:  BRA    0AD8
....................              
....................                   CMD_RUN = 0x00; 
00C06:  CLRF   5B
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
00C08:  GOTO   0C1E (RETURN)
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
00F3A:  CLRF   xFD
00F3C:  CLRF   xFE
.................... { 
....................    int ret=0,idx=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(buffer_flag_Resp[resp_Flag][Valid]==0){ 
00F3E:  MOVF   5D,W
00F40:  MULLW  06
00F42:  MOVF   FF3,W
00F44:  MOVLB  1
00F46:  CLRF   x01
00F48:  MOVWF  x00
00F4A:  MOVLW  5F
00F4C:  ADDWF  x00,W
00F4E:  MOVWF  FE9
00F50:  MOVLW  00
00F52:  ADDWFC x01,W
00F54:  MOVWF  FEA
00F56:  MOVF   FEF,F
00F58:  BNZ   101A
....................       idx++; 
00F5A:  MOVLB  0
00F5C:  INCF   xFE,F
....................       if(buffer_flag_Resp[resp_Flag][idx]==1){ 
00F5E:  MOVF   5D,W
00F60:  MULLW  06
00F62:  MOVF   FF3,W
00F64:  MOVLB  1
00F66:  CLRF   x01
00F68:  MOVWF  x00
00F6A:  CLRF   03
00F6C:  MOVLB  0
00F6E:  MOVF   xFE,W
00F70:  MOVLB  1
00F72:  ADDWF  x00,W
00F74:  MOVWF  01
00F76:  MOVF   x01,W
00F78:  ADDWFC 03,F
00F7A:  MOVF   01,W
00F7C:  ADDLW  5F
00F7E:  MOVWF  FE9
00F80:  MOVLW  00
00F82:  ADDWFC 03,W
00F84:  MOVWF  FEA
00F86:  DECFSZ FEF,W
00F88:  BRA    100C
....................          buffer_flag_Resp[resp_Pos][idx]   = 0; 
00F8A:  MOVF   5C,W
00F8C:  MULLW  06
00F8E:  MOVF   FF3,W
00F90:  CLRF   x01
00F92:  MOVWF  x00
00F94:  CLRF   03
00F96:  MOVLB  0
00F98:  MOVF   xFE,W
00F9A:  MOVLB  1
00F9C:  ADDWF  x00,W
00F9E:  MOVWF  01
00FA0:  MOVF   x01,W
00FA2:  ADDWFC 03,F
00FA4:  MOVF   01,W
00FA6:  ADDLW  5F
00FA8:  MOVWF  FE9
00FAA:  MOVLW  00
00FAC:  ADDWFC 03,W
00FAE:  MOVWF  FEA
00FB0:  CLRF   FEF
....................          buffer_flag_Resp[resp_Flag][idx]  = 0; 
00FB2:  MOVF   5D,W
00FB4:  MULLW  06
00FB6:  MOVF   FF3,W
00FB8:  CLRF   x01
00FBA:  MOVWF  x00
00FBC:  CLRF   03
00FBE:  MOVLB  0
00FC0:  MOVF   xFE,W
00FC2:  MOVLB  1
00FC4:  ADDWF  x00,W
00FC6:  MOVWF  01
00FC8:  MOVF   x01,W
00FCA:  ADDWFC 03,F
00FCC:  MOVF   01,W
00FCE:  ADDLW  5F
00FD0:  MOVWF  FE9
00FD2:  MOVLW  00
00FD4:  ADDWFC 03,W
00FD6:  MOVWF  FEA
00FD8:  CLRF   FEF
....................          
....................          if(idx == Fail || idx == Error){ 
00FDA:  MOVLB  0
00FDC:  MOVF   xFE,W
00FDE:  SUBLW  04
00FE0:  BZ    0FE8
00FE2:  MOVF   xFE,W
00FE4:  SUBLW  05
00FE6:  BNZ   1006
....................             buffer_flag_Resp[resp_Flag][Valid]  = 1; 
00FE8:  MOVF   5D,W
00FEA:  MULLW  06
00FEC:  MOVF   FF3,W
00FEE:  MOVLB  1
00FF0:  CLRF   x01
00FF2:  MOVWF  x00
00FF4:  MOVLW  5F
00FF6:  ADDWF  x00,W
00FF8:  MOVWF  FE9
00FFA:  MOVLW  00
00FFC:  ADDWFC x01,W
00FFE:  MOVWF  FEA
01000:  MOVLW  01
01002:  MOVWF  FEF
01004:  MOVLB  0
....................          } 
....................          ret = idx; 
01006:  MOVFF  FE,FD
0100A:  MOVLB  1
....................       } 
....................       // Reinicia el contador para no desbordar el array de flag_resp 
....................       if(idx>=countResp){ 
0100C:  MOVF   5E,W
0100E:  MOVLB  0
01010:  SUBWF  xFE,W
01012:  BNC   1016
....................          idx = 0; 
01014:  CLRF   xFE
....................       } 
01016:  BRA    0F3E
01018:  MOVLB  1
....................        
....................    }; // Fin del loop 
....................     
....................    buffer_flag_Resp[resp_Flag][Valid] = 0; 
0101A:  MOVF   5D,W
0101C:  MULLW  06
0101E:  MOVF   FF3,W
01020:  CLRF   x01
01022:  MOVWF  x00
01024:  MOVLW  5F
01026:  ADDWF  x00,W
01028:  MOVWF  FE9
0102A:  MOVLW  00
0102C:  ADDWFC x01,W
0102E:  MOVWF  FEA
01030:  CLRF   FEF
....................    CMD_RUN = 0x00; 
01032:  CLRF   5B
....................    delay_ms(10); 
01034:  MOVLW  0A
01036:  MOVWF  x26
01038:  MOVLB  0
0103A:  RCALL  0C36
....................    return ret; 
0103C:  MOVFF  FD,01
01040:  RETURN 0
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
.................... void waitRespMajor(int buffer,int flag_resp) 
*
00644:  MOVLB  1
00646:  CLRF   x3E
00648:  CLRF   x3F
.................... { 
....................     
....................    char  strResp[10]; 
....................    int   lenResp = 0,restartFlag = 0; 
....................  
....................    switch(flag_resp) 
0064A:  MOVF   x33,W
0064C:  ADDLW  FB
0064E:  BTFSC  FD8.0
00650:  BRA    0736
00652:  ADDLW  05
00654:  MOVLB  0
00656:  GOTO   0836
....................    { 
....................       case Valid: 
....................          strResp = "OK\r\n"; 
0065A:  MOVLW  01
0065C:  MOVWF  FEA
0065E:  MOVLW  34
00660:  MOVWF  FE9
00662:  MOVFF  FF2,140
00666:  BCF    FF2.7
00668:  MOVLW  00
0066A:  RCALL  00EA
0066C:  TBLRD*-
0066E:  TBLRD*+
00670:  MOVF   FF5,W
00672:  MOVWF  FEE
00674:  IORLW  00
00676:  BNZ   066E
00678:  MOVLB  1
0067A:  BTFSC  x40.7
0067C:  BSF    FF2.7
....................          lenResp = 4; 
0067E:  MOVLW  04
00680:  MOVWF  x3E
....................          // Como esta funcion es el ultimo caracter recibido no es necesario mantener 
....................          // Activa la bandera flag_Resp_Valid 
....................          restartFlag = 1; 
00682:  MOVLW  01
00684:  MOVWF  x3F
....................          break; 
00686:  BRA    0736
....................  
....................       case NoAp: 
....................          strResp = "No Ap"; 
00688:  MOVLW  01
0068A:  MOVWF  FEA
0068C:  MOVLW  34
0068E:  MOVWF  FE9
00690:  MOVFF  FF2,140
00694:  BCF    FF2.7
00696:  MOVLW  00
00698:  RCALL  0100
0069A:  TBLRD*-
0069C:  TBLRD*+
0069E:  MOVF   FF5,W
006A0:  MOVWF  FEE
006A2:  IORLW  00
006A4:  BNZ   069C
006A6:  MOVLB  1
006A8:  BTFSC  x40.7
006AA:  BSF    FF2.7
....................          lenResp = 5; 
006AC:  MOVLW  05
006AE:  MOVWF  x3E
....................          break; 
006B0:  BRA    0736
....................  
....................       case CWJAP: 
....................          strResp = "+CWJAP:"; 
006B2:  MOVLW  01
006B4:  MOVWF  FEA
006B6:  MOVLW  34
006B8:  MOVWF  FE9
006BA:  MOVFF  FF2,140
006BE:  BCF    FF2.7
006C0:  MOVLW  00
006C2:  RCALL  0116
006C4:  TBLRD*-
006C6:  TBLRD*+
006C8:  MOVF   FF5,W
006CA:  MOVWF  FEE
006CC:  IORLW  00
006CE:  BNZ   06C6
006D0:  MOVLB  1
006D2:  BTFSC  x40.7
006D4:  BSF    FF2.7
....................          lenResp = 7; 
006D6:  MOVLW  07
006D8:  MOVWF  x3E
....................          break; 
006DA:  BRA    0736
....................           
....................       case Connected: 
....................          strResp = "CONNECTED"; 
006DC:  MOVLW  01
006DE:  MOVWF  FEA
006E0:  MOVLW  34
006E2:  MOVWF  FE9
006E4:  MOVFF  FF2,140
006E8:  BCF    FF2.7
006EA:  MOVLW  00
006EC:  RCALL  012E
006EE:  TBLRD*-
006F0:  TBLRD*+
006F2:  MOVF   FF5,W
006F4:  MOVWF  FEE
006F6:  IORLW  00
006F8:  BNZ   06F0
006FA:  MOVLB  1
006FC:  BTFSC  x40.7
006FE:  BSF    FF2.7
....................          lenResp = 9; 
00700:  MOVLW  09
00702:  MOVWF  x3E
....................          break; 
00704:  BRA    0736
....................        
....................       case Fail: 
....................          strResp = "FAIL"; 
00706:  MOVLW  01
00708:  MOVWF  FEA
0070A:  MOVLW  34
0070C:  MOVWF  FE9
0070E:  MOVFF  FF2,140
00712:  BCF    FF2.7
00714:  MOVLW  00
00716:  RCALL  0148
00718:  TBLRD*-
0071A:  TBLRD*+
0071C:  MOVF   FF5,W
0071E:  MOVWF  FEE
00720:  IORLW  00
00722:  BNZ   071A
00724:  MOVLB  1
00726:  BTFSC  x40.7
00728:  BSF    FF2.7
....................          lenResp = 4; 
0072A:  MOVLW  04
0072C:  MOVWF  x3E
....................          restartFlag = 1; 
0072E:  MOVLW  01
00730:  MOVWF  x3F
....................          break; 
00732:  BRA    0736
00734:  MOVLB  1
....................    } 
....................  
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................  
....................    if(buffer == strResp[buffer_flag_Resp[resp_Pos][flag_resp]]) 
00736:  MOVF   5C,W
00738:  MULLW  06
0073A:  MOVF   FF3,W
0073C:  CLRF   x41
0073E:  MOVWF  x40
00740:  CLRF   03
00742:  MOVF   x33,W
00744:  ADDWF  x40,W
00746:  MOVWF  01
00748:  MOVF   x41,W
0074A:  ADDWFC 03,F
0074C:  MOVF   01,W
0074E:  ADDLW  5F
00750:  MOVWF  FE9
00752:  MOVLW  00
00754:  ADDWFC 03,W
00756:  MOVWF  FEA
00758:  CLRF   03
0075A:  MOVF   FEF,W
0075C:  ADDLW  34
0075E:  MOVWF  FE9
00760:  MOVLW  01
00762:  ADDWFC 03,W
00764:  MOVWF  FEA
00766:  MOVF   FEF,W
00768:  SUBWF  x32,W
0076A:  BNZ   07E6
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       buffer_flag_Resp[resp_Pos][flag_resp]++; 
0076C:  MOVF   5C,W
0076E:  MULLW  06
00770:  MOVF   FF3,W
00772:  CLRF   x41
00774:  MOVWF  x40
00776:  CLRF   03
00778:  MOVF   x33,W
0077A:  ADDWF  x40,W
0077C:  MOVWF  01
0077E:  MOVF   x41,W
00780:  ADDWFC 03,F
00782:  MOVF   01,W
00784:  ADDLW  5F
00786:  MOVWF  FE9
00788:  MOVLW  00
0078A:  ADDWFC 03,W
0078C:  MOVWF  FEA
0078E:  INCF   FEF,F
....................        
....................       if(buffer_flag_Resp[resp_Pos][flag_resp]==lenResp){ 
00790:  MOVF   5C,W
00792:  MULLW  06
00794:  MOVF   FF3,W
00796:  CLRF   x41
00798:  MOVWF  x40
0079A:  CLRF   03
0079C:  MOVF   x33,W
0079E:  ADDWF  x40,W
007A0:  MOVWF  01
007A2:  MOVF   x41,W
007A4:  ADDWFC 03,F
007A6:  MOVF   01,W
007A8:  ADDLW  5F
007AA:  MOVWF  FE9
007AC:  MOVLW  00
007AE:  ADDWFC 03,W
007B0:  MOVWF  FEA
007B2:  MOVF   x3E,W
007B4:  SUBWF  FEF,W
007B6:  BNZ   07E0
....................          // Respuesta es valida 
....................          buffer_flag_Resp[resp_Flag][flag_resp]  = 1; 
007B8:  MOVF   5D,W
007BA:  MULLW  06
007BC:  MOVF   FF3,W
007BE:  CLRF   x41
007C0:  MOVWF  x40
007C2:  CLRF   03
007C4:  MOVF   x33,W
007C6:  ADDWF  x40,W
007C8:  MOVWF  01
007CA:  MOVF   x41,W
007CC:  ADDWFC 03,F
007CE:  MOVF   01,W
007D0:  ADDLW  5F
007D2:  MOVWF  FE9
007D4:  MOVLW  00
007D6:  ADDWFC 03,W
007D8:  MOVWF  FEA
007DA:  MOVLW  01
007DC:  MOVWF  FEF
....................       }else if(flag_resp == Valid) { 
007DE:  BRA    07E4
007E0:  MOVF   x33,F
007E2:  BNZ   07E4
....................          // Reinicia la bandera para indicar el final del comando 
....................           //buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
....................       } 
....................         
....................    }else{ 
007E4:  BRA    0832
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       buffer_flag_Resp[resp_Pos][flag_resp]   = 0; 
007E6:  MOVF   5C,W
007E8:  MULLW  06
007EA:  MOVF   FF3,W
007EC:  CLRF   x41
007EE:  MOVWF  x40
007F0:  CLRF   03
007F2:  MOVF   x33,W
007F4:  ADDWF  x40,W
007F6:  MOVWF  01
007F8:  MOVF   x41,W
007FA:  ADDWFC 03,F
007FC:  MOVF   01,W
007FE:  ADDLW  5F
00800:  MOVWF  FE9
00802:  MOVLW  00
00804:  ADDWFC 03,W
00806:  MOVWF  FEA
00808:  CLRF   FEF
....................  
....................       // Banderas que se reinician 
....................       if(restartFlag == 1){ 
0080A:  DECFSZ x3F,W
0080C:  BRA    0832
....................          buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
0080E:  MOVF   5D,W
00810:  MULLW  06
00812:  MOVF   FF3,W
00814:  CLRF   x41
00816:  MOVWF  x40
00818:  CLRF   03
0081A:  MOVF   x33,W
0081C:  ADDWF  x40,W
0081E:  MOVWF  01
00820:  MOVF   x41,W
00822:  ADDWFC 03,F
00824:  MOVF   01,W
00826:  ADDLW  5F
00828:  MOVWF  FE9
0082A:  MOVLW  00
0082C:  ADDWFC 03,W
0082E:  MOVWF  FEA
00830:  CLRF   FEF
....................       } 
....................        
....................    } 
00832:  MOVLB  0
00834:  RETURN 0
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la IP del modo AP, STA, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getIP(int buffer) 
.................... { 
....................    const int END_GET_IP_CMD = 6; 
....................     
....................    // bandera de IP_First esta habilita 
....................    if(flag_Resp_Get_IP_CMD==1){ 
*
0085A:  DECFSZ xBB,W
0085C:  BRA    08B4
....................       // Fin de Get First IP 
....................       if(buffer == '"'){ 
0085E:  MOVLB  1
00860:  MOVF   x32,W
00862:  SUBLW  22
00864:  BNZ   0882
....................          // Finaliza el almacenamiento en el buffer 
....................          if( modeStar=='1' || modeStar=='2' ){ 
00866:  MOVLB  0
00868:  MOVF   xC1,W
0086A:  SUBLW  31
0086C:  BZ    0874
0086E:  MOVF   xC1,W
00870:  SUBLW  32
00872:  BNZ   087C
....................             flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
00874:  MOVLW  06
00876:  MOVWF  xBB
....................             flag_Pos_Get_IP_CMD =0; 
00878:  CLRF   xBC
....................          }else{ 
0087A:  BRA    087E
....................             // Activa Bandera de IP_STACION, reinicia el contador de Pos 
....................             flag_Pos_Get_IP_CMD =0; 
0087C:  CLRF   xBC
....................          } 
....................  
....................       }else{ 
0087E:  BRA    08B2
00880:  MOVLB  1
....................          if(modeStar=='1'){ 
00882:  MOVLB  0
00884:  MOVF   xC1,W
00886:  SUBLW  31
00888:  BNZ   089E
....................             // IP Estacion 
....................             buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
0088A:  CLRF   03
0088C:  MOVF   xBC,W
0088E:  ADDLW  7B
00890:  MOVWF  FE9
00892:  MOVLW  00
00894:  ADDWFC 03,W
00896:  MOVWF  FEA
00898:  MOVFF  132,FEF
....................          }else{ 
0089C:  BRA    08B0
....................             // IP AP 
....................              buffer_Resp_CMD[0][flag_Pos_Get_IP_CMD] = buffer; 
0089E:  CLRF   03
008A0:  MOVF   xBC,W
008A2:  ADDLW  6B
008A4:  MOVWF  FE9
008A6:  MOVLW  00
008A8:  ADDWFC 03,W
008AA:  MOVWF  FEA
008AC:  MOVFF  132,FEF
....................          } 
....................          flag_Pos_Get_IP_CMD++; 
008B0:  INCF   xBC,F
....................       } // Fin del if(buffer == '"') 
....................     
....................    // bandera de IP_Second(Estacion) esta habilita 
....................    }else if(flag_Resp_Get_IP_CMD==5){ 
008B2:  BRA    08E4
008B4:  MOVF   xBB,W
008B6:  SUBLW  05
008B8:  BNZ   08E4
....................        if(buffer == '"'){ 
008BA:  MOVLB  1
008BC:  MOVF   x32,W
008BE:  SUBLW  22
008C0:  BNZ   08CE
....................          flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
008C2:  MOVLW  06
008C4:  MOVLB  0
008C6:  MOVWF  xBB
....................          flag_Pos_Get_IP_CMD =0; 
008C8:  CLRF   xBC
....................        }else{ 
008CA:  BRA    08E4
008CC:  MOVLB  1
....................          buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
008CE:  CLRF   03
008D0:  MOVLB  0
008D2:  MOVF   xBC,W
008D4:  ADDLW  7B
008D6:  MOVWF  FE9
008D8:  MOVLW  00
008DA:  ADDWFC 03,W
008DC:  MOVWF  FEA
008DE:  MOVFF  132,FEF
....................          flag_Pos_Get_IP_CMD++; 
008E2:  INCF   xBC,F
....................        } 
....................    } // Fin de if(flag_Resp_Get_IP_CMD) 
....................        
....................    if( buffer == '"'){ 
008E4:  MOVLB  1
008E6:  MOVF   x32,W
008E8:  SUBLW  22
008EA:  BNZ   0900
....................       switch(flag_Resp_Get_IP_CMD){ 
008EC:  MOVLB  0
008EE:  MOVF   xBB,W
008F0:  ADDLW  FB
008F2:  BC    08FE
008F4:  ADDLW  05
008F6:  GOTO   0906
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................          case 4: 
....................             flag_Resp_Get_IP_CMD++; 
008FA:  INCF   xBB,F
....................             flag_Pos_Get_IP_CMD =0; 
008FC:  CLRF   xBC
....................             break; 
008FE:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
00900:  MOVLB  0
00902:  GOTO   0BAC (RETURN)
.................... } // Fin de la funcion getIP() 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo AP, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getAPInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_AP_Info_CMD==1){ 
*
0092A:  DECFSZ xBD,W
0092C:  BRA    0952
....................        
....................       if(buffer != '"'){ 
0092E:  MOVLB  1
00930:  MOVF   x32,W
00932:  SUBLW  22
00934:  BZ    094E
....................          buffer_Resp_CMD[2][flag_Pos_Get_AP_Info_CMD] = buffer; 
00936:  CLRF   03
00938:  MOVLB  0
0093A:  MOVF   xBE,W
0093C:  ADDLW  8B
0093E:  MOVWF  FE9
00940:  MOVLW  00
00942:  ADDWFC 03,W
00944:  MOVWF  FEA
00946:  MOVFF  132,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
0094A:  INCF   xBE,F
0094C:  MOVLB  1
....................       } 
....................  
....................    }else if(flag_Resp_Get_AP_Info_CMD==3){ 
0094E:  BRA    0980
00950:  MOVLB  0
00952:  MOVF   xBD,W
00954:  SUBLW  03
00956:  BNZ   097E
....................        
....................       if(buffer != '"'){ 
00958:  MOVLB  1
0095A:  MOVF   x32,W
0095C:  SUBLW  22
0095E:  BZ    097A
....................          buffer_Resp_CMD[3][flag_Pos_Get_AP_Info_CMD] = buffer; 
00960:  CLRF   03
00962:  MOVLB  0
00964:  MOVF   xBE,W
00966:  ADDLW  9B
00968:  MOVWF  FE9
0096A:  MOVLW  00
0096C:  ADDWFC 03,W
0096E:  MOVWF  FEA
00970:  MOVFF  132,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
00974:  INCF   xBE,F
....................       }else{ 
00976:  BRA    097E
00978:  MOVLB  1
....................          flag_Pos_Get_AP_Info_CMD =0; 
0097A:  MOVLB  0
0097C:  CLRF   xBE
0097E:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
00980:  MOVF   x32,W
00982:  SUBLW  22
00984:  BNZ   099A
....................       switch(flag_Resp_Get_AP_Info_CMD){ 
00986:  MOVLB  0
00988:  MOVF   xBD,W
0098A:  ADDLW  FC
0098C:  BC    0998
0098E:  ADDLW  04
00990:  GOTO   09A0
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................             flag_Resp_Get_AP_Info_CMD++; 
00994:  INCF   xBD,F
....................             flag_Pos_Get_AP_Info_CMD =0; 
00996:  CLRF   xBE
....................             break; 
00998:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
0099A:  MOVLB  0
0099C:  GOTO   0BC0 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo STA 
....................  *     
....................  *********************************************************/ 
.................... void getSTAInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_STA_Info_CMD==1){ 
*
009C2:  DECFSZ xBF,W
009C4:  BRA    09E4
....................        
....................       if(buffer != '"'){ 
009C6:  MOVLB  1
009C8:  MOVF   x32,W
009CA:  SUBLW  22
009CC:  BZ    09E6
....................          buffer_Resp_CMD[4][flag_Pos_Get_STA_Info_CMD] = buffer; 
009CE:  CLRF   03
009D0:  MOVLB  0
009D2:  MOVF   xC0,W
009D4:  ADDLW  AB
009D6:  MOVWF  FE9
009D8:  MOVLW  00
009DA:  ADDWFC 03,W
009DC:  MOVWF  FEA
009DE:  MOVFF  132,FEF
....................          flag_Pos_Get_STA_Info_CMD++; 
009E2:  INCF   xC0,F
009E4:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
009E6:  MOVF   x32,W
009E8:  SUBLW  22
009EA:  BNZ   09FE
....................       switch(flag_Resp_Get_STA_Info_CMD){ 
009EC:  MOVLB  0
009EE:  MOVF   xBF,W
009F0:  BZ    09F8
009F2:  XORLW  01
009F4:  BZ    09F8
009F6:  BRA    09FC
....................          case 0: 
....................          case 1: 
....................             flag_Resp_Get_STA_Info_CMD++; 
009F8:  INCF   xBF,F
....................             flag_Pos_Get_STA_Info_CMD =0; 
009FA:  CLRF   xC0
....................             break; 
009FC:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_STA_Info_CMD) 
....................    } // Fin del if(buffer == '"')  
009FE:  MOVLB  0
00A00:  GOTO   0BD4 (RETURN)
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_STA_IP     0 
....................   #define OPT_SHOW_STA_SSID   1 
....................   #define OPT_SHOW_AP_SSID    2 
....................   #define OPT_SHOW_AP_KEY     3 
....................   #define OPT_SHOW_AP_IP      4 
....................   #define OPT_MODE_AP         5 
....................   #define OPT_BACKLIGH        6 
....................   #define OPT_EXIT            7 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[9][17]    =  { {"ESTACION IP     "}, 
....................                                         {"ESTACION SSID   "}, 
....................                                         {"AP SSID         "}, 
....................                                         {"AP KEY          "}, 
....................                                         {"AP IP           "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacin     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 7; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
01BA6:  CLRF   xFA
01BA8:  CLRF   xFB
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
01BAA:  MOVF   xFA,W
01BAC:  MULLW  10
01BAE:  MOVF   FF3,W
01BB0:  CLRF   03
01BB2:  MOVWF  xFC
01BB4:  MOVLW  0C
01BB6:  MOVLB  1
01BB8:  MOVWF  x02
01BBA:  MOVLB  0
01BBC:  CALL   0E62
01BC0:  MOVLW  A2
01BC2:  MOVWF  FF6
01BC4:  MOVLW  02
01BC6:  MOVWF  FF7
01BC8:  MOVF   xFC,W
01BCA:  ADDWF  FF6,F
01BCC:  MOVLW  00
01BCE:  ADDWFC FF7,F
01BD0:  CALL   0ECE
....................    showBottonMenu(); 
01BD4:  CALL   126E
....................    while(!exit){ 
01BD8:  MOVF   xFB,F
01BDA:  BNZ   1C82
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01BDC:  CALL   12CA
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01BE0:  BSF    F93.4
01BE2:  BTFSC  F81.4
01BE4:  BRA    1C4A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01BE6:  MOVLW  02
01BE8:  MOVWF  xFC
01BEA:  MOVLW  FA
01BEC:  MOVLB  1
01BEE:  MOVWF  x26
01BF0:  MOVLB  0
01BF2:  CALL   0C36
01BF6:  DECFSZ xFC,F
01BF8:  BRA    1BEA
....................          BEEP; 
01BFA:  MOVLW  04
01BFC:  MOVLB  1
01BFE:  MOVWF  x00
01C00:  MOVLW  B9
01C02:  MOVLB  0
01C04:  MOVWF  xFF
01C06:  MOVLB  1
01C08:  CLRF   x02
01C0A:  MOVLW  14
01C0C:  MOVWF  x01
01C0E:  MOVLB  0
01C10:  RCALL  1A52
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
01C12:  INCF   xFA,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
01C14:  MOVF   xFA,W
01C16:  SUBWF  xF4,W
01C18:  BC    1C1C
....................             optSelected = 0; 
01C1A:  CLRF   xFA
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
01C1C:  MOVF   xFA,W
01C1E:  MULLW  10
01C20:  MOVF   FF3,W
01C22:  CLRF   03
01C24:  MOVWF  xFC
01C26:  MOVLW  0C
01C28:  MOVLB  1
01C2A:  MOVWF  x02
01C2C:  MOVLB  0
01C2E:  CALL   0E62
01C32:  MOVLW  A2
01C34:  MOVWF  FF6
01C36:  MOVLW  02
01C38:  MOVWF  FF7
01C3A:  MOVF   xFC,W
01C3C:  ADDWF  FF6,F
01C3E:  MOVLW  00
01C40:  ADDWFC FF7,F
01C42:  CALL   0ECE
....................          showBottonMenu(); 
01C46:  CALL   126E
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01C4A:  BSF    F93.5
01C4C:  BTFSC  F81.5
01C4E:  BRA    1C80
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01C50:  MOVLW  02
01C52:  MOVWF  xFC
01C54:  MOVLW  FA
01C56:  MOVLB  1
01C58:  MOVWF  x26
01C5A:  MOVLB  0
01C5C:  CALL   0C36
01C60:  DECFSZ xFC,F
01C62:  BRA    1C54
....................          BEEP; 
01C64:  MOVLW  04
01C66:  MOVLB  1
01C68:  MOVWF  x00
01C6A:  MOVLW  B9
01C6C:  MOVLB  0
01C6E:  MOVWF  xFF
01C70:  MOVLB  1
01C72:  CLRF   x02
01C74:  MOVLW  14
01C76:  MOVWF  x01
01C78:  MOVLB  0
01C7A:  RCALL  1A52
....................          // Rompe el Loop 
....................          exit = 1; 
01C7C:  MOVLW  01
01C7E:  MOVWF  xFB
....................       } // Fin KEY_OK 
01C80:  BRA    1BD8
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
01C82:  MOVLW  01
01C84:  ADDWF  xFA,W
01C86:  MOVWF  01
01C88:  GOTO   258C (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
01F28:  MOVLW  0C
01F2A:  MOVLB  1
01F2C:  MOVWF  x03
01F2E:  MOVLW  02
01F30:  MOVWF  x04
01F32:  MOVLB  0
01F34:  CALL   0E3C
....................   printf(lcd_putc, "SALIR"); 
01F38:  MOVLW  F8
01F3A:  MOVWF  FF6
01F3C:  MOVLW  04
01F3E:  MOVWF  FF7
01F40:  CALL   0ECE
....................    
....................   while(1){ 
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01F44:  CALL   12CA
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
01F48:  BSF    F93.5
01F4A:  BTFSC  F81.5
01F4C:  BRA    1F64
....................            // Elimina el rebote 
....................            delay_ms(500); 
01F4E:  MOVLW  02
01F50:  MOVWF  xFF
01F52:  MOVLW  FA
01F54:  MOVLB  1
01F56:  MOVWF  x26
01F58:  MOVLB  0
01F5A:  CALL   0C36
01F5E:  DECFSZ xFF,F
01F60:  BRA    1F52
....................            break; 
01F62:  BRA    1F66
....................      } 
01F64:  BRA    1F44
....................   } 
01F66:  RETURN 0
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
0126E:  MOVLW  01
01270:  MOVLB  1
01272:  MOVWF  x03
01274:  MOVLW  02
01276:  MOVWF  x04
01278:  MOVLB  0
0127A:  RCALL  0E3C
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
0127C:  MOVLW  FE
0127E:  MOVWF  FF6
01280:  MOVLW  04
01282:  MOVWF  FF7
01284:  RCALL  0ECE
01286:  RETURN 0
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
01C8C:  CLRF   xFA
01C8E:  CLRF   xFB
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
01C90:  MOVF   xFA,W
01C92:  MULLW  0F
01C94:  MOVF   FF3,W
01C96:  CLRF   03
01C98:  MOVWF  xFC
01C9A:  MOVLW  0C
01C9C:  MOVLB  1
01C9E:  MOVWF  x02
01CA0:  MOVLB  0
01CA2:  CALL   0E62
01CA6:  MOVLW  E2
01CA8:  MOVWF  FF6
01CAA:  MOVLW  02
01CAC:  MOVWF  FF7
01CAE:  MOVF   xFC,W
01CB0:  ADDWF  FF6,F
01CB2:  MOVLW  00
01CB4:  ADDWFC FF7,F
01CB6:  CALL   0ECE
....................    showBottonMenu(); 
01CBA:  CALL   126E
....................     
....................    while(!exit){ 
01CBE:  MOVF   xFB,F
01CC0:  BTFSS  FD8.2
01CC2:  BRA    1DC0
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01CC4:  CALL   12CA
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01CC8:  BSF    F93.4
01CCA:  BTFSC  F81.4
01CCC:  BRA    1D32
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01CCE:  MOVLW  02
01CD0:  MOVWF  xFC
01CD2:  MOVLW  FA
01CD4:  MOVLB  1
01CD6:  MOVWF  x26
01CD8:  MOVLB  0
01CDA:  CALL   0C36
01CDE:  DECFSZ xFC,F
01CE0:  BRA    1CD2
....................          BEEP; 
01CE2:  MOVLW  04
01CE4:  MOVLB  1
01CE6:  MOVWF  x00
01CE8:  MOVLW  B9
01CEA:  MOVLB  0
01CEC:  MOVWF  xFF
01CEE:  MOVLB  1
01CF0:  CLRF   x02
01CF2:  MOVLW  14
01CF4:  MOVWF  x01
01CF6:  MOVLB  0
01CF8:  RCALL  1A52
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
01CFA:  INCF   xFA,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
01CFC:  MOVF   xFA,W
01CFE:  SUBWF  xF5,W
01D00:  BC    1D04
....................             optSelected = 0; 
01D02:  CLRF   xFA
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
01D04:  MOVF   xFA,W
01D06:  MULLW  0F
01D08:  MOVF   FF3,W
01D0A:  CLRF   03
01D0C:  MOVWF  xFC
01D0E:  MOVLW  0C
01D10:  MOVLB  1
01D12:  MOVWF  x02
01D14:  MOVLB  0
01D16:  CALL   0E62
01D1A:  MOVLW  E2
01D1C:  MOVWF  FF6
01D1E:  MOVLW  02
01D20:  MOVWF  FF7
01D22:  MOVF   xFC,W
01D24:  ADDWF  FF6,F
01D26:  MOVLW  00
01D28:  ADDWFC FF7,F
01D2A:  CALL   0ECE
....................          showBottonMenu(); 
01D2E:  CALL   126E
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01D32:  BSF    F93.5
01D34:  BTFSC  F81.5
01D36:  BRA    1DBE
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01D38:  MOVLW  02
01D3A:  MOVWF  xFC
01D3C:  MOVLW  FA
01D3E:  MOVLB  1
01D40:  MOVWF  x26
01D42:  MOVLB  0
01D44:  CALL   0C36
01D48:  DECFSZ xFC,F
01D4A:  BRA    1D3C
....................          BEEP; 
01D4C:  MOVLW  04
01D4E:  MOVLB  1
01D50:  MOVWF  x00
01D52:  MOVLW  B9
01D54:  MOVLB  0
01D56:  MOVWF  xFF
01D58:  MOVLB  1
01D5A:  CLRF   x02
01D5C:  MOVLW  14
01D5E:  MOVWF  x01
01D60:  MOVLB  0
01D62:  RCALL  1A52
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuOn){ 
01D64:  MOVF   xF5,W
01D66:  SUBWF  xFA,W
01D68:  BNZ   1D70
....................             exit = 1; 
01D6A:  MOVLW  01
01D6C:  MOVWF  xFB
....................          }else{ 
01D6E:  BRA    1DBE
....................             output_high(PIN_OUT[optSelected]); 
01D70:  BCF    FD8.0
01D72:  RLCF   xFA,W
01D74:  CLRF   03
01D76:  MOVFF  FF2,FC
01D7A:  BCF    FF2.7
01D7C:  CALL   0096
01D80:  TBLRD*+
01D82:  MOVFF  FF5,03
01D86:  BTFSC  xFC.7
01D88:  BSF    FF2.7
01D8A:  MOVWF  xFC
01D8C:  MOVFF  03,FD
01D90:  MOVFF  FE8,127
01D94:  MOVLW  01
01D96:  MOVLB  1
01D98:  MOVWF  x28
01D9A:  MOVLW  0F
01D9C:  MOVWF  x2A
01D9E:  MOVLW  89
01DA0:  MOVWF  x29
01DA2:  MOVLB  0
01DA4:  CALL   1288
01DA8:  MOVFF  FC,127
01DAC:  MOVLB  1
01DAE:  CLRF   x28
01DB0:  MOVLW  0F
01DB2:  MOVWF  x2A
01DB4:  MOVLW  92
01DB6:  MOVWF  x29
01DB8:  MOVLB  0
01DBA:  CALL   1288
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
01DBE:  BRA    1CBE
....................    } // FIN While Infinito 
....................  
....................    return 0; 
01DC0:  MOVLW  00
01DC2:  MOVWF  01
01DC4:  GOTO   2596 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
01DC8:  CLRF   xFA
01DCA:  CLRF   xFB
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
01DCC:  MOVF   xFA,W
01DCE:  MULLW  10
01DD0:  MOVF   FF3,W
01DD2:  CLRF   03
01DD4:  MOVWF  xFC
01DD6:  MOVLW  0C
01DD8:  MOVLB  1
01DDA:  MOVWF  x02
01DDC:  MOVLB  0
01DDE:  CALL   0E62
01DE2:  MOVLW  78
01DE4:  MOVWF  FF6
01DE6:  MOVLW  03
01DE8:  MOVWF  FF7
01DEA:  MOVF   xFC,W
01DEC:  ADDWF  FF6,F
01DEE:  MOVLW  00
01DF0:  ADDWFC FF7,F
01DF2:  CALL   0ECE
....................    showBottonMenu(); 
01DF6:  CALL   126E
....................     
....................    while(!exit){ 
01DFA:  MOVF   xFB,F
01DFC:  BTFSS  FD8.2
01DFE:  BRA    1EFA
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01E00:  CALL   12CA
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01E04:  BSF    F93.4
01E06:  BTFSC  F81.4
01E08:  BRA    1E6E
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01E0A:  MOVLW  02
01E0C:  MOVWF  xFC
01E0E:  MOVLW  FA
01E10:  MOVLB  1
01E12:  MOVWF  x26
01E14:  MOVLB  0
01E16:  CALL   0C36
01E1A:  DECFSZ xFC,F
01E1C:  BRA    1E0E
....................          BEEP; 
01E1E:  MOVLW  04
01E20:  MOVLB  1
01E22:  MOVWF  x00
01E24:  MOVLW  B9
01E26:  MOVLB  0
01E28:  MOVWF  xFF
01E2A:  MOVLB  1
01E2C:  CLRF   x02
01E2E:  MOVLW  14
01E30:  MOVWF  x01
01E32:  MOVLB  0
01E34:  RCALL  1A52
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
01E36:  INCF   xFA,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
01E38:  MOVF   xFA,W
01E3A:  SUBWF  xF6,W
01E3C:  BC    1E40
....................             optSelected = 0; 
01E3E:  CLRF   xFA
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
01E40:  MOVF   xFA,W
01E42:  MULLW  10
01E44:  MOVF   FF3,W
01E46:  CLRF   03
01E48:  MOVWF  xFC
01E4A:  MOVLW  0C
01E4C:  MOVLB  1
01E4E:  MOVWF  x02
01E50:  MOVLB  0
01E52:  CALL   0E62
01E56:  MOVLW  78
01E58:  MOVWF  FF6
01E5A:  MOVLW  03
01E5C:  MOVWF  FF7
01E5E:  MOVF   xFC,W
01E60:  ADDWF  FF6,F
01E62:  MOVLW  00
01E64:  ADDWFC FF7,F
01E66:  CALL   0ECE
....................          showBottonMenu(); 
01E6A:  CALL   126E
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01E6E:  BSF    F93.5
01E70:  BTFSC  F81.5
01E72:  BRA    1EF8
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01E74:  MOVLW  02
01E76:  MOVWF  xFC
01E78:  MOVLW  FA
01E7A:  MOVLB  1
01E7C:  MOVWF  x26
01E7E:  MOVLB  0
01E80:  CALL   0C36
01E84:  DECFSZ xFC,F
01E86:  BRA    1E78
....................          BEEP; 
01E88:  MOVLW  04
01E8A:  MOVLB  1
01E8C:  MOVWF  x00
01E8E:  MOVLW  B9
01E90:  MOVLB  0
01E92:  MOVWF  xFF
01E94:  MOVLB  1
01E96:  CLRF   x02
01E98:  MOVLW  14
01E9A:  MOVWF  x01
01E9C:  MOVLB  0
01E9E:  RCALL  1A52
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
01EA0:  MOVF   xF6,W
01EA2:  SUBWF  xFA,W
01EA4:  BNZ   1EAC
....................             exit = 1; 
01EA6:  MOVLW  01
01EA8:  MOVWF  xFB
....................          }else{ 
01EAA:  BRA    1EF8
....................             output_low(PIN_OUT[optSelected]); 
01EAC:  BCF    FD8.0
01EAE:  RLCF   xFA,W
01EB0:  CLRF   03
01EB2:  MOVFF  FF2,FC
01EB6:  BCF    FF2.7
01EB8:  CALL   0096
01EBC:  TBLRD*+
01EBE:  MOVFF  FF5,03
01EC2:  BTFSC  xFC.7
01EC4:  BSF    FF2.7
01EC6:  MOVWF  xFC
01EC8:  MOVFF  03,FD
01ECC:  MOVFF  FE8,127
01ED0:  MOVLB  1
01ED2:  CLRF   x28
01ED4:  MOVLW  0F
01ED6:  MOVWF  x2A
01ED8:  MOVLW  89
01EDA:  MOVWF  x29
01EDC:  MOVLB  0
01EDE:  CALL   1288
01EE2:  MOVFF  FC,127
01EE6:  MOVLB  1
01EE8:  CLRF   x28
01EEA:  MOVLW  0F
01EEC:  MOVWF  x2A
01EEE:  MOVLW  92
01EF0:  MOVWF  x29
01EF2:  MOVLB  0
01EF4:  CALL   1288
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
01EF8:  BRA    1DFA
....................    } // FIN While Infinito 
....................  
....................    return 0; 
01EFA:  MOVLW  00
01EFC:  MOVWF  01
01EFE:  GOTO   259E (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
....................  
....................    /******************************************** 
....................    *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................    *********************************************/ 
....................    run_command_wifi(); 
*
02348:  CALL   12CA
....................    /********************************************/ 
....................     
....................    int optSelected = 0; 
....................    int exit = 0; 
0234C:  CLRF   xFA
0234E:  CLRF   xFB
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02350:  MOVF   xFA,W
02352:  MULLW  11
02354:  MOVF   FF3,W
02356:  CLRF   03
02358:  MOVWF  xFC
0235A:  MOVLW  0C
0235C:  MOVLB  1
0235E:  MOVWF  x02
02360:  MOVLB  0
02362:  CALL   0E62
02366:  MOVLW  18
02368:  MOVWF  FF6
0236A:  MOVLW  04
0236C:  MOVWF  FF7
0236E:  MOVF   xFC,W
02370:  ADDWF  FF6,F
02372:  MOVLW  00
02374:  ADDWFC FF7,F
02376:  CALL   0ECE
....................    showBottonMenu(); 
0237A:  CALL   126E
....................     
....................    while(!exit){ 
0237E:  MOVF   xFB,F
02380:  BNZ   2464
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
02382:  BSF    F93.4
02384:  BTFSC  F81.4
02386:  BRA    23EE
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02388:  MOVLW  02
0238A:  MOVWF  xFC
0238C:  MOVLW  FA
0238E:  MOVLB  1
02390:  MOVWF  x26
02392:  MOVLB  0
02394:  CALL   0C36
02398:  DECFSZ xFC,F
0239A:  BRA    238C
....................          BEEP; 
0239C:  MOVLW  04
0239E:  MOVLB  1
023A0:  MOVWF  x00
023A2:  MOVLW  B9
023A4:  MOVLB  0
023A6:  MOVWF  xFF
023A8:  MOVLB  1
023AA:  CLRF   x02
023AC:  MOVLW  14
023AE:  MOVWF  x01
023B0:  MOVLB  0
023B2:  CALL   1A52
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
023B6:  INCF   xFA,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
023B8:  MOVF   xFA,W
023BA:  SUBWF  xF7,W
023BC:  BC    23C0
....................             optSelected = 0; 
023BE:  CLRF   xFA
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
023C0:  MOVF   xFA,W
023C2:  MULLW  11
023C4:  MOVF   FF3,W
023C6:  CLRF   03
023C8:  MOVWF  xFC
023CA:  MOVLW  0C
023CC:  MOVLB  1
023CE:  MOVWF  x02
023D0:  MOVLB  0
023D2:  CALL   0E62
023D6:  MOVLW  18
023D8:  MOVWF  FF6
023DA:  MOVLW  04
023DC:  MOVWF  FF7
023DE:  MOVF   xFC,W
023E0:  ADDWF  FF6,F
023E2:  MOVLW  00
023E4:  ADDWFC FF7,F
023E6:  CALL   0ECE
....................          showBottonMenu(); 
023EA:  CALL   126E
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
023EE:  BSF    F93.5
023F0:  BTFSC  F81.5
023F2:  BRA    2462
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
023F4:  MOVLW  02
023F6:  MOVWF  xFC
023F8:  MOVLW  FA
023FA:  MOVLB  1
023FC:  MOVWF  x26
023FE:  MOVLB  0
02400:  CALL   0C36
02404:  DECFSZ xFC,F
02406:  BRA    23F8
....................          BEEP; 
02408:  MOVLW  04
0240A:  MOVLB  1
0240C:  MOVWF  x00
0240E:  MOVLW  B9
02410:  MOVLB  0
02412:  MOVWF  xFF
02414:  MOVLB  1
02416:  CLRF   x02
02418:  MOVLW  14
0241A:  MOVWF  x01
0241C:  MOVLB  0
0241E:  CALL   1A52
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
02422:  MOVF   xF7,W
02424:  SUBWF  xFA,W
02426:  BNZ   242E
....................             exit = 1; 
02428:  MOVLW  01
0242A:  MOVWF  xFB
....................          }else{ 
0242C:  BRA    2462
....................             executeSetup(optSelected); 
0242E:  MOVFF  FA,FC
02432:  BRA    217E
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02434:  MOVF   xFA,W
02436:  MULLW  11
02438:  MOVF   FF3,W
0243A:  CLRF   03
0243C:  MOVWF  xFC
0243E:  MOVLW  0C
02440:  MOVLB  1
02442:  MOVWF  x02
02444:  MOVLB  0
02446:  CALL   0E62
0244A:  MOVLW  18
0244C:  MOVWF  FF6
0244E:  MOVLW  04
02450:  MOVWF  FF7
02452:  MOVF   xFC,W
02454:  ADDWF  FF6,F
02456:  MOVLW  00
02458:  ADDWFC FF7,F
0245A:  CALL   0ECE
....................             showBottonMenu(); 
0245E:  CALL   126E
....................          } 
....................       } // Fin KEY_OK 
02462:  BRA    237E
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02464:  MOVLW  00
02466:  MOVWF  01
02468:  GOTO   25A6 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................     
....................    
....................   switch(optSelect){ 
*
0217E:  MOVF   xFC,W
02180:  ADDLW  F8
02182:  BTFSC  FD8.0
02184:  BRA    2308
02186:  ADDLW  08
02188:  GOTO   2314
....................    
....................      case OPT_SHOW_AP_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
0218C:  MOVLW  10
0218E:  MOVWF  FF6
02190:  MOVLW  05
02192:  MOVWF  FF7
02194:  CALL   0EEE
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
02198:  MOVLW  05
0219A:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
0219C:  MOVLW  1C
0219E:  MOVWF  FF6
021A0:  MOVLW  05
021A2:  MOVWF  FF7
021A4:  CALL   0ECE
....................         waitResp(); 
021A8:  CALL   0F3A
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[0]); 
021AC:  MOVLW  0C
021AE:  MOVLB  1
021B0:  MOVWF  x02
021B2:  MOVLB  0
021B4:  CALL   0E62
021B8:  CLRF   FEA
021BA:  MOVLW  6B
021BC:  MOVWF  FE9
021BE:  RCALL  1F02
....................         flag_Resp_Get_IP_CMD = 0; 
021C0:  CLRF   xBB
....................         break; 
021C2:  BRA    2308
....................          
....................      case OPT_SHOW_STA_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
021C4:  MOVLW  2A
021C6:  MOVWF  FF6
021C8:  MOVLW  05
021CA:  MOVWF  FF7
021CC:  CALL   0EEE
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
021D0:  MOVLW  05
021D2:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
021D4:  MOVLW  36
021D6:  MOVWF  FF6
021D8:  MOVLW  05
021DA:  MOVWF  FF7
021DC:  CALL   0ECE
....................         waitResp(); 
021E0:  CALL   0F3A
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[1]); 
021E4:  MOVLW  0C
021E6:  MOVLB  1
021E8:  MOVWF  x02
021EA:  MOVLB  0
021EC:  CALL   0E62
021F0:  CLRF   FEA
021F2:  MOVLW  7B
021F4:  MOVWF  FE9
021F6:  RCALL  1F02
....................         flag_Resp_Get_IP_CMD = 0; 
021F8:  CLRF   xBB
....................         break; 
021FA:  BRA    2308
....................          
....................      case OPT_SHOW_STA_SSID: 
....................         if(modeStar!='2'){ 
021FC:  MOVF   xC1,W
021FE:  SUBLW  32
02200:  BZ    223A
....................            fprintf(ESP8266, "AT+CWJAP?\r\n"); 
02202:  MOVLW  44
02204:  MOVWF  FF6
02206:  MOVLW  05
02208:  MOVWF  FF7
0220A:  CALL   0EEE
....................            CMD_RUN = CMD_GET_STA_INFO_FROM_MENU; 
0220E:  MOVLW  07
02210:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
02212:  MOVLW  50
02214:  MOVWF  FF6
02216:  MOVLW  05
02218:  MOVWF  FF7
0221A:  CALL   0ECE
....................            waitResp(); 
0221E:  CALL   0F3A
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[4]); 
02222:  MOVLW  0C
02224:  MOVLB  1
02226:  MOVWF  x02
02228:  MOVLB  0
0222A:  CALL   0E62
0222E:  CLRF   FEA
02230:  MOVLW  AB
02232:  MOVWF  FE9
02234:  RCALL  1F02
....................            flag_Resp_Get_STA_Info_CMD=0; 
02236:  CLRF   xBF
....................         }else{ 
02238:  BRA    2246
....................            printf(lcd_putc, "\fDeshabilitado"); 
0223A:  MOVLW  5E
0223C:  MOVWF  FF6
0223E:  MOVLW  05
02240:  MOVWF  FF7
02242:  CALL   0ECE
....................         } 
....................         break; 
02246:  BRA    2308
....................          
....................      case OPT_SHOW_AP_SSID: 
....................         if(modeStar!='1'){ 
02248:  MOVF   xC1,W
0224A:  SUBLW  31
0224C:  BZ    2286
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
0224E:  MOVLW  6E
02250:  MOVWF  FF6
02252:  MOVLW  05
02254:  MOVWF  FF7
02256:  CALL   0EEE
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
0225A:  MOVLW  06
0225C:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
0225E:  MOVLW  7A
02260:  MOVWF  FF6
02262:  MOVLW  05
02264:  MOVWF  FF7
02266:  CALL   0ECE
....................            waitResp(); 
0226A:  CALL   0F3A
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[2]); 
0226E:  MOVLW  0C
02270:  MOVLB  1
02272:  MOVWF  x02
02274:  MOVLB  0
02276:  CALL   0E62
0227A:  CLRF   FEA
0227C:  MOVLW  8B
0227E:  MOVWF  FE9
02280:  RCALL  1F02
....................            flag_Resp_Get_AP_Info_CMD=0; 
02282:  CLRF   xBD
....................         }else{ 
02284:  BRA    2292
....................            printf(lcd_putc, "\fDeshabilitado"); 
02286:  MOVLW  88
02288:  MOVWF  FF6
0228A:  MOVLW  05
0228C:  MOVWF  FF7
0228E:  CALL   0ECE
....................         } 
....................         break; 
02292:  BRA    2308
....................          
....................      case OPT_SHOW_AP_KEY: 
....................         if(modeStar!='1'){ 
02294:  MOVF   xC1,W
02296:  SUBLW  31
02298:  BZ    22D2
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
0229A:  MOVLW  98
0229C:  MOVWF  FF6
0229E:  MOVLW  05
022A0:  MOVWF  FF7
022A2:  CALL   0EEE
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
022A6:  MOVLW  06
022A8:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
022AA:  MOVLW  A4
022AC:  MOVWF  FF6
022AE:  MOVLW  05
022B0:  MOVWF  FF7
022B2:  CALL   0ECE
....................            waitResp(); 
022B6:  CALL   0F3A
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[3]); 
022BA:  MOVLW  0C
022BC:  MOVLB  1
022BE:  MOVWF  x02
022C0:  MOVLB  0
022C2:  CALL   0E62
022C6:  CLRF   FEA
022C8:  MOVLW  9B
022CA:  MOVWF  FE9
022CC:  RCALL  1F02
....................            flag_Resp_Get_AP_Info_CMD=0; 
022CE:  CLRF   xBD
....................         }else{ 
022D0:  BRA    22DE
....................            printf(lcd_putc, "\fDeshabilitado"); 
022D2:  MOVLW  B2
022D4:  MOVWF  FF6
022D6:  MOVLW  05
022D8:  MOVWF  FF7
022DA:  CALL   0ECE
....................         } 
....................         break; 
022DE:  BRA    2308
....................          
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
022E0:  BRA    1F68
....................         break; 
022E2:  BRA    2308
....................          
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
022E4:  BCF    F95.3
022E6:  BTG    F8C.3
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
022E8:  BTFSS  F83.3
022EA:  BRA    22FA
....................            printf(lcd_putc, "\fBacklight On"); 
022EC:  MOVLW  C2
022EE:  MOVWF  FF6
022F0:  MOVLW  05
022F2:  MOVWF  FF7
022F4:  CALL   0ECE
....................         }else{ 
022F8:  BRA    2306
....................            printf(lcd_putc, "\fBacklight Off"); 
022FA:  MOVLW  D0
022FC:  MOVWF  FF6
022FE:  MOVLW  05
02300:  MOVWF  FF7
02302:  CALL   0ECE
....................         } 
....................         break; 
02306:  BRA    2308
....................          
....................      case OPT_EXIT: 
....................         break; 
....................          
....................   } 
....................    
....................   if(optSelect!=OPT_EXIT){ 
02308:  MOVF   xFC,W
0230A:  SUBLW  07
0230C:  BZ    2310
....................    pressExit(); 
0230E:  RCALL  1F28
....................   } 
02310:  GOTO   2434 (RETURN)
.................... } 
....................    
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
*
01F68:  CLRF   xFD
01F6A:  CLRF   xFE
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
01F6C:  MOVF   xFD,W
01F6E:  MULLW  0E
01F70:  MOVF   FF3,W
01F72:  CLRF   03
01F74:  MOVWF  xFF
01F76:  MOVLW  0C
01F78:  MOVLB  1
01F7A:  MOVWF  x02
01F7C:  MOVLB  0
01F7E:  CALL   0E62
01F82:  MOVLW  B2
01F84:  MOVWF  FF6
01F86:  MOVLW  04
01F88:  MOVWF  FF7
01F8A:  MOVF   xFF,W
01F8C:  ADDWF  FF6,F
01F8E:  MOVLW  00
01F90:  ADDWFC FF7,F
01F92:  CALL   0ECE
....................   showBottonMenu(); 
01F96:  CALL   126E
....................    
....................   while(!exit){ 
01F9A:  MOVF   xFE,F
01F9C:  BTFSS  FD8.2
01F9E:  BRA    217A
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01FA0:  CALL   12CA
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
01FA4:  BSF    F93.4
01FA6:  BTFSC  F81.4
01FA8:  BRA    200E
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
01FAA:  MOVLW  02
01FAC:  MOVWF  xFF
01FAE:  MOVLW  FA
01FB0:  MOVLB  1
01FB2:  MOVWF  x26
01FB4:  MOVLB  0
01FB6:  CALL   0C36
01FBA:  DECFSZ xFF,F
01FBC:  BRA    1FAE
....................         BEEP; 
01FBE:  MOVLW  04
01FC0:  MOVLB  1
01FC2:  MOVWF  x00
01FC4:  MOVLW  B9
01FC6:  MOVLB  0
01FC8:  MOVWF  xFF
01FCA:  MOVLB  1
01FCC:  CLRF   x02
01FCE:  MOVLW  14
01FD0:  MOVWF  x01
01FD2:  MOVLB  0
01FD4:  RCALL  1A52
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
01FD6:  INCF   xFD,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
01FD8:  MOVF   xFD,W
01FDA:  SUBWF  xF8,W
01FDC:  BC    1FE0
....................            optSelected = 0; 
01FDE:  CLRF   xFD
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
01FE0:  MOVF   xFD,W
01FE2:  MULLW  0E
01FE4:  MOVF   FF3,W
01FE6:  CLRF   03
01FE8:  MOVWF  xFF
01FEA:  MOVLW  0C
01FEC:  MOVLB  1
01FEE:  MOVWF  x02
01FF0:  MOVLB  0
01FF2:  CALL   0E62
01FF6:  MOVLW  B2
01FF8:  MOVWF  FF6
01FFA:  MOVLW  04
01FFC:  MOVWF  FF7
01FFE:  MOVF   xFF,W
02000:  ADDWF  FF6,F
02002:  MOVLW  00
02004:  ADDWFC FF7,F
02006:  CALL   0ECE
....................         showBottonMenu(); 
0200A:  CALL   126E
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
0200E:  BSF    F93.5
02010:  BTFSC  F81.5
02012:  BRA    2178
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
02014:  MOVLW  02
02016:  MOVWF  xFF
02018:  MOVLW  FA
0201A:  MOVLB  1
0201C:  MOVWF  x26
0201E:  MOVLB  0
02020:  CALL   0C36
02024:  DECFSZ xFF,F
02026:  BRA    2018
....................         BEEP; 
02028:  MOVLW  04
0202A:  MOVLB  1
0202C:  MOVWF  x00
0202E:  MOVLW  B9
02030:  MOVLB  0
02032:  MOVWF  xFF
02034:  MOVLB  1
02036:  CLRF   x02
02038:  MOVLW  14
0203A:  MOVWF  x01
0203C:  MOVLB  0
0203E:  RCALL  1A52
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
02040:  MOVF   xF8,W
02042:  SUBWF  xFD,W
02044:  BNZ   204C
....................            exit = 1; 
02046:  MOVLW  01
02048:  MOVWF  xFE
....................         }else{ 
0204A:  BRA    2178
....................            switch(optSelected){ 
0204C:  MOVF   xFD,W
0204E:  BZ    205A
02050:  XORLW  01
02052:  BZ    20AA
02054:  XORLW  03
02056:  BZ    20FA
02058:  BRA    2148
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
0205A:  MOVLW  E0
0205C:  MOVWF  FF6
0205E:  MOVLW  05
02060:  MOVWF  FF7
02062:  CALL   0EEE
....................                  write_eeprom(0,'1'); 
02066:  MOVF   FF2,W
02068:  MOVWF  00
0206A:  BCF    FF2.7
0206C:  CLRF   FAA
0206E:  CLRF   FA9
02070:  MOVLW  31
02072:  MOVWF  FA8
02074:  BCF    FA6.6
02076:  BCF    FA6.7
02078:  BSF    FA6.2
0207A:  MOVLB  F
0207C:  MOVLW  55
0207E:  MOVWF  FA7
02080:  MOVLW  AA
02082:  MOVWF  FA7
02084:  BSF    FA6.1
02086:  BTFSC  FA6.1
02088:  BRA    2086
0208A:  BCF    FA6.2
0208C:  MOVF   00,W
0208E:  IORWF  FF2,F
....................                  delay_ms(10); 
02090:  MOVLW  0A
02092:  MOVLB  1
02094:  MOVWF  x26
02096:  MOVLB  0
02098:  CALL   0C36
....................                  printf(lcd_putc, "\fConfig Cliente"); 
0209C:  MOVLW  F2
0209E:  MOVWF  FF6
020A0:  MOVLW  05
020A2:  MOVWF  FF7
020A4:  CALL   0ECE
....................                  break; 
020A8:  BRA    2148
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
020AA:  MOVLW  02
020AC:  MOVWF  FF6
020AE:  MOVLW  06
020B0:  MOVWF  FF7
020B2:  CALL   0EEE
....................                  write_eeprom(0,'2'); 
020B6:  MOVF   FF2,W
020B8:  MOVWF  00
020BA:  BCF    FF2.7
020BC:  CLRF   FAA
020BE:  CLRF   FA9
020C0:  MOVLW  32
020C2:  MOVWF  FA8
020C4:  BCF    FA6.6
020C6:  BCF    FA6.7
020C8:  BSF    FA6.2
020CA:  MOVLB  F
020CC:  MOVLW  55
020CE:  MOVWF  FA7
020D0:  MOVLW  AA
020D2:  MOVWF  FA7
020D4:  BSF    FA6.1
020D6:  BTFSC  FA6.1
020D8:  BRA    20D6
020DA:  BCF    FA6.2
020DC:  MOVF   00,W
020DE:  IORWF  FF2,F
....................                  delay_ms(10); 
020E0:  MOVLW  0A
020E2:  MOVLB  1
020E4:  MOVWF  x26
020E6:  MOVLB  0
020E8:  CALL   0C36
....................                  printf(lcd_putc, "\fConfig AP"); 
020EC:  MOVLW  14
020EE:  MOVWF  FF6
020F0:  MOVLW  06
020F2:  MOVWF  FF7
020F4:  CALL   0ECE
....................                  break; 
020F8:  BRA    2148
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
020FA:  MOVLW  20
020FC:  MOVWF  FF6
020FE:  MOVLW  06
02100:  MOVWF  FF7
02102:  CALL   0EEE
....................                  write_eeprom(0,'3'); 
02106:  MOVF   FF2,W
02108:  MOVWF  00
0210A:  BCF    FF2.7
0210C:  CLRF   FAA
0210E:  CLRF   FA9
02110:  MOVLW  33
02112:  MOVWF  FA8
02114:  BCF    FA6.6
02116:  BCF    FA6.7
02118:  BSF    FA6.2
0211A:  MOVLB  F
0211C:  MOVLW  55
0211E:  MOVWF  FA7
02120:  MOVLW  AA
02122:  MOVWF  FA7
02124:  BSF    FA6.1
02126:  BTFSC  FA6.1
02128:  BRA    2126
0212A:  BCF    FA6.2
0212C:  MOVF   00,W
0212E:  IORWF  FF2,F
....................                  delay_ms(10); 
02130:  MOVLW  0A
02132:  MOVLB  1
02134:  MOVWF  x26
02136:  MOVLB  0
02138:  CALL   0C36
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
0213C:  MOVLW  32
0213E:  MOVWF  FF6
02140:  MOVLW  06
02142:  MOVWF  FF7
02144:  CALL   0ECE
....................                  break; 
....................            } 
....................            pressExit(); 
02148:  RCALL  1F28
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
0214A:  MOVF   xFD,W
0214C:  MULLW  0E
0214E:  MOVF   FF3,W
02150:  CLRF   03
02152:  MOVWF  xFF
02154:  MOVLW  0C
02156:  MOVLB  1
02158:  MOVWF  x02
0215A:  MOVLB  0
0215C:  CALL   0E62
02160:  MOVLW  B2
02162:  MOVWF  FF6
02164:  MOVLW  04
02166:  MOVWF  FF7
02168:  MOVF   xFF,W
0216A:  ADDWF  FF6,F
0216C:  MOVLW  00
0216E:  ADDWFC FF7,F
02170:  CALL   0ECE
....................            showBottonMenu(); 
02174:  CALL   126E
....................         } 
....................      } // Fin KEY_OK 
02178:  BRA    1F9A
....................   } // FIN While Infinito 
0217A:  GOTO   2308 (RETURN)
.................... } // Fin funcion setMenuModo 
....................  
....................  
.................... /******************************************** 
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
00C0C:  BTFSS  F9E.5
00C0E:  BRA    0C0C
00C10:  MOVFF  FAE,130
00C14:  MOVLB  1
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
00C16:  MOVFF  130,131
00C1A:  MOVLB  0
00C1C:  BRA    0B24
00C1E:  BCF    F9E.5
00C20:  GOTO   0054
.................... } 
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
*
0246C:  CLRF   FF8
0246E:  BCF    FD0.7
02470:  BSF    07.7
02472:  BSF    FB8.3
02474:  MOVLW  08
02476:  MOVWF  FAF
02478:  MOVLW  02
0247A:  MOVWF  FB0
0247C:  MOVLW  A6
0247E:  MOVWF  FAC
02480:  MOVLW  90
02482:  MOVWF  FAB
02484:  BCF    F93.0
02486:  BSF    F8A.0
02488:  CLRF   53
0248A:  CLRF   52
0248C:  CLRF   54
0248E:  CLRF   55
02490:  CLRF   56
02492:  CLRF   57
02494:  CLRF   58
02496:  CLRF   59
02498:  CLRF   5A
0249A:  CLRF   5B
0249C:  MOVLW  01
0249E:  MOVWF  5C
024A0:  CLRF   5D
024A2:  MOVLW  05
024A4:  MOVWF  5E
024A6:  CLRF   xBB
024A8:  CLRF   xBC
024AA:  CLRF   xBD
024AC:  CLRF   xBE
024AE:  CLRF   xBF
024B0:  CLRF   xC0
024B2:  MOVLW  02
024B4:  MOVWF  xF4
024B6:  MOVLW  08
024B8:  MOVWF  xF5
024BA:  MOVWF  xF6
024BC:  MOVLW  07
024BE:  MOVWF  xF7
024C0:  MOVLW  03
024C2:  MOVWF  xF8
024C4:  CLRF   xF9
024C6:  MOVF   FC1,W
024C8:  ANDLW  C0
024CA:  IORLW  0F
024CC:  MOVWF  FC1
024CE:  MOVLW  07
024D0:  MOVWF  FB4
024D2:  BRA    2506
024D4:  DATA 02,00
024D6:  DATA 16,00
024D8:  DATA 00,0C
024DA:  DATA 40,5F
024DC:  DATA 00,07
024DE:  DATA 80,30
024E0:  DATA 2E,30
024E2:  DATA 2E,30
024E4:  DATA 2E,30
024E6:  DATA 09,C0
024E8:  DATA 00,07
024EA:  DATA 80,30
024EC:  DATA 2E,30
024EE:  DATA 2E,30
024F0:  DATA 2E,30
024F2:  DATA 19,C0
024F4:  DATA 00,03
024F6:  DATA 80,4B
024F8:  DATA 45,59
024FA:  DATA 0D,C0
024FC:  DATA 00,05
024FE:  DATA 80,53
02500:  DATA 53,49
02502:  DATA 44,00
02504:  DATA 00,00
02506:  MOVLW  00
02508:  MOVWF  FF8
0250A:  MOVLW  24
0250C:  MOVWF  FF7
0250E:  MOVLW  D4
02510:  MOVWF  FF6
02512:  TBLRD*+
02514:  MOVF   FF5,W
02516:  MOVWF  00
02518:  XORLW  00
0251A:  BZ    2542
0251C:  TBLRD*+
0251E:  MOVF   FF5,W
02520:  MOVWF  01
02522:  BTFSC  FE8.7
02524:  BRA    2530
02526:  ANDLW  0F
02528:  MOVWF  FEA
0252A:  TBLRD*+
0252C:  MOVFF  FF5,FE9
02530:  BTFSC  01.6
02532:  TBLRD*+
02534:  BTFSS  01.6
02536:  TBLRD*+
02538:  MOVFF  FF5,FEE
0253C:  DCFSNZ 00,F
0253E:  BRA    2512
02540:  BRA    2534
02542:  CLRF   FF8
....................    {       
....................       /*for(int idxNC=0;idxNC<=255;idxNC++){ 
....................          write_eeprom(idxNC,0xFF); 
....................          delay_ms(10); 
....................       }*/ 
....................           
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
02544:  MOVLW  02
02546:  MOVWF  xFA
02548:  MOVLW  FA
0254A:  MOVLB  1
0254C:  MOVWF  x26
0254E:  MOVLB  0
02550:  CALL   0C36
02554:  DECFSZ xFA,F
02556:  BRA    2548
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
02558:  BCF    FF1.7
....................       set_tris_b(0b00110010); 
0255A:  MOVLW  32
0255C:  MOVWF  F93
....................       enable_interrupts(INT_RDA);  
0255E:  BSF    F9D.5
....................       enable_interrupts(GLOBAL);  
02560:  MOVLW  C0
02562:  IORWF  FF2,F
....................        
....................       // Inicializa la LCD 
....................       lcd_init(); 
02564:  GOTO   0DA4
....................       printf(lcd_putc, "\fConfigurando..."); 
02568:  MOVLW  24
0256A:  MOVWF  FF6
0256C:  MOVLW  0C
0256E:  MOVWF  FF7
02570:  CALL   0ECE
....................  
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
02574:  BCF    F95.3
02576:  BSF    F8C.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
02578:  GOTO   1068
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
0257C:  MOVF   xF9,W
0257E:  ADDLW  FC
02580:  BC    25AA
02582:  ADDLW  04
02584:  GOTO   25AE
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
02588:  GOTO   1BA6
0258C:  MOVFF  01,F9
....................                break; 
02590:  BRA    25AA
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
02592:  GOTO   1C8C
02596:  MOVFF  01,F9
....................                break; 
0259A:  BRA    25AA
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
0259C:  BRA    1DC8
0259E:  MOVFF  01,F9
....................                break; 
025A2:  BRA    25AA
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
025A4:  BRA    2348
025A6:  MOVFF  01,F9
....................                break; 
....................          } // Fin del Switch(menuActive) 
025AA:  BRA    257C
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
025AC:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
