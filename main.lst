CCS PCM C Compiler, Version 5.015, 5967               03-dic.-17 19:27

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   5135 words (63%)
                           Largest free fragment is 2048
               RAM used:   115 (31%) at main() level
                           152 (41%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 8

*
0000:  MOVLW  13
0001:  MOVWF  0A
0002:  GOTO   3EC
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   346
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  4F
0056:  RETLW  4B
0057:  RETLW  0D
0058:  RETLW  0A
0059:  BCF    0A.0
005A:  BCF    0A.1
005B:  BCF    0A.2
005C:  ADDWF  02,F
005D:  RETLW  4E
005E:  RETLW  6F
005F:  RETLW  20
0060:  RETLW  41
0061:  RETLW  50
0062:  BCF    0A.0
0063:  BCF    0A.1
0064:  BCF    0A.2
0065:  ADDWF  02,F
0066:  RETLW  2B
0067:  RETLW  43
0068:  RETLW  57
0069:  RETLW  4A
006A:  RETLW  41
006B:  RETLW  50
006C:  RETLW  3A
006D:  BCF    0A.0
006E:  BCF    0A.1
006F:  BCF    0A.2
0070:  ADDWF  02,F
0071:  RETLW  43
0072:  RETLW  4F
0073:  RETLW  4E
0074:  RETLW  4E
0075:  RETLW  45
0076:  RETLW  43
0077:  RETLW  54
0078:  RETLW  45
0079:  RETLW  44
007A:  BCF    0A.0
007B:  BCF    0A.1
007C:  BCF    0A.2
007D:  ADDWF  02,F
007E:  RETLW  46
007F:  RETLW  41
0080:  RETLW  49
0081:  RETLW  4C
0082:  RETLW  43
0083:  RETLW  6C
0084:  RETLW  69
0085:  RETLW  65
0086:  RETLW  6E
0087:  RETLW  74
0088:  RETLW  65
0089:  RETLW  20
008A:  RETLW  20
008B:  RETLW  20
008C:  RETLW  20
008D:  RETLW  20
008E:  RETLW  00
008F:  RETLW  41
0090:  RETLW  63
0091:  RETLW  63
0092:  RETLW  65
0093:  RETLW  73
0094:  RETLW  73
0095:  RETLW  20
0096:  RETLW  50
0097:  RETLW  6F
0098:  RETLW  69
0099:  RETLW  6E
009A:  RETLW  74
009B:  RETLW  00
009C:  RETLW  43
009D:  RETLW  6C
009E:  RETLW  69
009F:  RETLW  65
00A0:  RETLW  6E
00A1:  RETLW  74
00A2:  RETLW  65
00A3:  RETLW  20
00A4:  RETLW  2B
00A5:  RETLW  20
00A6:  RETLW  41
00A7:  RETLW  50
00A8:  RETLW  00
00A9:  RETLW  53
00AA:  RETLW  41
00AB:  RETLW  4C
00AC:  RETLW  49
00AD:  RETLW  52
00AE:  RETLW  20
00AF:  RETLW  20
00B0:  RETLW  20
00B1:  RETLW  20
00B2:  RETLW  20
00B3:  RETLW  20
00B4:  RETLW  20
00B5:  RETLW  00
00B6:  RETLW  00
00B7:  RETLW  00
00B8:  RETLW  00
00B9:  RETLW  00
00BA:  RETLW  00
00BB:  RETLW  00
00BC:  RETLW  00
00BD:  RETLW  00
00BE:  RETLW  00
00BF:  RETLW  00
00C0:  RETLW  00
00C1:  RETLW  00
00C2:  RETLW  00
00C3:  DATA D3,20
00C4:  DATA CC,24
00C5:  DATA 52,00
00C6:  DATA DB,29
00C7:  DATA C9,23
00C8:  DATA 5D,10
00C9:  DATA 20,10
00CA:  DATA 20,10
00CB:  DATA A0,2D
00CC:  DATA 45,27
00CD:  DATA D4,2E
00CE:  DATA 00,00
00CF:  DATA 8C,21
00D0:  DATA 6F,37
00D1:  DATA E6,34
00D2:  DATA 67,10
00D3:  DATA 43,36
00D4:  DATA E9,32
00D5:  DATA 6E,3A
00D6:  DATA 65,00
00D7:  DATA 8C,21
00D8:  DATA 6F,37
00D9:  DATA E6,34
00DA:  DATA 67,10
00DB:  DATA 41,28
00DC:  DATA 00,01
00DD:  DATA 8C,21
00DE:  DATA 6F,37
00DF:  DATA E6,34
00E0:  DATA 67,10
00E1:  DATA 43,36
00E2:  DATA E9,32
00E3:  DATA 6E,3A
00E4:  DATA E5,20
00E5:  DATA 50,00
00E6:  DATA 8C,18
00E7:  DATA 39,19
00E8:  DATA AE,18
00E9:  DATA 36,1C
00EA:  DATA 2E,18
00EB:  DATA AE,18
00EC:  DATA 00,01
00ED:  DATA 8C,21
00EE:  DATA B0,23
00EF:  DATA B3,2F
00F0:  DATA 55,27
00F1:  DATA 45,00
00F2:  DATA 8C,18
00F3:  DATA B2,19
00F4:  DATA B4,20
00F5:  DATA FA,10
00F6:  DATA 00,01
00F7:  DATA 0C,21
00F8:  DATA E1,31
00F9:  DATA 6B,36
00FA:  DATA E9,33
00FB:  DATA 68,3A
00FC:  DATA A0,27
00FD:  DATA 6E,00
00FE:  DATA 0C,21
00FF:  DATA E1,31
0100:  DATA 6B,36
0101:  DATA E9,33
0102:  DATA 68,3A
0103:  DATA A0,27
0104:  DATA 66,33
0105:  DATA 00,01
0106:  RETLW  45
0107:  RETLW  6E
0108:  RETLW  63
0109:  RETLW  65
010A:  RETLW  6E
010B:  RETLW  64
010C:  RETLW  65
010D:  RETLW  72
010E:  RETLW  20
010F:  RETLW  4D
0110:  RETLW  61
0111:  RETLW  6E
0112:  RETLW  75
0113:  RETLW  61
0114:  RETLW  6C
0115:  RETLW  00
0116:  RETLW  41
0117:  RETLW  70
0118:  RETLW  61
0119:  RETLW  67
011A:  RETLW  61
011B:  RETLW  64
011C:  RETLW  6F
011D:  RETLW  20
011E:  RETLW  4D
011F:  RETLW  61
0120:  RETLW  6E
0121:  RETLW  75
0122:  RETLW  61
0123:  RETLW  6C
0124:  RETLW  20
0125:  RETLW  00
0126:  RETLW  43
0127:  RETLW  6F
0128:  RETLW  6E
0129:  RETLW  66
012A:  RETLW  69
012B:  RETLW  67
012C:  RETLW  75
012D:  RETLW  72
012E:  RETLW  61
012F:  RETLW  63
0130:  RETLW  69
0131:  RETLW  6F
0132:  RETLW  6E
0133:  RETLW  20
0134:  RETLW  20
0135:  RETLW  00
0136:  RETLW  00
0137:  RETLW  00
0138:  RETLW  00
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  00
013C:  RETLW  00
013D:  RETLW  00
013E:  RETLW  00
013F:  RETLW  00
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  00
0143:  RETLW  00
0144:  RETLW  00
0145:  RETLW  00
0146:  RETLW  4F
0147:  RETLW  6E
0148:  RETLW  20
0149:  RETLW  2D
014A:  RETLW  3E
014B:  RETLW  20
014C:  RETLW  53
014D:  RETLW  61
014E:  RETLW  6C
014F:  RETLW  69
0150:  RETLW  64
0151:  RETLW  61
0152:  RETLW  20
0153:  RETLW  31
0154:  RETLW  00
0155:  RETLW  4F
0156:  RETLW  6E
0157:  RETLW  20
0158:  RETLW  2D
0159:  RETLW  3E
015A:  RETLW  20
015B:  RETLW  53
015C:  RETLW  61
015D:  RETLW  6C
015E:  RETLW  69
015F:  RETLW  64
0160:  RETLW  61
0161:  RETLW  20
0162:  RETLW  32
0163:  RETLW  00
0164:  RETLW  4F
0165:  RETLW  6E
0166:  RETLW  20
0167:  RETLW  2D
0168:  RETLW  3E
0169:  RETLW  20
016A:  RETLW  53
016B:  RETLW  61
016C:  RETLW  6C
016D:  RETLW  69
016E:  RETLW  64
016F:  RETLW  61
0170:  RETLW  20
0171:  RETLW  33
0172:  RETLW  00
0173:  RETLW  4F
0174:  RETLW  6E
0175:  RETLW  20
0176:  RETLW  2D
0177:  RETLW  3E
0178:  RETLW  20
0179:  RETLW  53
017A:  RETLW  61
017B:  RETLW  6C
017C:  RETLW  69
017D:  RETLW  64
017E:  RETLW  61
017F:  RETLW  20
0180:  RETLW  34
0181:  RETLW  00
0182:  RETLW  4F
0183:  RETLW  6E
0184:  RETLW  20
0185:  RETLW  2D
0186:  RETLW  3E
0187:  RETLW  20
0188:  RETLW  53
0189:  RETLW  61
018A:  RETLW  6C
018B:  RETLW  69
018C:  RETLW  64
018D:  RETLW  61
018E:  RETLW  20
018F:  RETLW  35
0190:  RETLW  00
0191:  RETLW  4F
0192:  RETLW  6E
0193:  RETLW  20
0194:  RETLW  2D
0195:  RETLW  3E
0196:  RETLW  20
0197:  RETLW  53
0198:  RETLW  61
0199:  RETLW  6C
019A:  RETLW  69
019B:  RETLW  64
019C:  RETLW  61
019D:  RETLW  20
019E:  RETLW  36
019F:  RETLW  00
01A0:  RETLW  4F
01A1:  RETLW  6E
01A2:  RETLW  20
01A3:  RETLW  2D
01A4:  RETLW  3E
01A5:  RETLW  20
01A6:  RETLW  53
01A7:  RETLW  61
01A8:  RETLW  6C
01A9:  RETLW  69
01AA:  RETLW  64
01AB:  RETLW  61
01AC:  RETLW  20
01AD:  RETLW  37
01AE:  RETLW  00
01AF:  RETLW  4F
01B0:  RETLW  6E
01B1:  RETLW  20
01B2:  RETLW  2D
01B3:  RETLW  3E
01B4:  RETLW  20
01B5:  RETLW  53
01B6:  RETLW  61
01B7:  RETLW  6C
01B8:  RETLW  69
01B9:  RETLW  64
01BA:  RETLW  61
01BB:  RETLW  20
01BC:  RETLW  38
01BD:  RETLW  00
01BE:  RETLW  53
01BF:  RETLW  41
01C0:  RETLW  4C
01C1:  RETLW  49
01C2:  RETLW  52
01C3:  RETLW  20
01C4:  RETLW  20
01C5:  RETLW  20
01C6:  RETLW  20
01C7:  RETLW  20
01C8:  RETLW  20
01C9:  RETLW  20
01CA:  RETLW  20
01CB:  RETLW  20
01CC:  RETLW  00
01CD:  RETLW  00
01CE:  RETLW  00
01CF:  RETLW  00
01D0:  RETLW  00
01D1:  RETLW  00
01D2:  RETLW  00
01D3:  RETLW  00
01D4:  RETLW  00
01D5:  RETLW  00
01D6:  RETLW  00
01D7:  RETLW  00
01D8:  RETLW  00
01D9:  RETLW  00
01DA:  RETLW  00
01DB:  RETLW  00
01DC:  RETLW  4F
01DD:  RETLW  66
01DE:  RETLW  66
01DF:  RETLW  20
01E0:  RETLW  2D
01E1:  RETLW  3E
01E2:  RETLW  20
01E3:  RETLW  53
01E4:  RETLW  61
01E5:  RETLW  6C
01E6:  RETLW  69
01E7:  RETLW  64
01E8:  RETLW  61
01E9:  RETLW  20
01EA:  RETLW  31
01EB:  RETLW  00
01EC:  RETLW  4F
01ED:  RETLW  66
01EE:  RETLW  66
01EF:  RETLW  20
01F0:  RETLW  2D
01F1:  RETLW  3E
01F2:  RETLW  20
01F3:  RETLW  53
01F4:  RETLW  61
01F5:  RETLW  6C
01F6:  RETLW  69
01F7:  RETLW  64
01F8:  RETLW  61
01F9:  RETLW  20
01FA:  RETLW  32
01FB:  RETLW  00
01FC:  RETLW  4F
01FD:  RETLW  66
01FE:  RETLW  66
01FF:  RETLW  20
0200:  RETLW  2D
0201:  RETLW  3E
0202:  RETLW  20
0203:  RETLW  53
0204:  RETLW  61
0205:  RETLW  6C
0206:  RETLW  69
0207:  RETLW  64
0208:  RETLW  61
0209:  RETLW  20
020A:  RETLW  33
020B:  RETLW  00
020C:  RETLW  4F
020D:  RETLW  66
020E:  RETLW  66
020F:  RETLW  20
0210:  RETLW  2D
0211:  RETLW  3E
0212:  RETLW  20
0213:  RETLW  53
0214:  RETLW  61
0215:  RETLW  6C
0216:  RETLW  69
0217:  RETLW  64
0218:  RETLW  61
0219:  RETLW  20
021A:  RETLW  34
021B:  RETLW  00
021C:  RETLW  4F
021D:  RETLW  66
021E:  RETLW  66
021F:  RETLW  20
0220:  RETLW  2D
0221:  RETLW  3E
0222:  RETLW  20
0223:  RETLW  53
0224:  RETLW  61
0225:  RETLW  6C
0226:  RETLW  69
0227:  RETLW  64
0228:  RETLW  61
0229:  RETLW  20
022A:  RETLW  35
022B:  RETLW  00
022C:  RETLW  4F
022D:  RETLW  66
022E:  RETLW  66
022F:  RETLW  20
0230:  RETLW  2D
0231:  RETLW  3E
0232:  RETLW  20
0233:  RETLW  53
0234:  RETLW  61
0235:  RETLW  6C
0236:  RETLW  69
0237:  RETLW  64
0238:  RETLW  61
0239:  RETLW  20
023A:  RETLW  36
023B:  RETLW  00
023C:  RETLW  4F
023D:  RETLW  66
023E:  RETLW  66
023F:  RETLW  20
0240:  RETLW  2D
0241:  RETLW  3E
0242:  RETLW  20
0243:  RETLW  53
0244:  RETLW  61
0245:  RETLW  6C
0246:  RETLW  69
0247:  RETLW  64
0248:  RETLW  61
0249:  RETLW  20
024A:  RETLW  37
024B:  RETLW  00
024C:  RETLW  4F
024D:  RETLW  66
024E:  RETLW  66
024F:  RETLW  20
0250:  RETLW  2D
0251:  RETLW  3E
0252:  RETLW  20
0253:  RETLW  53
0254:  RETLW  61
0255:  RETLW  6C
0256:  RETLW  69
0257:  RETLW  64
0258:  RETLW  61
0259:  RETLW  20
025A:  RETLW  38
025B:  RETLW  00
025C:  RETLW  53
025D:  RETLW  41
025E:  RETLW  4C
025F:  RETLW  49
0260:  RETLW  52
0261:  RETLW  20
0262:  RETLW  20
0263:  RETLW  20
0264:  RETLW  20
0265:  RETLW  20
0266:  RETLW  20
0267:  RETLW  20
0268:  RETLW  20
0269:  RETLW  20
026A:  RETLW  20
026B:  RETLW  00
026C:  RETLW  00
026D:  RETLW  00
026E:  RETLW  00
026F:  RETLW  00
0270:  RETLW  00
0271:  RETLW  00
0272:  RETLW  00
0273:  RETLW  00
0274:  RETLW  00
0275:  RETLW  00
0276:  RETLW  00
0277:  RETLW  00
0278:  RETLW  00
0279:  RETLW  00
027A:  RETLW  00
027B:  RETLW  00
027C:  RETLW  56
027D:  RETLW  45
027E:  RETLW  52
027F:  RETLW  20
0280:  RETLW  49
0281:  RETLW  50
0282:  RETLW  20
0283:  RETLW  20
0284:  RETLW  20
0285:  RETLW  20
0286:  RETLW  20
0287:  RETLW  20
0288:  RETLW  20
0289:  RETLW  20
028A:  RETLW  20
028B:  RETLW  20
028C:  RETLW  00
028D:  RETLW  56
028E:  RETLW  45
028F:  RETLW  52
0290:  RETLW  20
0291:  RETLW  53
0292:  RETLW  53
0293:  RETLW  49
0294:  RETLW  44
0295:  RETLW  20
0296:  RETLW  20
0297:  RETLW  20
0298:  RETLW  20
0299:  RETLW  20
029A:  RETLW  20
029B:  RETLW  20
029C:  RETLW  20
029D:  RETLW  00
029E:  RETLW  56
029F:  RETLW  45
02A0:  RETLW  52
02A1:  RETLW  20
02A2:  RETLW  4B
02A3:  RETLW  45
02A4:  RETLW  59
02A5:  RETLW  20
02A6:  RETLW  20
02A7:  RETLW  20
02A8:  RETLW  20
02A9:  RETLW  20
02AA:  RETLW  20
02AB:  RETLW  20
02AC:  RETLW  20
02AD:  RETLW  20
02AE:  RETLW  00
02AF:  RETLW  43
02B0:  RETLW  6F
02B1:  RETLW  6E
02B2:  RETLW  66
02B3:  RETLW  20
02B4:  RETLW  41
02B5:  RETLW  63
02B6:  RETLW  63
02B7:  RETLW  65
02B8:  RETLW  73
02B9:  RETLW  73
02BA:  RETLW  6F
02BB:  RETLW  20
02BC:  RETLW  52
02BD:  RETLW  65
02BE:  RETLW  64
02BF:  RETLW  00
02C0:  RETLW  4F
02C1:  RETLW  6E
02C2:  RETLW  2F
02C3:  RETLW  4F
02C4:  RETLW  66
02C5:  RETLW  66
02C6:  RETLW  20
02C7:  RETLW  42
02C8:  RETLW  61
02C9:  RETLW  63
02CA:  RETLW  6B
02CB:  RETLW  6C
02CC:  RETLW  69
02CD:  RETLW  67
02CE:  RETLW  68
02CF:  RETLW  74
02D0:  RETLW  00
02D1:  RETLW  53
02D2:  RETLW  41
02D3:  RETLW  4C
02D4:  RETLW  49
02D5:  RETLW  52
02D6:  RETLW  20
02D7:  RETLW  20
02D8:  RETLW  20
02D9:  RETLW  20
02DA:  RETLW  20
02DB:  RETLW  20
02DC:  RETLW  20
02DD:  RETLW  20
02DE:  RETLW  20
02DF:  RETLW  20
02E0:  RETLW  20
02E1:  RETLW  00
02E2:  RETLW  00
02E3:  RETLW  00
02E4:  RETLW  00
02E5:  RETLW  00
02E6:  RETLW  00
02E7:  RETLW  00
02E8:  RETLW  00
02E9:  RETLW  00
02EA:  RETLW  00
02EB:  RETLW  00
02EC:  RETLW  00
02ED:  RETLW  00
02EE:  RETLW  00
02EF:  RETLW  00
02F0:  RETLW  00
02F1:  RETLW  00
02F2:  RETLW  00
02F3:  DATA 41,2A
02F4:  DATA 2B,29
02F5:  DATA 53,2A
02F6:  DATA 0D,05
02F7:  DATA 00,00
02F8:  DATA 41,2A
02F9:  DATA AB,21
02FA:  DATA D7,26
02FB:  DATA 4F,22
02FC:  DATA C5,1E
02FD:  DATA A5,39
02FE:  DATA 0D,05
02FF:  DATA 00,00
0300:  DATA 41,2A
0301:  DATA AB,21
0302:  DATA 57,25
0303:  DATA 41,28
0304:  DATA BF,06
0305:  DATA 0A,00
0306:  DATA 41,2A
0307:  DATA AB,21
0308:  DATA 57,25
0309:  DATA 41,28
030A:  DATA BD,12
030B:  DATA 73,00
030C:  DATA 41,2A
030D:  DATA AB,21
030E:  DATA 49,28
030F:  DATA CD,2A
0310:  DATA D8,1E
0311:  DATA B1,06
0312:  DATA 0A,00
0313:  DATA 41,2A
0314:  DATA AB,21
0315:  DATA 49,28
0316:  DATA D3,22
0317:  DATA 52,2B
0318:  DATA 45,29
0319:  DATA BD,18
031A:  DATA 2C,1C
031B:  DATA B0,06
031C:  DATA 0A,00
*
0675:  MOVF   0B,W
0676:  BSF    03.5
0677:  MOVWF  43
0678:  BCF    03.5
0679:  BCF    0B.7
067A:  BSF    03.5
067B:  BSF    03.6
067C:  BSF    0C.7
067D:  BSF    0C.0
067E:  NOP
067F:  NOP
0680:  BCF    03.6
0681:  BTFSS  43.7
0682:  GOTO   686
0683:  BCF    03.5
0684:  BSF    0B.7
0685:  BSF    03.5
0686:  BCF    03.5
0687:  BSF    03.6
0688:  MOVF   0C,F
0689:  BTFSC  03.2
068A:  GOTO   6AE
068B:  MOVF   0D,W
068C:  BSF    03.5
068D:  BCF    03.6
068E:  MOVWF  43
068F:  BCF    03.5
0690:  BSF    03.6
0691:  MOVF   0F,W
0692:  BSF    03.5
0693:  BCF    03.6
0694:  MOVWF  44
0695:  BCF    03.5
0696:  BSF    03.6
0697:  MOVF   0C,W
0698:  BSF    03.5
0699:  BCF    03.6
069A:  MOVWF  45
069B:  BCF    03.5
069C:  CALL   61B
069D:  BSF    03.5
069E:  MOVF   43,W
069F:  BCF    03.5
06A0:  BSF    03.6
06A1:  MOVWF  0D
06A2:  BSF    03.5
06A3:  BCF    03.6
06A4:  MOVF   44,W
06A5:  BCF    03.5
06A6:  BSF    03.6
06A7:  MOVWF  0F
06A8:  INCF   0D,F
06A9:  BTFSC  03.2
06AA:  INCF   0F,F
06AB:  BCF    03.6
06AC:  GOTO   675
06AD:  BSF    03.6
06AE:  BCF    03.6
06AF:  RETURN
06B0:  MOVF   0B,W
06B1:  BSF    03.5
06B2:  MOVWF  42
06B3:  BCF    03.5
06B4:  BCF    0B.7
06B5:  BSF    03.5
06B6:  BSF    03.6
06B7:  BSF    0C.7
06B8:  BSF    0C.0
06B9:  NOP
06BA:  NOP
06BB:  BCF    03.6
06BC:  BTFSS  42.7
06BD:  GOTO   6C1
06BE:  BCF    03.5
06BF:  BSF    0B.7
06C0:  BSF    03.5
06C1:  BCF    03.5
06C2:  BSF    03.6
06C3:  MOVF   0C,W
06C4:  ANDLW  7F
06C5:  BTFSC  03.2
06C6:  GOTO   722
06C7:  BSF    03.5
06C8:  BCF    03.6
06C9:  MOVWF  42
06CA:  BCF    03.5
06CB:  BSF    03.6
06CC:  MOVF   0D,W
06CD:  BSF    03.5
06CE:  BCF    03.6
06CF:  MOVWF  43
06D0:  BCF    03.5
06D1:  BSF    03.6
06D2:  MOVF   0F,W
06D3:  BSF    03.5
06D4:  BCF    03.6
06D5:  MOVWF  44
06D6:  MOVF   42,W
06D7:  MOVWF  45
06D8:  BCF    03.5
06D9:  CALL   61B
06DA:  BSF    03.5
06DB:  MOVF   43,W
06DC:  BCF    03.5
06DD:  BSF    03.6
06DE:  MOVWF  0D
06DF:  BSF    03.5
06E0:  BCF    03.6
06E1:  MOVF   44,W
06E2:  BCF    03.5
06E3:  BSF    03.6
06E4:  MOVWF  0F
06E5:  BCF    03.6
06E6:  MOVF   0B,W
06E7:  BSF    03.5
06E8:  MOVWF  45
06E9:  BCF    03.5
06EA:  BCF    0B.7
06EB:  BSF    03.5
06EC:  BSF    03.6
06ED:  BSF    0C.7
06EE:  BSF    0C.0
06EF:  NOP
06F0:  NOP
06F1:  BCF    03.6
06F2:  BTFSS  45.7
06F3:  GOTO   6F7
06F4:  BCF    03.5
06F5:  BSF    0B.7
06F6:  BSF    03.5
06F7:  BCF    03.5
06F8:  BSF    03.6
06F9:  RLF    0C,W
06FA:  RLF    0E,W
06FB:  ANDLW  7F
06FC:  BTFSC  03.2
06FD:  GOTO   722
06FE:  BSF    03.5
06FF:  BCF    03.6
0700:  MOVWF  42
0701:  BCF    03.5
0702:  BSF    03.6
0703:  MOVF   0D,W
0704:  BSF    03.5
0705:  BCF    03.6
0706:  MOVWF  43
0707:  BCF    03.5
0708:  BSF    03.6
0709:  MOVF   0F,W
070A:  BSF    03.5
070B:  BCF    03.6
070C:  MOVWF  44
070D:  MOVF   42,W
070E:  MOVWF  45
070F:  BCF    03.5
0710:  CALL   61B
0711:  BSF    03.5
0712:  MOVF   43,W
0713:  BCF    03.5
0714:  BSF    03.6
0715:  MOVWF  0D
0716:  BSF    03.5
0717:  BCF    03.6
0718:  MOVF   44,W
0719:  BCF    03.5
071A:  BSF    03.6
071B:  MOVWF  0F
071C:  INCF   0D,F
071D:  BTFSC  03.2
071E:  INCF   0F,F
071F:  BCF    03.6
0720:  GOTO   6B0
0721:  BSF    03.6
0722:  BCF    03.6
0723:  RETURN
*
0812:  BCF    03.5
0813:  MOVF   0B,W
0814:  BSF    03.5
0815:  MOVWF  43
0816:  BCF    03.5
0817:  BCF    0B.7
0818:  BSF    03.5
0819:  BSF    03.6
081A:  BSF    0C.7
081B:  BSF    0C.0
081C:  NOP
081D:  NOP
081E:  BCF    03.6
081F:  BTFSS  43.7
0820:  GOTO   024
0821:  BCF    03.5
0822:  BSF    0B.7
0823:  BSF    03.5
0824:  BTFSC  03.0
0825:  GOTO   05E
0826:  BCF    03.5
0827:  BSF    03.6
0828:  MOVF   0C,W
0829:  ANDLW  7F
082A:  BSF    03.5
082B:  BCF    03.6
082C:  MOVWF  43
082D:  BCF    03.5
082E:  BSF    03.6
082F:  MOVF   0D,W
0830:  BSF    03.5
0831:  BCF    03.6
0832:  MOVWF  44
0833:  BCF    03.5
0834:  BSF    03.6
0835:  MOVF   0F,W
0836:  BSF    03.5
0837:  BCF    03.6
0838:  MOVWF  45
0839:  MOVF   43,W
083A:  BCF    03.5
083B:  BTFSS  0C.4
083C:  GOTO   03B
083D:  MOVWF  19
083E:  BSF    03.5
083F:  MOVF   44,W
0840:  BCF    03.5
0841:  BSF    03.6
0842:  MOVWF  0D
0843:  BSF    03.5
0844:  BCF    03.6
0845:  MOVF   45,W
0846:  BCF    03.5
0847:  BSF    03.6
0848:  MOVWF  0F
0849:  BCF    03.6
084A:  MOVF   0B,W
084B:  BSF    03.5
084C:  MOVWF  46
084D:  BCF    03.5
084E:  BCF    0B.7
084F:  BSF    03.5
0850:  BSF    03.6
0851:  BSF    0C.7
0852:  BSF    0C.0
0853:  NOP
0854:  NOP
0855:  BCF    03.6
0856:  BTFSS  46.7
0857:  GOTO   05B
0858:  BCF    03.5
0859:  BSF    0B.7
085A:  BSF    03.5
085B:  DECFSZ 42,F
085C:  GOTO   05E
085D:  GOTO   08A
085E:  BCF    03.5
085F:  BSF    03.6
0860:  RLF    0C,W
0861:  RLF    0E,W
0862:  ANDLW  7F
0863:  BSF    03.5
0864:  BCF    03.6
0865:  MOVWF  43
0866:  BCF    03.5
0867:  BSF    03.6
0868:  MOVF   0D,W
0869:  BSF    03.5
086A:  BCF    03.6
086B:  MOVWF  44
086C:  BCF    03.5
086D:  BSF    03.6
086E:  MOVF   0F,W
086F:  BSF    03.5
0870:  BCF    03.6
0871:  MOVWF  45
0872:  MOVF   43,W
0873:  BCF    03.5
0874:  BTFSS  0C.4
0875:  GOTO   074
0876:  MOVWF  19
0877:  BSF    03.5
0878:  MOVF   44,W
0879:  BCF    03.5
087A:  BSF    03.6
087B:  MOVWF  0D
087C:  BSF    03.5
087D:  BCF    03.6
087E:  MOVF   45,W
087F:  BCF    03.5
0880:  BSF    03.6
0881:  MOVWF  0F
0882:  INCF   0D,F
0883:  BTFSC  03.2
0884:  INCF   0F,F
0885:  BCF    03.0
0886:  BSF    03.5
0887:  BCF    03.6
0888:  DECFSZ 42,F
0889:  GOTO   012
*
088F:  MOVF   00,F
0890:  BTFSC  03.2
0891:  GOTO   0AA
0892:  CLRF   43
0893:  MOVF   04,W
0894:  MOVWF  42
0895:  BCF    43.0
0896:  BTFSC  03.7
0897:  BSF    43.0
0898:  MOVF   00,W
0899:  BCF    03.5
089A:  BTFSS  0C.4
089B:  GOTO   09A
089C:  MOVWF  19
089D:  BSF    03.5
089E:  MOVF   42,W
089F:  MOVWF  04
08A0:  BCF    03.7
08A1:  BTFSC  43.0
08A2:  BSF    03.7
08A3:  INCF   04,F
08A4:  BTFSS  03.2
08A5:  GOTO   0A9
08A6:  BCF    03.5
08A7:  INCF   05,F
08A8:  BSF    03.5
08A9:  GOTO   08F
*
08BF:  BCF    03.6
08C0:  MOVF   0B,W
08C1:  BSF    03.5
08C2:  MOVWF  40
08C3:  BCF    03.5
08C4:  BCF    0B.7
08C5:  BSF    03.5
08C6:  BSF    03.6
08C7:  BSF    0C.7
08C8:  BSF    0C.0
08C9:  NOP
08CA:  NOP
08CB:  BCF    03.6
08CC:  BTFSS  40.7
08CD:  GOTO   0D1
08CE:  BCF    03.5
08CF:  BSF    0B.7
08D0:  BSF    03.5
08D1:  BCF    03.5
08D2:  BSF    03.6
08D3:  MOVF   0C,W
08D4:  ANDLW  7F
08D5:  BTFSC  03.2
08D6:  GOTO   132
08D7:  BSF    03.5
08D8:  BCF    03.6
08D9:  MOVWF  40
08DA:  BCF    03.5
08DB:  BSF    03.6
08DC:  MOVF   0D,W
08DD:  BSF    03.5
08DE:  BCF    03.6
08DF:  MOVWF  41
08E0:  BCF    03.5
08E1:  BSF    03.6
08E2:  MOVF   0F,W
08E3:  BSF    03.5
08E4:  BCF    03.6
08E5:  MOVWF  42
08E6:  MOVF   40,W
08E7:  BCF    03.5
08E8:  BTFSS  0C.4
08E9:  GOTO   0E8
08EA:  MOVWF  19
08EB:  BSF    03.5
08EC:  MOVF   41,W
08ED:  BCF    03.5
08EE:  BSF    03.6
08EF:  MOVWF  0D
08F0:  BSF    03.5
08F1:  BCF    03.6
08F2:  MOVF   42,W
08F3:  BCF    03.5
08F4:  BSF    03.6
08F5:  MOVWF  0F
08F6:  BCF    03.6
08F7:  MOVF   0B,W
08F8:  BSF    03.5
08F9:  MOVWF  43
08FA:  BCF    03.5
08FB:  BCF    0B.7
08FC:  BSF    03.5
08FD:  BSF    03.6
08FE:  BSF    0C.7
08FF:  BSF    0C.0
0900:  NOP
0901:  NOP
0902:  BCF    03.6
0903:  BTFSS  43.7
0904:  GOTO   108
0905:  BCF    03.5
0906:  BSF    0B.7
0907:  BSF    03.5
0908:  BCF    03.5
0909:  BSF    03.6
090A:  RLF    0C,W
090B:  RLF    0E,W
090C:  ANDLW  7F
090D:  BTFSC  03.2
090E:  GOTO   132
090F:  BSF    03.5
0910:  BCF    03.6
0911:  MOVWF  40
0912:  BCF    03.5
0913:  BSF    03.6
0914:  MOVF   0D,W
0915:  BSF    03.5
0916:  BCF    03.6
0917:  MOVWF  41
0918:  BCF    03.5
0919:  BSF    03.6
091A:  MOVF   0F,W
091B:  BSF    03.5
091C:  BCF    03.6
091D:  MOVWF  42
091E:  MOVF   40,W
091F:  BCF    03.5
0920:  BTFSS  0C.4
0921:  GOTO   120
0922:  MOVWF  19
0923:  BSF    03.5
0924:  MOVF   41,W
0925:  BCF    03.5
0926:  BSF    03.6
0927:  MOVWF  0D
0928:  BSF    03.5
0929:  BCF    03.6
092A:  MOVF   42,W
092B:  BCF    03.5
092C:  BSF    03.6
092D:  MOVWF  0F
092E:  INCF   0D,F
092F:  BTFSC  03.2
0930:  INCF   0F,F
0931:  GOTO   0BF
*
094F:  BCF    03.5
0950:  MOVF   0B,W
0951:  BSF    03.5
0952:  MOVWF  43
0953:  BCF    03.5
0954:  BCF    0B.7
0955:  BSF    03.5
0956:  BSF    03.6
0957:  BSF    0C.7
0958:  BSF    0C.0
0959:  NOP
095A:  NOP
095B:  BCF    03.6
095C:  BTFSS  43.7
095D:  GOTO   161
095E:  BCF    03.5
095F:  BSF    0B.7
0960:  BSF    03.5
0961:  BTFSC  03.0
0962:  GOTO   19B
0963:  BCF    03.5
0964:  BSF    03.6
0965:  MOVF   0C,W
0966:  ANDLW  7F
0967:  BSF    03.5
0968:  BCF    03.6
0969:  MOVWF  43
096A:  BCF    03.5
096B:  BSF    03.6
096C:  MOVF   0D,W
096D:  BSF    03.5
096E:  BCF    03.6
096F:  MOVWF  44
0970:  BCF    03.5
0971:  BSF    03.6
0972:  MOVF   0F,W
0973:  BSF    03.5
0974:  BCF    03.6
0975:  MOVWF  45
0976:  MOVF   43,W
0977:  BCF    03.5
0978:  BTFSS  0C.4
0979:  GOTO   178
097A:  MOVWF  19
097B:  BSF    03.5
097C:  MOVF   44,W
097D:  BCF    03.5
097E:  BSF    03.6
097F:  MOVWF  0D
0980:  BSF    03.5
0981:  BCF    03.6
0982:  MOVF   45,W
0983:  BCF    03.5
0984:  BSF    03.6
0985:  MOVWF  0F
0986:  BCF    03.6
0987:  MOVF   0B,W
0988:  BSF    03.5
0989:  MOVWF  46
098A:  BCF    03.5
098B:  BCF    0B.7
098C:  BSF    03.5
098D:  BSF    03.6
098E:  BSF    0C.7
098F:  BSF    0C.0
0990:  NOP
0991:  NOP
0992:  BCF    03.6
0993:  BTFSS  46.7
0994:  GOTO   198
0995:  BCF    03.5
0996:  BSF    0B.7
0997:  BSF    03.5
0998:  DECFSZ 42,F
0999:  GOTO   19B
099A:  GOTO   1C7
099B:  BCF    03.5
099C:  BSF    03.6
099D:  RLF    0C,W
099E:  RLF    0E,W
099F:  ANDLW  7F
09A0:  BSF    03.5
09A1:  BCF    03.6
09A2:  MOVWF  43
09A3:  BCF    03.5
09A4:  BSF    03.6
09A5:  MOVF   0D,W
09A6:  BSF    03.5
09A7:  BCF    03.6
09A8:  MOVWF  44
09A9:  BCF    03.5
09AA:  BSF    03.6
09AB:  MOVF   0F,W
09AC:  BSF    03.5
09AD:  BCF    03.6
09AE:  MOVWF  45
09AF:  MOVF   43,W
09B0:  BCF    03.5
09B1:  BTFSS  0C.4
09B2:  GOTO   1B1
09B3:  MOVWF  19
09B4:  BSF    03.5
09B5:  MOVF   44,W
09B6:  BCF    03.5
09B7:  BSF    03.6
09B8:  MOVWF  0D
09B9:  BSF    03.5
09BA:  BCF    03.6
09BB:  MOVF   45,W
09BC:  BCF    03.5
09BD:  BSF    03.6
09BE:  MOVWF  0F
09BF:  INCF   0D,F
09C0:  BTFSC  03.2
09C1:  INCF   0F,F
09C2:  BCF    03.0
09C3:  BSF    03.5
09C4:  BCF    03.6
09C5:  DECFSZ 42,F
09C6:  GOTO   14F
*
09CC:  MOVF   00,F
09CD:  BTFSC  03.2
09CE:  GOTO   1E7
09CF:  CLRF   43
09D0:  MOVF   04,W
09D1:  MOVWF  42
09D2:  BCF    43.0
09D3:  BTFSC  03.7
09D4:  BSF    43.0
09D5:  MOVF   00,W
09D6:  BCF    03.5
09D7:  BTFSS  0C.4
09D8:  GOTO   1D7
09D9:  MOVWF  19
09DA:  BSF    03.5
09DB:  MOVF   42,W
09DC:  MOVWF  04
09DD:  BCF    03.7
09DE:  BTFSC  43.0
09DF:  BSF    03.7
09E0:  INCF   04,F
09E1:  BTFSS  03.2
09E2:  GOTO   1E6
09E3:  BCF    03.5
09E4:  INCF   05,F
09E5:  BSF    03.5
09E6:  GOTO   1CC
*
0A04:  BCF    03.5
0A05:  MOVF   0B,W
0A06:  BSF    03.5
0A07:  MOVWF  43
0A08:  BCF    03.5
0A09:  BCF    0B.7
0A0A:  BSF    03.5
0A0B:  BSF    03.6
0A0C:  BSF    0C.7
0A0D:  BSF    0C.0
0A0E:  NOP
0A0F:  NOP
0A10:  BCF    03.6
0A11:  BTFSS  43.7
0A12:  GOTO   216
0A13:  BCF    03.5
0A14:  BSF    0B.7
0A15:  BSF    03.5
0A16:  BTFSC  03.0
0A17:  GOTO   250
0A18:  BCF    03.5
0A19:  BSF    03.6
0A1A:  MOVF   0C,W
0A1B:  ANDLW  7F
0A1C:  BSF    03.5
0A1D:  BCF    03.6
0A1E:  MOVWF  43
0A1F:  BCF    03.5
0A20:  BSF    03.6
0A21:  MOVF   0D,W
0A22:  BSF    03.5
0A23:  BCF    03.6
0A24:  MOVWF  44
0A25:  BCF    03.5
0A26:  BSF    03.6
0A27:  MOVF   0F,W
0A28:  BSF    03.5
0A29:  BCF    03.6
0A2A:  MOVWF  45
0A2B:  MOVF   43,W
0A2C:  BCF    03.5
0A2D:  BTFSS  0C.4
0A2E:  GOTO   22D
0A2F:  MOVWF  19
0A30:  BSF    03.5
0A31:  MOVF   44,W
0A32:  BCF    03.5
0A33:  BSF    03.6
0A34:  MOVWF  0D
0A35:  BSF    03.5
0A36:  BCF    03.6
0A37:  MOVF   45,W
0A38:  BCF    03.5
0A39:  BSF    03.6
0A3A:  MOVWF  0F
0A3B:  BCF    03.6
0A3C:  MOVF   0B,W
0A3D:  BSF    03.5
0A3E:  MOVWF  46
0A3F:  BCF    03.5
0A40:  BCF    0B.7
0A41:  BSF    03.5
0A42:  BSF    03.6
0A43:  BSF    0C.7
0A44:  BSF    0C.0
0A45:  NOP
0A46:  NOP
0A47:  BCF    03.6
0A48:  BTFSS  46.7
0A49:  GOTO   24D
0A4A:  BCF    03.5
0A4B:  BSF    0B.7
0A4C:  BSF    03.5
0A4D:  DECFSZ 42,F
0A4E:  GOTO   250
0A4F:  GOTO   27C
0A50:  BCF    03.5
0A51:  BSF    03.6
0A52:  RLF    0C,W
0A53:  RLF    0E,W
0A54:  ANDLW  7F
0A55:  BSF    03.5
0A56:  BCF    03.6
0A57:  MOVWF  43
0A58:  BCF    03.5
0A59:  BSF    03.6
0A5A:  MOVF   0D,W
0A5B:  BSF    03.5
0A5C:  BCF    03.6
0A5D:  MOVWF  44
0A5E:  BCF    03.5
0A5F:  BSF    03.6
0A60:  MOVF   0F,W
0A61:  BSF    03.5
0A62:  BCF    03.6
0A63:  MOVWF  45
0A64:  MOVF   43,W
0A65:  BCF    03.5
0A66:  BTFSS  0C.4
0A67:  GOTO   266
0A68:  MOVWF  19
0A69:  BSF    03.5
0A6A:  MOVF   44,W
0A6B:  BCF    03.5
0A6C:  BSF    03.6
0A6D:  MOVWF  0D
0A6E:  BSF    03.5
0A6F:  BCF    03.6
0A70:  MOVF   45,W
0A71:  BCF    03.5
0A72:  BSF    03.6
0A73:  MOVWF  0F
0A74:  INCF   0D,F
0A75:  BTFSC  03.2
0A76:  INCF   0F,F
0A77:  BCF    03.0
0A78:  BSF    03.5
0A79:  BCF    03.6
0A7A:  DECFSZ 42,F
0A7B:  GOTO   204
*
0A81:  MOVF   00,F
0A82:  BTFSC  03.2
0A83:  GOTO   29C
0A84:  CLRF   43
0A85:  MOVF   04,W
0A86:  MOVWF  42
0A87:  BCF    43.0
0A88:  BTFSC  03.7
0A89:  BSF    43.0
0A8A:  MOVF   00,W
0A8B:  BCF    03.5
0A8C:  BTFSS  0C.4
0A8D:  GOTO   28C
0A8E:  MOVWF  19
0A8F:  BSF    03.5
0A90:  MOVF   42,W
0A91:  MOVWF  04
0A92:  BCF    03.7
0A93:  BTFSC  43.0
0A94:  BSF    03.7
0A95:  INCF   04,F
0A96:  BTFSS  03.2
0A97:  GOTO   29B
0A98:  BCF    03.5
0A99:  INCF   05,F
0A9A:  BSF    03.5
0A9B:  GOTO   281
*
0AB3:  BCF    03.6
0AB4:  MOVF   0B,W
0AB5:  BSF    03.5
0AB6:  MOVWF  40
0AB7:  BCF    03.5
0AB8:  BCF    0B.7
0AB9:  BSF    03.5
0ABA:  BSF    03.6
0ABB:  BSF    0C.7
0ABC:  BSF    0C.0
0ABD:  NOP
0ABE:  NOP
0ABF:  BCF    03.6
0AC0:  BTFSS  40.7
0AC1:  GOTO   2C5
0AC2:  BCF    03.5
0AC3:  BSF    0B.7
0AC4:  BSF    03.5
0AC5:  BCF    03.5
0AC6:  BSF    03.6
0AC7:  MOVF   0C,W
0AC8:  ANDLW  7F
0AC9:  BTFSC  03.2
0ACA:  GOTO   326
0ACB:  BSF    03.5
0ACC:  BCF    03.6
0ACD:  MOVWF  40
0ACE:  BCF    03.5
0ACF:  BSF    03.6
0AD0:  MOVF   0D,W
0AD1:  BSF    03.5
0AD2:  BCF    03.6
0AD3:  MOVWF  41
0AD4:  BCF    03.5
0AD5:  BSF    03.6
0AD6:  MOVF   0F,W
0AD7:  BSF    03.5
0AD8:  BCF    03.6
0AD9:  MOVWF  42
0ADA:  MOVF   40,W
0ADB:  BCF    03.5
0ADC:  BTFSS  0C.4
0ADD:  GOTO   2DC
0ADE:  MOVWF  19
0ADF:  BSF    03.5
0AE0:  MOVF   41,W
0AE1:  BCF    03.5
0AE2:  BSF    03.6
0AE3:  MOVWF  0D
0AE4:  BSF    03.5
0AE5:  BCF    03.6
0AE6:  MOVF   42,W
0AE7:  BCF    03.5
0AE8:  BSF    03.6
0AE9:  MOVWF  0F
0AEA:  BCF    03.6
0AEB:  MOVF   0B,W
0AEC:  BSF    03.5
0AED:  MOVWF  43
0AEE:  BCF    03.5
0AEF:  BCF    0B.7
0AF0:  BSF    03.5
0AF1:  BSF    03.6
0AF2:  BSF    0C.7
0AF3:  BSF    0C.0
0AF4:  NOP
0AF5:  NOP
0AF6:  BCF    03.6
0AF7:  BTFSS  43.7
0AF8:  GOTO   2FC
0AF9:  BCF    03.5
0AFA:  BSF    0B.7
0AFB:  BSF    03.5
0AFC:  BCF    03.5
0AFD:  BSF    03.6
0AFE:  RLF    0C,W
0AFF:  RLF    0E,W
0B00:  ANDLW  7F
0B01:  BTFSC  03.2
0B02:  GOTO   326
0B03:  BSF    03.5
0B04:  BCF    03.6
0B05:  MOVWF  40
0B06:  BCF    03.5
0B07:  BSF    03.6
0B08:  MOVF   0D,W
0B09:  BSF    03.5
0B0A:  BCF    03.6
0B0B:  MOVWF  41
0B0C:  BCF    03.5
0B0D:  BSF    03.6
0B0E:  MOVF   0F,W
0B0F:  BSF    03.5
0B10:  BCF    03.6
0B11:  MOVWF  42
0B12:  MOVF   40,W
0B13:  BCF    03.5
0B14:  BTFSS  0C.4
0B15:  GOTO   314
0B16:  MOVWF  19
0B17:  BSF    03.5
0B18:  MOVF   41,W
0B19:  BCF    03.5
0B1A:  BSF    03.6
0B1B:  MOVWF  0D
0B1C:  BSF    03.5
0B1D:  BCF    03.6
0B1E:  MOVF   42,W
0B1F:  BCF    03.5
0B20:  BSF    03.6
0B21:  MOVWF  0F
0B22:  INCF   0D,F
0B23:  BTFSC  03.2
0B24:  INCF   0F,F
0B25:  GOTO   2B3
*
0B39:  BCF    03.6
0B3A:  MOVF   0B,W
0B3B:  BSF    03.5
0B3C:  MOVWF  40
0B3D:  BCF    03.5
0B3E:  BCF    0B.7
0B3F:  BSF    03.5
0B40:  BSF    03.6
0B41:  BSF    0C.7
0B42:  BSF    0C.0
0B43:  NOP
0B44:  NOP
0B45:  BCF    03.6
0B46:  BTFSS  40.7
0B47:  GOTO   34B
0B48:  BCF    03.5
0B49:  BSF    0B.7
0B4A:  BSF    03.5
0B4B:  BCF    03.5
0B4C:  BSF    03.6
0B4D:  MOVF   0C,W
0B4E:  ANDLW  7F
0B4F:  BTFSC  03.2
0B50:  GOTO   3AC
0B51:  BSF    03.5
0B52:  BCF    03.6
0B53:  MOVWF  40
0B54:  BCF    03.5
0B55:  BSF    03.6
0B56:  MOVF   0D,W
0B57:  BSF    03.5
0B58:  BCF    03.6
0B59:  MOVWF  41
0B5A:  BCF    03.5
0B5B:  BSF    03.6
0B5C:  MOVF   0F,W
0B5D:  BSF    03.5
0B5E:  BCF    03.6
0B5F:  MOVWF  42
0B60:  MOVF   40,W
0B61:  BCF    03.5
0B62:  BTFSS  0C.4
0B63:  GOTO   362
0B64:  MOVWF  19
0B65:  BSF    03.5
0B66:  MOVF   41,W
0B67:  BCF    03.5
0B68:  BSF    03.6
0B69:  MOVWF  0D
0B6A:  BSF    03.5
0B6B:  BCF    03.6
0B6C:  MOVF   42,W
0B6D:  BCF    03.5
0B6E:  BSF    03.6
0B6F:  MOVWF  0F
0B70:  BCF    03.6
0B71:  MOVF   0B,W
0B72:  BSF    03.5
0B73:  MOVWF  43
0B74:  BCF    03.5
0B75:  BCF    0B.7
0B76:  BSF    03.5
0B77:  BSF    03.6
0B78:  BSF    0C.7
0B79:  BSF    0C.0
0B7A:  NOP
0B7B:  NOP
0B7C:  BCF    03.6
0B7D:  BTFSS  43.7
0B7E:  GOTO   382
0B7F:  BCF    03.5
0B80:  BSF    0B.7
0B81:  BSF    03.5
0B82:  BCF    03.5
0B83:  BSF    03.6
0B84:  RLF    0C,W
0B85:  RLF    0E,W
0B86:  ANDLW  7F
0B87:  BTFSC  03.2
0B88:  GOTO   3AC
0B89:  BSF    03.5
0B8A:  BCF    03.6
0B8B:  MOVWF  40
0B8C:  BCF    03.5
0B8D:  BSF    03.6
0B8E:  MOVF   0D,W
0B8F:  BSF    03.5
0B90:  BCF    03.6
0B91:  MOVWF  41
0B92:  BCF    03.5
0B93:  BSF    03.6
0B94:  MOVF   0F,W
0B95:  BSF    03.5
0B96:  BCF    03.6
0B97:  MOVWF  42
0B98:  MOVF   40,W
0B99:  BCF    03.5
0B9A:  BTFSS  0C.4
0B9B:  GOTO   39A
0B9C:  MOVWF  19
0B9D:  BSF    03.5
0B9E:  MOVF   41,W
0B9F:  BCF    03.5
0BA0:  BSF    03.6
0BA1:  MOVWF  0D
0BA2:  BSF    03.5
0BA3:  BCF    03.6
0BA4:  MOVF   42,W
0BA5:  BCF    03.5
0BA6:  BSF    03.6
0BA7:  MOVWF  0F
0BA8:  INCF   0D,F
0BA9:  BTFSC  03.2
0BAA:  INCF   0F,F
0BAB:  GOTO   339
*
0BEB:  BTFSC  03.1
0BEC:  GOTO   3F0
0BED:  MOVLW  D8
0BEE:  MOVWF  04
0BEF:  BCF    03.7
0BF0:  CLRF   77
0BF1:  CLRF   78
0BF2:  CLRF   79
0BF3:  CLRF   7A
0BF4:  CLRF   58
0BF5:  CLRF   59
0BF6:  CLRF   5A
0BF7:  CLRF   5B
0BF8:  MOVF   57,W
0BF9:  IORWF  56,W
0BFA:  IORWF  55,W
0BFB:  IORWF  54,W
0BFC:  BTFSC  03.2
0BFD:  GOTO   42E
0BFE:  MOVLW  20
0BFF:  MOVWF  5C
0C00:  BCF    03.0
0C01:  RLF    50,F
0C02:  RLF    51,F
0C03:  RLF    52,F
0C04:  RLF    53,F
0C05:  RLF    58,F
0C06:  RLF    59,F
0C07:  RLF    5A,F
0C08:  RLF    5B,F
0C09:  MOVF   57,W
0C0A:  SUBWF  5B,W
0C0B:  BTFSS  03.2
0C0C:  GOTO   417
0C0D:  MOVF   56,W
0C0E:  SUBWF  5A,W
0C0F:  BTFSS  03.2
0C10:  GOTO   417
0C11:  MOVF   55,W
0C12:  SUBWF  59,W
0C13:  BTFSS  03.2
0C14:  GOTO   417
0C15:  MOVF   54,W
0C16:  SUBWF  58,W
0C17:  BTFSS  03.0
0C18:  GOTO   428
0C19:  MOVF   54,W
0C1A:  SUBWF  58,F
0C1B:  MOVF   55,W
0C1C:  BTFSS  03.0
0C1D:  INCFSZ 55,W
0C1E:  SUBWF  59,F
0C1F:  MOVF   56,W
0C20:  BTFSS  03.0
0C21:  INCFSZ 56,W
0C22:  SUBWF  5A,F
0C23:  MOVF   57,W
0C24:  BTFSS  03.0
0C25:  INCFSZ 57,W
0C26:  SUBWF  5B,F
0C27:  BSF    03.0
0C28:  RLF    77,F
0C29:  RLF    78,F
0C2A:  RLF    79,F
0C2B:  RLF    7A,F
0C2C:  DECFSZ 5C,F
0C2D:  GOTO   400
0C2E:  MOVF   58,W
0C2F:  MOVWF  00
0C30:  INCF   04,F
0C31:  MOVF   59,W
0C32:  MOVWF  00
0C33:  INCF   04,F
0C34:  MOVF   5A,W
0C35:  MOVWF  00
0C36:  INCF   04,F
0C37:  MOVF   5B,W
0C38:  MOVWF  00
*
0C4E:  MOVLW  20
0C4F:  MOVWF  5C
0C50:  CLRF   58
0C51:  CLRF   59
0C52:  CLRF   5A
0C53:  CLRF   5B
0C54:  MOVF   53,W
0C55:  MOVWF  7A
0C56:  MOVF   52,W
0C57:  MOVWF  79
0C58:  MOVF   51,W
0C59:  MOVWF  78
0C5A:  MOVF   50,W
0C5B:  MOVWF  77
0C5C:  BCF    03.0
0C5D:  BTFSS  77.0
0C5E:  GOTO   46D
0C5F:  MOVF   54,W
0C60:  ADDWF  58,F
0C61:  MOVF   55,W
0C62:  BTFSC  03.0
0C63:  INCFSZ 55,W
0C64:  ADDWF  59,F
0C65:  MOVF   56,W
0C66:  BTFSC  03.0
0C67:  INCFSZ 56,W
0C68:  ADDWF  5A,F
0C69:  MOVF   57,W
0C6A:  BTFSC  03.0
0C6B:  INCFSZ 57,W
0C6C:  ADDWF  5B,F
0C6D:  RRF    5B,F
0C6E:  RRF    5A,F
0C6F:  RRF    59,F
0C70:  RRF    58,F
0C71:  RRF    7A,F
0C72:  RRF    79,F
0C73:  RRF    78,F
0C74:  RRF    77,F
0C75:  DECFSZ 5C,F
0C76:  GOTO   45C
*
0D0E:  CLRF   77
0D0F:  CLRF   78
0D10:  BSF    03.5
0D11:  MOVF   42,W
0D12:  BCF    03.0
0D13:  BTFSC  43.0
0D14:  ADDWF  77,F
0D15:  RRF    77,F
0D16:  RRF    78,F
0D17:  BTFSC  43.1
0D18:  ADDWF  77,F
0D19:  RRF    77,F
0D1A:  RRF    78,F
0D1B:  BTFSC  43.2
0D1C:  ADDWF  77,F
0D1D:  RRF    77,F
0D1E:  RRF    78,F
0D1F:  BTFSC  43.3
0D20:  ADDWF  77,F
0D21:  RRF    77,F
0D22:  RRF    78,F
0D23:  BTFSC  43.4
0D24:  ADDWF  77,F
0D25:  RRF    77,F
0D26:  RRF    78,F
0D27:  BTFSC  43.5
0D28:  ADDWF  77,F
0D29:  RRF    77,F
0D2A:  RRF    78,F
0D2B:  BTFSC  43.6
0D2C:  ADDWF  77,F
0D2D:  RRF    77,F
0D2E:  RRF    78,F
0D2F:  BTFSC  43.7
0D30:  ADDWF  77,F
0D31:  RRF    77,F
0D32:  RRF    78,F
0D33:  BCF    03.5
0D34:  RETURN
0D35:  BSF    03.5
0D36:  MOVF   41,W
0D37:  ANDLW  07
0D38:  MOVWF  77
0D39:  RRF    41,W
0D3A:  MOVWF  78
0D3B:  RRF    78,F
0D3C:  RRF    78,F
0D3D:  MOVLW  1F
0D3E:  ANDWF  78,F
0D3F:  MOVF   78,W
0D40:  ADDWF  43,W
0D41:  MOVWF  04
0D42:  BCF    03.7
0D43:  BTFSC  44.0
0D44:  BSF    03.7
0D45:  CLRF   78
0D46:  INCF   78,F
0D47:  INCF   77,F
0D48:  GOTO   54A
0D49:  RLF    78,F
0D4A:  DECFSZ 77,F
0D4B:  GOTO   549
0D4C:  MOVF   42,F
0D4D:  BTFSC  03.2
0D4E:  GOTO   552
0D4F:  MOVF   78,W
0D50:  IORWF  00,F
0D51:  GOTO   555
0D52:  COMF   78,F
0D53:  MOVF   78,W
0D54:  ANDWF  00,F
0D55:  BCF    03.5
0D56:  RETURN
*
12AE:  BCF    0A.0
12AF:  BSF    0A.1
12B0:  BCF    0A.2
12B1:  ADDWF  02,F
12B2:  GOTO   008
12B3:  GOTO   049
12B4:  GOTO   08A
12B5:  GOTO   0CB
12B6:  GOTO   255
12B7:  GOTO   2A7
*
14EB:  BCF    0A.0
14EC:  BCF    0A.1
14ED:  BSF    0A.2
14EE:  ADDWF  02,F
14EF:  GOTO   4D0
14F0:  GOTO   4D6
14F1:  GOTO   4DE
14F2:  GOTO   4E6
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20000000) 
*
03F0:  MOVLW  C6
03F1:  MOVWF  04
03F2:  BCF    03.7
03F3:  MOVF   00,W
03F4:  BTFSC  03.2
03F5:  GOTO   403
03F6:  MOVLW  06
03F7:  MOVWF  78
03F8:  CLRF   77
03F9:  DECFSZ 77,F
03FA:  GOTO   3F9
03FB:  DECFSZ 78,F
03FC:  GOTO   3F8
03FD:  MOVLW  7B
03FE:  MOVWF  77
03FF:  DECFSZ 77,F
0400:  GOTO   3FF
0401:  DECFSZ 00,F
0402:  GOTO   3F6
0403:  RETURN
*
0C8F:  MOVLW  03
0C90:  SUBWF  51,F
0C91:  BTFSS  03.0
0C92:  GOTO   49D
0C93:  MOVLW  D1
0C94:  MOVWF  04
0C95:  BCF    03.7
0C96:  MOVF   00,W
0C97:  BTFSC  03.2
0C98:  GOTO   49D
0C99:  GOTO   49B
0C9A:  GOTO   49B
0C9B:  DECFSZ 00,F
0C9C:  GOTO   49A
*
0CA0:  MOVLW  03
0CA1:  SUBWF  51,F
0CA2:  BTFSS  03.0
0CA3:  GOTO   4AE
0CA4:  MOVLW  D1
0CA5:  MOVWF  04
0CA6:  BCF    03.7
0CA7:  MOVF   00,W
0CA8:  BTFSC  03.2
0CA9:  GOTO   4AE
0CAA:  GOTO   4AC
0CAB:  GOTO   4AC
0CAC:  DECFSZ 00,F
0CAD:  GOTO   4AB
*
0CC0:  MOVLW  03
0CC1:  SUBWF  51,F
0CC2:  BTFSS  03.0
0CC3:  GOTO   4CE
0CC4:  MOVLW  D1
0CC5:  MOVWF  04
0CC6:  BCF    03.7
0CC7:  MOVF   00,W
0CC8:  BTFSC  03.2
0CC9:  GOTO   4CE
0CCA:  GOTO   4CC
0CCB:  GOTO   4CC
0CCC:  DECFSZ 00,F
0CCD:  GOTO   4CB
*
0CD1:  MOVLW  03
0CD2:  SUBWF  51,F
0CD3:  BTFSS  03.0
0CD4:  GOTO   4DF
0CD5:  MOVLW  D1
0CD6:  MOVWF  04
0CD7:  BCF    03.7
0CD8:  MOVF   00,W
0CD9:  BTFSC  03.2
0CDA:  GOTO   4DF
0CDB:  GOTO   4DD
0CDC:  GOTO   4DD
0CDD:  DECFSZ 00,F
0CDE:  GOTO   4DC
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... //#define TRUE            0x01; 
.................... //#define FALSE           0x00; 
....................  
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
*
1425:  MOVLW  4A
1426:  BCF    03.6
1427:  MOVWF  2B
1428:  CLRF   2C
1429:  MOVLW  49
142A:  MOVWF  2D
142B:  CLRF   2E
142C:  MOVLW  48
142D:  MOVWF  2F
142E:  CLRF   30
142F:  MOVLW  2C
1430:  MOVWF  31
1431:  CLRF   32
1432:  MOVLW  28
1433:  MOVWF  33
1434:  CLRF   34
1435:  MOVLW  29
1436:  MOVWF  35
1437:  CLRF   36
1438:  MOVLW  2A
1439:  MOVWF  37
143A:  CLRF   38
143B:  MOVLW  2B
143C:  MOVWF  39
143D:  CLRF   3A
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
143E:  CLRF   3B
143F:  CLRF   3C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
040C:  BSF    08.4
....................    output_float(LCD_DATA5); 
040D:  BSF    08.5
....................    output_float(LCD_DATA6); 
040E:  BSF    08.6
....................    output_float(LCD_DATA7); 
040F:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0410:  BCF    03.5
0411:  BSF    08.1
0412:  BSF    03.5
0413:  BCF    08.1
....................    delay_cycles(1); 
0414:  NOP
....................    lcd_output_enable(1); 
0415:  BCF    03.5
0416:  BSF    08.0
0417:  BSF    03.5
0418:  BCF    08.0
....................    delay_cycles(1); 
0419:  NOP
....................    high = lcd_read_nibble(); 
*
044A:  MOVF   78,W
044B:  MOVWF  4D
....................        
....................    lcd_output_enable(0); 
044C:  BCF    03.5
044D:  BCF    08.0
044E:  BSF    03.5
044F:  BCF    08.0
....................    delay_cycles(1); 
0450:  NOP
....................    lcd_output_enable(1); 
0451:  BCF    03.5
0452:  BSF    08.0
0453:  BSF    03.5
0454:  BCF    08.0
....................    delay_us(1); 
0455:  GOTO   456
0456:  GOTO   457
0457:  NOP
....................    low = lcd_read_nibble(); 
*
0488:  MOVF   78,W
0489:  MOVWF  4C
....................        
....................    lcd_output_enable(0); 
048A:  BCF    03.5
048B:  BCF    08.0
048C:  BSF    03.5
048D:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
048E:  BCF    08.4
....................    output_drive(LCD_DATA5); 
048F:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0490:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0491:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0492:  SWAPF  4D,W
0493:  MOVWF  77
0494:  MOVLW  F0
0495:  ANDWF  77,F
0496:  MOVF   77,W
0497:  IORWF  4C,W
0498:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
041A:  CLRF   4E
*
0458:  CLRF   4E
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
041B:  BSF    08.4
041C:  MOVLW  00
041D:  BCF    03.5
041E:  BTFSC  08.4
041F:  MOVLW  01
0420:  BSF    03.5
0421:  IORWF  4E,F
*
0459:  BSF    08.4
045A:  MOVLW  00
045B:  BCF    03.5
045C:  BTFSC  08.4
045D:  MOVLW  01
045E:  BSF    03.5
045F:  IORWF  4E,F
....................    n |= input(LCD_DATA5) << 1; 
*
0422:  BSF    08.5
0423:  MOVLW  00
0424:  BCF    03.5
0425:  BTFSC  08.5
0426:  MOVLW  01
0427:  MOVWF  77
0428:  BCF    03.0
0429:  RLF    77,F
042A:  MOVF   77,W
042B:  BSF    03.5
042C:  IORWF  4E,F
*
0460:  BSF    08.5
0461:  MOVLW  00
0462:  BCF    03.5
0463:  BTFSC  08.5
0464:  MOVLW  01
0465:  MOVWF  77
0466:  BCF    03.0
0467:  RLF    77,F
0468:  MOVF   77,W
0469:  BSF    03.5
046A:  IORWF  4E,F
....................    n |= input(LCD_DATA6) << 2; 
*
042D:  BSF    08.6
042E:  MOVLW  00
042F:  BCF    03.5
0430:  BTFSC  08.6
0431:  MOVLW  01
0432:  MOVWF  77
0433:  RLF    77,F
0434:  RLF    77,F
0435:  MOVLW  FC
0436:  ANDWF  77,F
0437:  MOVF   77,W
0438:  BSF    03.5
0439:  IORWF  4E,F
*
046B:  BSF    08.6
046C:  MOVLW  00
046D:  BCF    03.5
046E:  BTFSC  08.6
046F:  MOVLW  01
0470:  MOVWF  77
0471:  RLF    77,F
0472:  RLF    77,F
0473:  MOVLW  FC
0474:  ANDWF  77,F
0475:  MOVF   77,W
0476:  BSF    03.5
0477:  IORWF  4E,F
....................    n |= input(LCD_DATA7) << 3; 
*
043A:  BSF    08.7
043B:  MOVLW  00
043C:  BCF    03.5
043D:  BTFSC  08.7
043E:  MOVLW  01
043F:  MOVWF  77
0440:  RLF    77,F
0441:  RLF    77,F
0442:  RLF    77,F
0443:  MOVLW  F8
0444:  ANDWF  77,F
0445:  MOVF   77,W
0446:  BSF    03.5
0447:  IORWF  4E,F
*
0478:  BSF    08.7
0479:  MOVLW  00
047A:  BCF    03.5
047B:  BTFSC  08.7
047C:  MOVLW  01
047D:  MOVWF  77
047E:  RLF    77,F
047F:  RLF    77,F
0480:  RLF    77,F
0481:  MOVLW  F8
0482:  ANDWF  77,F
0483:  MOVF   77,W
0484:  BSF    03.5
0485:  IORWF  4E,F
....................     
....................    return(n); 
*
0448:  MOVF   4E,W
0449:  MOVWF  78
*
0486:  MOVF   4E,W
0487:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
04B8:  BTFSC  4D.0
04B9:  GOTO   4BE
04BA:  BCF    03.5
04BB:  BCF    08.4
04BC:  GOTO   4C0
04BD:  BSF    03.5
04BE:  BCF    03.5
04BF:  BSF    08.4
04C0:  BSF    03.5
04C1:  BCF    08.4
*
04F4:  BTFSC  4D.0
04F5:  GOTO   4FA
04F6:  BCF    03.5
04F7:  BCF    08.4
04F8:  GOTO   4FC
04F9:  BSF    03.5
04FA:  BCF    03.5
04FB:  BSF    08.4
04FC:  BSF    03.5
04FD:  BCF    08.4
*
0556:  BTFSC  4D.0
0557:  GOTO   55C
0558:  BCF    03.5
0559:  BCF    08.4
055A:  GOTO   55E
055B:  BSF    03.5
055C:  BCF    03.5
055D:  BSF    08.4
055E:  BSF    03.5
055F:  BCF    08.4
*
0596:  BTFSC  4D.0
0597:  GOTO   59C
0598:  BCF    03.5
0599:  BCF    08.4
059A:  GOTO   59E
059B:  BSF    03.5
059C:  BCF    03.5
059D:  BSF    08.4
059E:  BSF    03.5
059F:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
*
04C2:  BTFSC  4D.1
04C3:  GOTO   4C8
04C4:  BCF    03.5
04C5:  BCF    08.5
04C6:  GOTO   4CA
04C7:  BSF    03.5
04C8:  BCF    03.5
04C9:  BSF    08.5
04CA:  BSF    03.5
04CB:  BCF    08.5
*
04FE:  BTFSC  4D.1
04FF:  GOTO   504
0500:  BCF    03.5
0501:  BCF    08.5
0502:  GOTO   506
0503:  BSF    03.5
0504:  BCF    03.5
0505:  BSF    08.5
0506:  BSF    03.5
0507:  BCF    08.5
*
0560:  BTFSC  4D.1
0561:  GOTO   566
0562:  BCF    03.5
0563:  BCF    08.5
0564:  GOTO   568
0565:  BSF    03.5
0566:  BCF    03.5
0567:  BSF    08.5
0568:  BSF    03.5
0569:  BCF    08.5
*
05A0:  BTFSC  4D.1
05A1:  GOTO   5A6
05A2:  BCF    03.5
05A3:  BCF    08.5
05A4:  GOTO   5A8
05A5:  BSF    03.5
05A6:  BCF    03.5
05A7:  BSF    08.5
05A8:  BSF    03.5
05A9:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
*
04CC:  BTFSC  4D.2
04CD:  GOTO   4D2
04CE:  BCF    03.5
04CF:  BCF    08.6
04D0:  GOTO   4D4
04D1:  BSF    03.5
04D2:  BCF    03.5
04D3:  BSF    08.6
04D4:  BSF    03.5
04D5:  BCF    08.6
*
0508:  BTFSC  4D.2
0509:  GOTO   50E
050A:  BCF    03.5
050B:  BCF    08.6
050C:  GOTO   510
050D:  BSF    03.5
050E:  BCF    03.5
050F:  BSF    08.6
0510:  BSF    03.5
0511:  BCF    08.6
*
056A:  BTFSC  4D.2
056B:  GOTO   570
056C:  BCF    03.5
056D:  BCF    08.6
056E:  GOTO   572
056F:  BSF    03.5
0570:  BCF    03.5
0571:  BSF    08.6
0572:  BSF    03.5
0573:  BCF    08.6
*
05AA:  BTFSC  4D.2
05AB:  GOTO   5B0
05AC:  BCF    03.5
05AD:  BCF    08.6
05AE:  GOTO   5B2
05AF:  BSF    03.5
05B0:  BCF    03.5
05B1:  BSF    08.6
05B2:  BSF    03.5
05B3:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
*
04D6:  BTFSC  4D.3
04D7:  GOTO   4DC
04D8:  BCF    03.5
04D9:  BCF    08.7
04DA:  GOTO   4DE
04DB:  BSF    03.5
04DC:  BCF    03.5
04DD:  BSF    08.7
04DE:  BSF    03.5
04DF:  BCF    08.7
*
0512:  BTFSC  4D.3
0513:  GOTO   518
0514:  BCF    03.5
0515:  BCF    08.7
0516:  GOTO   51A
0517:  BSF    03.5
0518:  BCF    03.5
0519:  BSF    08.7
051A:  BSF    03.5
051B:  BCF    08.7
*
0574:  BTFSC  4D.3
0575:  GOTO   57A
0576:  BCF    03.5
0577:  BCF    08.7
0578:  GOTO   57C
0579:  BSF    03.5
057A:  BCF    03.5
057B:  BSF    08.7
057C:  BSF    03.5
057D:  BCF    08.7
*
05B4:  BTFSC  4D.3
05B5:  GOTO   5BA
05B6:  BCF    03.5
05B7:  BCF    08.7
05B8:  GOTO   5BC
05B9:  BSF    03.5
05BA:  BCF    03.5
05BB:  BSF    08.7
05BC:  BSF    03.5
05BD:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
*
04E0:  NOP
*
051C:  NOP
*
057E:  NOP
*
05BE:  NOP
....................    lcd_output_enable(1); 
*
04E1:  BCF    03.5
04E2:  BSF    08.0
04E3:  BSF    03.5
04E4:  BCF    08.0
*
051D:  BCF    03.5
051E:  BSF    08.0
051F:  BSF    03.5
0520:  BCF    08.0
*
057F:  BCF    03.5
0580:  BSF    08.0
0581:  BSF    03.5
0582:  BCF    08.0
*
05BF:  BCF    03.5
05C0:  BSF    08.0
05C1:  BSF    03.5
05C2:  BCF    08.0
....................    delay_us(2); 
*
04E5:  MOVLW  02
04E6:  MOVWF  77
04E7:  DECFSZ 77,F
04E8:  GOTO   4E7
04E9:  GOTO   4EA
04EA:  NOP
*
0521:  MOVLW  02
0522:  MOVWF  77
0523:  DECFSZ 77,F
0524:  GOTO   523
0525:  GOTO   526
0526:  NOP
*
0583:  MOVLW  02
0584:  MOVWF  77
0585:  DECFSZ 77,F
0586:  GOTO   585
0587:  GOTO   588
0588:  NOP
*
05C3:  MOVLW  02
05C4:  MOVWF  77
05C5:  DECFSZ 77,F
05C6:  GOTO   5C5
05C7:  GOTO   5C8
05C8:  NOP
....................    lcd_output_enable(0); 
*
04EB:  BCF    03.5
04EC:  BCF    08.0
04ED:  BSF    03.5
04EE:  BCF    08.0
*
0527:  BCF    03.5
0528:  BCF    08.0
0529:  BSF    03.5
052A:  BCF    08.0
*
0589:  BCF    03.5
058A:  BCF    08.0
058B:  BSF    03.5
058C:  BCF    08.0
*
05C9:  BCF    03.5
05CA:  BCF    08.0
05CB:  BSF    03.5
05CC:  BCF    08.0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0404:  BSF    03.5
0405:  BCF    08.0
....................    lcd_rs_tris(); 
0406:  BCF    08.2
....................    lcd_rw_tris(); 
0407:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0408:  BCF    03.5
0409:  BCF    08.2
040A:  BSF    03.5
040B:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0499:  MOVF   78,W
049A:  MOVWF  4C
049B:  BTFSC  4C.7
049C:  GOTO   40C
....................    lcd_output_rs(address); 
049D:  MOVF   4A,F
049E:  BTFSS  03.2
049F:  GOTO   4A4
04A0:  BCF    03.5
04A1:  BCF    08.2
04A2:  GOTO   4A6
04A3:  BSF    03.5
04A4:  BCF    03.5
04A5:  BSF    08.2
04A6:  BSF    03.5
04A7:  BCF    08.2
....................    delay_cycles(1); 
04A8:  NOP
....................    lcd_output_rw(0); 
04A9:  BCF    03.5
04AA:  BCF    08.1
04AB:  BSF    03.5
04AC:  BCF    08.1
....................    delay_cycles(1); 
04AD:  NOP
....................    lcd_output_enable(0); 
04AE:  BCF    03.5
04AF:  BCF    08.0
04B0:  BSF    03.5
04B1:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
04B2:  SWAPF  4B,W
04B3:  MOVWF  4C
04B4:  MOVLW  0F
04B5:  ANDWF  4C,F
04B6:  MOVF   4C,W
04B7:  MOVWF  4D
....................    lcd_send_nibble(n & 0xf); 
*
04EF:  MOVF   4B,W
04F0:  ANDLW  0F
04F1:  MOVWF  4C
04F2:  MOVF   4C,W
04F3:  MOVWF  4D
*
052B:  BCF    03.5
052C:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
052D:  MOVLW  28
052E:  BSF    03.5
052F:  MOVWF  3E
0530:  MOVLW  0C
0531:  MOVWF  3F
0532:  MOVLW  01
0533:  MOVWF  40
0534:  MOVLW  06
0535:  MOVWF  41
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0536:  BCF    03.5
0537:  BCF    08.0
0538:  BSF    03.5
0539:  BCF    08.0
....................    lcd_output_rs(0); 
053A:  BCF    03.5
053B:  BCF    08.2
053C:  BSF    03.5
053D:  BCF    08.2
....................    lcd_output_rw(0); 
053E:  BCF    03.5
053F:  BCF    08.1
0540:  BSF    03.5
0541:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0542:  BCF    08.4
....................    output_drive(LCD_DATA5); 
0543:  BCF    08.5
....................    output_drive(LCD_DATA6); 
0544:  BCF    08.6
....................    output_drive(LCD_DATA7); 
0545:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0546:  BCF    08.0
....................    lcd_rs_tris(); 
0547:  BCF    08.2
....................    lcd_rw_tris(); 
0548:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
0549:  MOVLW  0F
054A:  MOVWF  46
054B:  BCF    03.5
054C:  CALL   3F0
....................    for(i=1;i<=3;++i) 
054D:  MOVLW  01
054E:  BSF    03.5
054F:  MOVWF  3D
0550:  MOVF   3D,W
0551:  SUBLW  03
0552:  BTFSS  03.0
0553:  GOTO   594
....................    { 
....................        lcd_send_nibble(3); 
0554:  MOVLW  03
0555:  MOVWF  4D
....................        delay_ms(5); 
*
058D:  MOVLW  05
058E:  MOVWF  46
058F:  BCF    03.5
0590:  CALL   3F0
0591:  BSF    03.5
0592:  INCF   3D,F
0593:  GOTO   550
....................    } 
....................     
....................    lcd_send_nibble(2); 
0594:  MOVLW  02
0595:  MOVWF  4D
....................    delay_ms(5); 
*
05CD:  MOVLW  05
05CE:  MOVWF  46
05CF:  BCF    03.5
05D0:  CALL   3F0
....................    for(i=0;i<=3;++i) 
05D1:  BSF    03.5
05D2:  CLRF   3D
05D3:  MOVF   3D,W
05D4:  SUBLW  03
05D5:  BTFSS  03.0
05D6:  GOTO   5E5
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
05D7:  MOVLW  BE
05D8:  ADDWF  3D,W
05D9:  MOVWF  04
05DA:  BCF    03.7
05DB:  MOVF   00,W
05DC:  MOVWF  42
05DD:  CLRF   4A
05DE:  MOVF   42,W
05DF:  MOVWF  4B
05E0:  BCF    03.5
05E1:  CALL   404
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
05E2:  BSF    03.5
05E3:  INCF   3D,F
05E4:  GOTO   5D3
05E5:  BCF    03.5
05E6:  BCF    0A.3
05E7:  BSF    0A.4
05E8:  GOTO   4C0 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
062F:  DECFSZ 47,W
0630:  GOTO   632
0631:  GOTO   635
*
0653:  DECFSZ 47,W
0654:  GOTO   656
0655:  GOTO   659
*
0745:  DECFSZ 47,W
0746:  GOTO   748
0747:  GOTO   74B
*
07A4:  DECFSZ 47,W
07A5:  GOTO   7A7
07A6:  GOTO   7AA
*
0D7F:  DECFSZ 47,W
0D80:  GOTO   582
0D81:  GOTO   585
*
0DE9:  DECFSZ 47,W
0DEA:  GOTO   5EC
0DEB:  GOTO   5EF
*
0E70:  DECFSZ 47,W
0E71:  GOTO   673
0E72:  GOTO   676
*
0ED7:  DECFSZ 47,W
0ED8:  GOTO   6DA
0ED9:  GOTO   6DD
*
1016:  DECFSZ 47,W
1017:  GOTO   019
1018:  GOTO   01C
*
1057:  DECFSZ 47,W
1058:  GOTO   05A
1059:  GOTO   05D
*
1098:  DECFSZ 47,W
1099:  GOTO   09B
109A:  GOTO   09E
*
10F7:  DECFSZ 47,W
10F8:  GOTO   0FA
10F9:  GOTO   0FD
*
1169:  DECFSZ 47,W
116A:  GOTO   16C
116B:  GOTO   16F
*
11DA:  DECFSZ 47,W
11DB:  GOTO   1DD
11DC:  GOTO   1E0
*
1235:  DECFSZ 47,W
1236:  GOTO   238
1237:  GOTO   23B
*
1274:  DECFSZ 47,W
1275:  GOTO   277
1276:  GOTO   27A
*
12E4:  DECFSZ 47,W
12E5:  GOTO   2E7
12E6:  GOTO   2EA
*
1356:  DECFSZ 47,W
1357:  GOTO   359
1358:  GOTO   35C
*
13C7:  DECFSZ 47,W
13C8:  GOTO   3CA
13C9:  GOTO   3CD
....................       address=LCD_LINE_TWO; 
*
0632:  MOVLW  40
0633:  MOVWF  48
0634:  GOTO   636
*
0656:  MOVLW  40
0657:  MOVWF  48
0658:  GOTO   65A
*
0748:  MOVLW  40
0749:  MOVWF  48
074A:  GOTO   74C
*
07A7:  MOVLW  40
07A8:  MOVWF  48
07A9:  GOTO   7AB
*
0D82:  MOVLW  40
0D83:  MOVWF  48
0D84:  GOTO   586
*
0DEC:  MOVLW  40
0DED:  MOVWF  48
0DEE:  GOTO   5F0
*
0E73:  MOVLW  40
0E74:  MOVWF  48
0E75:  GOTO   677
*
0EDA:  MOVLW  40
0EDB:  MOVWF  48
0EDC:  GOTO   6DE
*
1019:  MOVLW  40
101A:  MOVWF  48
101B:  GOTO   01D
*
105A:  MOVLW  40
105B:  MOVWF  48
105C:  GOTO   05E
*
109B:  MOVLW  40
109C:  MOVWF  48
109D:  GOTO   09F
*
10FA:  MOVLW  40
10FB:  MOVWF  48
10FC:  GOTO   0FE
*
116C:  MOVLW  40
116D:  MOVWF  48
116E:  GOTO   170
*
11DD:  MOVLW  40
11DE:  MOVWF  48
11DF:  GOTO   1E1
*
1238:  MOVLW  40
1239:  MOVWF  48
123A:  GOTO   23C
*
1277:  MOVLW  40
1278:  MOVWF  48
1279:  GOTO   27B
*
12E7:  MOVLW  40
12E8:  MOVWF  48
12E9:  GOTO   2EB
*
1359:  MOVLW  40
135A:  MOVWF  48
135B:  GOTO   35D
*
13CA:  MOVLW  40
13CB:  MOVWF  48
13CC:  GOTO   3CE
....................    else 
....................       address=0; 
*
0635:  CLRF   48
*
0659:  CLRF   48
*
074B:  CLRF   48
*
07AA:  CLRF   48
*
0D85:  CLRF   48
*
0DEF:  CLRF   48
*
0E76:  CLRF   48
*
0EDD:  CLRF   48
*
101C:  CLRF   48
*
105D:  CLRF   48
*
109E:  CLRF   48
*
10FD:  CLRF   48
*
116F:  CLRF   48
*
11E0:  CLRF   48
*
123B:  CLRF   48
*
127A:  CLRF   48
*
12EA:  CLRF   48
*
135C:  CLRF   48
*
13CD:  CLRF   48
....................       
....................    address+=x-1; 
*
0636:  MOVLW  01
0637:  SUBWF  46,W
0638:  ADDWF  48,F
*
065A:  MOVLW  01
065B:  SUBWF  46,W
065C:  ADDWF  48,F
*
074C:  MOVLW  01
074D:  SUBWF  46,W
074E:  ADDWF  48,F
*
07AB:  MOVLW  01
07AC:  SUBWF  46,W
07AD:  ADDWF  48,F
*
0D86:  MOVLW  01
0D87:  SUBWF  46,W
0D88:  ADDWF  48,F
*
0DF0:  MOVLW  01
0DF1:  SUBWF  46,W
0DF2:  ADDWF  48,F
*
0E77:  MOVLW  01
0E78:  SUBWF  46,W
0E79:  ADDWF  48,F
*
0EDE:  MOVLW  01
0EDF:  SUBWF  46,W
0EE0:  ADDWF  48,F
*
101D:  MOVLW  01
101E:  SUBWF  46,W
101F:  ADDWF  48,F
*
105E:  MOVLW  01
105F:  SUBWF  46,W
1060:  ADDWF  48,F
*
109F:  MOVLW  01
10A0:  SUBWF  46,W
10A1:  ADDWF  48,F
*
10FE:  MOVLW  01
10FF:  SUBWF  46,W
1100:  ADDWF  48,F
*
1170:  MOVLW  01
1171:  SUBWF  46,W
1172:  ADDWF  48,F
*
11E1:  MOVLW  01
11E2:  SUBWF  46,W
11E3:  ADDWF  48,F
*
123C:  MOVLW  01
123D:  SUBWF  46,W
123E:  ADDWF  48,F
*
127B:  MOVLW  01
127C:  SUBWF  46,W
127D:  ADDWF  48,F
*
12EB:  MOVLW  01
12EC:  SUBWF  46,W
12ED:  ADDWF  48,F
*
135D:  MOVLW  01
135E:  SUBWF  46,W
135F:  ADDWF  48,F
*
13CE:  MOVLW  01
13CF:  SUBWF  46,W
13D0:  ADDWF  48,F
....................    lcd_send_byte(0,0x80|address); 
*
0639:  MOVF   48,W
063A:  IORLW  80
063B:  MOVWF  49
063C:  CLRF   4A
063D:  MOVF   49,W
063E:  MOVWF  4B
063F:  BCF    03.5
0640:  CALL   404
*
065D:  MOVF   48,W
065E:  IORLW  80
065F:  MOVWF  49
0660:  CLRF   4A
0661:  MOVF   49,W
0662:  MOVWF  4B
0663:  BCF    03.5
0664:  CALL   404
*
074F:  MOVF   48,W
0750:  IORLW  80
0751:  MOVWF  49
0752:  CLRF   4A
0753:  MOVF   49,W
0754:  MOVWF  4B
0755:  BCF    03.5
0756:  CALL   404
*
07AE:  MOVF   48,W
07AF:  IORLW  80
07B0:  MOVWF  49
07B1:  CLRF   4A
07B2:  MOVF   49,W
07B3:  MOVWF  4B
07B4:  BCF    03.5
07B5:  CALL   404
*
0D89:  MOVF   48,W
0D8A:  IORLW  80
0D8B:  MOVWF  49
0D8C:  CLRF   4A
0D8D:  MOVF   49,W
0D8E:  MOVWF  4B
0D8F:  BCF    0A.3
0D90:  BCF    03.5
0D91:  CALL   404
0D92:  BSF    0A.3
*
0DF3:  MOVF   48,W
0DF4:  IORLW  80
0DF5:  MOVWF  49
0DF6:  CLRF   4A
0DF7:  MOVF   49,W
0DF8:  MOVWF  4B
0DF9:  BCF    0A.3
0DFA:  BCF    03.5
0DFB:  CALL   404
0DFC:  BSF    0A.3
*
0E7A:  MOVF   48,W
0E7B:  IORLW  80
0E7C:  MOVWF  49
0E7D:  CLRF   4A
0E7E:  MOVF   49,W
0E7F:  MOVWF  4B
0E80:  BCF    0A.3
0E81:  BCF    03.5
0E82:  CALL   404
0E83:  BSF    0A.3
*
0EE1:  MOVF   48,W
0EE2:  IORLW  80
0EE3:  MOVWF  49
0EE4:  CLRF   4A
0EE5:  MOVF   49,W
0EE6:  MOVWF  4B
0EE7:  BCF    0A.3
0EE8:  BCF    03.5
0EE9:  CALL   404
0EEA:  BSF    0A.3
*
1020:  MOVF   48,W
1021:  IORLW  80
1022:  MOVWF  49
1023:  CLRF   4A
1024:  MOVF   49,W
1025:  MOVWF  4B
1026:  BCF    0A.4
1027:  BCF    03.5
1028:  CALL   404
1029:  BSF    0A.4
*
1061:  MOVF   48,W
1062:  IORLW  80
1063:  MOVWF  49
1064:  CLRF   4A
1065:  MOVF   49,W
1066:  MOVWF  4B
1067:  BCF    0A.4
1068:  BCF    03.5
1069:  CALL   404
106A:  BSF    0A.4
*
10A2:  MOVF   48,W
10A3:  IORLW  80
10A4:  MOVWF  49
10A5:  CLRF   4A
10A6:  MOVF   49,W
10A7:  MOVWF  4B
10A8:  BCF    0A.4
10A9:  BCF    03.5
10AA:  CALL   404
10AB:  BSF    0A.4
*
1101:  MOVF   48,W
1102:  IORLW  80
1103:  MOVWF  49
1104:  CLRF   4A
1105:  MOVF   49,W
1106:  MOVWF  4B
1107:  BCF    0A.4
1108:  BCF    03.5
1109:  CALL   404
110A:  BSF    0A.4
*
1173:  MOVF   48,W
1174:  IORLW  80
1175:  MOVWF  49
1176:  CLRF   4A
1177:  MOVF   49,W
1178:  MOVWF  4B
1179:  BCF    0A.4
117A:  BCF    03.5
117B:  CALL   404
117C:  BSF    0A.4
*
11E4:  MOVF   48,W
11E5:  IORLW  80
11E6:  MOVWF  49
11E7:  CLRF   4A
11E8:  MOVF   49,W
11E9:  MOVWF  4B
11EA:  BCF    0A.4
11EB:  BCF    03.5
11EC:  CALL   404
11ED:  BSF    0A.4
*
123F:  MOVF   48,W
1240:  IORLW  80
1241:  MOVWF  49
1242:  CLRF   4A
1243:  MOVF   49,W
1244:  MOVWF  4B
1245:  BCF    0A.4
1246:  BCF    03.5
1247:  CALL   404
1248:  BSF    0A.4
*
127E:  MOVF   48,W
127F:  IORLW  80
1280:  MOVWF  49
1281:  CLRF   4A
1282:  MOVF   49,W
1283:  MOVWF  4B
1284:  BCF    0A.4
1285:  BCF    03.5
1286:  CALL   404
1287:  BSF    0A.4
*
12EE:  MOVF   48,W
12EF:  IORLW  80
12F0:  MOVWF  49
12F1:  CLRF   4A
12F2:  MOVF   49,W
12F3:  MOVWF  4B
12F4:  BCF    0A.4
12F5:  BCF    03.5
12F6:  CALL   404
12F7:  BSF    0A.4
*
1360:  MOVF   48,W
1361:  IORLW  80
1362:  MOVWF  49
1363:  CLRF   4A
1364:  MOVF   49,W
1365:  MOVWF  4B
1366:  BCF    0A.4
1367:  BCF    03.5
1368:  CALL   404
1369:  BSF    0A.4
*
13D1:  MOVF   48,W
13D2:  IORLW  80
13D3:  MOVWF  49
13D4:  CLRF   4A
13D5:  MOVF   49,W
13D6:  MOVWF  4B
13D7:  BCF    0A.4
13D8:  BCF    03.5
13D9:  CALL   404
13DA:  BSF    0A.4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
061B:  BSF    03.5
061C:  MOVF   45,W
061D:  XORLW  07
061E:  BCF    03.5
061F:  BTFSC  03.2
0620:  GOTO   62B
0621:  XORLW  0B
0622:  BTFSC  03.2
0623:  GOTO   642
0624:  XORLW  06
0625:  BTFSC  03.2
0626:  GOTO   64E
0627:  XORLW  02
0628:  BTFSC  03.2
0629:  GOTO   666
062A:  GOTO   66D
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
062B:  MOVLW  01
062C:  BSF    03.5
062D:  MOVWF  46
062E:  MOVWF  47
*
0641:  GOTO   674
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0642:  BSF    03.5
0643:  CLRF   4A
0644:  MOVLW  01
0645:  MOVWF  4B
0646:  BCF    03.5
0647:  CALL   404
....................                      delay_ms(2); 
0648:  MOVLW  02
0649:  BSF    03.5
064A:  MOVWF  46
064B:  BCF    03.5
064C:  CALL   3F0
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
064D:  GOTO   674
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
064E:  MOVLW  01
064F:  BSF    03.5
0650:  MOVWF  46
0651:  MOVLW  02
0652:  MOVWF  47
*
0665:  GOTO   674
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0666:  BSF    03.5
0667:  CLRF   4A
0668:  MOVLW  10
0669:  MOVWF  4B
066A:  BCF    03.5
066B:  CALL   404
066C:  GOTO   674
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
066D:  MOVLW  01
066E:  BSF    03.5
066F:  MOVWF  4A
0670:  MOVF   45,W
0671:  MOVWF  4B
0672:  BCF    03.5
0673:  CALL   404
....................      #endif 
....................    } 
0674:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
....................  
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
*
1440:  MOVLW  B9
1441:  MOVWF  41
1442:  MOVLW  3B
1443:  MOVWF  42
1444:  MOVLW  5E
1445:  MOVWF  43
1446:  MOVLW  38
1447:  MOVWF  44
1448:  MOVLW  34
1449:  MOVWF  45
144A:  MOVLW  35
144B:  MOVWF  46
144C:  MOVLW  38
144D:  MOVWF  47
144E:  MOVLW  32
144F:  MOVWF  48
1450:  MOVLW  66
1451:  MOVWF  49
1452:  MOVLW  2F
1453:  MOVWF  4A
1454:  MOVLW  BD
1455:  MOVWF  4B
1456:  MOVLW  2C
1457:  MOVWF  4C
1458:  MOVLW  3A
1459:  MOVWF  4D
145A:  MOVLW  2A
145B:  MOVWF  4E
145C:  MOVLW  DC
145D:  MOVWF  4F
145E:  MOVLW  27
145F:  MOVWF  50
1460:  MOVLW  9F
1461:  MOVWF  51
1462:  MOVLW  25
1463:  MOVWF  52
1464:  MOVLW  82
1465:  MOVWF  53
1466:  MOVLW  23
1467:  MOVWF  54
1468:  MOVLW  84
1469:  MOVWF  55
146A:  MOVLW  21
146B:  MOVWF  56
146C:  MOVLW  A3
146D:  MOVWF  57
146E:  MOVLW  1F
146F:  MOVWF  58
.................... /* 
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
0BBF:  BSF    03.5
0BC0:  CLRF   47
0BC1:  CLRF   46
0BC2:  CLRF   49
0BC3:  CLRF   48
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
0BC4:  MOVF   43,F
0BC5:  BTFSS  03.2
0BC6:  GOTO   3CB
0BC7:  MOVF   42,W
0BC8:  SUBLW  13
0BC9:  BTFSC  03.0
0BCA:  GOTO   50C
0BCB:  MOVF   43,W
0BCC:  SUBLW  4E
0BCD:  BTFSS  03.0
0BCE:  GOTO   50C
0BCF:  BTFSS  03.2
0BD0:  GOTO   3D5
0BD1:  MOVF   42,W
0BD2:  SUBLW  20
0BD3:  BTFSS  03.0
0BD4:  GOTO   50C
....................       tmp=100000; 
0BD5:  CLRF   4F
0BD6:  MOVLW  01
0BD7:  MOVWF  4E
0BD8:  MOVLW  86
0BD9:  MOVWF  4D
0BDA:  MOVLW  A0
0BDB:  MOVWF  4C
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
0BDC:  BCF    03.1
0BDD:  MOVF   4F,W
0BDE:  MOVWF  53
0BDF:  MOVF   4E,W
0BE0:  MOVWF  52
0BE1:  MOVF   4D,W
0BE2:  MOVWF  51
0BE3:  MOVF   4C,W
0BE4:  MOVWF  50
0BE5:  CLRF   57
0BE6:  CLRF   56
0BE7:  MOVF   43,W
0BE8:  MOVWF  55
0BE9:  MOVF   42,W
0BEA:  MOVWF  54
*
0C39:  MOVF   7A,W
0C3A:  MOVWF  4F
0C3B:  MOVF   79,W
0C3C:  MOVWF  4E
0C3D:  MOVF   78,W
0C3E:  MOVWF  4D
0C3F:  MOVF   77,W
0C40:  MOVWF  4C
....................       tmp*=5;    
0C41:  MOVF   4F,W
0C42:  MOVWF  53
0C43:  MOVF   4E,W
0C44:  MOVWF  52
0C45:  MOVF   4D,W
0C46:  MOVWF  51
0C47:  MOVF   4C,W
0C48:  MOVWF  50
0C49:  CLRF   57
0C4A:  CLRF   56
0C4B:  CLRF   55
0C4C:  MOVLW  05
0C4D:  MOVWF  54
*
0C77:  MOVF   7A,W
0C78:  MOVWF  4F
0C79:  MOVF   79,W
0C7A:  MOVWF  4E
0C7B:  MOVF   78,W
0C7C:  MOVWF  4D
0C7D:  MOVF   77,W
0C7E:  MOVWF  4C
....................       uS=tmp; 
0C7F:  MOVF   4D,W
0C80:  MOVWF  4B
0C81:  MOVF   4C,W
0C82:  MOVWF  4A
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
0C83:  BCF    06.2
0C84:  BCF    03.5
0C85:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
0C86:  BSF    03.5
0C87:  MOVF   4B,W
0C88:  MOVWF  50
0C89:  INCF   50,F
0C8A:  DECF   50,F
0C8B:  BTFSC  03.2
0C8C:  GOTO   49E
0C8D:  MOVLW  FF
0C8E:  MOVWF  51
*
0C9D:  GOTO   48A
0C9E:  MOVF   4A,W
0C9F:  MOVWF  51
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
0CAE:  MOVF   4A,W
0CAF:  ADDWF  48,F
0CB0:  MOVF   4B,W
0CB1:  BTFSC  03.0
0CB2:  INCFSZ 4B,W
0CB3:  ADDWF  49,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0CB4:  BCF    06.2
0CB5:  BCF    03.5
0CB6:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
0CB7:  BSF    03.5
0CB8:  MOVF   4B,W
0CB9:  MOVWF  50
0CBA:  INCF   50,F
0CBB:  DECF   50,F
0CBC:  BTFSC  03.2
0CBD:  GOTO   4CF
0CBE:  MOVLW  FF
0CBF:  MOVWF  51
*
0CCE:  GOTO   4BB
0CCF:  MOVF   4A,W
0CD0:  MOVWF  51
....................          CiclosL+=(uS);          //  
*
0CDF:  MOVF   4A,W
0CE0:  ADDWF  48,F
0CE1:  MOVF   4B,W
0CE2:  BTFSC  03.0
0CE3:  INCFSZ 4B,W
0CE4:  ADDWF  49,F
....................          CiclosL+=25;            // Compensador. 
0CE5:  MOVLW  19
0CE6:  ADDWF  48,F
0CE7:  BTFSC  03.0
0CE8:  INCF   49,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
0CE9:  MOVF   49,W
0CEA:  SUBLW  02
0CEB:  BTFSC  03.0
0CEC:  GOTO   502
0CED:  XORLW  FF
0CEE:  BTFSS  03.2
0CEF:  GOTO   4F4
0CF0:  MOVF   48,W
0CF1:  SUBLW  E7
0CF2:  BTFSC  03.0
0CF3:  GOTO   502
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0CF4:  MOVLW  E8
0CF5:  SUBWF  48,F
0CF6:  MOVLW  03
0CF7:  BTFSS  03.0
0CF8:  MOVLW  04
0CF9:  SUBWF  49,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0CFA:  INCF   46,F
0CFB:  BTFSC  03.2
0CFC:  INCF   47,F
....................             CiclosL+=25;         // Compensador. 
0CFD:  MOVLW  19
0CFE:  ADDWF  48,F
0CFF:  BTFSC  03.0
0D00:  INCF   49,F
0D01:  GOTO   4E9
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
0D02:  MOVF   47,W
0D03:  SUBWF  45,W
0D04:  BTFSS  03.0
0D05:  GOTO   50C
0D06:  BTFSS  03.2
0D07:  GOTO   483
0D08:  MOVF   44,W
0D09:  SUBWF  46,W
0D0A:  BTFSS  03.0
0D0B:  GOTO   483
....................                                          // tiempo indicado. 
....................    } 
0D0C:  BCF    03.5
0D0D:  RETURN
.................... } 
....................  
.................... #include "header/func_menu_setup.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
.................... /** DIRECTIVAS **/ 
.................... #define OPT_SHOW_IP     0 
.................... #define OPT_SHOW_SSID   1 
.................... #define OPT_SHOW_KEY    2 
.................... #define OPT_MODE_AP     3 
.................... #define OPT_BACKLIGH    4 
.................... #define OPT_EXIT        5 
....................  
.................... //Flag, Modo Cliente(1), Access Point(2), Cliente + AP (3) 
.................... #define MODE_CLIENT     0 
.................... #define MODE_AP         1 
.................... #define MODE_CLIENT_AP  2 
....................  
.................... int8 countOptMenuModo = 3; 
....................  
.................... //Contiene las opciones del menu optMenuModo[pos][lenString] 
.................... const char  optMenuModo[5][13]    =  { {"Cliente     "}, 
....................                                        {"Access Point"}, 
....................                                        {"Cliente + AP"}, 
....................                                        {"SALIR       "} 
....................                                      }; 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................    lcd_gotoxy(12,2); 
*
1011:  MOVLW  0C
1012:  BSF    03.5
1013:  MOVWF  46
1014:  MOVLW  02
1015:  MOVWF  47
*
1052:  MOVLW  0C
1053:  BSF    03.5
1054:  MOVWF  46
1055:  MOVLW  02
1056:  MOVWF  47
*
1093:  MOVLW  0C
1094:  BSF    03.5
1095:  MOVWF  46
1096:  MOVLW  02
1097:  MOVWF  47
*
11D5:  MOVLW  0C
11D6:  BSF    03.5
11D7:  MOVWF  46
11D8:  MOVLW  02
11D9:  MOVWF  47
*
126F:  MOVLW  0C
1270:  BSF    03.5
1271:  MOVWF  46
1272:  MOVLW  02
1273:  MOVWF  47
....................    printf(lcd_putc, "SALIR"); 
*
102A:  MOVLW  C3
102B:  BSF    03.6
102C:  MOVWF  0D
102D:  MOVLW  00
102E:  MOVWF  0F
102F:  BCF    0A.4
1030:  BCF    03.6
1031:  CALL   6B0
1032:  BSF    0A.4
*
106B:  MOVLW  C3
106C:  BSF    03.6
106D:  MOVWF  0D
106E:  MOVLW  00
106F:  MOVWF  0F
1070:  BCF    0A.4
1071:  BCF    03.6
1072:  CALL   6B0
1073:  BSF    0A.4
*
10AC:  MOVLW  C3
10AD:  BSF    03.6
10AE:  MOVWF  0D
10AF:  MOVLW  00
10B0:  MOVWF  0F
10B1:  BCF    0A.4
10B2:  BCF    03.6
10B3:  CALL   6B0
10B4:  BSF    0A.4
*
11EE:  MOVLW  C3
11EF:  BSF    03.6
11F0:  MOVWF  0D
11F1:  MOVLW  00
11F2:  MOVWF  0F
11F3:  BCF    0A.4
11F4:  BCF    03.6
11F5:  CALL   6B0
11F6:  BSF    0A.4
*
1288:  MOVLW  C3
1289:  BSF    03.6
128A:  MOVWF  0D
128B:  MOVLW  00
128C:  MOVWF  0F
128D:  BCF    0A.4
128E:  BCF    03.6
128F:  CALL   6B0
1290:  BSF    0A.4
....................    while(1){ 
....................       if(input(KEY_OK)==0){ 
*
1033:  BSF    03.5
1034:  BSF    06.5
1035:  BCF    03.5
1036:  BTFSC  06.5
1037:  GOTO   046
*
1074:  BSF    03.5
1075:  BSF    06.5
1076:  BCF    03.5
1077:  BTFSC  06.5
1078:  GOTO   087
*
10B5:  BSF    03.5
10B6:  BSF    06.5
10B7:  BCF    03.5
10B8:  BTFSC  06.5
10B9:  GOTO   0C8
*
11F7:  BSF    03.5
11F8:  BSF    06.5
11F9:  BCF    03.5
11FA:  BTFSC  06.5
11FB:  GOTO   20A
*
1291:  BSF    03.5
1292:  BSF    06.5
1293:  BCF    03.5
1294:  BTFSC  06.5
1295:  GOTO   2A4
....................             // Elimina el rebote 
....................             delay_ms(500); 
*
1038:  MOVLW  02
1039:  BSF    03.5
103A:  MOVWF  42
103B:  MOVLW  FA
103C:  MOVWF  46
103D:  BCF    0A.4
103E:  BCF    03.5
103F:  CALL   3F0
1040:  BSF    0A.4
1041:  BSF    03.5
1042:  DECFSZ 42,F
1043:  GOTO   03B
*
1079:  MOVLW  02
107A:  BSF    03.5
107B:  MOVWF  42
107C:  MOVLW  FA
107D:  MOVWF  46
107E:  BCF    0A.4
107F:  BCF    03.5
1080:  CALL   3F0
1081:  BSF    0A.4
1082:  BSF    03.5
1083:  DECFSZ 42,F
1084:  GOTO   07C
*
10BA:  MOVLW  02
10BB:  BSF    03.5
10BC:  MOVWF  42
10BD:  MOVLW  FA
10BE:  MOVWF  46
10BF:  BCF    0A.4
10C0:  BCF    03.5
10C1:  CALL   3F0
10C2:  BSF    0A.4
10C3:  BSF    03.5
10C4:  DECFSZ 42,F
10C5:  GOTO   0BD
*
11FC:  MOVLW  02
11FD:  BSF    03.5
11FE:  MOVWF  42
11FF:  MOVLW  FA
1200:  MOVWF  46
1201:  BCF    0A.4
1202:  BCF    03.5
1203:  CALL   3F0
1204:  BSF    0A.4
1205:  BSF    03.5
1206:  DECFSZ 42,F
1207:  GOTO   1FF
*
1296:  MOVLW  02
1297:  BSF    03.5
1298:  MOVWF  42
1299:  MOVLW  FA
129A:  MOVWF  46
129B:  BCF    0A.4
129C:  BCF    03.5
129D:  CALL   3F0
129E:  BSF    0A.4
129F:  BSF    03.5
12A0:  DECFSZ 42,F
12A1:  GOTO   299
....................             break; 
*
1044:  GOTO   048
1045:  BCF    03.5
*
1085:  GOTO   089
1086:  BCF    03.5
*
10C6:  GOTO   0CA
10C7:  BCF    03.5
*
1208:  GOTO   20C
1209:  BCF    03.5
*
12A2:  GOTO   2A6
12A3:  BCF    03.5
....................       } 
*
1046:  GOTO   033
1047:  BSF    03.5
*
1087:  GOTO   074
1088:  BSF    03.5
*
10C8:  GOTO   0B5
10C9:  BSF    03.5
*
120A:  GOTO   1F7
120B:  BSF    03.5
*
12A4:  GOTO   291
12A5:  BSF    03.5
....................    } 
.................... } 
....................  
.................... void showBottonMenu(void){ 
....................    lcd_gotoxy(1,2); 
*
0740:  MOVLW  01
0741:  BSF    03.5
0742:  MOVWF  46
0743:  MOVLW  02
0744:  MOVWF  47
*
079F:  MOVLW  01
07A0:  BSF    03.5
07A1:  MOVWF  46
07A2:  MOVLW  02
07A3:  MOVWF  47
*
0D7A:  MOVLW  01
0D7B:  BSF    03.5
0D7C:  MOVWF  46
0D7D:  MOVLW  02
0D7E:  MOVWF  47
*
0DE4:  MOVLW  01
0DE5:  BSF    03.5
0DE6:  MOVWF  46
0DE7:  MOVLW  02
0DE8:  MOVWF  47
*
0E6B:  MOVLW  01
0E6C:  BSF    03.5
0E6D:  MOVWF  46
0E6E:  MOVLW  02
0E6F:  MOVWF  47
*
0ED2:  MOVLW  01
0ED3:  BSF    03.5
0ED4:  MOVWF  46
0ED5:  MOVLW  02
0ED6:  MOVWF  47
*
10F2:  MOVLW  01
10F3:  BSF    03.5
10F4:  MOVWF  46
10F5:  MOVLW  02
10F6:  MOVWF  47
*
1164:  MOVLW  01
1165:  BSF    03.5
1166:  MOVWF  46
1167:  MOVLW  02
1168:  MOVWF  47
*
1230:  MOVLW  01
1231:  BSF    03.5
1232:  MOVWF  46
1233:  MOVLW  02
1234:  MOVWF  47
*
12DF:  MOVLW  01
12E0:  BSF    03.5
12E1:  MOVWF  46
12E2:  MOVLW  02
12E3:  MOVWF  47
*
1351:  MOVLW  01
1352:  BSF    03.5
1353:  MOVWF  46
1354:  MOVLW  02
1355:  MOVWF  47
*
13C2:  MOVLW  01
13C3:  BSF    03.5
13C4:  MOVWF  46
13C5:  MOVLW  02
13C6:  MOVWF  47
....................    printf(lcd_putc, "[SIG]      [ENT]"); 
*
0757:  MOVLW  C6
0758:  BSF    03.6
0759:  MOVWF  0D
075A:  MOVLW  00
075B:  MOVWF  0F
075C:  BCF    03.6
075D:  CALL   6B0
*
07B6:  MOVLW  C6
07B7:  BSF    03.6
07B8:  MOVWF  0D
07B9:  MOVLW  00
07BA:  MOVWF  0F
07BB:  BCF    03.6
07BC:  CALL   6B0
*
0D93:  MOVLW  C6
0D94:  BSF    03.6
0D95:  MOVWF  0D
0D96:  MOVLW  00
0D97:  MOVWF  0F
0D98:  BCF    0A.3
0D99:  BCF    03.6
0D9A:  CALL   6B0
0D9B:  BSF    0A.3
*
0DFD:  MOVLW  C6
0DFE:  BSF    03.6
0DFF:  MOVWF  0D
0E00:  MOVLW  00
0E01:  MOVWF  0F
0E02:  BCF    0A.3
0E03:  BCF    03.6
0E04:  CALL   6B0
0E05:  BSF    0A.3
*
0E84:  MOVLW  C6
0E85:  BSF    03.6
0E86:  MOVWF  0D
0E87:  MOVLW  00
0E88:  MOVWF  0F
0E89:  BCF    0A.3
0E8A:  BCF    03.6
0E8B:  CALL   6B0
0E8C:  BSF    0A.3
*
0EEB:  MOVLW  C6
0EEC:  BSF    03.6
0EED:  MOVWF  0D
0EEE:  MOVLW  00
0EEF:  MOVWF  0F
0EF0:  BCF    0A.3
0EF1:  BCF    03.6
0EF2:  CALL   6B0
0EF3:  BSF    0A.3
*
110B:  MOVLW  C6
110C:  BSF    03.6
110D:  MOVWF  0D
110E:  MOVLW  00
110F:  MOVWF  0F
1110:  BCF    0A.4
1111:  BCF    03.6
1112:  CALL   6B0
1113:  BSF    0A.4
*
117D:  MOVLW  C6
117E:  BSF    03.6
117F:  MOVWF  0D
1180:  MOVLW  00
1181:  MOVWF  0F
1182:  BCF    0A.4
1183:  BCF    03.6
1184:  CALL   6B0
1185:  BSF    0A.4
*
1249:  MOVLW  C6
124A:  BSF    03.6
124B:  MOVWF  0D
124C:  MOVLW  00
124D:  MOVWF  0F
124E:  BCF    0A.4
124F:  BCF    03.6
1250:  CALL   6B0
1251:  BSF    0A.4
1252:  BSF    03.5
*
12F8:  MOVLW  C6
12F9:  BSF    03.6
12FA:  MOVWF  0D
12FB:  MOVLW  00
12FC:  MOVWF  0F
12FD:  BCF    0A.4
12FE:  BCF    03.6
12FF:  CALL   6B0
1300:  BSF    0A.4
*
136A:  MOVLW  C6
136B:  BSF    03.6
136C:  MOVWF  0D
136D:  MOVLW  00
136E:  MOVWF  0F
136F:  BCF    0A.4
1370:  BCF    03.6
1371:  CALL   6B0
1372:  BSF    0A.4
*
13DB:  MOVLW  C6
13DC:  BSF    03.6
13DD:  MOVWF  0D
13DE:  MOVLW  00
13DF:  MOVWF  0F
13E0:  BCF    0A.4
13E1:  BCF    03.6
13E2:  CALL   6B0
13E3:  BSF    0A.4
13E4:  BSF    03.5
.................... } 
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
.................... void setMenuModo(void){ 
*
10CB:  BSF    03.5
10CC:  CLRF   40
10CD:  CLRF   41
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
10CE:  MOVF   40,W
10CF:  MOVWF  42
10D0:  MOVLW  0D
10D1:  MOVWF  43
10D2:  BCF    0A.4
10D3:  BSF    0A.3
10D4:  BCF    03.5
10D5:  CALL   50E
10D6:  BSF    0A.4
10D7:  BCF    0A.3
10D8:  MOVF   78,W
10D9:  BSF    03.5
10DA:  MOVWF  42
10DB:  MOVLW  0C
10DC:  MOVWF  45
10DD:  BCF    0A.4
10DE:  BCF    03.5
10DF:  CALL   61B
10E0:  BSF    0A.4
10E1:  MOVLW  82
10E2:  BSF    03.6
10E3:  MOVWF  0D
10E4:  MOVLW  00
10E5:  MOVWF  0F
10E6:  BSF    03.5
10E7:  BCF    03.6
10E8:  MOVF   42,W
10E9:  BCF    03.5
10EA:  BSF    03.6
10EB:  ADDWF  0D,F
10EC:  BTFSC  03.0
10ED:  INCF   0F,F
10EE:  BCF    0A.4
10EF:  BCF    03.6
10F0:  CALL   675
10F1:  BSF    0A.4
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1114:  BSF    03.5
1115:  MOVF   41,F
1116:  BTFSS  03.2
1117:  GOTO   254
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
1118:  BSF    06.4
1119:  BCF    03.5
111A:  BTFSC  06.4
111B:  GOTO   186
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
111C:  MOVLW  02
111D:  BSF    03.5
111E:  MOVWF  42
111F:  MOVLW  FA
1120:  MOVWF  46
1121:  BCF    0A.4
1122:  BCF    03.5
1123:  CALL   3F0
1124:  BSF    0A.4
1125:  BSF    03.5
1126:  DECFSZ 42,F
1127:  GOTO   11F
....................          BEEP; 
1128:  MOVLW  04
1129:  MOVWF  43
112A:  MOVLW  B9
112B:  MOVWF  42
112C:  CLRF   45
112D:  MOVLW  14
112E:  MOVWF  44
112F:  BCF    0A.4
1130:  BSF    0A.3
1131:  BCF    03.5
1132:  CALL   3BF
1133:  BSF    0A.4
1134:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
1135:  BSF    03.5
1136:  INCF   40,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuModo){ 
1137:  MOVF   40,W
1138:  BCF    03.5
1139:  SUBWF  59,W
113A:  BTFSC  03.0
113B:  GOTO   13F
....................             optSelected = 0; 
113C:  BSF    03.5
113D:  CLRF   40
113E:  BCF    03.5
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
113F:  BSF    03.5
1140:  MOVF   40,W
1141:  MOVWF  42
1142:  MOVLW  0D
1143:  MOVWF  43
1144:  BCF    0A.4
1145:  BSF    0A.3
1146:  BCF    03.5
1147:  CALL   50E
1148:  BSF    0A.4
1149:  BCF    0A.3
114A:  MOVF   78,W
114B:  BSF    03.5
114C:  MOVWF  42
114D:  MOVLW  0C
114E:  MOVWF  45
114F:  BCF    0A.4
1150:  BCF    03.5
1151:  CALL   61B
1152:  BSF    0A.4
1153:  MOVLW  82
1154:  BSF    03.6
1155:  MOVWF  0D
1156:  MOVLW  00
1157:  MOVWF  0F
1158:  BSF    03.5
1159:  BCF    03.6
115A:  MOVF   42,W
115B:  BCF    03.5
115C:  BSF    03.6
115D:  ADDWF  0D,F
115E:  BTFSC  03.0
115F:  INCF   0F,F
1160:  BCF    0A.4
1161:  BCF    03.6
1162:  CALL   675
1163:  BSF    0A.4
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
1186:  BSF    03.5
1187:  BSF    06.5
1188:  BCF    03.5
1189:  BTFSC  06.5
118A:  GOTO   252
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
118B:  MOVLW  02
118C:  BSF    03.5
118D:  MOVWF  42
118E:  MOVLW  FA
118F:  MOVWF  46
1190:  BCF    0A.4
1191:  BCF    03.5
1192:  CALL   3F0
1193:  BSF    0A.4
1194:  BSF    03.5
1195:  DECFSZ 42,F
1196:  GOTO   18E
....................          BEEP; 
1197:  MOVLW  04
1198:  MOVWF  43
1199:  MOVLW  B9
119A:  MOVWF  42
119B:  CLRF   45
119C:  MOVLW  14
119D:  MOVWF  44
119E:  BCF    0A.4
119F:  BSF    0A.3
11A0:  BCF    03.5
11A1:  CALL   3BF
11A2:  BSF    0A.4
11A3:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuModo){ 
11A4:  MOVF   59,W
11A5:  BSF    03.5
11A6:  SUBWF  40,W
11A7:  BTFSS  03.2
11A8:  GOTO   1AC
....................             exit = 1; 
11A9:  MOVLW  01
11AA:  MOVWF  41
....................          }else{ 
11AB:  GOTO   253
....................             switch(optSelected){ 
11AC:  MOVF   40,W
11AD:  XORLW  00
11AE:  BCF    03.5
11AF:  BTFSC  03.2
11B0:  GOTO   1B8
11B1:  XORLW  01
11B2:  BTFSC  03.2
11B3:  GOTO   1C2
11B4:  XORLW  03
11B5:  BTFSC  03.2
11B6:  GOTO   1CC
11B7:  GOTO   1D5
....................                case MODE_CLIENT: 
....................                   //fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
....................                   printf(lcd_putc, "\fConfig Cliente"); 
11B8:  MOVLW  CF
11B9:  BSF    03.6
11BA:  MOVWF  0D
11BB:  MOVLW  00
11BC:  MOVWF  0F
11BD:  BCF    0A.4
11BE:  BCF    03.6
11BF:  CALL   6B0
11C0:  BSF    0A.4
....................                   break; 
11C1:  GOTO   1D5
....................                case MODE_AP: 
....................                   //fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
....................                   printf(lcd_putc, "\fConfig AP"); 
11C2:  MOVLW  D7
11C3:  BSF    03.6
11C4:  MOVWF  0D
11C5:  MOVLW  00
11C6:  MOVWF  0F
11C7:  BCF    0A.4
11C8:  BCF    03.6
11C9:  CALL   6B0
11CA:  BSF    0A.4
....................                   break; 
11CB:  GOTO   1D5
....................                case MODE_CLIENT_AP: 
....................                   //fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
....................                   printf(lcd_putc, "\fConfig ClienteAP"); 
11CC:  MOVLW  DD
11CD:  BSF    03.6
11CE:  MOVWF  0D
11CF:  MOVLW  00
11D0:  MOVWF  0F
11D1:  BCF    0A.4
11D2:  BCF    03.6
11D3:  CALL   6B0
11D4:  BSF    0A.4
....................                   break; 
....................             } 
....................             pressExit(); 
....................             // Muestra la ultima opcion del menu seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
*
120C:  MOVF   40,W
120D:  MOVWF  42
120E:  MOVLW  0D
120F:  MOVWF  43
1210:  BCF    0A.4
1211:  BSF    0A.3
1212:  BCF    03.5
1213:  CALL   50E
1214:  BSF    0A.4
1215:  BCF    0A.3
1216:  MOVF   78,W
1217:  BSF    03.5
1218:  MOVWF  42
1219:  MOVLW  0C
121A:  MOVWF  45
121B:  BCF    0A.4
121C:  BCF    03.5
121D:  CALL   61B
121E:  BSF    0A.4
121F:  MOVLW  82
1220:  BSF    03.6
1221:  MOVWF  0D
1222:  MOVLW  00
1223:  MOVWF  0F
1224:  BSF    03.5
1225:  BCF    03.6
1226:  MOVF   42,W
1227:  BCF    03.5
1228:  BSF    03.6
1229:  ADDWF  0D,F
122A:  BTFSC  03.0
122B:  INCF   0F,F
122C:  BCF    0A.4
122D:  BCF    03.6
122E:  CALL   675
122F:  BSF    0A.4
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
1253:  GOTO   115
....................    } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................    switch(optSelect){ 
*
1000:  BSF    03.5
1001:  MOVF   3F,W
1002:  ADDLW  FA
1003:  BTFSC  03.0
1004:  GOTO   2AA
1005:  ADDLW  06
1006:  BCF    03.5
1007:  GOTO   2AE
....................        
....................       case OPT_SHOW_IP: 
....................          printf(lcd_putc, "\f192.168.0.1"); 
1008:  MOVLW  E6
1009:  BSF    03.6
100A:  MOVWF  0D
100B:  MOVLW  00
100C:  MOVWF  0F
100D:  BCF    0A.4
100E:  BCF    03.6
100F:  CALL   6B0
1010:  BSF    0A.4
....................          pressExit(); 
....................          break; 
*
1048:  GOTO   2AA
....................       case OPT_SHOW_SSID: 
....................          printf(lcd_putc, "\fC0G3_UNE"); 
1049:  MOVLW  ED
104A:  BSF    03.6
104B:  MOVWF  0D
104C:  MOVLW  00
104D:  MOVWF  0F
104E:  BCF    0A.4
104F:  BCF    03.6
1050:  CALL   6B0
1051:  BSF    0A.4
....................          pressExit();          
....................          break; 
*
1089:  GOTO   2AA
....................       case OPT_SHOW_KEY: 
....................          printf(lcd_putc, "\f1234Az!"); 
108A:  MOVLW  F2
108B:  BSF    03.6
108C:  MOVWF  0D
108D:  MOVLW  00
108E:  MOVWF  0F
108F:  BCF    0A.4
1090:  BCF    03.6
1091:  CALL   6B0
1092:  BSF    0A.4
....................          pressExit(); 
....................          break; 
*
10CA:  GOTO   2AA
....................       case OPT_MODE_AP: 
....................          setMenuModo(); 
....................          break; 
*
1254:  GOTO   2AA
....................       case OPT_BACKLIGH: 
....................          output_toggle(LCD_LIGHT_PIN); 
1255:  BSF    03.5
1256:  BCF    08.3
1257:  MOVLW  08
1258:  BCF    03.5
1259:  XORWF  08,F
....................          if(input_state(LCD_LIGHT_PIN)==1){ 
125A:  BTFSS  08.3
125B:  GOTO   266
....................             printf(lcd_putc, "\fBacklight On"); 
125C:  MOVLW  F7
125D:  BSF    03.6
125E:  MOVWF  0D
125F:  MOVLW  00
1260:  MOVWF  0F
1261:  BCF    0A.4
1262:  BCF    03.6
1263:  CALL   6B0
1264:  BSF    0A.4
....................          }else{ 
1265:  GOTO   26F
....................             printf(lcd_putc, "\fBacklight Off"); 
1266:  MOVLW  FE
1267:  BSF    03.6
1268:  MOVWF  0D
1269:  MOVLW  00
126A:  MOVWF  0F
126B:  BCF    0A.4
126C:  BCF    03.6
126D:  CALL   6B0
126E:  BSF    0A.4
....................          } 
....................          pressExit(); 
....................          break; 
*
12A6:  GOTO   2AA
....................       case OPT_EXIT: 
....................          break; 
12A7:  BSF    03.5
12A8:  GOTO   2AA
12A9:  BSF    03.5
....................           
....................    } 
12AA:  BCF    03.5
12AB:  BCF    0A.3
12AC:  BSF    0A.4
12AD:  GOTO   39D (RETURN)
....................  
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuSetup  = 5; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[7][17]    =  { {"VER IP          "}, 
....................                                         {"VER SSID        "}, 
....................                                         {"VER KEY         "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................                                        
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
0724:  BSF    03.5
0725:  CLRF   3D
0726:  CLRF   3E
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0727:  SWAPF  3D,W
0728:  MOVWF  77
0729:  MOVLW  F0
072A:  ANDWF  77,F
072B:  MOVF   77,W
072C:  MOVWF  3F
072D:  MOVLW  0C
072E:  MOVWF  45
072F:  BCF    03.5
0730:  CALL   61B
0731:  MOVLW  06
0732:  BSF    03.6
0733:  MOVWF  0D
0734:  MOVLW  01
0735:  MOVWF  0F
0736:  BSF    03.5
0737:  BCF    03.6
0738:  MOVF   3F,W
0739:  BCF    03.5
073A:  BSF    03.6
073B:  ADDWF  0D,F
073C:  BTFSC  03.0
073D:  INCF   0F,F
073E:  BCF    03.6
073F:  CALL   675
....................    showBottonMenu(); 
....................    while(!exit){ 
*
075E:  BSF    03.5
075F:  MOVF   3E,F
0760:  BTFSS  03.2
0761:  GOTO   7DD
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0762:  BSF    06.4
0763:  BCF    03.5
0764:  BTFSC  06.4
0765:  GOTO   7BD
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0766:  MOVLW  02
0767:  BSF    03.5
0768:  MOVWF  3F
0769:  MOVLW  FA
076A:  MOVWF  46
076B:  BCF    03.5
076C:  CALL   3F0
076D:  BSF    03.5
076E:  DECFSZ 3F,F
076F:  GOTO   769
....................          BEEP; 
0770:  MOVLW  04
0771:  MOVWF  43
0772:  MOVLW  B9
0773:  MOVWF  42
0774:  CLRF   45
0775:  MOVLW  14
0776:  MOVWF  44
0777:  BSF    0A.3
0778:  BCF    03.5
0779:  CALL   3BF
077A:  BCF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
077B:  BSF    03.5
077C:  INCF   3D,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
077D:  MOVF   3D,W
077E:  BCF    03.5
077F:  SUBWF  5A,W
0780:  BTFSC  03.0
0781:  GOTO   785
....................             optSelected = 0; 
0782:  BSF    03.5
0783:  CLRF   3D
0784:  BCF    03.5
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0785:  BSF    03.5
0786:  SWAPF  3D,W
0787:  MOVWF  77
0788:  MOVLW  F0
0789:  ANDWF  77,F
078A:  MOVF   77,W
078B:  MOVWF  3F
078C:  MOVLW  0C
078D:  MOVWF  45
078E:  BCF    03.5
078F:  CALL   61B
0790:  MOVLW  06
0791:  BSF    03.6
0792:  MOVWF  0D
0793:  MOVLW  01
0794:  MOVWF  0F
0795:  BSF    03.5
0796:  BCF    03.6
0797:  MOVF   3F,W
0798:  BCF    03.5
0799:  BSF    03.6
079A:  ADDWF  0D,F
079B:  BTFSC  03.0
079C:  INCF   0F,F
079D:  BCF    03.6
079E:  CALL   675
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
07BD:  BSF    03.5
07BE:  BSF    06.5
07BF:  BCF    03.5
07C0:  BTFSC  06.5
07C1:  GOTO   7DB
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
07C2:  MOVLW  02
07C3:  BSF    03.5
07C4:  MOVWF  3F
07C5:  MOVLW  FA
07C6:  MOVWF  46
07C7:  BCF    03.5
07C8:  CALL   3F0
07C9:  BSF    03.5
07CA:  DECFSZ 3F,F
07CB:  GOTO   7C5
....................          BEEP; 
07CC:  MOVLW  04
07CD:  MOVWF  43
07CE:  MOVLW  B9
07CF:  MOVWF  42
07D0:  CLRF   45
07D1:  MOVLW  14
07D2:  MOVWF  44
07D3:  BSF    0A.3
07D4:  BCF    03.5
07D5:  CALL   3BF
07D6:  BCF    0A.3
....................          // Rompe el Loop 
....................          exit = 1; 
07D7:  MOVLW  01
07D8:  BSF    03.5
07D9:  MOVWF  3E
07DA:  BCF    03.5
....................       } // Fin KEY_OK 
07DB:  GOTO   75E
07DC:  BSF    03.5
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
07DD:  MOVLW  01
07DE:  ADDWF  3D,W
07DF:  MOVWF  78
07E0:  BCF    03.5
07E1:  BCF    0A.3
07E2:  BSF    0A.4
07E3:  GOTO   4D2 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
0D57:  BSF    03.5
0D58:  CLRF   3D
0D59:  CLRF   3E
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0D5A:  MOVF   3D,W
0D5B:  MOVWF  42
0D5C:  MOVLW  0F
0D5D:  MOVWF  43
0D5E:  BCF    03.5
0D5F:  CALL   50E
0D60:  MOVF   78,W
0D61:  BSF    03.5
0D62:  MOVWF  3F
0D63:  MOVLW  0C
0D64:  MOVWF  45
0D65:  BCF    0A.3
0D66:  BCF    03.5
0D67:  CALL   61B
0D68:  BSF    0A.3
0D69:  MOVLW  46
0D6A:  BSF    03.6
0D6B:  MOVWF  0D
0D6C:  MOVLW  01
0D6D:  MOVWF  0F
0D6E:  BSF    03.5
0D6F:  BCF    03.6
0D70:  MOVF   3F,W
0D71:  BCF    03.5
0D72:  BSF    03.6
0D73:  ADDWF  0D,F
0D74:  BTFSC  03.0
0D75:  INCF   0F,F
0D76:  BCF    0A.3
0D77:  BCF    03.6
0D78:  CALL   675
0D79:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0D9C:  BSF    03.5
0D9D:  MOVF   3E,F
0D9E:  BTFSS  03.2
0D9F:  GOTO   645
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0DA0:  BSF    06.4
0DA1:  BCF    03.5
0DA2:  BTFSC  06.4
0DA3:  GOTO   606
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0DA4:  MOVLW  02
0DA5:  BSF    03.5
0DA6:  MOVWF  3F
0DA7:  MOVLW  FA
0DA8:  MOVWF  46
0DA9:  BCF    0A.3
0DAA:  BCF    03.5
0DAB:  CALL   3F0
0DAC:  BSF    0A.3
0DAD:  BSF    03.5
0DAE:  DECFSZ 3F,F
0DAF:  GOTO   5A7
....................          BEEP; 
0DB0:  MOVLW  04
0DB1:  MOVWF  43
0DB2:  MOVLW  B9
0DB3:  MOVWF  42
0DB4:  CLRF   45
0DB5:  MOVLW  14
0DB6:  MOVWF  44
0DB7:  BCF    03.5
0DB8:  CALL   3BF
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0DB9:  BSF    03.5
0DBA:  INCF   3D,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
0DBB:  MOVF   3D,W
0DBC:  BCF    03.5
0DBD:  SUBWF  5C,W
0DBE:  BTFSC  03.0
0DBF:  GOTO   5C3
....................             optSelected = 0; 
0DC0:  BSF    03.5
0DC1:  CLRF   3D
0DC2:  BCF    03.5
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0DC3:  BSF    03.5
0DC4:  MOVF   3D,W
0DC5:  MOVWF  42
0DC6:  MOVLW  0F
0DC7:  MOVWF  43
0DC8:  BCF    03.5
0DC9:  CALL   50E
0DCA:  MOVF   78,W
0DCB:  BSF    03.5
0DCC:  MOVWF  3F
0DCD:  MOVLW  0C
0DCE:  MOVWF  45
0DCF:  BCF    0A.3
0DD0:  BCF    03.5
0DD1:  CALL   61B
0DD2:  BSF    0A.3
0DD3:  MOVLW  46
0DD4:  BSF    03.6
0DD5:  MOVWF  0D
0DD6:  MOVLW  01
0DD7:  MOVWF  0F
0DD8:  BSF    03.5
0DD9:  BCF    03.6
0DDA:  MOVF   3F,W
0DDB:  BCF    03.5
0DDC:  BSF    03.6
0DDD:  ADDWF  0D,F
0DDE:  BTFSC  03.0
0DDF:  INCF   0F,F
0DE0:  BCF    0A.3
0DE1:  BCF    03.6
0DE2:  CALL   675
0DE3:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0E06:  BSF    03.5
0E07:  BSF    06.5
0E08:  BCF    03.5
0E09:  BTFSC  06.5
0E0A:  GOTO   643
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0E0B:  MOVLW  02
0E0C:  BSF    03.5
0E0D:  MOVWF  3F
0E0E:  MOVLW  FA
0E0F:  MOVWF  46
0E10:  BCF    0A.3
0E11:  BCF    03.5
0E12:  CALL   3F0
0E13:  BSF    0A.3
0E14:  BSF    03.5
0E15:  DECFSZ 3F,F
0E16:  GOTO   60E
....................          BEEP; 
0E17:  MOVLW  04
0E18:  MOVWF  43
0E19:  MOVLW  B9
0E1A:  MOVWF  42
0E1B:  CLRF   45
0E1C:  MOVLW  14
0E1D:  MOVWF  44
0E1E:  BCF    03.5
0E1F:  CALL   3BF
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
0E20:  MOVF   5C,W
0E21:  BSF    03.5
0E22:  SUBWF  3D,W
0E23:  BTFSS  03.2
0E24:  GOTO   628
....................             exit = 1; 
0E25:  MOVLW  01
0E26:  MOVWF  3E
....................          }else{ 
0E27:  GOTO   644
....................             output_high(PIN_OUT[optSelected]); 
0E28:  BCF    03.0
0E29:  RLF    3D,W
0E2A:  ADDLW  2B
0E2B:  MOVWF  04
0E2C:  BCF    03.7
0E2D:  INCF   04,F
0E2E:  MOVF   00,W
0E2F:  MOVWF  40
0E30:  DECF   04,F
0E31:  MOVF   00,W
0E32:  MOVWF  3F
0E33:  MOVWF  41
0E34:  MOVLW  01
0E35:  MOVWF  42
0E36:  CLRF   44
0E37:  CLRF   43
0E38:  BCF    03.5
0E39:  CALL   535
0E3A:  BSF    03.5
0E3B:  MOVF   3F,W
0E3C:  MOVWF  41
0E3D:  CLRF   42
0E3E:  CLRF   44
0E3F:  MOVLW  80
0E40:  MOVWF  43
0E41:  BCF    03.5
0E42:  CALL   535
0E43:  BSF    03.5
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0E44:  GOTO   59D
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0E45:  MOVLW  00
0E46:  MOVWF  78
0E47:  BCF    03.5
0E48:  BCF    0A.3
0E49:  BSF    0A.4
0E4A:  GOTO   4D9 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
0E4B:  BSF    03.5
0E4C:  CLRF   3D
0E4D:  CLRF   3E
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0E4E:  SWAPF  3D,W
0E4F:  MOVWF  77
0E50:  MOVLW  F0
0E51:  ANDWF  77,F
0E52:  MOVF   77,W
0E53:  MOVWF  3F
0E54:  MOVLW  0C
0E55:  MOVWF  45
0E56:  BCF    0A.3
0E57:  BCF    03.5
0E58:  CALL   61B
0E59:  BSF    0A.3
0E5A:  MOVLW  DC
0E5B:  BSF    03.6
0E5C:  MOVWF  0D
0E5D:  MOVLW  01
0E5E:  MOVWF  0F
0E5F:  BSF    03.5
0E60:  BCF    03.6
0E61:  MOVF   3F,W
0E62:  BCF    03.5
0E63:  BSF    03.6
0E64:  ADDWF  0D,F
0E65:  BTFSC  03.0
0E66:  INCF   0F,F
0E67:  BCF    0A.3
0E68:  BCF    03.6
0E69:  CALL   675
0E6A:  BSF    0A.3
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
0E8D:  BSF    03.5
0E8E:  MOVF   3E,F
0E8F:  BTFSS  03.2
0E90:  GOTO   732
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0E91:  BSF    06.4
0E92:  BCF    03.5
0E93:  BTFSC  06.4
0E94:  GOTO   6F4
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0E95:  MOVLW  02
0E96:  BSF    03.5
0E97:  MOVWF  3F
0E98:  MOVLW  FA
0E99:  MOVWF  46
0E9A:  BCF    0A.3
0E9B:  BCF    03.5
0E9C:  CALL   3F0
0E9D:  BSF    0A.3
0E9E:  BSF    03.5
0E9F:  DECFSZ 3F,F
0EA0:  GOTO   698
....................          BEEP; 
0EA1:  MOVLW  04
0EA2:  MOVWF  43
0EA3:  MOVLW  B9
0EA4:  MOVWF  42
0EA5:  CLRF   45
0EA6:  MOVLW  14
0EA7:  MOVWF  44
0EA8:  BCF    03.5
0EA9:  CALL   3BF
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0EAA:  BSF    03.5
0EAB:  INCF   3D,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
0EAC:  MOVF   3D,W
0EAD:  BCF    03.5
0EAE:  SUBWF  5D,W
0EAF:  BTFSC  03.0
0EB0:  GOTO   6B4
....................             optSelected = 0; 
0EB1:  BSF    03.5
0EB2:  CLRF   3D
0EB3:  BCF    03.5
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0EB4:  BSF    03.5
0EB5:  SWAPF  3D,W
0EB6:  MOVWF  77
0EB7:  MOVLW  F0
0EB8:  ANDWF  77,F
0EB9:  MOVF   77,W
0EBA:  MOVWF  3F
0EBB:  MOVLW  0C
0EBC:  MOVWF  45
0EBD:  BCF    0A.3
0EBE:  BCF    03.5
0EBF:  CALL   61B
0EC0:  BSF    0A.3
0EC1:  MOVLW  DC
0EC2:  BSF    03.6
0EC3:  MOVWF  0D
0EC4:  MOVLW  01
0EC5:  MOVWF  0F
0EC6:  BSF    03.5
0EC7:  BCF    03.6
0EC8:  MOVF   3F,W
0EC9:  BCF    03.5
0ECA:  BSF    03.6
0ECB:  ADDWF  0D,F
0ECC:  BTFSC  03.0
0ECD:  INCF   0F,F
0ECE:  BCF    0A.3
0ECF:  BCF    03.6
0ED0:  CALL   675
0ED1:  BSF    0A.3
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
0EF4:  BSF    03.5
0EF5:  BSF    06.5
0EF6:  BCF    03.5
0EF7:  BTFSC  06.5
0EF8:  GOTO   730
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0EF9:  MOVLW  02
0EFA:  BSF    03.5
0EFB:  MOVWF  3F
0EFC:  MOVLW  FA
0EFD:  MOVWF  46
0EFE:  BCF    0A.3
0EFF:  BCF    03.5
0F00:  CALL   3F0
0F01:  BSF    0A.3
0F02:  BSF    03.5
0F03:  DECFSZ 3F,F
0F04:  GOTO   6FC
....................          BEEP; 
0F05:  MOVLW  04
0F06:  MOVWF  43
0F07:  MOVLW  B9
0F08:  MOVWF  42
0F09:  CLRF   45
0F0A:  MOVLW  14
0F0B:  MOVWF  44
0F0C:  BCF    03.5
0F0D:  CALL   3BF
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
0F0E:  MOVF   5D,W
0F0F:  BSF    03.5
0F10:  SUBWF  3D,W
0F11:  BTFSS  03.2
0F12:  GOTO   716
....................             exit = 1; 
0F13:  MOVLW  01
0F14:  MOVWF  3E
....................          }else{ 
0F15:  GOTO   731
....................             output_low(PIN_OUT[optSelected]); 
0F16:  BCF    03.0
0F17:  RLF    3D,W
0F18:  ADDLW  2B
0F19:  MOVWF  04
0F1A:  BCF    03.7
0F1B:  INCF   04,F
0F1C:  MOVF   00,W
0F1D:  MOVWF  40
0F1E:  DECF   04,F
0F1F:  MOVF   00,W
0F20:  MOVWF  3F
0F21:  MOVWF  41
0F22:  CLRF   42
0F23:  CLRF   44
0F24:  CLRF   43
0F25:  BCF    03.5
0F26:  CALL   535
0F27:  BSF    03.5
0F28:  MOVF   3F,W
0F29:  MOVWF  41
0F2A:  CLRF   42
0F2B:  CLRF   44
0F2C:  MOVLW  80
0F2D:  MOVWF  43
0F2E:  BCF    03.5
0F2F:  CALL   535
0F30:  BSF    03.5
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0F31:  GOTO   68E
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0F32:  MOVLW  00
0F33:  MOVWF  78
0F34:  BCF    03.5
0F35:  BCF    0A.3
0F36:  BSF    0A.4
0F37:  GOTO   4E1 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
.................... int getMenuSetup(void){ 
*
12B8:  BSF    03.5
12B9:  CLRF   3D
12BA:  CLRF   3E
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
12BB:  MOVF   3D,W
12BC:  MOVWF  42
12BD:  MOVLW  11
12BE:  MOVWF  43
12BF:  BCF    0A.4
12C0:  BSF    0A.3
12C1:  BCF    03.5
12C2:  CALL   50E
12C3:  BSF    0A.4
12C4:  BCF    0A.3
12C5:  MOVF   78,W
12C6:  BSF    03.5
12C7:  MOVWF  3F
12C8:  MOVLW  0C
12C9:  MOVWF  45
12CA:  BCF    0A.4
12CB:  BCF    03.5
12CC:  CALL   61B
12CD:  BSF    0A.4
12CE:  MOVLW  7C
12CF:  BSF    03.6
12D0:  MOVWF  0D
12D1:  MOVLW  02
12D2:  MOVWF  0F
12D3:  BSF    03.5
12D4:  BCF    03.6
12D5:  MOVF   3F,W
12D6:  BCF    03.5
12D7:  BSF    03.6
12D8:  ADDWF  0D,F
12D9:  BTFSC  03.0
12DA:  INCF   0F,F
12DB:  BCF    0A.4
12DC:  BCF    03.6
12DD:  CALL   675
12DE:  BSF    0A.4
....................    showBottonMenu(); 
....................     
....................    while(!exit){ 
*
1301:  BSF    03.5
1302:  MOVF   3E,F
1303:  BTFSS  03.2
1304:  GOTO   3E6
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
1305:  BSF    06.4
1306:  BCF    03.5
1307:  BTFSC  06.4
1308:  GOTO   373
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1309:  MOVLW  02
130A:  BSF    03.5
130B:  MOVWF  3F
130C:  MOVLW  FA
130D:  MOVWF  46
130E:  BCF    0A.4
130F:  BCF    03.5
1310:  CALL   3F0
1311:  BSF    0A.4
1312:  BSF    03.5
1313:  DECFSZ 3F,F
1314:  GOTO   30C
....................          BEEP; 
1315:  MOVLW  04
1316:  MOVWF  43
1317:  MOVLW  B9
1318:  MOVWF  42
1319:  CLRF   45
131A:  MOVLW  14
131B:  MOVWF  44
131C:  BCF    0A.4
131D:  BSF    0A.3
131E:  BCF    03.5
131F:  CALL   3BF
1320:  BSF    0A.4
1321:  BCF    0A.3
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
1322:  BSF    03.5
1323:  INCF   3D,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
1324:  MOVF   3D,W
1325:  BCF    03.5
1326:  SUBWF  5B,W
1327:  BTFSC  03.0
1328:  GOTO   32C
....................             optSelected = 0; 
1329:  BSF    03.5
132A:  CLRF   3D
132B:  BCF    03.5
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
132C:  BSF    03.5
132D:  MOVF   3D,W
132E:  MOVWF  42
132F:  MOVLW  11
1330:  MOVWF  43
1331:  BCF    0A.4
1332:  BSF    0A.3
1333:  BCF    03.5
1334:  CALL   50E
1335:  BSF    0A.4
1336:  BCF    0A.3
1337:  MOVF   78,W
1338:  BSF    03.5
1339:  MOVWF  3F
133A:  MOVLW  0C
133B:  MOVWF  45
133C:  BCF    0A.4
133D:  BCF    03.5
133E:  CALL   61B
133F:  BSF    0A.4
1340:  MOVLW  7C
1341:  BSF    03.6
1342:  MOVWF  0D
1343:  MOVLW  02
1344:  MOVWF  0F
1345:  BSF    03.5
1346:  BCF    03.6
1347:  MOVF   3F,W
1348:  BCF    03.5
1349:  BSF    03.6
134A:  ADDWF  0D,F
134B:  BTFSC  03.0
134C:  INCF   0F,F
134D:  BCF    0A.4
134E:  BCF    03.6
134F:  CALL   675
1350:  BSF    0A.4
....................          showBottonMenu(); 
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
*
1373:  BSF    03.5
1374:  BSF    06.5
1375:  BCF    03.5
1376:  BTFSC  06.5
1377:  GOTO   3E4
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
1378:  MOVLW  02
1379:  BSF    03.5
137A:  MOVWF  3F
137B:  MOVLW  FA
137C:  MOVWF  46
137D:  BCF    0A.4
137E:  BCF    03.5
137F:  CALL   3F0
1380:  BSF    0A.4
1381:  BSF    03.5
1382:  DECFSZ 3F,F
1383:  GOTO   37B
....................          BEEP; 
1384:  MOVLW  04
1385:  MOVWF  43
1386:  MOVLW  B9
1387:  MOVWF  42
1388:  CLRF   45
1389:  MOVLW  14
138A:  MOVWF  44
138B:  BCF    0A.4
138C:  BSF    0A.3
138D:  BCF    03.5
138E:  CALL   3BF
138F:  BSF    0A.4
1390:  BCF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
1391:  MOVF   5B,W
1392:  BSF    03.5
1393:  SUBWF  3D,W
1394:  BTFSS  03.2
1395:  GOTO   399
....................             exit = 1; 
1396:  MOVLW  01
1397:  MOVWF  3E
....................          }else{ 
1398:  GOTO   3E5
....................             executeSetup(optSelected); 
1399:  MOVF   3D,W
139A:  MOVWF  3F
139B:  BCF    03.5
139C:  GOTO   000
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
139D:  BSF    03.5
139E:  MOVF   3D,W
139F:  MOVWF  42
13A0:  MOVLW  11
13A1:  MOVWF  43
13A2:  BCF    0A.4
13A3:  BSF    0A.3
13A4:  BCF    03.5
13A5:  CALL   50E
13A6:  BSF    0A.4
13A7:  BCF    0A.3
13A8:  MOVF   78,W
13A9:  BSF    03.5
13AA:  MOVWF  3F
13AB:  MOVLW  0C
13AC:  MOVWF  45
13AD:  BCF    0A.4
13AE:  BCF    03.5
13AF:  CALL   61B
13B0:  BSF    0A.4
13B1:  MOVLW  7C
13B2:  BSF    03.6
13B3:  MOVWF  0D
13B4:  MOVLW  02
13B5:  MOVWF  0F
13B6:  BSF    03.5
13B7:  BCF    03.6
13B8:  MOVF   3F,W
13B9:  BCF    03.5
13BA:  BSF    03.6
13BB:  ADDWF  0D,F
13BC:  BTFSC  03.0
13BD:  INCF   0F,F
13BE:  BCF    0A.4
13BF:  BCF    03.6
13C0:  CALL   675
13C1:  BSF    0A.4
....................             showBottonMenu(); 
....................          } 
....................       } // Fin KEY_OK 
*
13E5:  GOTO   302
....................    } // FIN While Infinito 
....................  
....................    return 0; 
13E6:  MOVLW  00
13E7:  MOVWF  78
13E8:  BCF    03.5
13E9:  BCF    0A.3
13EA:  BSF    0A.4
13EB:  GOTO   4E7 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... #include "header/esp8266.h" 
.................... #define  CMD_MODE    1 
.................... #define  CMD_DO_CONN 2 
.................... #define  CMD_CONN    3 
....................  
.................... // Esta bandera indica que comando fue lanzado 
.................... int   CMD_RUN = 0x00; 
....................  
.................... /* Constantes de respuestas */ 
.................... const char ESP8266_RESP_OK[4]             ={'O','K',0x0D,0x0A}; 
.................... const char ESP8266_RESP_NoAP[5]           ={'N', 'o', ' ', 'A', 'P'}; 
.................... const char ESP8266_RESP_CWJAP[7]          ={'+', 'C', 'W', 'J', 'A', 'P', ':'}; 
.................... const char ESP8266_RESP_Connected[9]      ={'C','O','N','N','E','C','T','E','D'}; 
.................... const char ESP8266_RESP_FAIL[4]           ={'F', 'A', 'I', 'L'}; 
....................  
.................... /* Buffer de response ESP8266 */ 
.................... char bufferRespOK[4]; 
.................... /*char bufferRespNoAp[5]; 
.................... char bufferRespCWJAP[7]; 
.................... char bufferRespConneted[9]; 
.................... char bufferRespFail[4];*/ 
....................  
.................... /* Declaracion de Funciones de comandos */ 
.................... void  reset(void); 
.................... int   setupMode(char modeVal[]); 
.................... int   doConnected(); 
.................... int   setupConn(char SSIDAndKey[]); 
.................... int   setupServer(void); 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void  waitRespOK(int buffer); 
.................... void  waitRespNoAp(int buffer); 
.................... void  waitRespCWJAP(int buffer); 
.................... void  waitRespConnected(int buffer); 
.................... void  waitRespFail(int buffer); 
.................... int   waitResp(void); 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_Valid         = 0; 
.................... int flag_Resp_NoAp          = 0; 
.................... int flag_Resp_CWJAP         = 0; 
.................... int flag_Resp_Connected     = 0; 
.................... int flag_Resp_Fail          = 0; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp           = 0; 
.................... int flag_Pos_Resp_NoAp      = 0; 
.................... int flag_Pos_Resp_CWJAP     = 0; 
.................... int flag_Pos_Resp_Connected = 0; 
.................... int flag_Pos_Resp_Fail      = 0; 
....................  
.................... /*@TODO: Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar[]  = "1"; 
*
1470:  MOVLW  31
1471:  MOVWF  6D
1472:  CLRF   6E
.................... char  SSIDAndKey[]= {'"','U','N','E','_','C','0','6','E','"', 
....................                      ',', 
....................                      '"','0','0','9','8','6','3','4','4','2','0','0','7','7','1','"', 
....................                      0x0D,0x0A 
....................                     }; 
1473:  MOVLW  22
1474:  BSF    03.5
1475:  MOVWF  20
1476:  MOVLW  55
1477:  MOVWF  21
1478:  MOVLW  4E
1479:  MOVWF  22
147A:  MOVLW  45
147B:  MOVWF  23
147C:  MOVLW  5F
147D:  MOVWF  24
147E:  MOVLW  43
147F:  MOVWF  25
1480:  MOVLW  30
1481:  MOVWF  26
1482:  MOVLW  36
1483:  MOVWF  27
1484:  MOVLW  45
1485:  MOVWF  28
1486:  MOVLW  22
1487:  MOVWF  29
1488:  MOVLW  2C
1489:  MOVWF  2A
148A:  MOVLW  22
148B:  MOVWF  2B
148C:  MOVLW  30
148D:  MOVWF  2C
148E:  MOVWF  2D
148F:  MOVLW  39
1490:  MOVWF  2E
1491:  MOVLW  38
1492:  MOVWF  2F
1493:  MOVLW  36
1494:  MOVWF  30
1495:  MOVLW  33
1496:  MOVWF  31
1497:  MOVLW  34
1498:  MOVWF  32
1499:  MOVWF  33
149A:  MOVLW  32
149B:  MOVWF  34
149C:  MOVLW  30
149D:  MOVWF  35
149E:  MOVWF  36
149F:  MOVLW  37
14A0:  MOVWF  37
14A1:  MOVWF  38
14A2:  MOVLW  31
14A3:  MOVWF  39
14A4:  MOVLW  22
14A5:  MOVWF  3A
14A6:  MOVLW  0D
14A7:  MOVWF  3B
14A8:  MOVLW  0A
14A9:  MOVWF  3C
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    char  modeWithoutConnect[] = "3"; 
*
0800:  MOVLW  33
0801:  BSF    03.5
0802:  MOVWF  3D
0803:  CLRF   3E
....................    int   resp; 
....................     
....................    /*fprintf(console, "Inicializando ESP8266"); 
....................    fputc(0x0D,console);*/ 
....................  
....................    // @TODO: Usar este comando solo en produccion 
....................    /**reset(); 
....................    delay_ms(2000);**/ 
....................  
....................    CMD_RUN =  setupMode(modeStar); 
0804:  CLRF   41
0805:  MOVLW  6D
0806:  MOVWF  40
*
08B5:  MOVF   78,W
08B6:  MOVWF  5E
....................    waitResp(); 
08B7:  BCF    0A.3
08B8:  CALL   5E9
08B9:  BSF    0A.3
....................  
....................    CMD_RUN =  doConnected(); 
*
0934:  MOVF   78,W
0935:  BCF    03.6
0936:  MOVWF  5E
....................     
....................    resp = waitResp(); 
0937:  BCF    0A.3
0938:  CALL   5E9
0939:  BSF    0A.3
093A:  MOVF   78,W
093B:  BSF    03.5
093C:  MOVWF  3F
....................    /*fprintf(console, "Respuesta: %u",resp); 
....................    fputc(0x0D,console);*/ 
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
093D:  MOVF   3F,W
093E:  SUBLW  02
093F:  BTFSS  03.2
0940:  GOTO   2AD
....................     
....................       /*fprintf(console, "Iniciando Conexion"); 
....................       fputc(0x0D,console);*/ 
....................        
....................       // Lanza el comando para conectarce a la red 
....................       CMD_RUN = setupConn(SSIDAndKey); 
0941:  CLRF   41
0942:  MOVLW  A0
0943:  MOVWF  40
*
09E9:  MOVF   78,W
09EA:  BCF    03.5
09EB:  MOVWF  5E
....................       resp    = waitResp(); 
09EC:  BCF    0A.3
09ED:  CALL   5E9
09EE:  BSF    0A.3
09EF:  MOVF   78,W
09F0:  BSF    03.5
09F1:  MOVWF  3F
....................        
....................       /*fprintf(console, "Segunda Respuesta: %u",resp); 
....................       fputc(0x0D,console);*/ 
....................        
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4){ 
09F2:  MOVF   3F,W
09F3:  SUBLW  04
09F4:  BTFSS  03.2
09F5:  GOTO   2AD
....................        
....................          /*fprintf(console, "Configurando Modo AP"); 
....................          fputc(0x0D,console);*/ 
....................           
....................          CMD_RUN =  setupMode(modeWithoutConnect); 
09F6:  CLRF   41
09F7:  MOVLW  BD
09F8:  MOVWF  40
*
0AA7:  MOVF   78,W
0AA8:  MOVWF  5E
....................          waitResp(); 
0AA9:  BCF    0A.3
0AAA:  CALL   5E9
0AAB:  BSF    0A.3
0AAC:  BSF    03.5
....................           
....................          /*fprintf(console, "Modo AP Activado");  
....................          fputc(0x0D,console);*/ 
....................           
....................       } 
....................    } // Fin del if(doConnect) 
....................    
....................    /** @TODO: Rutina que se encarga de recibir datos desde ESP8266 **/ 
....................    setupServer(); 
*
0BBB:  BCF    03.5
0BBC:  BCF    0A.3
0BBD:  BSF    0A.4
0BBE:  GOTO   4C8 (RETURN)
.................... } 
....................  
....................  
.................... /** 
....................  *  
....................  * Funcion encangada de procesar las respuestas del modulo, debe ser llamada 
....................  * durante la interrupcion del USART 
....................  *  
....................  **/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
034D:  BCF    03.5
034E:  MOVF   5E,W
034F:  XORLW  01
0350:  BTFSC  03.2
0351:  GOTO   359
0352:  XORLW  03
0353:  BTFSC  03.2
0354:  GOTO   35F
0355:  XORLW  01
0356:  BTFSC  03.2
0357:  GOTO   3A5
0358:  GOTO   3EB
....................             case CMD_MODE: 
....................                   waitRespOK(buffer); 
0359:  BSF    03.5
035A:  MOVF   5E,W
035B:  MOVWF  5F
035C:  BCF    03.5
035D:  CALL   31D
....................                   break; 
035E:  GOTO   3EC
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespNoAp(buffer); 
035F:  BSF    03.5
0360:  MOVF   5E,W
0361:  MOVWF  5F
....................                   waitRespCWJAP(buffer); 
*
037F:  BSF    03.5
0380:  MOVF   5E,W
0381:  MOVWF  5F
....................                   waitRespOK(buffer); 
*
039F:  BSF    03.5
03A0:  MOVF   5E,W
03A1:  MOVWF  5F
03A2:  BCF    03.5
03A3:  CALL   31D
....................                   break; 
03A4:  GOTO   3EC
....................  
....................             case CMD_CONN: 
....................                   waitRespConnected(buffer); 
03A5:  BSF    03.5
03A6:  MOVF   5E,W
03A7:  MOVWF  5F
....................                   waitRespFail(buffer); 
*
03C5:  BSF    03.5
03C6:  MOVF   5E,W
03C7:  MOVWF  5F
....................                   waitRespOK(buffer); 
*
03E5:  BSF    03.5
03E6:  MOVF   5E,W
03E7:  MOVWF  5F
03E8:  BCF    03.5
03E9:  CALL   31D
....................                   break; 
03EA:  GOTO   3EC
....................              
....................             default: 
....................                   CMD_RUN = 0x00; 
03EB:  CLRF   5E
....................                   break; 
....................       } 
.................... } 
....................  
.................... /* reinicia el modulo para tener sincronia */ 
.................... void reset(void) 
.................... { 
....................    fprintf(ESP8266, "AT+RST\r\n"); 
.................... } // fin de la funcion reset() 
....................  
.................... /** 
....................  *  
....................  *  Configura el modo de funcionamiento 
....................  *  1-Cliente, 2-AccessPoint, 3-AP+STA  
....................  *  
....................  **/ 
....................  
.................... int setupMode(char modeVal[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWMODE=%s\r\n",modeVal ); 
*
0807:  MOVLW  F8
0808:  BCF    03.5
0809:  BSF    03.6
080A:  MOVWF  0D
080B:  MOVLW  02
080C:  MOVWF  0F
080D:  BCF    03.0
080E:  MOVLW  0A
080F:  BSF    03.5
0810:  BCF    03.6
0811:  MOVWF  42
*
088A:  MOVF   40,W
088B:  MOVWF  04
088C:  BCF    03.7
088D:  BTFSC  41.0
088E:  BSF    03.7
*
08AA:  MOVLW  0D
08AB:  BCF    03.5
08AC:  BTFSS  0C.4
08AD:  GOTO   0AC
08AE:  MOVWF  19
08AF:  MOVLW  0A
08B0:  BTFSS  0C.4
08B1:  GOTO   0B0
08B2:  MOVWF  19
*
09F9:  MOVLW  F8
09FA:  BCF    03.5
09FB:  BSF    03.6
09FC:  MOVWF  0D
09FD:  MOVLW  02
09FE:  MOVWF  0F
09FF:  BCF    03.0
0A00:  MOVLW  0A
0A01:  BSF    03.5
0A02:  BCF    03.6
0A03:  MOVWF  42
*
0A7C:  MOVF   40,W
0A7D:  MOVWF  04
0A7E:  BCF    03.7
0A7F:  BTFSC  41.0
0A80:  BSF    03.7
*
0A9C:  MOVLW  0D
0A9D:  BCF    03.5
0A9E:  BTFSS  0C.4
0A9F:  GOTO   29E
0AA0:  MOVWF  19
0AA1:  MOVLW  0A
0AA2:  BTFSS  0C.4
0AA3:  GOTO   2A2
0AA4:  MOVWF  19
....................    return CMD_MODE; 
*
08B3:  MOVLW  01
08B4:  MOVWF  78
*
0AA5:  MOVLW  01
0AA6:  MOVWF  78
.................... } // fin de la funcion setupMode() 
....................  
.................... /** 
....................  *  
....................  *  lanza el comando para verificar si el modulo 
....................  *  se encuentra conectado a la red wifi  
....................  *  
....................  **/ 
....................  
.................... int doConnected() 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
*
08BA:  MOVLW  00
08BB:  BSF    03.6
08BC:  MOVWF  0D
08BD:  MOVLW  03
08BE:  MOVWF  0F
....................    return CMD_DO_CONN; 
*
0932:  MOVLW  02
0933:  MOVWF  78
.................... } 
....................  
.................... /** 
....................  *  
....................  *  @TODO: Conecta a la red wifi 
....................  *         AT+CWJAP="UNE_C06E","00986344200771" 
....................  *  
....................  **/ 
....................  
.................... int setupConn(char SSID_And_Key[]) 
.................... { 
....................    fprintf(ESP8266, "AT+CWJAP=%s",SSID_And_Key ); 
*
0944:  MOVLW  06
0945:  BCF    03.5
0946:  BSF    03.6
0947:  MOVWF  0D
0948:  MOVLW  03
0949:  MOVWF  0F
094A:  BCF    03.0
094B:  MOVLW  09
094C:  BSF    03.5
094D:  BCF    03.6
094E:  MOVWF  42
*
09C7:  MOVF   40,W
09C8:  MOVWF  04
09C9:  BCF    03.7
09CA:  BTFSC  41.0
09CB:  BSF    03.7
....................    return CMD_CONN; 
*
09E7:  MOVLW  03
09E8:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
.................... /** 
....................  *  
....................  *  Activa el modo multiconexin 
....................  *        
....................  *  
....................  **/ 
....................  
.................... int setupServer(void) 
.................... { 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
*
0AAD:  MOVLW  0C
0AAE:  BCF    03.5
0AAF:  BSF    03.6
0AB0:  MOVWF  0D
0AB1:  MOVLW  03
0AB2:  MOVWF  0F
....................    delay_ms(1000); 
*
0B26:  MOVLW  04
0B27:  BSF    03.5
0B28:  BCF    03.6
0B29:  MOVWF  40
0B2A:  MOVLW  FA
0B2B:  MOVWF  46
0B2C:  BCF    0A.3
0B2D:  BCF    03.5
0B2E:  CALL   3F0
0B2F:  BSF    0A.3
0B30:  BSF    03.5
0B31:  DECFSZ 40,F
0B32:  GOTO   32A
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
0B33:  MOVLW  13
0B34:  BCF    03.5
0B35:  BSF    03.6
0B36:  MOVWF  0D
0B37:  MOVLW  03
0B38:  MOVWF  0F
....................    delay_ms(1000); 
*
0BAC:  MOVLW  04
0BAD:  BSF    03.5
0BAE:  BCF    03.6
0BAF:  MOVWF  40
0BB0:  MOVLW  FA
0BB1:  MOVWF  46
0BB2:  BCF    0A.3
0BB3:  BCF    03.5
0BB4:  CALL   3F0
0BB5:  BSF    0A.3
0BB6:  BSF    03.5
0BB7:  DECFSZ 40,F
0BB8:  GOTO   3B0
....................    return CMD_CONN; 
0BB9:  MOVLW  03
0BBA:  MOVWF  78
.................... } // fin de la funcion setupConn() 
....................  
....................  
.................... /** 
....................    Espera hasta que la respuesta sea completada, si la respuesta es completada 
....................    retorna 1 de lo contrario siempre retornara 0, es llamada en cada interrupcion  
....................    del USART 
.................... **/ 
....................  
.................... void waitRespOK(int buffer) 
*
031D:  MOVLW  04
031E:  BSF    03.5
031F:  MOVWF  60
.................... { 
....................    int lenResp = 4;  // Tamao del buffer de respuesta esperado 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_OK[flag_Pos_Resp] ) 
0320:  BCF    03.5
0321:  MOVF   68,W
0322:  CALL   051
0323:  MOVWF  78
0324:  BSF    03.5
0325:  SUBWF  5F,W
0326:  BTFSS  03.2
0327:  GOTO   33E
....................    { 
....................       // Almacena el caracter en el buffer de respuesta 
....................       bufferRespOK[flag_Pos_Resp] = buffer; 
0328:  MOVLW  5F
0329:  BCF    03.5
032A:  ADDWF  68,W
032B:  MOVWF  04
032C:  BCF    03.7
032D:  BSF    03.5
032E:  MOVF   5F,W
032F:  MOVWF  00
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp++; 
0330:  BCF    03.5
0331:  INCF   68,F
....................        
....................       if(flag_Pos_Resp==lenResp){ 
0332:  BSF    03.5
0333:  MOVF   60,W
0334:  BCF    03.5
0335:  SUBWF  68,W
0336:  BTFSS  03.2
0337:  GOTO   33B
....................          // Respuesta es valida 
....................          flag_Resp_Valid   = 1; 
0338:  MOVLW  01
0339:  MOVWF  63
....................       }else{ 
033A:  GOTO   33C
....................          // Reinicia la bandera para asegurar la integridad de la respesta 
....................          flag_Resp_Valid   = 0; 
033B:  CLRF   63
....................       } 
....................  
....................    }else{ 
033C:  GOTO   345
033D:  BSF    03.5
....................       // Reinicia la bandera para asegurar la integridad de la respesta y 
....................       // asegura que la respuesta optenida no es valida, limpia el buffer de 
....................       // respuesta 
....................       flag_Pos_Resp     = 0; 
033E:  BCF    03.5
033F:  CLRF   68
....................       flag_Resp_Valid   = 0; 
0340:  CLRF   63
....................       bufferRespOK[0]   = 0x00; 
0341:  CLRF   5F
....................       bufferRespOK[1]   = 0x00; 
0342:  CLRF   60
....................       bufferRespOK[2]   = 0x00; 
0343:  CLRF   61
....................       bufferRespOK[3]   = 0x00; 
0344:  CLRF   62
....................    } 
0345:  RETURN
.................... } // Fin de la funcion waitRespOK() 
....................  
.................... /** 
....................    Espera hasta que la respuesta sea completada, si la respuesta es completada 
....................    retorna 1 de lo contrario siempre retornara 0, debe ser llamada en cada interrupcion  
....................    del USART cuando se lanza el comando "doConnected" 
.................... **/ 
.................... void waitRespNoAp(int buffer) 
*
0362:  MOVLW  05
0363:  MOVWF  60
.................... { 
....................    int lenResp = 5;  // Tamao del buffer de respuesta esperado 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_NoAp[flag_Pos_Resp_NoAp] ) 
0364:  BCF    03.5
0365:  MOVF   69,W
0366:  CALL   059
0367:  MOVWF  78
0368:  BSF    03.5
0369:  SUBWF  5F,W
036A:  BTFSS  03.2
036B:  GOTO   37D
....................    { 
....................       // Almacena el caracter en el buffer de respuesta 
....................       ESP8266_RESP_NoAp[flag_Pos_Resp_NoAp] = buffer; 
036C:  BCF    03.5
036D:  MOVF   69,W
036E:  CALL   059
036F:  MOVWF  78
0370:  BSF    03.5
....................        
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer 
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp_NoAp++; 
0371:  BCF    03.5
0372:  INCF   69,F
....................        
....................       if(flag_Pos_Resp_NoAp==lenResp){ 
0373:  BSF    03.5
0374:  MOVF   60,W
0375:  BCF    03.5
0376:  SUBWF  69,W
0377:  BTFSS  03.2
0378:  GOTO   37B
....................          // Respuesta es valida 
....................          flag_Resp_NoAp   = 1; 
0379:  MOVLW  01
037A:  MOVWF  64
....................       } 
....................    }else{ 
037B:  GOTO   37F
037C:  BSF    03.5
....................       // Reinicia la bandera para asegurar la integridad de la respesta y 
....................       // asegura que la respuesta optenida no es valida, basea el buffer de 
....................       // respuesta 
....................       flag_Pos_Resp_NoAp  = 0; 
037D:  BCF    03.5
037E:  CLRF   69
....................    } 
.................... } // Fin de la funcion waitRespNoAp() 
....................  
.................... /** 
....................    Espera hasta que la respuesta sea completada, si la respuesta es completada 
....................    retorna 1 de lo contrario siempre retornara 0, debe ser llamada en cada interrupcion  
....................    del USART cuando se lanza el comando "doConnected" 
.................... **/ 
.................... void waitRespCWJAP(int buffer) 
*
0382:  MOVLW  07
0383:  MOVWF  60
.................... { 
....................    int lenResp = 7;  // Tamao del buffer de respuesta esperado 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera 
....................    if(buffer == ESP8266_RESP_CWJAP[flag_Pos_Resp_CWJAP] ) 
0384:  BCF    03.5
0385:  MOVF   6A,W
0386:  CALL   062
0387:  MOVWF  78
0388:  BSF    03.5
0389:  SUBWF  5F,W
038A:  BTFSS  03.2
038B:  GOTO   39D
....................    { 
....................       // Almacena el caracter en el buffer de respuesta 
....................       ESP8266_RESP_CWJAP[flag_Pos_Resp_CWJAP] = buffer; 
038C:  BCF    03.5
038D:  MOVF   6A,W
038E:  CALL   062
038F:  MOVWF  78
0390:  BSF    03.5
....................       
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer 
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp_CWJAP++; 
0391:  BCF    03.5
0392:  INCF   6A,F
....................        
....................       if(flag_Pos_Resp_CWJAP==lenResp){ 
0393:  BSF    03.5
0394:  MOVF   60,W
0395:  BCF    03.5
0396:  SUBWF  6A,W
0397:  BTFSS  03.2
0398:  GOTO   39B
....................          // Respuesta es valida 
....................          flag_Resp_CWJAP   = 1; 
0399:  MOVLW  01
039A:  MOVWF  65
....................       } 
....................    }else { 
039B:  GOTO   39F
039C:  BSF    03.5
....................       flag_Pos_Resp_CWJAP = 0; 
039D:  BCF    03.5
039E:  CLRF   6A
....................    } 
....................     
.................... } // Fin de la funcion waitRespCWJAP() 
....................  
.................... /** 
....................    Espera hasta que la respuesta sea completada, si la respuesta es completada 
....................    retorna 1 de lo contrario siempre retornara 0, debe ser llamada en cada interrupcion  
....................    del USART cuando se lanza el comando "doConnected" 
.................... **/ 
....................  
.................... void waitRespConnected(int buffer) 
*
03A8:  MOVLW  09
03A9:  MOVWF  60
.................... { 
....................    int lenResp = 9;  // Tamao del buffer de respuesta esperado 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_Connected[flag_Pos_Resp_Connected] ) 
03AA:  BCF    03.5
03AB:  MOVF   6B,W
03AC:  CALL   06D
03AD:  MOVWF  78
03AE:  BSF    03.5
03AF:  SUBWF  5F,W
03B0:  BTFSS  03.2
03B1:  GOTO   3C3
....................    { 
....................       // Almacena el caracter en el buffer de respuesta 
....................       ESP8266_RESP_Connected[flag_Pos_Resp_Connected] = buffer; 
03B2:  BCF    03.5
03B3:  MOVF   6B,W
03B4:  CALL   06D
03B5:  MOVWF  78
03B6:  BSF    03.5
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp_Connected++; 
03B7:  BCF    03.5
03B8:  INCF   6B,F
....................        
....................       if(flag_Pos_Resp_Connected==lenResp){ 
03B9:  BSF    03.5
03BA:  MOVF   60,W
03BB:  BCF    03.5
03BC:  SUBWF  6B,W
03BD:  BTFSS  03.2
03BE:  GOTO   3C1
....................          // Respuesta es valida 
....................          flag_Resp_Connected   = 1; 
03BF:  MOVLW  01
03C0:  MOVWF  66
....................       } 
....................  
....................    }else{ 
03C1:  GOTO   3C5
03C2:  BSF    03.5
....................       // Reinicia la bandera para asegurar la integridad de la respesta y 
....................       // asegura que la respuesta optenida no es valida, limpia el buffer de 
....................       // respuesta 
....................       flag_Pos_Resp_Connected = 0; 
03C3:  BCF    03.5
03C4:  CLRF   6B
....................    } 
.................... } // Fin de la funcion waitRespConnected() 
....................  
.................... /** 
....................    Espera hasta que la respuesta sea completada, si la respuesta es completada 
....................    retorna 1 de lo contrario siempre retornara 0, debe ser llamada en cada interrupcion  
....................    del USART cuando se lanza el comando "setupConn" 
.................... **/ 
....................  
.................... void waitRespFail(int buffer) 
*
03C8:  MOVLW  04
03C9:  MOVWF  60
.................... { 
....................    int lenResp = 4;  // Tamao del buffer de respuesta esperado 
....................     
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................    if(buffer == ESP8266_RESP_Fail[flag_Pos_Resp_Fail] ) 
03CA:  BCF    03.5
03CB:  MOVF   6C,W
03CC:  CALL   07A
03CD:  MOVWF  78
03CE:  BSF    03.5
03CF:  SUBWF  5F,W
03D0:  BTFSS  03.2
03D1:  GOTO   3E3
....................    { 
....................       // Almacena el caracter en el buffer de respuesta 
....................       ESP8266_RESP_Fail[flag_Pos_Resp_Fail] = buffer; 
03D2:  BCF    03.5
03D3:  MOVF   6C,W
03D4:  CALL   07A
03D5:  MOVWF  78
03D6:  BSF    03.5
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       flag_Pos_Resp_Fail++; 
03D7:  BCF    03.5
03D8:  INCF   6C,F
....................        
....................       if(flag_Pos_Resp_Fail==lenResp){ 
03D9:  BSF    03.5
03DA:  MOVF   60,W
03DB:  BCF    03.5
03DC:  SUBWF  6C,W
03DD:  BTFSS  03.2
03DE:  GOTO   3E1
....................          // Respuesta es valida 
....................          flag_Resp_Fail   = 1; 
03DF:  MOVLW  01
03E0:  MOVWF  67
....................       } 
....................    }else{ 
03E1:  GOTO   3E5
03E2:  BSF    03.5
....................       // Reinicia la bandera para asegurar la integridad de la respesta y 
....................       // asegura que la respuesta optenida no es valida, limpia el buffer de 
....................       // respuesta 
....................       flag_Pos_Resp_Fail  = 0; 
03E3:  BCF    03.5
03E4:  CLRF   6C
....................    } 
.................... } // Fin de la funcion waitRespFail() 
....................  
.................... /* Bloquea el programa hasta que la bandera flag_Resp_Valid=1 utilizada para 
....................    esperar por una respuesta valida */ 
.................... int waitResp(void) 
*
05E9:  BSF    03.5
05EA:  CLRF   40
.................... { 
....................    int ret=0; 
....................    while(flag_Resp_Valid==0){ 
05EB:  BCF    03.5
05EC:  MOVF   63,F
05ED:  BTFSS  03.2
05EE:  GOTO   615
....................     
....................       if(flag_Resp_CWJAP==1){ 
05EF:  DECFSZ 65,W
05F0:  GOTO   5F8
....................        
....................          /*fprintf(console, "Inicio Conectado en la red\n"); 
....................          fputc(0x0D,console);*/ 
....................           
....................          // Reinicia la bandera para asegurar la integridad de la respesta y 
....................          // asegura que la respuesta optenida no es valida, limpia el buffer de 
....................          // respuesta 
....................          flag_Pos_Resp_CWJAP  = 0; 
05F1:  CLRF   6A
....................          flag_Resp_CWJAP      = 0; 
05F2:  CLRF   65
....................           
....................          /*bufferRespCWJAP[0]   = 0x00; 
....................          bufferRespCWJAP[1]   = 0x00; 
....................          bufferRespCWJAP[2]   = 0x00; 
....................          bufferRespCWJAP[3]   = 0x00; 
....................          bufferRespCWJAP[4]   = 0x00; 
....................          bufferRespCWJAP[5]   = 0x00; 
....................          bufferRespCWJAP[6]   = 0x00;*/ 
....................          ret = 1; 
05F3:  MOVLW  01
05F4:  BSF    03.5
05F5:  MOVWF  40
....................       } else if(flag_Resp_NoAp==1){ 
05F6:  GOTO   613
05F7:  BCF    03.5
05F8:  DECFSZ 64,W
05F9:  GOTO   601
....................          /* 
....................          fprintf(console, "Preparando para conectar"); 
....................          fputc(0x0D,console);*/ 
....................          flag_Pos_Resp_NoAp  = 0; 
05FA:  CLRF   69
....................          flag_Resp_NoAp      = 0; 
05FB:  CLRF   64
....................        
....................          /*bufferRespNoAp[0]   = 0x00; 
....................          bufferRespNoAp[1]   = 0x00; 
....................          bufferRespNoAp[2]   = 0x00; 
....................          bufferRespNoAp[3]   = 0x00; 
....................          bufferRespNoAp[4]   = 0x00;*/ 
....................          ret = 2; 
05FC:  MOVLW  02
05FD:  BSF    03.5
05FE:  MOVWF  40
....................       } else if (flag_Resp_Connected==1){ 
05FF:  GOTO   613
0600:  BCF    03.5
0601:  DECFSZ 66,W
0602:  GOTO   60A
....................        
....................          /*fprintf(console, "Conectado por comandos en la red"); 
....................          fputc(0x0D,console);*/ 
....................           
....................          flag_Pos_Resp_Connected = 0; 
0603:  CLRF   6B
....................          flag_Resp_Connected     = 0; 
0604:  CLRF   66
....................           
....................          /*bufferRespConneted[0]   = 0x00; 
....................          bufferRespConneted[1]   = 0x00; 
....................          bufferRespConneted[2]   = 0x00; 
....................          bufferRespConneted[3]   = 0x00; 
....................          bufferRespConneted[4]   = 0x00; 
....................          bufferRespConneted[5]   = 0x00; 
....................          bufferRespConneted[6]   = 0x00; 
....................          bufferRespConneted[7]   = 0x00; 
....................          bufferRespConneted[8]   = 0x00;*/ 
....................          ret = 3; 
0605:  MOVLW  03
0606:  BSF    03.5
0607:  MOVWF  40
....................       } else if(flag_Resp_Fail==1){ 
0608:  GOTO   613
0609:  BCF    03.5
060A:  DECFSZ 67,W
060B:  GOTO   614
....................        
....................          /*fprintf(console, "No se pudo conectar a la red"); 
....................          fputc(0x0D,console);**/ 
....................           
....................          flag_Pos_Resp_Fail   = 0; 
060C:  CLRF   6C
....................          flag_Resp_Fail       = 0; 
060D:  CLRF   67
....................          // Rompe el ciclo 
....................          flag_Resp_Valid      = 1; 
060E:  MOVLW  01
060F:  MOVWF  63
....................           
....................          /*bufferRespFail[0]    = 0x00; 
....................          bufferRespFail[1]    = 0x00; 
....................          bufferRespFail[2]    = 0x00; 
....................          bufferRespFail[3]    = 0x00;*/ 
....................          ret = 4; 
0610:  MOVLW  04
0611:  BSF    03.5
0612:  MOVWF  40
0613:  BCF    03.5
....................       } 
0614:  GOTO   5EC
....................    }; 
....................    flag_Resp_Valid = 0; 
0615:  CLRF   63
....................    return ret; 
0616:  BSF    03.5
0617:  MOVF   40,W
0618:  MOVWF  78
0619:  BCF    03.5
061A:  RETURN
.................... } 
....................  
.................... /** VARIABLES GLOBALS **/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /** INTERRUPCIONES **/ 
.................... //@hint: se dispara cuando se detectan datos de llegada al puerto serie portWF 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
0346:  BTFSS  0C.5
0347:  GOTO   346
0348:  MOVF   1A,W
0349:  BSF    03.5
034A:  MOVWF  5D
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
034B:  MOVF   5D,W
034C:  MOVWF  5E
*
03EC:  BCF    0C.5
03ED:  BCF    0A.3
03EE:  BCF    0A.4
03EF:  GOTO   02D
.................... } 
....................  
.................... /** INIT **/ 
....................  
....................    void main() 
*
13EC:  MOVF   03,W
13ED:  ANDLW  1F
13EE:  MOVWF  03
13EF:  BSF    03.5
13F0:  BSF    03.6
13F1:  BSF    07.3
13F2:  MOVLW  08
13F3:  BCF    03.6
13F4:  MOVWF  19
13F5:  MOVLW  02
13F6:  MOVWF  1A
13F7:  MOVLW  A6
13F8:  MOVWF  18
13F9:  MOVLW  90
13FA:  BCF    03.5
13FB:  MOVWF  18
13FC:  BSF    03.5
13FD:  BCF    06.0
13FE:  BCF    03.5
13FF:  BSF    06.0
1400:  MOVLW  03
1401:  MOVWF  59
1402:  MOVLW  02
1403:  MOVWF  5A
1404:  MOVLW  05
1405:  MOVWF  5B
1406:  MOVLW  08
1407:  MOVWF  5C
1408:  MOVWF  5D
1409:  CLRF   5E
140A:  CLRF   63
140B:  CLRF   64
140C:  CLRF   65
140D:  CLRF   66
140E:  CLRF   67
140F:  CLRF   68
1410:  CLRF   69
1411:  CLRF   6A
1412:  CLRF   6B
1413:  CLRF   6C
1414:  CLRF   6F
1415:  BSF    03.5
1416:  BSF    03.6
1417:  MOVF   09,W
1418:  ANDLW  C0
1419:  MOVWF  09
141A:  BCF    03.6
141B:  BCF    1F.4
141C:  BCF    1F.5
141D:  MOVLW  00
141E:  BSF    03.6
141F:  MOVWF  08
1420:  BCF    03.5
1421:  CLRF   07
1422:  CLRF   08
1423:  CLRF   09
1424:  BCF    03.7
....................    { 
....................        
....................       //Estabiliza el inicio del programa 
....................       delay_ms(500); 
*
14AA:  MOVLW  02
14AB:  MOVWF  3D
14AC:  MOVLW  FA
14AD:  MOVWF  46
14AE:  BCF    0A.4
14AF:  BCF    03.5
14B0:  CALL   3F0
14B1:  BSF    0A.4
14B2:  BSF    03.5
14B3:  DECFSZ 3D,F
14B4:  GOTO   4AC
....................        
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
14B5:  MOVLW  30
14B6:  MOVWF  15
14B7:  BCF    01.7
....................       set_tris_b(0b00110010); 
14B8:  MOVLW  32
14B9:  MOVWF  06
....................        
....................       enable_interrupts(INT_RDA);  
14BA:  BSF    0C.5
....................       enable_interrupts(GLOBAL);  
14BB:  MOVLW  C0
14BC:  BCF    03.5
14BD:  IORWF  0B,F
....................  
....................       // Inicializa la lcd 
....................       lcd_init(); 
14BE:  BCF    0A.4
14BF:  GOTO   52D
14C0:  BSF    0A.4
....................       output_high(LCD_LIGHT_PIN); 
14C1:  BSF    03.5
14C2:  BCF    08.3
14C3:  BCF    03.5
14C4:  BSF    08.3
....................        
....................       esp8266_init(); 
14C5:  BCF    0A.4
14C6:  BSF    0A.3
14C7:  GOTO   000
14C8:  BSF    0A.4
14C9:  BCF    0A.3
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
14CA:  MOVF   6F,W
14CB:  ADDLW  FC
14CC:  BTFSC  03.0
14CD:  GOTO   4E9
14CE:  ADDLW  04
14CF:  GOTO   4EB
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
14D0:  BCF    0A.4
14D1:  GOTO   724
14D2:  BSF    0A.4
14D3:  MOVF   78,W
14D4:  MOVWF  6F
....................                break; 
14D5:  GOTO   4E9
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
14D6:  BCF    0A.4
14D7:  BSF    0A.3
14D8:  GOTO   557
14D9:  BSF    0A.4
14DA:  BCF    0A.3
14DB:  MOVF   78,W
14DC:  MOVWF  6F
....................                break; 
14DD:  GOTO   4E9
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
14DE:  BCF    0A.4
14DF:  BSF    0A.3
14E0:  GOTO   64B
14E1:  BSF    0A.4
14E2:  BCF    0A.3
14E3:  MOVF   78,W
14E4:  MOVWF  6F
....................                break; 
14E5:  GOTO   4E9
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
14E6:  GOTO   2B8
14E7:  MOVF   78,W
14E8:  MOVWF  6F
....................                break; 
....................          } // Fin del Switch(menuActive) 
14E9:  GOTO   4CA
....................           
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
14EA:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
