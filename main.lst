CCS PCH C Compiler, Version 5.015, 5967               14-ene.-18 01:34

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   11848 bytes (18%)
                           Largest free fragment is 53684
               RAM used:   362 (9%) at main() level
                           486 (12%) worst case
               Stack used: 14 locations (10 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   2BCC
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  F9D.5
0004A:  GOTO   0054
0004E:  BTFSC  F9E.5
00050:  GOTO   0BE8
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          MAIN.C: Funcion principal 
....................  
.................... *******************************************************/ 
....................  
.................... #include "header/config.h" 
.................... #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
00096:  MOVFF  FF2,0D
0009A:  BCF    FF2.7
0009C:  CLRF   FF7
0009E:  ADDLW  B0
000A0:  MOVWF  FF6
000A2:  MOVLW  00
000A4:  ADDWFC FF7,F
000A6:  TBLRD*+
000A8:  MOVF   FF5,W
000AA:  BTFSC  0D.7
000AC:  BSF    FF2.7
000AE:  RETURN 0
000B0:  DATA 22,7C
000B2:  DATA 21,7C
000B4:  DATA 20,7C
000B6:  DATA 04,7C
000B8:  DATA 00,7C
000BA:  DATA 01,7C
000BC:  DATA 02,7C
000BE:  DATA 03,7C
000C0:  CLRF   FF7
000C2:  ADDLW  D0
000C4:  MOVWF  FF6
000C6:  MOVLW  00
000C8:  ADDWFC FF7,F
000CA:  TBLRD*+
000CC:  MOVF   FF5,W
000CE:  RETURN 0
000D0:  DATA 2B,49
000D2:  DATA 50,44
000D4:  DATA 2C,00
000D6:  CLRF   FF7
000D8:  ADDLW  E6
000DA:  MOVWF  FF6
000DC:  MOVLW  00
000DE:  ADDWFC FF7,F
000E0:  TBLRD*+
000E2:  MOVF   FF5,W
000E4:  RETURN 0
000E6:  DATA 43,4D
000E8:  DATA 44,3A
000EA:  CLRF   FF7
000EC:  ADDLW  FA
000EE:  MOVWF  FF6
000F0:  MOVLW  00
000F2:  ADDWFC FF7,F
000F4:  TBLRD*+
000F6:  MOVF   FF5,W
000F8:  RETURN 0
000FA:  DATA 4F,4B
000FC:  DATA 0D,0A
000FE:  DATA 00,00
00100:  CLRF   FF7
00102:  ADDLW  10
00104:  MOVWF  FF6
00106:  MOVLW  01
00108:  ADDWFC FF7,F
0010A:  TBLRD*+
0010C:  MOVF   FF5,W
0010E:  RETURN 0
00110:  DATA 4E,6F
00112:  DATA 20,41
00114:  DATA 50,00
00116:  CLRF   FF7
00118:  ADDLW  26
0011A:  MOVWF  FF6
0011C:  MOVLW  01
0011E:  ADDWFC FF7,F
00120:  TBLRD*+
00122:  MOVF   FF5,W
00124:  RETURN 0
00126:  DATA 2B,43
00128:  DATA 57,4A
0012A:  DATA 41,50
0012C:  DATA 3A,00
0012E:  CLRF   FF7
00130:  ADDLW  3E
00132:  MOVWF  FF6
00134:  MOVLW  01
00136:  ADDWFC FF7,F
00138:  TBLRD*+
0013A:  MOVF   FF5,W
0013C:  RETURN 0
0013E:  DATA 43,4F
00140:  DATA 4E,4E
00142:  DATA 45,43
00144:  DATA 54,45
00146:  DATA 44,00
00148:  CLRF   FF7
0014A:  ADDLW  58
0014C:  MOVWF  FF6
0014E:  MOVLW  01
00150:  ADDWFC FF7,F
00152:  TBLRD*+
00154:  MOVF   FF5,W
00156:  RETURN 0
00158:  DATA 46,41
0015A:  DATA 49,4C
0015C:  DATA 00,00
0015E:  DATA 41,54
00160:  DATA 2B,43
00162:  DATA 49,50
00164:  DATA 53,45
00166:  DATA 4E,44
00168:  DATA 3D,25
0016A:  DATA 63,2C
0016C:  DATA 25,75
0016E:  DATA 0D,0A
00170:  DATA 00,00
00172:  DATA 41,54
00174:  DATA 2B,43
00176:  DATA 49,50
00178:  DATA 53,45
0017A:  DATA 4E,44
0017C:  DATA 3D,25
0017E:  DATA 63,2C
00180:  DATA 25,75
00182:  DATA 0D,0A
00184:  DATA 00,00
00186:  DATA 41,54
00188:  DATA 2B,43
0018A:  DATA 49,50
0018C:  DATA 53,45
0018E:  DATA 4E,44
00190:  DATA 3D,25
00192:  DATA 63,2C
00194:  DATA 25,75
00196:  DATA 0D,0A
00198:  DATA 00,00
0019A:  DATA 41,54
0019C:  DATA 2B,43
0019E:  DATA 49,50
001A0:  DATA 43,4C
001A2:  DATA 4F,53
001A4:  DATA 45,3D
001A6:  DATA 25,63
001A8:  DATA 0D,0A
001AA:  DATA 00,00
001AC:  DATA 41,54
001AE:  DATA 2B,43
001B0:  DATA 57,51
001B2:  DATA 41,50
001B4:  DATA 0A,0D
001B6:  DATA 00,00
001B8:  DATA 41,54
001BA:  DATA 2B,43
001BC:  DATA 49,50
001BE:  DATA 53,45
001C0:  DATA 4E,44
001C2:  DATA 3D,25
001C4:  DATA 63,2C
001C6:  DATA 25,75
001C8:  DATA 0D,0A
001CA:  DATA 00,00
001CC:  DATA 41,54
001CE:  DATA 2B,43
001D0:  DATA 49,50
001D2:  DATA 43,4C
001D4:  DATA 4F,53
001D6:  DATA 45,3D
001D8:  DATA 25,63
001DA:  DATA 0D,0A
001DC:  DATA 00,00
001DE:  DATA 41,54
001E0:  DATA 2B,43
001E2:  DATA 57,53
001E4:  DATA 41,50
001E6:  DATA 5F,44
001E8:  DATA 45,46
001EA:  DATA 3D,25
001EC:  DATA 73,2C
001EE:  DATA 31,2C
001F0:  DATA 34,0D
001F2:  DATA 0A,00
001F4:  DATA 41,54
001F6:  DATA 2B,43
001F8:  DATA 49,50
001FA:  DATA 53,45
001FC:  DATA 4E,44
001FE:  DATA 3D,25
00200:  DATA 63,2C
00202:  DATA 25,75
00204:  DATA 0D,0A
00206:  DATA 00,00
00208:  DATA 41,54
0020A:  DATA 2B,43
0020C:  DATA 49,50
0020E:  DATA 43,4C
00210:  DATA 4F,53
00212:  DATA 45,3D
00214:  DATA 25,63
00216:  DATA 0D,0A
00218:  DATA 00,00
0021A:  DATA 41,54
0021C:  DATA 2B,43
0021E:  DATA 49,50
00220:  DATA 53,45
00222:  DATA 4E,44
00224:  DATA 3D,25
00226:  DATA 63,2C
00228:  DATA 25,75
0022A:  DATA 0D,0A
0022C:  DATA 00,00
0022E:  DATA 41,54
00230:  DATA 2B,43
00232:  DATA 49,50
00234:  DATA 53,45
00236:  DATA 4E,44
00238:  DATA 3D,25
0023A:  DATA 63,2C
0023C:  DATA 25,75
0023E:  DATA 0D,0A
00240:  DATA 00,00
00242:  DATA 48,54
00244:  DATA 54,50
00246:  DATA 2F,31
00248:  DATA 2E,31
0024A:  DATA 20,32
0024C:  DATA 30,30
0024E:  DATA 20,4F
00250:  DATA 4B,0A
00252:  DATA 0A,25
00254:  DATA 73,0A
00256:  DATA 0D,00
00258:  DATA 41,54
0025A:  DATA 2B,43
0025C:  DATA 49,50
0025E:  DATA 43,4C
00260:  DATA 4F,53
00262:  DATA 45,3D
00264:  DATA 25,63
00266:  DATA 0D,0A
00268:  DATA 00,00
0026A:  DATA 41,54
0026C:  DATA 2B,43
0026E:  DATA 57,4D
00270:  DATA 4F,44
00272:  DATA 45,3D
00274:  DATA 25,63
00276:  DATA 0D,0A
00278:  DATA 00,00
0027A:  DATA 41,54
0027C:  DATA 2B,43
0027E:  DATA 57,4A
00280:  DATA 41,50
00282:  DATA 3F,0D
00284:  DATA 0A,00
00286:  DATA 41,54
00288:  DATA 2B,43
0028A:  DATA 57,4A
0028C:  DATA 41,50
0028E:  DATA 3D,25
00290:  DATA 73,00
00292:  DATA 4C,61
00294:  DATA 6E,7A
00296:  DATA 61,20
00298:  DATA 63,6F
0029A:  DATA 6D,61
0029C:  DATA 6E,64
0029E:  DATA 6F,20
002A0:  DATA 50,61
002A2:  DATA 72,61
002A4:  DATA 20,63
002A6:  DATA 6F,6E
002A8:  DATA 65,63
002AA:  DATA 74,61
002AC:  DATA 72,73
002AE:  DATA 65,20
002B0:  DATA 61,20
002B2:  DATA 75,6E
002B4:  DATA 61,20
002B6:  DATA 72,65
002B8:  DATA 64,20
002BA:  DATA 0D,0A
002BC:  DATA 00,00
002BE:  DATA 53,69
002C0:  DATA 6E,20
002C2:  DATA 72,65
002C4:  DATA 64,20
002C6:  DATA 65,6E
002C8:  DATA 74,6F
002CA:  DATA 6E,63
002CC:  DATA 65,73
002CE:  DATA 20,61
002D0:  DATA 63,74
002D2:  DATA 69,76
002D4:  DATA 61,20
002D6:  DATA 4D,6F
002D8:  DATA 64,6F
002DA:  DATA 20,41
002DC:  DATA 50,20
002DE:  DATA 0D,0A
002E0:  DATA 00,00
002E2:  DATA 41,54
002E4:  DATA 2B,43
002E6:  DATA 57,4D
002E8:  DATA 4F,44
002EA:  DATA 45,3D
002EC:  DATA 25,63
002EE:  DATA 0D,0A
002F0:  DATA 00,00
002F2:  DATA 41,54
002F4:  DATA 2B,43
002F6:  DATA 49,50
002F8:  DATA 4D,55
002FA:  DATA 58,3D
002FC:  DATA 31,0D
002FE:  DATA 0A,00
00300:  DATA 41,54
00302:  DATA 2B,43
00304:  DATA 49,50
00306:  DATA 53,45
00308:  DATA 52,56
0030A:  DATA 45,52
0030C:  DATA 3D,31
0030E:  DATA 2C,38
00310:  DATA 30,0D
00312:  DATA 0A,00
00314:  DATA 45,6E
00316:  DATA 63,65
00318:  DATA 6E,64
0031A:  DATA 65,72
0031C:  DATA 20,4D
0031E:  DATA 61,6E
00320:  DATA 75,61
00322:  DATA 6C,00
00324:  DATA 41,70
00326:  DATA 61,67
00328:  DATA 61,64
0032A:  DATA 6F,20
0032C:  DATA 4D,61
0032E:  DATA 6E,75
00330:  DATA 61,6C
00332:  DATA 20,00
00334:  DATA 43,6F
00336:  DATA 6E,66
00338:  DATA 69,67
0033A:  DATA 75,72
0033C:  DATA 61,63
0033E:  DATA 69,6F
00340:  DATA 6E,20
00342:  DATA 20,00
00344:  DATA 00,00
00346:  DATA 00,00
00348:  DATA 00,00
0034A:  DATA 00,00
0034C:  DATA 00,00
0034E:  DATA 00,00
00350:  DATA 00,00
00352:  DATA 00,00
00354:  DATA 45,53
00356:  DATA 54,41
00358:  DATA 43,49
0035A:  DATA 4F,4E
0035C:  DATA 20,49
0035E:  DATA 50,20
00360:  DATA 20,20
00362:  DATA 20,20
00364:  DATA 00,45
00366:  DATA 53,54
00368:  DATA 41,43
0036A:  DATA 49,4F
0036C:  DATA 4E,20
0036E:  DATA 53,53
00370:  DATA 49,44
00372:  DATA 20,20
00374:  DATA 20,00
00376:  DATA 41,50
00378:  DATA 20,53
0037A:  DATA 53,49
0037C:  DATA 44,20
0037E:  DATA 20,20
00380:  DATA 20,20
00382:  DATA 20,20
00384:  DATA 20,20
00386:  DATA 00,41
00388:  DATA 50,20
0038A:  DATA 4B,45
0038C:  DATA 59,20
0038E:  DATA 20,20
00390:  DATA 20,20
00392:  DATA 20,20
00394:  DATA 20,20
00396:  DATA 20,00
00398:  DATA 41,50
0039A:  DATA 20,49
0039C:  DATA 50,20
0039E:  DATA 20,20
003A0:  DATA 20,20
003A2:  DATA 20,20
003A4:  DATA 20,20
003A6:  DATA 20,20
003A8:  DATA 00,43
003AA:  DATA 6F,6E
003AC:  DATA 66,20
003AE:  DATA 41,63
003B0:  DATA 63,65
003B2:  DATA 73,73
003B4:  DATA 6F,20
003B6:  DATA 52,65
003B8:  DATA 64,00
003BA:  DATA 42,6F
003BC:  DATA 72,72
003BE:  DATA 61,72
003C0:  DATA 20,61
003C2:  DATA 20,46
003C4:  DATA 61,62
003C6:  DATA 72,69
003C8:  DATA 63,61
003CA:  DATA 00,4F
003CC:  DATA 6E,2F
003CE:  DATA 4F,66
003D0:  DATA 66,20
003D2:  DATA 42,61
003D4:  DATA 63,6B
003D6:  DATA 6C,69
003D8:  DATA 67,68
003DA:  DATA 74,00
003DC:  DATA 53,41
003DE:  DATA 4C,49
003E0:  DATA 52,20
003E2:  DATA 20,20
003E4:  DATA 20,20
003E6:  DATA 20,20
003E8:  DATA 20,20
003EA:  DATA 20,20
003EC:  DATA 00,00
003EE:  DATA 45,73
003F0:  DATA 74,61
003F2:  DATA 63,69
003F4:  DATA 6F,6E
003F6:  DATA 20,20
003F8:  DATA 20,20
003FA:  DATA 20,00
003FC:  DATA 41,63
003FE:  DATA 63,65
00400:  DATA 73,73
00402:  DATA 20,50
00404:  DATA 6F,69
00406:  DATA 6E,74
00408:  DATA 20,00
0040A:  DATA 45,73
0040C:  DATA 74,61
0040E:  DATA 63,69
00410:  DATA 6F,6E
00412:  DATA 20,2B
00414:  DATA 20,41
00416:  DATA 50,00
00418:  DATA 53,41
0041A:  DATA 4C,49
0041C:  DATA 52,20
0041E:  DATA 20,20
00420:  DATA 20,20
00422:  DATA 20,20
00424:  DATA 20,00
00426:  DATA 00,00
00428:  DATA 00,00
0042A:  DATA 00,00
0042C:  DATA 00,00
0042E:  DATA 00,00
00430:  DATA 00,00
00432:  DATA 00,00
00434:  DATA 53,41
00436:  DATA 4C,49
00438:  DATA 52,00
0043A:  DATA 5B,53
0043C:  DATA 49,47
0043E:  DATA 5D,20
00440:  DATA 20,20
00442:  DATA 20,20
00444:  DATA 20,5B
00446:  DATA 45,4E
00448:  DATA 54,5D
0044A:  DATA 00,00
0044C:  DATA 0C,4F
0044E:  DATA 6E,20
00450:  DATA 2D,3E
00452:  DATA 20,25
00454:  DATA 73,00
00456:  DATA 0C,4F
00458:  DATA 6E,20
0045A:  DATA 2D,3E
0045C:  DATA 20,25
0045E:  DATA 73,00
00460:  DATA 0C,4F
00462:  DATA 66,66
00464:  DATA 2D,3E
00466:  DATA 20,25
00468:  DATA 73,00
0046A:  DATA 0C,4F
0046C:  DATA 66,66
0046E:  DATA 2D,3E
00470:  DATA 20,25
00472:  DATA 73,00
00474:  DATA 41,54
00476:  DATA 2B,43
00478:  DATA 49,46
0047A:  DATA 53,52
0047C:  DATA 0D,0A
0047E:  DATA 00,00
00480:  DATA 0C,43
00482:  DATA 61,72
00484:  DATA 67,61
00486:  DATA 6E,64
00488:  DATA 6F,2E
0048A:  DATA 2E,2E
0048C:  DATA 00,00
0048E:  DATA 41,54
00490:  DATA 2B,43
00492:  DATA 49,46
00494:  DATA 53,52
00496:  DATA 0D,0A
00498:  DATA 00,00
0049A:  DATA 0C,43
0049C:  DATA 61,72
0049E:  DATA 67,61
004A0:  DATA 6E,64
004A2:  DATA 6F,2E
004A4:  DATA 2E,2E
004A6:  DATA 00,00
004A8:  DATA 41,54
004AA:  DATA 2B,43
004AC:  DATA 57,4A
004AE:  DATA 41,50
004B0:  DATA 3F,0D
004B2:  DATA 0A,00
004B4:  DATA 0C,43
004B6:  DATA 61,72
004B8:  DATA 67,61
004BA:  DATA 6E,64
004BC:  DATA 6F,2E
004BE:  DATA 2E,2E
004C0:  DATA 00,00
004C2:  DATA 0C,44
004C4:  DATA 65,73
004C6:  DATA 68,61
004C8:  DATA 62,69
004CA:  DATA 6C,69
004CC:  DATA 74,61
004CE:  DATA 64,6F
004D0:  DATA 00,00
004D2:  DATA 41,54
004D4:  DATA 2B,43
004D6:  DATA 57,53
004D8:  DATA 41,50
004DA:  DATA 3F,0D
004DC:  DATA 0A,00
004DE:  DATA 0C,43
004E0:  DATA 61,72
004E2:  DATA 67,61
004E4:  DATA 6E,64
004E6:  DATA 6F,2E
004E8:  DATA 2E,2E
004EA:  DATA 00,00
004EC:  DATA 0C,44
004EE:  DATA 65,73
004F0:  DATA 68,61
004F2:  DATA 62,69
004F4:  DATA 6C,69
004F6:  DATA 74,61
004F8:  DATA 64,6F
004FA:  DATA 00,00
004FC:  DATA 41,54
004FE:  DATA 2B,43
00500:  DATA 57,53
00502:  DATA 41,50
00504:  DATA 3F,0D
00506:  DATA 0A,00
00508:  DATA 0C,43
0050A:  DATA 61,72
0050C:  DATA 67,61
0050E:  DATA 6E,64
00510:  DATA 6F,2E
00512:  DATA 2E,2E
00514:  DATA 00,00
00516:  DATA 0C,44
00518:  DATA 65,73
0051A:  DATA 68,61
0051C:  DATA 62,69
0051E:  DATA 6C,69
00520:  DATA 74,61
00522:  DATA 64,6F
00524:  DATA 00,00
00526:  DATA 0C,42
00528:  DATA 6F,72
0052A:  DATA 72,61
0052C:  DATA 6E,64
0052E:  DATA 6F,20
00530:  DATA 45,45
00532:  DATA 45,50
00534:  DATA 52,4F
00536:  DATA 4D,00
00538:  DATA 0C,42
0053A:  DATA 6F,72
0053C:  DATA 72,61
0053E:  DATA 6E,64
00540:  DATA 6F,20
00542:  DATA 52,45
00544:  DATA 44,00
00546:  DATA 41,54
00548:  DATA 2B,43
0054A:  DATA 57,51
0054C:  DATA 41,50
0054E:  DATA 0A,0D
00550:  DATA 00,00
00552:  DATA 41,54
00554:  DATA 2B,52
00556:  DATA 53,54
00558:  DATA 0A,0D
0055A:  DATA 00,00
0055C:  DATA 41,54
0055E:  DATA 2B,43
00560:  DATA 57,53
00562:  DATA 41,50
00564:  DATA 5F,44
00566:  DATA 45,46
00568:  DATA 3D,22
0056A:  DATA 4B,72
0056C:  DATA 69,76
0056E:  DATA 65,72
00570:  DATA 20,53
00572:  DATA 6D,61
00574:  DATA 72,74
00576:  DATA 48,6F
00578:  DATA 6D,65
0057A:  DATA 22,2C
0057C:  DATA 22,6B
0057E:  DATA 72,69
00580:  DATA 76,65
00582:  DATA 72,35
00584:  DATA 36,31
00586:  DATA 30,36
00588:  DATA 22,2C
0058A:  DATA 31,2C
0058C:  DATA 34,0D
0058E:  DATA 0A,00
00590:  DATA 0C,42
00592:  DATA 61,63
00594:  DATA 6B,6C
00596:  DATA 69,67
00598:  DATA 68,74
0059A:  DATA 20,4F
0059C:  DATA 6E,00
0059E:  DATA 0C,42
005A0:  DATA 61,63
005A2:  DATA 6B,6C
005A4:  DATA 69,67
005A6:  DATA 68,74
005A8:  DATA 20,4F
005AA:  DATA 66,66
005AC:  DATA 00,00
005AE:  DATA 41,54
005B0:  DATA 2B,43
005B2:  DATA 57,4D
005B4:  DATA 4F,44
005B6:  DATA 45,5F
005B8:  DATA 44,45
005BA:  DATA 46,3D
005BC:  DATA 31,0D
005BE:  DATA 0A,00
005C0:  DATA 0C,43
005C2:  DATA 6F,6E
005C4:  DATA 66,69
005C6:  DATA 67,20
005C8:  DATA 43,6C
005CA:  DATA 69,65
005CC:  DATA 6E,74
005CE:  DATA 65,00
005D0:  DATA 41,54
005D2:  DATA 2B,43
005D4:  DATA 57,4D
005D6:  DATA 4F,44
005D8:  DATA 45,5F
005DA:  DATA 44,45
005DC:  DATA 46,3D
005DE:  DATA 32,0D
005E0:  DATA 0A,00
005E2:  DATA 0C,43
005E4:  DATA 6F,6E
005E6:  DATA 66,69
005E8:  DATA 67,20
005EA:  DATA 41,50
005EC:  DATA 00,00
005EE:  DATA 41,54
005F0:  DATA 2B,43
005F2:  DATA 57,4D
005F4:  DATA 4F,44
005F6:  DATA 45,5F
005F8:  DATA 44,45
005FA:  DATA 46,3D
005FC:  DATA 33,0D
005FE:  DATA 0A,00
00600:  DATA 0C,43
00602:  DATA 6F,6E
00604:  DATA 66,69
00606:  DATA 67,20
00608:  DATA 43,6C
0060A:  DATA 69,65
0060C:  DATA 6E,74
0060E:  DATA 65,41
00610:  DATA 50,00
00612:  DATA 0C,52
00614:  DATA 65,69
00616:  DATA 6E,69
00618:  DATA 63,69
0061A:  DATA 61,6E
0061C:  DATA 64,6F
0061E:  DATA 00,00
*
00812:  ADDWF  FE8,W
00814:  CLRF   FF7
00816:  RLCF   FF7,F
00818:  ADDLW  2D
0081A:  MOVWF  FF6
0081C:  MOVLW  08
0081E:  ADDWFC FF7,F
00820:  TBLRD*-
00822:  MOVF   FF5,W
00824:  MOVWF  FFA
00826:  TBLRD*
00828:  MOVF   FF5,W
0082A:  MOVWF  FF9
0082C:  DATA 36,06
0082E:  DATA 8E,06
00830:  DATA 64,06
00832:  DATA B8,06
00834:  DATA E2,06
*
008E2:  ADDWF  FE8,W
008E4:  CLRF   FF7
008E6:  RLCF   FF7,F
008E8:  ADDLW  FD
008EA:  MOVWF  FF6
008EC:  MOVLW  08
008EE:  ADDWFC FF7,F
008F0:  TBLRD*-
008F2:  MOVF   FF5,W
008F4:  MOVWF  FFA
008F6:  TBLRD*
008F8:  MOVF   FF5,W
008FA:  MOVWF  FF9
008FC:  DATA D6,08
008FE:  DATA D6,08
00900:  DATA D6,08
00902:  DATA D6,08
00904:  DATA D6,08
*
0097C:  ADDWF  FE8,W
0097E:  CLRF   FF7
00980:  RLCF   FF7,F
00982:  ADDLW  97
00984:  MOVWF  FF6
00986:  MOVLW  09
00988:  ADDWFC FF7,F
0098A:  TBLRD*-
0098C:  MOVF   FF5,W
0098E:  MOVWF  FFA
00990:  TBLRD*
00992:  MOVF   FF5,W
00994:  MOVWF  FF9
00996:  DATA 70,09
00998:  DATA 70,09
0099A:  DATA 70,09
0099C:  DATA 70,09
*
00C00:  DATA 41,54
00C02:  DATA 2B,52
00C04:  DATA 53,54
00C06:  DATA 0D,0A
00C08:  DATA 00,00
00C0A:  DATA 0C,49
00C0C:  DATA 6E,69
00C0E:  DATA 63,69
00C10:  DATA 61,6E
00C12:  DATA 64,6F
00C14:  DATA 2E,2E
00C16:  DATA 2E,00
00C18:  MOVLB  1
00C1A:  MOVF   xCE,W
00C1C:  ANDLW  07
00C1E:  MOVWF  00
00C20:  RRCF   xCE,W
00C22:  MOVWF  01
00C24:  RRCF   01,F
00C26:  RRCF   01,F
00C28:  MOVLW  1F
00C2A:  ANDWF  01,F
00C2C:  MOVF   01,W
00C2E:  ADDWF  xD0,W
00C30:  MOVWF  FE9
00C32:  MOVLW  00
00C34:  ADDWFC xD1,W
00C36:  MOVWF  FEA
00C38:  CLRF   01
00C3A:  INCF   01,F
00C3C:  INCF   00,F
00C3E:  BRA    0C42
00C40:  RLCF   01,F
00C42:  DECFSZ 00,F
00C44:  BRA    0C40
00C46:  MOVF   xCF,F
00C48:  BZ    0C50
00C4A:  MOVF   01,W
00C4C:  IORWF  FEF,F
00C4E:  BRA    0C56
00C50:  COMF   01,F
00C52:  MOVF   01,W
00C54:  ANDWF  FEF,F
00C56:  MOVLB  0
00C58:  RETURN 0
*
00C82:  TBLRD*+
00C84:  MOVF   FF5,F
00C86:  BZ    0CA2
00C88:  MOVFF  FF6,1CC
00C8C:  MOVFF  FF7,1CD
00C90:  MOVF   FF5,W
00C92:  BTFSS  F9E.4
00C94:  BRA    0C92
00C96:  MOVWF  FAD
00C98:  MOVFF  1CC,FF6
00C9C:  MOVFF  1CD,FF7
00CA0:  BRA    0C82
00CA2:  RETURN 0
*
00F18:  TBLRD*+
00F1A:  MOVF   FF5,F
00F1C:  BZ    0F36
00F1E:  MOVFF  FF6,171
00F22:  MOVFF  FF7,172
00F26:  MOVFF  FF5,173
00F2A:  RCALL  0EAC
00F2C:  MOVFF  171,FF6
00F30:  MOVFF  172,FF7
00F34:  BRA    0F18
00F36:  RETURN 0
00F38:  TBLRD*+
00F3A:  MOVFF  FF6,1CD
00F3E:  MOVFF  FF7,1CE
00F42:  MOVF   FF5,W
00F44:  BTFSS  F9E.4
00F46:  BRA    0F44
00F48:  MOVWF  FAD
00F4A:  MOVFF  1CD,FF6
00F4E:  MOVFF  1CE,FF7
00F52:  MOVLB  1
00F54:  DECFSZ xCC,F
00F56:  BRA    0F5A
00F58:  BRA    0F5E
00F5A:  MOVLB  0
00F5C:  BRA    0F38
00F5E:  MOVLB  0
00F60:  RETURN 0
*
01052:  MOVF   FEF,F
01054:  BZ    1076
01056:  MOVFF  FEA,1CD
0105A:  MOVFF  FE9,1CC
0105E:  MOVF   FEF,W
01060:  BTFSS  F9E.4
01062:  BRA    1060
01064:  MOVWF  FAD
01066:  MOVFF  1CD,FEA
0106A:  MOVFF  1CC,FE9
0106E:  INCF   FE9,F
01070:  BTFSC  FD8.2
01072:  INCF   FEA,F
01074:  BRA    1052
01076:  RETURN 0
*
010BE:  TBLRD*+
010C0:  MOVF   FF5,F
010C2:  BZ    10DC
010C4:  MOVFF  FF6,16C
010C8:  MOVFF  FF7,16D
010CC:  MOVFF  FF5,16E
010D0:  BRA    1078
010D2:  MOVFF  16C,FF6
010D6:  MOVFF  16D,FF7
010DA:  BRA    10BE
010DC:  RETURN 0
*
013E8:  MOVLB  1
013EA:  MOVF   xCF,W
013EC:  CLRF   01
013EE:  SUBWF  xCE,W
013F0:  BC    13F8
013F2:  MOVFF  1CE,00
013F6:  BRA    1410
013F8:  CLRF   00
013FA:  MOVLW  08
013FC:  MOVWF  xD0
013FE:  RLCF   xCE,F
01400:  RLCF   00,F
01402:  MOVF   xCF,W
01404:  SUBWF  00,W
01406:  BTFSC  FD8.0
01408:  MOVWF  00
0140A:  RLCF   01,F
0140C:  DECFSZ xD0,F
0140E:  BRA    13FE
01410:  MOVLB  0
01412:  RETURN 0
01414:  MOVF   01,W
01416:  MOVFF  1CC,1CE
0141A:  MOVLW  64
0141C:  MOVLB  1
0141E:  MOVWF  xCF
01420:  MOVLB  0
01422:  RCALL  13E8
01424:  MOVFF  00,1CC
01428:  MOVF   01,W
0142A:  MOVLW  30
0142C:  BNZ   143E
0142E:  MOVLB  1
01430:  BTFSS  xCD.1
01432:  BRA    1450
01434:  BTFSC  xCD.3
01436:  BRA    1450
01438:  BTFSC  xCD.4
0143A:  MOVLW  20
0143C:  BRA    1446
0143E:  MOVLB  1
01440:  BCF    xCD.3
01442:  BCF    xCD.4
01444:  BSF    xCD.0
01446:  ADDWF  01,F
01448:  MOVF   01,W
0144A:  BTFSS  F9E.4
0144C:  BRA    144A
0144E:  MOVWF  FAD
01450:  MOVFF  1CC,1CE
01454:  MOVLW  0A
01456:  MOVWF  xCF
01458:  MOVLB  0
0145A:  RCALL  13E8
0145C:  MOVFF  00,1CC
01460:  MOVF   01,W
01462:  MOVLW  30
01464:  BNZ   1476
01466:  MOVLB  1
01468:  BTFSC  xCD.3
0146A:  BRA    1482
0146C:  BTFSS  xCD.0
0146E:  BRA    1482
01470:  BTFSC  xCD.4
01472:  MOVLW  20
01474:  MOVLB  0
01476:  ADDWF  01,F
01478:  MOVF   01,W
0147A:  BTFSS  F9E.4
0147C:  BRA    147A
0147E:  MOVWF  FAD
01480:  MOVLB  1
01482:  MOVLW  30
01484:  ADDWF  xCC,F
01486:  MOVF   xCC,W
01488:  BTFSS  F9E.4
0148A:  BRA    1488
0148C:  MOVWF  FAD
0148E:  MOVLB  0
01490:  RETURN 0
*
01EEA:  BTFSC  FD8.1
01EEC:  BRA    1EF6
01EEE:  MOVLW  01
01EF0:  MOVWF  FEA
01EF2:  MOVLW  86
01EF4:  MOVWF  FE9
01EF6:  CLRF   00
01EF8:  CLRF   01
01EFA:  CLRF   02
01EFC:  CLRF   03
01EFE:  MOVLB  1
01F00:  CLRF   x86
01F02:  CLRF   x87
01F04:  CLRF   x88
01F06:  CLRF   x89
01F08:  MOVF   x85,W
01F0A:  IORWF  x84,W
01F0C:  IORWF  x83,W
01F0E:  IORWF  x82,W
01F10:  BZ    1F6A
01F12:  MOVLW  20
01F14:  MOVWF  x8A
01F16:  BCF    FD8.0
01F18:  RLCF   x7E,F
01F1A:  RLCF   x7F,F
01F1C:  RLCF   x80,F
01F1E:  RLCF   x81,F
01F20:  RLCF   x86,F
01F22:  RLCF   x87,F
01F24:  RLCF   x88,F
01F26:  RLCF   x89,F
01F28:  MOVF   x85,W
01F2A:  SUBWF  x89,W
01F2C:  BNZ   1F3E
01F2E:  MOVF   x84,W
01F30:  SUBWF  x88,W
01F32:  BNZ   1F3E
01F34:  MOVF   x83,W
01F36:  SUBWF  x87,W
01F38:  BNZ   1F3E
01F3A:  MOVF   x82,W
01F3C:  SUBWF  x86,W
01F3E:  BNC   1F5E
01F40:  MOVF   x82,W
01F42:  SUBWF  x86,F
01F44:  MOVF   x83,W
01F46:  BTFSS  FD8.0
01F48:  INCFSZ x83,W
01F4A:  SUBWF  x87,F
01F4C:  MOVF   x84,W
01F4E:  BTFSS  FD8.0
01F50:  INCFSZ x84,W
01F52:  SUBWF  x88,F
01F54:  MOVF   x85,W
01F56:  BTFSS  FD8.0
01F58:  INCFSZ x85,W
01F5A:  SUBWF  x89,F
01F5C:  BSF    FD8.0
01F5E:  RLCF   00,F
01F60:  RLCF   01,F
01F62:  RLCF   02,F
01F64:  RLCF   03,F
01F66:  DECFSZ x8A,F
01F68:  BRA    1F16
01F6A:  MOVFF  186,FEF
01F6E:  MOVFF  187,FEC
01F72:  MOVFF  188,FEC
01F76:  MOVFF  189,FEC
01F7A:  MOVLB  0
01F7C:  GOTO   2054 (RETURN)
01F80:  MOVLB  1
01F82:  CLRF   x86
01F84:  CLRF   x87
01F86:  MOVLW  01
01F88:  MOVWF  x88
01F8A:  CLRF   FDA
01F8C:  CLRF   FD9
01F8E:  MOVWF  x8B
01F90:  MOVLW  7E
01F92:  MOVWF  x8A
01F94:  MOVLW  01
01F96:  MOVWF  FEA
01F98:  MOVLW  82
01F9A:  MOVWF  FE9
01F9C:  MOVFF  18B,FE2
01FA0:  MOVFF  18A,FE1
01FA4:  MOVFF  188,189
01FA8:  BCF    FD8.0
01FAA:  MOVF   FE5,W
01FAC:  MULWF  FEE
01FAE:  MOVF   FF3,W
01FB0:  ADDWFC x86,F
01FB2:  MOVF   FF4,W
01FB4:  ADDWFC x87,F
01FB6:  DECFSZ x89,F
01FB8:  BRA    1FA8
01FBA:  MOVFF  186,FDE
01FBE:  MOVFF  187,186
01FC2:  CLRF   x87
01FC4:  BTFSC  FD8.0
01FC6:  INCF   x87,F
01FC8:  INCF   x8A,F
01FCA:  BTFSC  FD8.2
01FCC:  INCF   x8B,F
01FCE:  INCF   x88,F
01FD0:  MOVF   x88,W
01FD2:  SUBLW  05
01FD4:  BNZ   1F94
01FD6:  MOVLB  0
01FD8:  GOTO   2084 (RETURN)
*
02236:  TBLRD*+
02238:  MOVFF  FF6,16F
0223C:  MOVFF  FF7,170
02240:  MOVFF  FF5,173
02244:  CALL   0EAC
02248:  MOVFF  16F,FF6
0224C:  MOVFF  170,FF7
02250:  MOVLB  1
02252:  DECFSZ x6E,F
02254:  BRA    2258
02256:  BRA    225C
02258:  MOVLB  0
0225A:  BRA    2236
0225C:  MOVLB  0
0225E:  RETURN 0
02260:  MOVF   FEF,F
02262:  BZ    2284
02264:  MOVFF  FEA,16F
02268:  MOVFF  FE9,16E
0226C:  MOVFF  FEF,173
02270:  CALL   0EAC
02274:  MOVFF  16F,FEA
02278:  MOVFF  16E,FE9
0227C:  INCF   FE9,F
0227E:  BTFSC  FD8.2
02280:  INCF   FEA,F
02282:  BRA    2260
02284:  RETURN 0
*
027AC:  MOVFF  FF2,0D
027B0:  BCF    FF2.7
027B2:  ADDWF  FE8,W
027B4:  CLRF   FF7
027B6:  RLCF   FF7,F
027B8:  ADDLW  D1
027BA:  MOVWF  FF6
027BC:  MOVLW  27
027BE:  ADDWFC FF7,F
027C0:  TBLRD*-
027C2:  MOVF   FF5,W
027C4:  MOVWF  FFA
027C6:  TBLRD*
027C8:  MOVF   FF5,W
027CA:  BTFSC  0D.7
027CC:  BSF    FF2.7
027CE:  MOVWF  FF9
027D0:  DATA 76,26
027D2:  DATA C8,26
027D4:  DATA 1A,27
027D6:  DATA 6C,27
*
02A60:  MOVFF  FF2,0D
02A64:  BCF    FF2.7
02A66:  ADDWF  FE8,W
02A68:  CLRF   FF7
02A6A:  RLCF   FF7,F
02A6C:  ADDLW  85
02A6E:  MOVWF  FF6
02A70:  MOVLW  2A
02A72:  ADDWFC FF7,F
02A74:  TBLRD*-
02A76:  MOVF   FF5,W
02A78:  MOVWF  FFA
02A7A:  TBLRD*
02A7C:  MOVF   FF5,W
02A7E:  BTFSC  0D.7
02A80:  BSF    FF2.7
02A82:  MOVWF  FF9
02A84:  DATA 24,28
02A86:  DATA 5E,28
02A88:  DATA AC,28
02A8A:  DATA FA,28
02A8C:  DATA EA,27
02A8E:  DATA 16,2A
02A90:  DATA 48,29
02A92:  DATA 1C,2A
02A94:  DATA 42,2A
*
02E20:  MOVFF  FF2,0D
02E24:  BCF    FF2.7
02E26:  ADDWF  FE8,W
02E28:  CLRF   FF7
02E2A:  RLCF   FF7,F
02E2C:  ADDLW  45
02E2E:  MOVWF  FF6
02E30:  MOVLW  2E
02E32:  ADDWFC FF7,F
02E34:  TBLRD*-
02E36:  MOVF   FF5,W
02E38:  MOVWF  FFA
02E3A:  TBLRD*
02E3C:  MOVF   FF5,W
02E3E:  BTFSC  0D.7
02E40:  BSF    FF2.7
02E42:  MOVWF  FF9
02E44:  DATA EC,2D
02E46:  DATA F8,2D
02E48:  DATA 04,2E
02E4A:  DATA 10,2E
....................  
.................... #list 
....................  
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20M) 
*
00C5A:  MOVLW  01
00C5C:  MOVWF  FEA
00C5E:  MOVLW  CD
00C60:  MOVWF  FE9
00C62:  MOVF   FEF,W
00C64:  BZ    0C80
00C66:  MOVLW  06
00C68:  MOVWF  01
00C6A:  CLRF   00
00C6C:  DECFSZ 00,F
00C6E:  BRA    0C6C
00C70:  DECFSZ 01,F
00C72:  BRA    0C6A
00C74:  MOVLW  7B
00C76:  MOVWF  00
00C78:  DECFSZ 00,F
00C7A:  BRA    0C78
00C7C:  DECFSZ FEF,F
00C7E:  BRA    0C66
00C80:  RETURN 0
*
01FDC:  MOVLW  03
01FDE:  MOVLB  1
01FE0:  SUBWF  x7F,F
01FE2:  BNC   1FF8
01FE4:  MOVLW  01
01FE6:  MOVWF  FEA
01FE8:  MOVLW  7F
01FEA:  MOVWF  FE9
01FEC:  MOVF   FEF,W
01FEE:  BZ    1FF8
01FF0:  BRA    1FF4
01FF2:  BRA    1FF4
01FF4:  DECFSZ FEF,F
01FF6:  BRA    1FF2
01FF8:  MOVLB  0
01FFA:  RETURN 0
.................... /* RS232 */ 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
*
01078:  BCF    F93.0
0107A:  BCF    F8A.0
0107C:  MOVLW  08
0107E:  MOVWF  01
01080:  BRA    1082
01082:  NOP   
01084:  BSF    01.7
01086:  BRA    10A8
01088:  BCF    01.7
0108A:  MOVLB  1
0108C:  RRCF   x6E,F
0108E:  MOVLB  0
01090:  BTFSC  FD8.0
01092:  BSF    F8A.0
01094:  BTFSS  FD8.0
01096:  BCF    F8A.0
01098:  BSF    01.6
0109A:  BRA    10A8
0109C:  BCF    01.6
0109E:  DECFSZ 01,F
010A0:  BRA    108A
010A2:  BRA    10A4
010A4:  NOP   
010A6:  BSF    F8A.0
010A8:  MOVLW  A7
010AA:  MOVWF  FE9
010AC:  DECFSZ FE9,F
010AE:  BRA    10AC
010B0:  BRA    10B2
010B2:  BTFSC  01.7
010B4:  BRA    1088
010B6:  BTFSC  01.6
010B8:  BRA    109C
010BA:  GOTO   10D2 (RETURN)
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... const int16 PIN_OUT[8]={ 
....................                         PIN_E2, 
....................                         PIN_E1, 
....................                         PIN_E0, 
....................                         PIN_A4, 
....................                         PIN_A0, 
....................                         PIN_A1, 
....................                         PIN_A2, 
....................                         PIN_A3 
....................                         }; 
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00D46:  BSF    F95.4
....................    output_float(LCD_DATA5); 
00D48:  BSF    F95.5
....................    output_float(LCD_DATA6); 
00D4A:  BSF    F95.6
....................    output_float(LCD_DATA7); 
00D4C:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00D4E:  BSF    F8C.1
00D50:  BCF    F95.1
....................    delay_cycles(1); 
00D52:  NOP   
....................    lcd_output_enable(1); 
00D54:  BSF    F8C.0
00D56:  BCF    F95.0
....................    delay_cycles(1); 
00D58:  NOP   
....................    high = lcd_read_nibble(); 
00D5A:  RCALL  0CF0
00D5C:  MOVFF  01,17B
....................        
....................    lcd_output_enable(0); 
00D60:  BCF    F8C.0
00D62:  BCF    F95.0
....................    delay_cycles(1); 
00D64:  NOP   
....................    lcd_output_enable(1); 
00D66:  BSF    F8C.0
00D68:  BCF    F95.0
....................    delay_us(1); 
00D6A:  BRA    0D6C
00D6C:  BRA    0D6E
00D6E:  NOP   
....................    low = lcd_read_nibble(); 
00D70:  RCALL  0CF0
00D72:  MOVFF  01,17A
....................        
....................    lcd_output_enable(0); 
00D76:  BCF    F8C.0
00D78:  BCF    F95.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00D7A:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00D7C:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00D7E:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00D80:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00D82:  MOVLB  1
00D84:  SWAPF  x7B,W
00D86:  MOVWF  00
00D88:  MOVLW  F0
00D8A:  ANDWF  00,F
00D8C:  MOVF   00,W
00D8E:  IORWF  x7A,W
00D90:  MOVWF  01
00D92:  MOVLB  0
00D94:  GOTO   0DA4 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00CF0:  MOVLB  1
00CF2:  CLRF   x7C
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00CF4:  BSF    F95.4
00CF6:  MOVLW  00
00CF8:  BTFSC  F83.4
00CFA:  MOVLW  01
00CFC:  IORWF  x7C,F
....................    n |= input(LCD_DATA5) << 1; 
00CFE:  BSF    F95.5
00D00:  MOVLW  00
00D02:  BTFSC  F83.5
00D04:  MOVLW  01
00D06:  MOVWF  00
00D08:  BCF    FD8.0
00D0A:  RLCF   00,F
00D0C:  MOVF   00,W
00D0E:  IORWF  x7C,F
....................    n |= input(LCD_DATA6) << 2; 
00D10:  BSF    F95.6
00D12:  MOVLW  00
00D14:  BTFSC  F83.6
00D16:  MOVLW  01
00D18:  MOVWF  00
00D1A:  RLCF   00,F
00D1C:  RLCF   00,F
00D1E:  MOVLW  FC
00D20:  ANDWF  00,F
00D22:  MOVF   00,W
00D24:  IORWF  x7C,F
....................    n |= input(LCD_DATA7) << 3; 
00D26:  BSF    F95.7
00D28:  MOVLW  00
00D2A:  BTFSC  F83.7
00D2C:  MOVLW  01
00D2E:  MOVWF  00
00D30:  RLCF   00,F
00D32:  RLCF   00,F
00D34:  RLCF   00,F
00D36:  MOVLW  F8
00D38:  ANDWF  00,F
00D3A:  MOVF   00,W
00D3C:  IORWF  x7C,F
....................     
....................    return(n); 
00D3E:  MOVFF  17C,01
....................   #else 
00D42:  MOVLB  0
00D44:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00CA4:  MOVLB  1
00CA6:  BTFSC  x7B.0
00CA8:  BRA    0CAE
00CAA:  BCF    F8C.4
00CAC:  BRA    0CB0
00CAE:  BSF    F8C.4
00CB0:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00CB2:  BTFSC  x7B.1
00CB4:  BRA    0CBA
00CB6:  BCF    F8C.5
00CB8:  BRA    0CBC
00CBA:  BSF    F8C.5
00CBC:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00CBE:  BTFSC  x7B.2
00CC0:  BRA    0CC6
00CC2:  BCF    F8C.6
00CC4:  BRA    0CC8
00CC6:  BSF    F8C.6
00CC8:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00CCA:  BTFSC  x7B.3
00CCC:  BRA    0CD2
00CCE:  BCF    F8C.7
00CD0:  BRA    0CD4
00CD2:  BSF    F8C.7
00CD4:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00CD6:  NOP   
....................    lcd_output_enable(1); 
00CD8:  BSF    F8C.0
00CDA:  BCF    F95.0
....................    delay_us(2); 
00CDC:  MOVLW  02
00CDE:  MOVWF  00
00CE0:  DECFSZ 00,F
00CE2:  BRA    0CE0
00CE4:  BRA    0CE6
00CE6:  NOP   
....................    lcd_output_enable(0); 
00CE8:  BCF    F8C.0
00CEA:  BCF    F95.0
00CEC:  MOVLB  0
00CEE:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00D98:  BCF    F95.0
....................    lcd_rs_tris(); 
00D9A:  BCF    F95.2
....................    lcd_rw_tris(); 
00D9C:  BCF    F95.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00D9E:  BCF    F8C.2
00DA0:  BCF    F95.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
00DA2:  BRA    0D46
00DA4:  MOVFF  01,17A
00DA8:  MOVLB  1
00DAA:  BTFSS  01.7
00DAC:  BRA    0DB2
00DAE:  MOVLB  0
00DB0:  BRA    0DA2
....................    lcd_output_rs(address); 
00DB2:  MOVF   x78,F
00DB4:  BNZ   0DBA
00DB6:  BCF    F8C.2
00DB8:  BRA    0DBC
00DBA:  BSF    F8C.2
00DBC:  BCF    F95.2
....................    delay_cycles(1); 
00DBE:  NOP   
....................    lcd_output_rw(0); 
00DC0:  BCF    F8C.1
00DC2:  BCF    F95.1
....................    delay_cycles(1); 
00DC4:  NOP   
....................    lcd_output_enable(0); 
00DC6:  BCF    F8C.0
00DC8:  BCF    F95.0
....................    lcd_send_nibble(n >> 4); 
00DCA:  SWAPF  x79,W
00DCC:  MOVWF  x7A
00DCE:  MOVLW  0F
00DD0:  ANDWF  x7A,F
00DD2:  MOVFF  17A,17B
00DD6:  MOVLB  0
00DD8:  RCALL  0CA4
....................    lcd_send_nibble(n & 0xf); 
00DDA:  MOVLB  1
00DDC:  MOVF   x79,W
00DDE:  ANDLW  0F
00DE0:  MOVWF  x7A
00DE2:  MOVWF  x7B
00DE4:  MOVLB  0
00DE6:  RCALL  0CA4
00DE8:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00DEA:  MOVLW  28
00DEC:  MOVLB  1
00DEE:  MOVWF  x6B
00DF0:  MOVLW  0C
00DF2:  MOVWF  x6C
00DF4:  MOVLW  01
00DF6:  MOVWF  x6D
00DF8:  MOVLW  06
00DFA:  MOVWF  x6E
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00DFC:  BCF    F8C.0
00DFE:  BCF    F95.0
....................    lcd_output_rs(0); 
00E00:  BCF    F8C.2
00E02:  BCF    F95.2
....................    lcd_output_rw(0); 
00E04:  BCF    F8C.1
00E06:  BCF    F95.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00E08:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00E0A:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00E0C:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00E0E:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00E10:  BCF    F95.0
....................    lcd_rs_tris(); 
00E12:  BCF    F95.2
....................    lcd_rw_tris(); 
00E14:  BCF    F95.1
....................  #endif 
....................      
....................    delay_ms(15); 
00E16:  MOVLW  0F
00E18:  MOVWF  xCD
00E1A:  MOVLB  0
00E1C:  RCALL  0C5A
....................    for(i=1;i<=3;++i) 
00E1E:  MOVLW  01
00E20:  MOVLB  1
00E22:  MOVWF  x6A
00E24:  MOVF   x6A,W
00E26:  SUBLW  03
00E28:  BNC   0E42
....................    { 
....................        lcd_send_nibble(3); 
00E2A:  MOVLW  03
00E2C:  MOVWF  x7B
00E2E:  MOVLB  0
00E30:  RCALL  0CA4
....................        delay_ms(5); 
00E32:  MOVLW  05
00E34:  MOVLB  1
00E36:  MOVWF  xCD
00E38:  MOVLB  0
00E3A:  RCALL  0C5A
00E3C:  MOVLB  1
00E3E:  INCF   x6A,F
00E40:  BRA    0E24
....................    } 
....................     
....................    lcd_send_nibble(2); 
00E42:  MOVLW  02
00E44:  MOVWF  x7B
00E46:  MOVLB  0
00E48:  RCALL  0CA4
....................    delay_ms(5); 
00E4A:  MOVLW  05
00E4C:  MOVLB  1
00E4E:  MOVWF  xCD
00E50:  MOVLB  0
00E52:  RCALL  0C5A
....................    for(i=0;i<=3;++i) 
00E54:  MOVLB  1
00E56:  CLRF   x6A
00E58:  MOVF   x6A,W
00E5A:  SUBLW  03
00E5C:  BNC   0E80
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00E5E:  CLRF   03
00E60:  MOVF   x6A,W
00E62:  ADDLW  6B
00E64:  MOVWF  FE9
00E66:  MOVLW  01
00E68:  ADDWFC 03,W
00E6A:  MOVWF  FEA
00E6C:  MOVFF  FEF,16F
00E70:  CLRF   x78
00E72:  MOVFF  16F,179
00E76:  MOVLB  0
00E78:  RCALL  0D98
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00E7A:  MOVLB  1
00E7C:  INCF   x6A,F
00E7E:  BRA    0E58
00E80:  MOVLB  0
00E82:  GOTO   2DA8 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00E86:  MOVLB  1
00E88:  DECFSZ x75,W
00E8A:  BRA    0E8E
00E8C:  BRA    0E94
....................       address=LCD_LINE_TWO; 
00E8E:  MOVLW  40
00E90:  MOVWF  x76
00E92:  BRA    0E96
....................    else 
....................       address=0; 
00E94:  CLRF   x76
....................       
....................    address+=x-1; 
00E96:  MOVLW  01
00E98:  SUBWF  x74,W
00E9A:  ADDWF  x76,F
....................    lcd_send_byte(0,0x80|address); 
00E9C:  MOVF   x76,W
00E9E:  IORLW  80
00EA0:  MOVWF  x77
00EA2:  CLRF   x78
00EA4:  MOVWF  x79
00EA6:  MOVLB  0
00EA8:  RCALL  0D98
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00EAA:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00EAC:  MOVLB  1
00EAE:  MOVF   x73,W
00EB0:  XORLW  07
00EB2:  MOVLB  0
00EB4:  BZ    0EC4
00EB6:  XORLW  0B
00EB8:  BZ    0ED2
00EBA:  XORLW  06
00EBC:  BZ    0EEA
00EBE:  XORLW  02
00EC0:  BZ    0EFA
00EC2:  BRA    0F08
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00EC4:  MOVLW  01
00EC6:  MOVLB  1
00EC8:  MOVWF  x74
00ECA:  MOVWF  x75
00ECC:  MOVLB  0
00ECE:  RCALL  0E86
00ED0:  BRA    0F16
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
00ED2:  MOVLB  1
00ED4:  CLRF   x78
00ED6:  MOVLW  01
00ED8:  MOVWF  x79
00EDA:  MOVLB  0
00EDC:  RCALL  0D98
....................                      delay_ms(2); 
00EDE:  MOVLW  02
00EE0:  MOVLB  1
00EE2:  MOVWF  xCD
00EE4:  MOVLB  0
00EE6:  RCALL  0C5A
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
00EE8:  BRA    0F16
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00EEA:  MOVLW  01
00EEC:  MOVLB  1
00EEE:  MOVWF  x74
00EF0:  MOVLW  02
00EF2:  MOVWF  x75
00EF4:  MOVLB  0
00EF6:  RCALL  0E86
00EF8:  BRA    0F16
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00EFA:  MOVLB  1
00EFC:  CLRF   x78
00EFE:  MOVLW  10
00F00:  MOVWF  x79
00F02:  MOVLB  0
00F04:  RCALL  0D98
00F06:  BRA    0F16
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
00F08:  MOVLW  01
00F0A:  MOVLB  1
00F0C:  MOVWF  x78
00F0E:  MOVFF  173,179
00F12:  MOVLB  0
00F14:  RCALL  0D98
....................      #endif 
....................    } 
00F16:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
01FFC:  MOVLB  1
01FFE:  CLRF   x75
02000:  CLRF   x74
02002:  CLRF   x77
02004:  CLRF   x76
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
02006:  MOVF   x71,F
02008:  BNZ   2012
0200A:  MOVF   x70,W
0200C:  SUBLW  13
0200E:  BTFSC  FD8.0
02010:  BRA    2140
02012:  MOVF   x71,W
02014:  SUBLW  4E
02016:  BTFSS  FD8.0
02018:  BRA    2140
0201A:  BNZ   2024
0201C:  MOVF   x70,W
0201E:  SUBLW  20
02020:  BTFSS  FD8.0
02022:  BRA    2140
....................       tmp=100000; 
02024:  CLRF   x7D
02026:  MOVLW  01
02028:  MOVWF  x7C
0202A:  MOVLW  86
0202C:  MOVWF  x7B
0202E:  MOVLW  A0
02030:  MOVWF  x7A
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
02032:  BCF    FD8.1
02034:  MOVFF  17D,181
02038:  MOVFF  17C,180
0203C:  MOVFF  17B,17F
02040:  MOVFF  17A,17E
02044:  CLRF   x85
02046:  CLRF   x84
02048:  MOVFF  171,183
0204C:  MOVFF  170,182
02050:  MOVLB  0
02052:  BRA    1EEA
02054:  MOVFF  03,17D
02058:  MOVFF  02,17C
0205C:  MOVFF  01,17B
02060:  MOVFF  00,17A
....................       tmp*=5;    
02064:  MOVFF  17D,181
02068:  MOVFF  17C,180
0206C:  MOVFF  17B,17F
02070:  MOVFF  17A,17E
02074:  MOVLB  1
02076:  CLRF   x85
02078:  CLRF   x84
0207A:  CLRF   x83
0207C:  MOVLW  05
0207E:  MOVWF  x82
02080:  MOVLB  0
02082:  BRA    1F80
02084:  MOVFF  03,17D
02088:  MOVFF  02,17C
0208C:  MOVFF  01,17B
02090:  MOVFF  00,17A
....................       uS=tmp; 
02094:  MOVFF  17B,179
02098:  MOVFF  17A,178
....................       do{ 
....................          output_high(Speaker);   // Genera la frecuancia deseada 
0209C:  BCF    F93.2
0209E:  BSF    F8A.2
....................          delay_us(uS);           // con los retardos mientras 
020A0:  MOVFF  179,17E
020A4:  MOVLB  1
020A6:  INCF   x7E,F
020A8:  DECF   x7E,F
020AA:  BTFSC  FD8.2
020AC:  BRA    20B8
020AE:  SETF   x7F
020B0:  MOVLB  0
020B2:  RCALL  1FDC
020B4:  MOVLB  1
020B6:  BRA    20A8
020B8:  MOVFF  178,17F
020BC:  MOVLB  0
020BE:  RCALL  1FDC
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
020C0:  MOVLB  1
020C2:  MOVF   x78,W
020C4:  ADDWF  x76,F
020C6:  MOVF   x79,W
020C8:  ADDWFC x77,F
....................          output_low(Speaker);    // en dos partes para repartir el  
020CA:  BCF    F93.2
020CC:  BCF    F8A.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
020CE:  MOVFF  179,17E
020D2:  INCF   x7E,F
020D4:  DECF   x7E,F
020D6:  BTFSC  FD8.2
020D8:  BRA    20E4
020DA:  SETF   x7F
020DC:  MOVLB  0
020DE:  RCALL  1FDC
020E0:  MOVLB  1
020E2:  BRA    20D4
020E4:  MOVFF  178,17F
020E8:  MOVLB  0
020EA:  RCALL  1FDC
....................          CiclosL+=(uS);          //  
020EC:  MOVLB  1
020EE:  MOVF   x78,W
020F0:  ADDWF  x76,F
020F2:  MOVF   x79,W
020F4:  ADDWFC x77,F
....................          CiclosL+=25;            // Compensador. 
020F6:  MOVLW  19
020F8:  ADDWF  x76,F
020FA:  MOVLW  00
020FC:  ADDWFC x77,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
020FE:  MOVF   x77,W
02100:  SUBLW  02
02102:  BC    2126
02104:  XORLW  FF
02106:  BNZ   210E
02108:  MOVF   x76,W
0210A:  SUBLW  E7
0210C:  BC    2126
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0210E:  MOVLW  E8
02110:  SUBWF  x76,F
02112:  MOVLW  03
02114:  SUBWFB x77,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
02116:  INCF   x74,F
02118:  BTFSC  FD8.2
0211A:  INCF   x75,F
....................             CiclosL+=25;         // Compensador. 
0211C:  MOVLW  19
0211E:  ADDWF  x76,F
02120:  MOVLW  00
02122:  ADDWFC x77,F
02124:  BRA    20FE
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
02126:  MOVF   x75,W
02128:  SUBWF  x73,W
0212A:  BNC   2140
0212C:  BTFSC  FD8.2
0212E:  BRA    2134
02130:  MOVLB  0
02132:  BRA    209C
02134:  MOVF   x72,W
02136:  SUBWF  x74,W
02138:  BTFSC  FD8.0
0213A:  BRA    2140
0213C:  MOVLB  0
0213E:  BRA    209C
....................                                          // tiempo indicado. 
....................    } 
02140:  MOVLB  0
02142:  RETURN 0
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          CMD_WIFI.H: Comandos Ejecutados desde 
....................                               wifi. 
....................  
.................... *******************************************************/ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando  
.................... // ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /********************************************************** 
....................    Funcion Busca la cadena de inicio recepcion de request,  
....................    y retorna el ID de la conexion 
.................... ***********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
009E0:  MOVLW  05
009E2:  MOVLB  1
009E4:  MOVWF  xD8
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
009E6:  DECFSZ 55,W
009E8:  BRA    0A10
....................        
....................       if(buffer!=','){ 
009EA:  MOVF   xD6,W
009EC:  SUBLW  2C
009EE:  BNZ   09F4
009F0:  MOVF   xD7,F
009F2:  BZ    0A0A
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
009F4:  CLRF   03
009F6:  MOVF   59,W
009F8:  ADDLW  1C
009FA:  MOVWF  FE9
009FC:  MOVLW  00
009FE:  ADDWFC 03,W
00A00:  MOVWF  FEA
00A02:  MOVFF  1D6,FEF
....................          flag_Pos_Resp_IPD++; 
00A06:  INCF   59,F
....................       }else{ 
00A08:  BRA    0A0E
....................          flag_Pos_Resp_IPD       = 0x00; 
00A0A:  CLRF   59
....................          flag_Resp_IPD           = 0x00; 
00A0C:  CLRF   55
....................       } 
....................    }else{ 
00A0E:  BRA    0A42
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
00A10:  CLRF   03
00A12:  MOVF   59,W
00A14:  MOVFF  FF2,1D9
00A18:  BCF    FF2.7
00A1A:  MOVLB  0
00A1C:  CALL   00C0
00A20:  MOVLB  1
00A22:  BTFSC  xD9.7
00A24:  BSF    FF2.7
00A26:  MOVWF  01
00A28:  SUBWF  xD6,W
00A2A:  BNZ   0A40
00A2C:  MOVF   xD7,F
00A2E:  BNZ   0A40
....................       { 
....................          flag_Pos_Resp_IPD++; 
00A30:  INCF   59,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
00A32:  MOVF   xD8,W
00A34:  SUBWF  59,W
00A36:  BNZ   0A3E
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
00A38:  MOVLW  01
00A3A:  MOVWF  55
....................             flag_Pos_Resp_IPD = 0; 
00A3C:  CLRF   59
....................          } 
....................       }else{ 
00A3E:  BRA    0A42
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
00A40:  CLRF   59
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00A42:  MOVLB  0
00A44:  GOTO   0BCA (RETURN)
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
....................    Busca la cadena de inicio comando, y retorna el  
....................    Comando enviado, Activa la bandera de recepcion  
....................    de datos 
.................... *********************************************************/ 
.................... void ESP8266_Get_CMD(char buffer[]){ 
00A48:  MOVLW  04
00A4A:  MOVLB  1
00A4C:  MOVWF  xD8
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
00A4E:  DECFSZ 54,W
00A50:  BRA    0A7C
....................     
....................       if(buffer!=','){ 
00A52:  MOVF   xD6,W
00A54:  SUBLW  2C
00A56:  BNZ   0A5C
00A58:  MOVF   xD7,F
00A5A:  BZ    0A72
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
00A5C:  CLRF   03
00A5E:  MOVF   58,W
00A60:  ADDLW  1E
00A62:  MOVWF  FE9
00A64:  MOVLW  00
00A66:  ADDWFC 03,W
00A68:  MOVWF  FEA
00A6A:  MOVFF  1D6,FEF
....................          flag_Pos_Resp_CMD++; 
00A6E:  INCF   58,F
....................       }else{         
00A70:  BRA    0A7A
....................          flag_Pos_Resp_CMD = 0x00; 
00A72:  CLRF   58
....................          flag_Resp_CMD     = 0x00; 
00A74:  CLRF   54
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
00A76:  MOVLW  01
00A78:  MOVWF  56
....................       } 
....................        
....................    }else{ 
00A7A:  BRA    0AAE
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
00A7C:  CLRF   03
00A7E:  MOVF   58,W
00A80:  MOVFF  FF2,1D9
00A84:  BCF    FF2.7
00A86:  MOVLB  0
00A88:  CALL   00D6
00A8C:  MOVLB  1
00A8E:  BTFSC  xD9.7
00A90:  BSF    FF2.7
00A92:  MOVWF  01
00A94:  SUBWF  xD6,W
00A96:  BNZ   0AAC
00A98:  MOVF   xD7,F
00A9A:  BNZ   0AAC
....................       { 
....................          flag_Pos_Resp_CMD++; 
00A9C:  INCF   58,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
00A9E:  MOVF   xD8,W
00AA0:  SUBWF  58,W
00AA2:  BNZ   0AAA
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
00AA4:  MOVLW  01
00AA6:  MOVWF  54
....................             flag_Pos_Resp_CMD = 0; 
00AA8:  CLRF   58
....................          } 
....................       }else{ 
00AAA:  BRA    0AAE
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
00AAC:  CLRF   58
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00AAE:  MOVLB  0
00AB0:  GOTO   0BD6 (RETURN)
.................... } 
....................  
.................... /*********************************************************** 
....................    Verifica si la bandera de recepcion de datos esta 
....................    activa y almacena los datos entrantes en el arreglo 
....................    DATA_COMMAND, Finaliza la captura de caracteres cuando 
....................    encuentra el caracter ":". 
.................... ************************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
00AB4:  DECFSZ 56,W
00AB6:  BRA    0AFA
....................       if(buffer!=':'){ 
00AB8:  MOVLB  1
00ABA:  MOVF   xD6,W
00ABC:  SUBLW  3A
00ABE:  BNZ   0AC4
00AC0:  MOVF   xD7,F
00AC2:  BZ    0AF2
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
00AC4:  CLRF   03
00AC6:  MOVF   5A,W
00AC8:  ADDLW  20
00ACA:  MOVWF  FE9
00ACC:  MOVLW  00
00ACE:  ADDWFC 03,W
00AD0:  MOVWF  FEA
00AD2:  MOVFF  1D6,FEF
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
00AD6:  CLRF   53
00AD8:  MOVFF  5A,52
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
00ADC:  MOVF   5A,F
00ADE:  BNZ   0AEE
00AE0:  MOVF   xD6,W
00AE2:  SUBLW  2C
00AE4:  BNZ   0AEE
00AE6:  MOVF   xD7,F
00AE8:  BNZ   0AEE
....................             flag_Pos_Resp_Data=0; 
00AEA:  CLRF   5A
....................          }else{ 
00AEC:  BRA    0AF0
....................             flag_Pos_Resp_Data++; 
00AEE:  INCF   5A,F
....................          } 
....................           
....................       }else{ 
00AF0:  BRA    0AFA
....................          flag_Pos_Resp_Data      = 0x00; 
00AF2:  CLRF   5A
....................          flag_Resp_StartGetData  = 0x00; 
00AF4:  CLRF   56
....................          flag_Resp_Ready         = 1; 
00AF6:  MOVLW  01
00AF8:  MOVWF  57
00AFA:  MOVLB  0
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
00AFC:  GOTO   0BE2 (RETURN)
.................... } // Fin Funcion ESP8266_Get_Data 
....................  
.................... /***************************************************** 
....................    Verifica si se ha recibido algun comando enviado 
....................    por WiFi y lo ejecuta.  
.................... *****************************************************/ 
.................... int run_command_wifi(void){ 
*
01492:  MOVLB  1
01494:  CLRF   x71
01496:  CLRF   x72
01498:  CLRF   x73
0149A:  CLRF   x74
0149C:  CLRF   x75
0149E:  MOVLW  1E
014A0:  MOVWF  x76
....................    int8 reset = 0, OS_CMD = 0 ,optSelected  = 0,counter = 0, idxRSTNC = 0,lenResponse = 30; 
....................    char response[57]    = "HTTP/1.1 200 OK\n\n{\"cmd\":\"ok\"}\n"; 
014A2:  MOVLW  48
014A4:  MOVWF  x77
014A6:  MOVLW  54
014A8:  MOVWF  x78
014AA:  MOVWF  x79
014AC:  MOVLW  50
014AE:  MOVWF  x7A
014B0:  MOVLW  2F
014B2:  MOVWF  x7B
014B4:  MOVLW  31
014B6:  MOVWF  x7C
014B8:  MOVLW  2E
014BA:  MOVWF  x7D
014BC:  MOVLW  31
014BE:  MOVWF  x7E
014C0:  MOVLW  20
014C2:  MOVWF  x7F
014C4:  MOVLW  32
014C6:  MOVWF  x80
014C8:  MOVLW  30
014CA:  MOVWF  x81
014CC:  MOVWF  x82
014CE:  MOVLW  20
014D0:  MOVWF  x83
014D2:  MOVLW  4F
014D4:  MOVWF  x84
014D6:  MOVLW  4B
014D8:  MOVWF  x85
014DA:  MOVLW  0A
014DC:  MOVWF  x86
014DE:  MOVWF  x87
014E0:  MOVLW  7B
014E2:  MOVWF  x88
014E4:  MOVLW  22
014E6:  MOVWF  x89
014E8:  MOVLW  63
014EA:  MOVWF  x8A
014EC:  MOVLW  6D
014EE:  MOVWF  x8B
014F0:  MOVLW  64
014F2:  MOVWF  x8C
014F4:  MOVLW  22
014F6:  MOVWF  x8D
014F8:  MOVLW  3A
014FA:  MOVWF  x8E
014FC:  MOVLW  22
014FE:  MOVWF  x8F
01500:  MOVLW  6F
01502:  MOVWF  x90
01504:  MOVLW  6B
01506:  MOVWF  x91
01508:  MOVLW  22
0150A:  MOVWF  x92
0150C:  MOVLW  7D
0150E:  MOVWF  x93
01510:  MOVLW  0A
01512:  MOVWF  x94
01514:  CLRF   x95
....................     
....................    char headers[]       = "Content-Type: text/html"; 
01516:  MOVLW  43
01518:  MOVWF  xB0
0151A:  MOVLW  6F
0151C:  MOVWF  xB1
0151E:  MOVLW  6E
01520:  MOVWF  xB2
01522:  MOVLW  74
01524:  MOVWF  xB3
01526:  MOVLW  65
01528:  MOVWF  xB4
0152A:  MOVLW  6E
0152C:  MOVWF  xB5
0152E:  MOVLW  74
01530:  MOVWF  xB6
01532:  MOVLW  2D
01534:  MOVWF  xB7
01536:  MOVLW  54
01538:  MOVWF  xB8
0153A:  MOVLW  79
0153C:  MOVWF  xB9
0153E:  MOVLW  70
01540:  MOVWF  xBA
01542:  MOVLW  65
01544:  MOVWF  xBB
01546:  MOVLW  3A
01548:  MOVWF  xBC
0154A:  MOVLW  20
0154C:  MOVWF  xBD
0154E:  MOVLW  74
01550:  MOVWF  xBE
01552:  MOVLW  65
01554:  MOVWF  xBF
01556:  MOVLW  78
01558:  MOVWF  xC0
0155A:  MOVLW  74
0155C:  MOVWF  xC1
0155E:  MOVLW  2F
01560:  MOVWF  xC2
01562:  MOVLW  68
01564:  MOVWF  xC3
01566:  MOVLW  74
01568:  MOVWF  xC4
0156A:  MOVLW  6D
0156C:  MOVWF  xC5
0156E:  MOVLW  6C
01570:  MOVWF  xC6
01572:  CLRF   xC7
....................     
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
01574:  DECFSZ 57,W
01576:  GOTO   1EE2
....................     
....................       /***************************** 
....................       *** Reinicia el Dispositivo ** 
....................       *** CMD:OP,[0|1][0-7]:      ** 
....................       *****************************/ 
....................       if(COMMAND[0]=='R' && 
....................          COMMAND[1]=='S') 
0157A:  MOVF   1E,W
0157C:  SUBLW  52
0157E:  BNZ   1650
01580:  MOVF   1F,W
01582:  SUBLW  53
01584:  BNZ   1650
....................       { 
....................                   
....................          // Body 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01586:  MOVLW  5E
01588:  MOVWF  FF6
0158A:  MOVLW  01
0158C:  MOVWF  FF7
0158E:  MOVLW  0B
01590:  MOVWF  xCC
01592:  MOVLB  0
01594:  RCALL  0F38
01596:  MOVF   1C,W
01598:  BTFSS  F9E.4
0159A:  BRA    1598
0159C:  MOVWF  FAD
0159E:  MOVLW  2C
015A0:  BTFSS  F9E.4
015A2:  BRA    15A0
015A4:  MOVWF  FAD
015A6:  MOVFF  176,1CC
015AA:  MOVLW  1B
015AC:  MOVLB  1
015AE:  MOVWF  xCD
015B0:  MOVLB  0
015B2:  RCALL  1414
015B4:  MOVLW  0D
015B6:  BTFSS  F9E.4
015B8:  BRA    15B6
015BA:  MOVWF  FAD
015BC:  MOVLW  0A
015BE:  BTFSS  F9E.4
015C0:  BRA    15BE
015C2:  MOVWF  FAD
....................          delay_ms(60); 
015C4:  MOVLW  3C
015C6:  MOVLB  1
015C8:  MOVWF  xCD
015CA:  MOVLB  0
015CC:  CALL   0C5A
....................          fprintf(ESP8266, "%s\n\r",response); 
015D0:  MOVLW  01
015D2:  MOVWF  FEA
015D4:  MOVLW  77
015D6:  MOVWF  FE9
015D8:  RCALL  1052
015DA:  MOVLW  0A
015DC:  BTFSS  F9E.4
015DE:  BRA    15DC
015E0:  MOVWF  FAD
015E2:  MOVLW  0D
015E4:  BTFSS  F9E.4
015E6:  BRA    15E4
015E8:  MOVWF  FAD
....................          delay_ms(120); 
015EA:  MOVLW  78
015EC:  MOVLB  1
015EE:  MOVWF  xCD
015F0:  MOVLB  0
015F2:  CALL   0C5A
....................                           
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],1); 
015F6:  MOVLW  72
015F8:  MOVWF  FF6
015FA:  MOVLW  01
015FC:  MOVWF  FF7
015FE:  MOVLW  0B
01600:  MOVLB  1
01602:  MOVWF  xCC
01604:  MOVLB  0
01606:  RCALL  0F38
01608:  MOVF   1C,W
0160A:  BTFSS  F9E.4
0160C:  BRA    160A
0160E:  MOVWF  FAD
01610:  MOVLW  2C
01612:  BTFSS  F9E.4
01614:  BRA    1612
01616:  MOVWF  FAD
01618:  MOVLW  01
0161A:  MOVLB  1
0161C:  MOVWF  xCC
0161E:  MOVLW  1B
01620:  MOVWF  xCD
01622:  MOVLB  0
01624:  RCALL  1414
01626:  MOVLW  0D
01628:  BTFSS  F9E.4
0162A:  BRA    1628
0162C:  MOVWF  FAD
0162E:  MOVLW  0A
01630:  BTFSS  F9E.4
01632:  BRA    1630
01634:  MOVWF  FAD
....................          delay_ms(500); 
01636:  MOVLW  02
01638:  MOVLB  1
0163A:  MOVWF  xCC
0163C:  MOVLW  FA
0163E:  MOVWF  xCD
01640:  MOVLB  0
01642:  CALL   0C5A
01646:  MOVLB  1
01648:  DECFSZ xCC,F
0164A:  BRA    163C
....................           
....................          reset = 1;          
0164C:  MOVLW  01
0164E:  MOVWF  x71
....................       } // Fin comando RS 
....................        
....................       /************************** 
....................       *** Activa o desactiva   ** 
....................       *** los puertos          ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
01650:  MOVF   1E,W
01652:  SUBLW  4F
01654:  BNZ   1712
01656:  MOVF   1F,W
01658:  SUBLW  50
0165A:  BNZ   1712
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
0165C:  MOVLW  30
0165E:  SUBWF  21,W
01660:  MOVWF  x73
....................           
....................          switch(DATA_COMMAND[0]){ 
01662:  MOVF   20,W
01664:  XORLW  30
01666:  MOVLB  0
01668:  BZ    1670
0166A:  XORLW  01
0166C:  BZ    16C0
0166E:  BRA    1710
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
01670:  BCF    FD8.0
01672:  MOVLB  1
01674:  RLCF   x73,W
01676:  CLRF   03
01678:  MOVFF  FF2,1CC
0167C:  BCF    FF2.7
0167E:  MOVLB  0
01680:  CALL   0096
01684:  TBLRD*+
01686:  MOVFF  FF5,03
0168A:  MOVLB  1
0168C:  BTFSC  xCC.7
0168E:  BSF    FF2.7
01690:  MOVWF  xCC
01692:  MOVFF  03,1CD
01696:  MOVWF  xCE
01698:  CLRF   xCF
0169A:  MOVLW  0F
0169C:  MOVWF  xD1
0169E:  MOVLW  89
016A0:  MOVWF  xD0
016A2:  MOVLB  0
016A4:  CALL   0C18
016A8:  MOVFF  1CC,1CE
016AC:  MOVLB  1
016AE:  CLRF   xCF
016B0:  MOVLW  0F
016B2:  MOVWF  xD1
016B4:  MOVLW  92
016B6:  MOVWF  xD0
016B8:  MOVLB  0
016BA:  CALL   0C18
....................                break; 
016BE:  BRA    1710
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
016C0:  BCF    FD8.0
016C2:  MOVLB  1
016C4:  RLCF   x73,W
016C6:  CLRF   03
016C8:  MOVFF  FF2,1CC
016CC:  BCF    FF2.7
016CE:  MOVLB  0
016D0:  CALL   0096
016D4:  TBLRD*+
016D6:  MOVFF  FF5,03
016DA:  MOVLB  1
016DC:  BTFSC  xCC.7
016DE:  BSF    FF2.7
016E0:  MOVWF  xCC
016E2:  MOVFF  03,1CD
016E6:  MOVWF  xCE
016E8:  MOVLW  01
016EA:  MOVWF  xCF
016EC:  MOVLW  0F
016EE:  MOVWF  xD1
016F0:  MOVLW  89
016F2:  MOVWF  xD0
016F4:  MOVLB  0
016F6:  CALL   0C18
016FA:  MOVFF  1CC,1CE
016FE:  MOVLB  1
01700:  CLRF   xCF
01702:  MOVLW  0F
01704:  MOVWF  xD1
01706:  MOVLW  92
01708:  MOVWF  xD0
0170A:  MOVLB  0
0170C:  CALL   0C18
....................                break; 
01710:  MOVLB  1
....................          } 
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
01712:  MOVF   1E,W
01714:  SUBLW  4E
01716:  BTFSS  FD8.2
01718:  BRA    1928
0171A:  MOVF   1F,W
0171C:  SUBLW  43
0171E:  BTFSS  FD8.2
01720:  BRA    1928
....................       { 
....................          // Borra la eeprom para almacenar las nuevas credenciales 
....................          // Desde la posicion 0x01 hasta 0x027 
....................          for(idxRSTNC=1;idxRSTNC<=27;idxRSTNC++){ 
01722:  MOVLW  01
01724:  MOVWF  x75
01726:  MOVF   x75,W
01728:  SUBLW  1B
0172A:  BNC   1768
....................             write_eeprom(idxRSTNC,0xFF); 
0172C:  MOVF   FF2,W
0172E:  MOVWF  00
01730:  BCF    FF2.7
01732:  CLRF   FAA
01734:  MOVFF  175,FA9
01738:  SETF   FA8
0173A:  BCF    FA6.6
0173C:  BCF    FA6.7
0173E:  BSF    FA6.2
01740:  MOVLB  F
01742:  MOVLW  55
01744:  MOVWF  FA7
01746:  MOVLW  AA
01748:  MOVWF  FA7
0174A:  BSF    FA6.1
0174C:  BTFSC  FA6.1
0174E:  BRA    174C
01750:  BCF    FA6.2
01752:  MOVF   00,W
01754:  IORWF  FF2,F
....................             delay_ms(10); 
01756:  MOVLW  0A
01758:  MOVLB  1
0175A:  MOVWF  xCD
0175C:  MOVLB  0
0175E:  CALL   0C5A
01762:  MOVLB  1
01764:  INCF   x75,F
01766:  BRA    1726
....................          } 
....................           
....................          // Guarda las nuevas credenciales 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
01768:  CLRF   xC8
0176A:  MOVF   53,F
0176C:  BNZ   1774
0176E:  MOVF   xC8,W
01770:  SUBWF  52,W
01772:  BNC   17CA
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
01774:  MOVLW  01
01776:  ADDWF  xC8,W
01778:  MOVWF  xCC
0177A:  CLRF   03
0177C:  MOVF   xC8,W
0177E:  ADDLW  20
01780:  MOVWF  FE9
01782:  MOVLW  00
01784:  ADDWFC 03,W
01786:  MOVWF  FEA
01788:  MOVFF  FEF,1CD
0178C:  MOVF   FF2,W
0178E:  MOVWF  00
01790:  BCF    FF2.7
01792:  CLRF   FAA
01794:  MOVFF  1CC,FA9
01798:  MOVFF  1CD,FA8
0179C:  BCF    FA6.6
0179E:  BCF    FA6.7
017A0:  BSF    FA6.2
017A2:  MOVLB  F
017A4:  MOVLW  55
017A6:  MOVWF  FA7
017A8:  MOVLW  AA
017AA:  MOVWF  FA7
017AC:  BSF    FA6.1
017AE:  BTFSC  FA6.1
017B0:  BRA    17AE
017B2:  BCF    FA6.2
017B4:  MOVF   00,W
017B6:  IORWF  FF2,F
....................             delay_ms(10); 
017B8:  MOVLW  0A
017BA:  MOVLB  1
017BC:  MOVWF  xCD
017BE:  MOVLB  0
017C0:  CALL   0C5A
017C4:  MOVLB  1
017C6:  INCF   xC8,F
017C8:  BRA    176A
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
017CA:  MOVLW  01
017CC:  ADDWF  xC8,W
017CE:  MOVWF  xCC
017D0:  MOVF   FF2,W
017D2:  MOVWF  00
017D4:  BCF    FF2.7
017D6:  CLRF   FAA
017D8:  MOVFF  1CC,FA9
017DC:  MOVLW  0D
017DE:  MOVWF  FA8
017E0:  BCF    FA6.6
017E2:  BCF    FA6.7
017E4:  BSF    FA6.2
017E6:  MOVLB  F
017E8:  MOVLW  55
017EA:  MOVWF  FA7
017EC:  MOVLW  AA
017EE:  MOVWF  FA7
017F0:  BSF    FA6.1
017F2:  BTFSC  FA6.1
017F4:  BRA    17F2
017F6:  BCF    FA6.2
017F8:  MOVF   00,W
017FA:  IORWF  FF2,F
....................          delay_ms(10); 
017FC:  MOVLW  0A
017FE:  MOVLB  1
01800:  MOVWF  xCD
01802:  MOVLB  0
01804:  CALL   0C5A
....................          write_eeprom(idxNC+2,0x0A); 
01808:  MOVLW  02
0180A:  MOVLB  1
0180C:  ADDWF  xC8,W
0180E:  MOVWF  xCC
01810:  MOVF   FF2,W
01812:  MOVWF  00
01814:  BCF    FF2.7
01816:  CLRF   FAA
01818:  MOVFF  1CC,FA9
0181C:  MOVLW  0A
0181E:  MOVWF  FA8
01820:  BCF    FA6.6
01822:  BCF    FA6.7
01824:  BSF    FA6.2
01826:  MOVLB  F
01828:  MOVLW  55
0182A:  MOVWF  FA7
0182C:  MOVLW  AA
0182E:  MOVWF  FA7
01830:  BSF    FA6.1
01832:  BTFSC  FA6.1
01834:  BRA    1832
01836:  BCF    FA6.2
01838:  MOVF   00,W
0183A:  IORWF  FF2,F
....................          delay_ms(30); 
0183C:  MOVLW  1E
0183E:  MOVLB  1
01840:  MOVWF  xCD
01842:  MOVLB  0
01844:  CALL   0C5A
....................                
....................          // Body 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01848:  MOVLW  86
0184A:  MOVWF  FF6
0184C:  MOVLW  01
0184E:  MOVWF  FF7
01850:  MOVLW  0B
01852:  MOVLB  1
01854:  MOVWF  xCC
01856:  MOVLB  0
01858:  CALL   0F38
0185C:  MOVF   1C,W
0185E:  BTFSS  F9E.4
01860:  BRA    185E
01862:  MOVWF  FAD
01864:  MOVLW  2C
01866:  BTFSS  F9E.4
01868:  BRA    1866
0186A:  MOVWF  FAD
0186C:  MOVFF  176,1CC
01870:  MOVLW  1B
01872:  MOVLB  1
01874:  MOVWF  xCD
01876:  MOVLB  0
01878:  RCALL  1414
0187A:  MOVLW  0D
0187C:  BTFSS  F9E.4
0187E:  BRA    187C
01880:  MOVWF  FAD
01882:  MOVLW  0A
01884:  BTFSS  F9E.4
01886:  BRA    1884
01888:  MOVWF  FAD
....................          delay_ms(60); 
0188A:  MOVLW  3C
0188C:  MOVLB  1
0188E:  MOVWF  xCD
01890:  MOVLB  0
01892:  CALL   0C5A
....................          fprintf(ESP8266, "%s\n\r",response); 
01896:  MOVLW  01
01898:  MOVWF  FEA
0189A:  MOVLW  77
0189C:  MOVWF  FE9
0189E:  CALL   1052
018A2:  MOVLW  0A
018A4:  BTFSS  F9E.4
018A6:  BRA    18A4
018A8:  MOVWF  FAD
018AA:  MOVLW  0D
018AC:  BTFSS  F9E.4
018AE:  BRA    18AC
018B0:  MOVWF  FAD
....................          delay_ms(120); 
018B2:  MOVLW  78
018B4:  MOVLB  1
018B6:  MOVWF  xCD
018B8:  MOVLB  0
018BA:  CALL   0C5A
....................  
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
018BE:  MOVLW  9A
018C0:  MOVWF  FF6
018C2:  MOVLW  01
018C4:  MOVWF  FF7
018C6:  MOVLW  0C
018C8:  MOVLB  1
018CA:  MOVWF  xCC
018CC:  MOVLB  0
018CE:  CALL   0F38
018D2:  MOVF   1C,W
018D4:  BTFSS  F9E.4
018D6:  BRA    18D4
018D8:  MOVWF  FAD
018DA:  MOVLW  0D
018DC:  BTFSS  F9E.4
018DE:  BRA    18DC
018E0:  MOVWF  FAD
018E2:  MOVLW  0A
018E4:  BTFSS  F9E.4
018E6:  BRA    18E4
018E8:  MOVWF  FAD
....................          delay_ms(500); 
018EA:  MOVLW  02
018EC:  MOVLB  1
018EE:  MOVWF  xCC
018F0:  MOVLW  FA
018F2:  MOVWF  xCD
018F4:  MOVLB  0
018F6:  CALL   0C5A
018FA:  MOVLB  1
018FC:  DECFSZ xCC,F
018FE:  BRA    18F0
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
01900:  MOVLW  AC
01902:  MOVWF  FF6
01904:  MOVLW  01
01906:  MOVWF  FF7
01908:  MOVLB  0
0190A:  CALL   0C82
....................          delay_ms(1000); 
0190E:  MOVLW  04
01910:  MOVLB  1
01912:  MOVWF  xCC
01914:  MOVLW  FA
01916:  MOVWF  xCD
01918:  MOVLB  0
0191A:  CALL   0C5A
0191E:  MOVLB  1
01920:  DECFSZ xCC,F
01922:  BRA    1914
....................           
....................          reset = 1; 
01924:  MOVLW  01
01926:  MOVWF  x71
....................       } // Fin comando NC 
....................        
....................       /********************************** 
....................       *** Cambia el SSID y Key del AP  ** 
....................       *** CMD:AP,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='A' && 
....................          COMMAND[1]=='P') 
01928:  MOVF   1E,W
0192A:  SUBLW  41
0192C:  BTFSS  FD8.2
0192E:  BRA    1A38
01930:  MOVF   1F,W
01932:  SUBLW  50
01934:  BTFSS  FD8.2
01936:  BRA    1A38
....................       { 
....................                         
....................          // Body 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01938:  MOVLW  B8
0193A:  MOVWF  FF6
0193C:  MOVLW  01
0193E:  MOVWF  FF7
01940:  MOVLW  0B
01942:  MOVWF  xCC
01944:  MOVLB  0
01946:  CALL   0F38
0194A:  MOVF   1C,W
0194C:  BTFSS  F9E.4
0194E:  BRA    194C
01950:  MOVWF  FAD
01952:  MOVLW  2C
01954:  BTFSS  F9E.4
01956:  BRA    1954
01958:  MOVWF  FAD
0195A:  MOVFF  176,1CC
0195E:  MOVLW  1B
01960:  MOVLB  1
01962:  MOVWF  xCD
01964:  MOVLB  0
01966:  RCALL  1414
01968:  MOVLW  0D
0196A:  BTFSS  F9E.4
0196C:  BRA    196A
0196E:  MOVWF  FAD
01970:  MOVLW  0A
01972:  BTFSS  F9E.4
01974:  BRA    1972
01976:  MOVWF  FAD
....................          delay_ms(50); 
01978:  MOVLW  32
0197A:  MOVLB  1
0197C:  MOVWF  xCD
0197E:  MOVLB  0
01980:  CALL   0C5A
....................          fprintf(ESP8266, "%s\n\r",response); 
01984:  MOVLW  01
01986:  MOVWF  FEA
01988:  MOVLW  77
0198A:  MOVWF  FE9
0198C:  CALL   1052
01990:  MOVLW  0A
01992:  BTFSS  F9E.4
01994:  BRA    1992
01996:  MOVWF  FAD
01998:  MOVLW  0D
0199A:  BTFSS  F9E.4
0199C:  BRA    199A
0199E:  MOVWF  FAD
....................          delay_ms(120); 
019A0:  MOVLW  78
019A2:  MOVLB  1
019A4:  MOVWF  xCD
019A6:  MOVLB  0
019A8:  CALL   0C5A
....................           
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
019AC:  MOVLW  CC
019AE:  MOVWF  FF6
019B0:  MOVLW  01
019B2:  MOVWF  FF7
019B4:  MOVLW  0C
019B6:  MOVLB  1
019B8:  MOVWF  xCC
019BA:  MOVLB  0
019BC:  CALL   0F38
019C0:  MOVF   1C,W
019C2:  BTFSS  F9E.4
019C4:  BRA    19C2
019C6:  MOVWF  FAD
019C8:  MOVLW  0D
019CA:  BTFSS  F9E.4
019CC:  BRA    19CA
019CE:  MOVWF  FAD
019D0:  MOVLW  0A
019D2:  BTFSS  F9E.4
019D4:  BRA    19D2
019D6:  MOVWF  FAD
....................          delay_ms(500); 
019D8:  MOVLW  02
019DA:  MOVLB  1
019DC:  MOVWF  xCC
019DE:  MOVLW  FA
019E0:  MOVWF  xCD
019E2:  MOVLB  0
019E4:  CALL   0C5A
019E8:  MOVLB  1
019EA:  DECFSZ xCC,F
019EC:  BRA    19DE
....................           
....................          fprintf(ESP8266, "AT+CWSAP_DEF=%s,1,4\r\n",DATA_COMMAND); 
019EE:  MOVLW  DE
019F0:  MOVWF  FF6
019F2:  MOVLW  01
019F4:  MOVWF  FF7
019F6:  MOVLW  0D
019F8:  MOVWF  xCC
019FA:  MOVLB  0
019FC:  CALL   0F38
01A00:  CLRF   FEA
01A02:  MOVLW  20
01A04:  MOVWF  FE9
01A06:  CALL   1052
01A0A:  MOVLW  ED
01A0C:  MOVWF  FF6
01A0E:  MOVLW  01
01A10:  MOVWF  FF7
01A12:  MOVLW  06
01A14:  MOVLB  1
01A16:  MOVWF  xCC
01A18:  MOVLB  0
01A1A:  CALL   0F38
....................          delay_ms(1000); 
01A1E:  MOVLW  04
01A20:  MOVLB  1
01A22:  MOVWF  xCC
01A24:  MOVLW  FA
01A26:  MOVWF  xCD
01A28:  MOVLB  0
01A2A:  CALL   0C5A
01A2E:  MOVLB  1
01A30:  DECFSZ xCC,F
01A32:  BRA    1A24
....................          reset = 1; 
01A34:  MOVLW  01
01A36:  MOVWF  x71
....................       } // Fin comando AP 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
01A38:  MOVF   1E,W
01A3A:  SUBLW  4E
01A3C:  BTFSS  FD8.2
01A3E:  BRA    1B32
01A40:  MOVF   1F,W
01A42:  SUBLW  4D
01A44:  BTFSS  FD8.2
01A46:  BRA    1B32
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
01A48:  MOVF   FF2,W
01A4A:  MOVWF  00
01A4C:  BCF    FF2.7
01A4E:  CLRF   FAA
01A50:  CLRF   FA9
01A52:  MOVFF  20,FA8
01A56:  BCF    FA6.6
01A58:  BCF    FA6.7
01A5A:  BSF    FA6.2
01A5C:  MOVLB  F
01A5E:  MOVLW  55
01A60:  MOVWF  FA7
01A62:  MOVLW  AA
01A64:  MOVWF  FA7
01A66:  BSF    FA6.1
01A68:  BTFSC  FA6.1
01A6A:  BRA    1A68
01A6C:  BCF    FA6.2
01A6E:  MOVF   00,W
01A70:  IORWF  FF2,F
....................          delay_ms(30); 
01A72:  MOVLW  1E
01A74:  MOVLB  1
01A76:  MOVWF  xCD
01A78:  MOVLB  0
01A7A:  CALL   0C5A
....................          
....................          // Body 
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01A7E:  MOVLW  F4
01A80:  MOVWF  FF6
01A82:  MOVLW  01
01A84:  MOVWF  FF7
01A86:  MOVLW  0B
01A88:  MOVLB  1
01A8A:  MOVWF  xCC
01A8C:  MOVLB  0
01A8E:  CALL   0F38
01A92:  MOVF   1C,W
01A94:  BTFSS  F9E.4
01A96:  BRA    1A94
01A98:  MOVWF  FAD
01A9A:  MOVLW  2C
01A9C:  BTFSS  F9E.4
01A9E:  BRA    1A9C
01AA0:  MOVWF  FAD
01AA2:  MOVFF  176,1CC
01AA6:  MOVLW  1B
01AA8:  MOVLB  1
01AAA:  MOVWF  xCD
01AAC:  MOVLB  0
01AAE:  RCALL  1414
01AB0:  MOVLW  0D
01AB2:  BTFSS  F9E.4
01AB4:  BRA    1AB2
01AB6:  MOVWF  FAD
01AB8:  MOVLW  0A
01ABA:  BTFSS  F9E.4
01ABC:  BRA    1ABA
01ABE:  MOVWF  FAD
....................          delay_ms(50); 
01AC0:  MOVLW  32
01AC2:  MOVLB  1
01AC4:  MOVWF  xCD
01AC6:  MOVLB  0
01AC8:  CALL   0C5A
....................          fprintf(ESP8266, "%s\n\r",response); 
01ACC:  MOVLW  01
01ACE:  MOVWF  FEA
01AD0:  MOVLW  77
01AD2:  MOVWF  FE9
01AD4:  CALL   1052
01AD8:  MOVLW  0A
01ADA:  BTFSS  F9E.4
01ADC:  BRA    1ADA
01ADE:  MOVWF  FAD
01AE0:  MOVLW  0D
01AE2:  BTFSS  F9E.4
01AE4:  BRA    1AE2
01AE6:  MOVWF  FAD
....................          delay_ms(120); 
01AE8:  MOVLW  78
01AEA:  MOVLB  1
01AEC:  MOVWF  xCD
01AEE:  MOVLB  0
01AF0:  CALL   0C5A
....................           
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01AF4:  MOVLW  08
01AF6:  MOVWF  FF6
01AF8:  MOVLW  02
01AFA:  MOVWF  FF7
01AFC:  MOVLW  0C
01AFE:  MOVLB  1
01B00:  MOVWF  xCC
01B02:  MOVLB  0
01B04:  CALL   0F38
01B08:  MOVF   1C,W
01B0A:  BTFSS  F9E.4
01B0C:  BRA    1B0A
01B0E:  MOVWF  FAD
01B10:  MOVLW  0D
01B12:  BTFSS  F9E.4
01B14:  BRA    1B12
01B16:  MOVWF  FAD
01B18:  MOVLW  0A
01B1A:  BTFSS  F9E.4
01B1C:  BRA    1B1A
01B1E:  MOVWF  FAD
....................          delay_ms(100); 
01B20:  MOVLW  64
01B22:  MOVLB  1
01B24:  MOVWF  xCD
01B26:  MOVLB  0
01B28:  CALL   0C5A
....................          reset = 1; 
01B2C:  MOVLW  01
01B2E:  MOVLB  1
01B30:  MOVWF  x71
....................       } // Fin comando NM 
....................        
....................       /********************************* 
....................       *** Optiene el estado de Puerto ** 
....................       *** CMD:OS,0:                   ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='S') 
01B32:  MOVF   1E,W
01B34:  SUBLW  4F
01B36:  BTFSS  FD8.2
01B38:  BRA    1C6A
01B3A:  MOVF   1F,W
01B3C:  SUBLW  53
01B3E:  BTFSS  FD8.2
01B40:  BRA    1C6A
....................       { 
....................          //char  response[57]; 
....................          OS_CMD = 1; 
01B42:  MOVLW  01
01B44:  MOVWF  x72
....................          response[0]  = '{'; 
01B46:  MOVLW  7B
01B48:  MOVWF  x77
....................          response[1]  = '"'; 
01B4A:  MOVLW  22
01B4C:  MOVWF  x78
....................          response[2]  = '0'; 
01B4E:  MOVLW  30
01B50:  MOVWF  x79
....................          response[3]  = '"'; 
01B52:  MOVLW  22
01B54:  MOVWF  x7A
....................          response[4]  = ':'; 
01B56:  MOVLW  3A
01B58:  MOVWF  x7B
....................          response[5]  = input_state(PIN_OUT[0])+ 48; 
01B5A:  MOVLW  00
01B5C:  BTFSC  F84.2
01B5E:  MOVLW  01
01B60:  ADDLW  30
01B62:  MOVWF  x7C
....................          response[6]  = ','; 
01B64:  MOVLW  2C
01B66:  MOVWF  x7D
....................           
....................          response[7]   = '"'; 
01B68:  MOVLW  22
01B6A:  MOVWF  x7E
....................          response[8]   = '1'; 
01B6C:  MOVLW  31
01B6E:  MOVWF  x7F
....................          response[9]   = '"'; 
01B70:  MOVLW  22
01B72:  MOVWF  x80
....................          response[10]  = ':'; 
01B74:  MOVLW  3A
01B76:  MOVWF  x81
....................          response[11]  = input_state(PIN_OUT[1])+ 48; 
01B78:  MOVLW  00
01B7A:  BTFSC  F84.1
01B7C:  MOVLW  01
01B7E:  ADDLW  30
01B80:  MOVWF  x82
....................          response[12]  = ','; 
01B82:  MOVLW  2C
01B84:  MOVWF  x83
....................           
....................          response[13]  = '"'; 
01B86:  MOVLW  22
01B88:  MOVWF  x84
....................          response[14]  = '2'; 
01B8A:  MOVLW  32
01B8C:  MOVWF  x85
....................          response[15]  = '"'; 
01B8E:  MOVLW  22
01B90:  MOVWF  x86
....................          response[16]  = ':'; 
01B92:  MOVLW  3A
01B94:  MOVWF  x87
....................          response[17]  = input_state(PIN_OUT[2])+ 48; 
01B96:  MOVLW  00
01B98:  BTFSC  F84.0
01B9A:  MOVLW  01
01B9C:  ADDLW  30
01B9E:  MOVWF  x88
....................          response[18]  = ','; 
01BA0:  MOVLW  2C
01BA2:  MOVWF  x89
....................           
....................          response[19]  = '"'; 
01BA4:  MOVLW  22
01BA6:  MOVWF  x8A
....................          response[20]  = '3'; 
01BA8:  MOVLW  33
01BAA:  MOVWF  x8B
....................          response[21]  = '"'; 
01BAC:  MOVLW  22
01BAE:  MOVWF  x8C
....................          response[22]  = ':'; 
01BB0:  MOVLW  3A
01BB2:  MOVWF  x8D
....................          response[23]  = input_state(PIN_OUT[3])+ 48; 
01BB4:  MOVLW  00
01BB6:  BTFSC  F80.4
01BB8:  MOVLW  01
01BBA:  ADDLW  30
01BBC:  MOVWF  x8E
....................          response[24]  = ','; 
01BBE:  MOVLW  2C
01BC0:  MOVWF  x8F
....................           
....................          response[25]  = '"'; 
01BC2:  MOVLW  22
01BC4:  MOVWF  x90
....................          response[26]  = '4'; 
01BC6:  MOVLW  34
01BC8:  MOVWF  x91
....................          response[27]  = '"'; 
01BCA:  MOVLW  22
01BCC:  MOVWF  x92
....................          response[28]  = ':'; 
01BCE:  MOVLW  3A
01BD0:  MOVWF  x93
....................          response[29]  = input_state(PIN_OUT[4])+ 48; 
01BD2:  MOVLW  00
01BD4:  BTFSC  F80.0
01BD6:  MOVLW  01
01BD8:  ADDLW  30
01BDA:  MOVWF  x94
....................          response[30]  = ','; 
01BDC:  MOVLW  2C
01BDE:  MOVWF  x95
....................           
....................          response[31]  = '"'; 
01BE0:  MOVLW  22
01BE2:  MOVWF  x96
....................          response[32]  = '5'; 
01BE4:  MOVLW  35
01BE6:  MOVWF  x97
....................          response[33]  = '"'; 
01BE8:  MOVLW  22
01BEA:  MOVWF  x98
....................          response[34]  = ':'; 
01BEC:  MOVLW  3A
01BEE:  MOVWF  x99
....................          response[35]  = input_state(PIN_OUT[5])+ 48; 
01BF0:  MOVLW  00
01BF2:  BTFSC  F80.1
01BF4:  MOVLW  01
01BF6:  ADDLW  30
01BF8:  MOVWF  x9A
....................          response[36]  = ','; 
01BFA:  MOVLW  2C
01BFC:  MOVWF  x9B
....................           
....................          response[37]  = '"'; 
01BFE:  MOVLW  22
01C00:  MOVWF  x9C
....................          response[38]  = '6'; 
01C02:  MOVLW  36
01C04:  MOVWF  x9D
....................          response[39]  = '"'; 
01C06:  MOVLW  22
01C08:  MOVWF  x9E
....................          response[40]  = ':'; 
01C0A:  MOVLW  3A
01C0C:  MOVWF  x9F
....................          response[41]  = input_state(PIN_OUT[6])+ 48; 
01C0E:  MOVLW  00
01C10:  BTFSC  F80.2
01C12:  MOVLW  01
01C14:  ADDLW  30
01C16:  MOVWF  xA0
....................          response[42]  = ','; 
01C18:  MOVLW  2C
01C1A:  MOVWF  xA1
....................           
....................          response[43]  = '"'; 
01C1C:  MOVLW  22
01C1E:  MOVWF  xA2
....................          response[44]  = '7'; 
01C20:  MOVLW  37
01C22:  MOVWF  xA3
....................          response[45]  = '"'; 
01C24:  MOVLW  22
01C26:  MOVWF  xA4
....................          response[46]  = ':'; 
01C28:  MOVLW  3A
01C2A:  MOVWF  xA5
....................          response[47]  = input_state(PIN_OUT[7])+ 48; 
01C2C:  MOVLW  00
01C2E:  BTFSC  F80.3
01C30:  MOVLW  01
01C32:  ADDLW  30
01C34:  MOVWF  xA6
....................          response[48]  = ','; 
01C36:  MOVLW  2C
01C38:  MOVWF  xA7
....................           
....................          response[49]  = '"'; 
01C3A:  MOVLW  22
01C3C:  MOVWF  xA8
....................          response[50]  = 'M'; 
01C3E:  MOVLW  4D
01C40:  MOVWF  xA9
....................          response[51]  = '"'; 
01C42:  MOVLW  22
01C44:  MOVWF  xAA
....................          response[52]  = ':'; 
01C46:  MOVLW  3A
01C48:  MOVWF  xAB
....................          response[53]  = read_eeprom(0x00); 
01C4A:  MOVFF  FF2,1CC
01C4E:  BCF    FF2.7
01C50:  CLRF   FAA
01C52:  CLRF   FA9
01C54:  BCF    FA6.6
01C56:  BCF    FA6.7
01C58:  BSF    FA6.0
01C5A:  MOVF   FA8,W
01C5C:  BTFSC  xCC.7
01C5E:  BSF    FF2.7
01C60:  MOVWF  xAC
....................           
....................          response[54]  = '}'; 
01C62:  MOVLW  7D
01C64:  MOVWF  xAD
....................          lenResponse   = 55+17; // 17 es el tamao del status line 
01C66:  MOVLW  48
01C68:  MOVWF  x76
....................       } // Fin comando OS 
....................        
....................       /*********************************** 
....................       *** Cambia el Nombre de Puerto    ** 
....................       *** lo almacena en la EEPROM      ** 
....................       *** CMD:NO,0NombreChar[10]:       ** 
....................       ***********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='O') 
01C6A:  MOVF   1E,W
01C6C:  SUBLW  4E
01C6E:  BTFSS  FD8.2
01C70:  BRA    1D56
01C72:  MOVF   1F,W
01C74:  SUBLW  4F
01C76:  BNZ   1D56
....................       { 
....................           
....................          int posIni = 0, posFin = 0; 
01C78:  CLRF   xC9
01C7A:  CLRF   xCA
....................          optSelected =(int) ( DATA_COMMAND[0] - 48); 
01C7C:  MOVLW  30
01C7E:  SUBWF  20,W
01C80:  MOVWF  x73
....................          posIni =( 10 * optSelected ) + 40; 
01C82:  MOVF   x73,W
01C84:  MULLW  0A
01C86:  MOVF   FF3,W
01C88:  ADDLW  28
01C8A:  MOVWF  xC9
....................          posFin = posIni + 10; 
01C8C:  MOVLW  0A
01C8E:  ADDWF  xC9,W
01C90:  MOVWF  xCA
....................           
....................          // Guarda el nuevo nombre 
....................          for(idxRSTNC=posIni;idxRSTNC<(posIni+LEN_DATA_COMMAND);idxRSTNC++){ 
01C92:  MOVFF  1C9,175
01C96:  MOVF   xC9,W
01C98:  ADDWF  52,W
01C9A:  MOVWF  01
01C9C:  MOVLW  00
01C9E:  ADDWFC 53,W
01CA0:  MOVWF  03
01CA2:  MOVF   01,W
01CA4:  MOVF   03,F
01CA6:  BNZ   1CAE
01CA8:  MOVF   01,W
01CAA:  SUBWF  x75,W
01CAC:  BC    1D00
....................             counter++; 
01CAE:  INCF   x74,F
....................             write_eeprom(idxRSTNC,DATA_COMMAND[counter]); 
01CB0:  CLRF   03
01CB2:  MOVF   x74,W
01CB4:  ADDLW  20
01CB6:  MOVWF  FE9
01CB8:  MOVLW  00
01CBA:  ADDWFC 03,W
01CBC:  MOVWF  FEA
01CBE:  MOVFF  FEF,1CC
01CC2:  MOVF   FF2,W
01CC4:  MOVWF  00
01CC6:  BCF    FF2.7
01CC8:  CLRF   FAA
01CCA:  MOVFF  175,FA9
01CCE:  MOVFF  1CC,FA8
01CD2:  BCF    FA6.6
01CD4:  BCF    FA6.7
01CD6:  BSF    FA6.2
01CD8:  MOVLB  F
01CDA:  MOVLW  55
01CDC:  MOVWF  FA7
01CDE:  MOVLW  AA
01CE0:  MOVWF  FA7
01CE2:  BSF    FA6.1
01CE4:  BTFSC  FA6.1
01CE6:  BRA    1CE4
01CE8:  BCF    FA6.2
01CEA:  MOVF   00,W
01CEC:  IORWF  FF2,F
....................             delay_ms(10); 
01CEE:  MOVLW  0A
01CF0:  MOVLB  1
01CF2:  MOVWF  xCD
01CF4:  MOVLB  0
01CF6:  CALL   0C5A
01CFA:  MOVLB  1
01CFC:  INCF   x75,F
01CFE:  BRA    1C96
....................          } 
....................           
....................          // Borra el restante de la eeprom para almacenar las nuevas credenciales 
....................          for(idxRSTNC=(posIni+LEN_DATA_COMMAND+1);idxRSTNC<=posFin;idxRSTNC++){ 
01D00:  MOVF   xC9,W
01D02:  ADDWF  52,W
01D04:  MOVWF  xCC
01D06:  MOVLW  00
01D08:  ADDWFC 53,W
01D0A:  MOVWF  xCD
01D0C:  MOVLW  01
01D0E:  ADDWF  xCC,W
01D10:  MOVWF  x75
01D12:  MOVF   x75,W
01D14:  SUBWF  xCA,W
01D16:  BNC   1D54
....................             write_eeprom(idxRSTNC,0xFF); 
01D18:  MOVF   FF2,W
01D1A:  MOVWF  00
01D1C:  BCF    FF2.7
01D1E:  CLRF   FAA
01D20:  MOVFF  175,FA9
01D24:  SETF   FA8
01D26:  BCF    FA6.6
01D28:  BCF    FA6.7
01D2A:  BSF    FA6.2
01D2C:  MOVLB  F
01D2E:  MOVLW  55
01D30:  MOVWF  FA7
01D32:  MOVLW  AA
01D34:  MOVWF  FA7
01D36:  BSF    FA6.1
01D38:  BTFSC  FA6.1
01D3A:  BRA    1D38
01D3C:  BCF    FA6.2
01D3E:  MOVF   00,W
01D40:  IORWF  FF2,F
....................             delay_ms(10); 
01D42:  MOVLW  0A
01D44:  MOVLB  1
01D46:  MOVWF  xCD
01D48:  MOVLB  0
01D4A:  CALL   0C5A
01D4E:  MOVLB  1
01D50:  INCF   x75,F
01D52:  BRA    1D12
....................          } 
....................           
....................          counter = 0; 
01D54:  CLRF   x74
....................          //reset = 1; //Reinicia el Dispositivo 
....................       } // Fin comando NO 
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................       if(reset==0){ 
01D56:  MOVF   x71,F
01D58:  BTFSS  FD8.2
01D5A:  BRA    1E92
....................          
....................          // Body 
....................          if(OS_CMD==0) 
01D5C:  MOVF   x72,F
01D5E:  BNZ   1DCE
....................          { 
....................             // Comandos que no tiene una respuesta personalizada 
....................             fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01D60:  MOVLW  1A
01D62:  MOVWF  FF6
01D64:  MOVLW  02
01D66:  MOVWF  FF7
01D68:  MOVLW  0B
01D6A:  MOVWF  xCC
01D6C:  MOVLB  0
01D6E:  CALL   0F38
01D72:  MOVF   1C,W
01D74:  BTFSS  F9E.4
01D76:  BRA    1D74
01D78:  MOVWF  FAD
01D7A:  MOVLW  2C
01D7C:  BTFSS  F9E.4
01D7E:  BRA    1D7C
01D80:  MOVWF  FAD
01D82:  MOVFF  176,1CC
01D86:  MOVLW  1B
01D88:  MOVLB  1
01D8A:  MOVWF  xCD
01D8C:  MOVLB  0
01D8E:  CALL   1414
01D92:  MOVLW  0D
01D94:  BTFSS  F9E.4
01D96:  BRA    1D94
01D98:  MOVWF  FAD
01D9A:  MOVLW  0A
01D9C:  BTFSS  F9E.4
01D9E:  BRA    1D9C
01DA0:  MOVWF  FAD
....................             delay_ms(50); 
01DA2:  MOVLW  32
01DA4:  MOVLB  1
01DA6:  MOVWF  xCD
01DA8:  MOVLB  0
01DAA:  CALL   0C5A
....................             fprintf(ESP8266, "%s\n\r",response); 
01DAE:  MOVLW  01
01DB0:  MOVWF  FEA
01DB2:  MOVLW  77
01DB4:  MOVWF  FE9
01DB6:  CALL   1052
01DBA:  MOVLW  0A
01DBC:  BTFSS  F9E.4
01DBE:  BRA    1DBC
01DC0:  MOVWF  FAD
01DC2:  MOVLW  0D
01DC4:  BTFSS  F9E.4
01DC6:  BRA    1DC4
01DC8:  MOVWF  FAD
....................          }else 
01DCA:  BRA    1E4C
01DCC:  MOVLB  1
....................          { 
....................             // Si el comando es OS se agrega el statusLine 
....................             fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01DCE:  MOVLW  2E
01DD0:  MOVWF  FF6
01DD2:  MOVLW  02
01DD4:  MOVWF  FF7
01DD6:  MOVLW  0B
01DD8:  MOVWF  xCC
01DDA:  MOVLB  0
01DDC:  CALL   0F38
01DE0:  MOVF   1C,W
01DE2:  BTFSS  F9E.4
01DE4:  BRA    1DE2
01DE6:  MOVWF  FAD
01DE8:  MOVLW  2C
01DEA:  BTFSS  F9E.4
01DEC:  BRA    1DEA
01DEE:  MOVWF  FAD
01DF0:  MOVFF  176,1CC
01DF4:  MOVLW  1B
01DF6:  MOVLB  1
01DF8:  MOVWF  xCD
01DFA:  MOVLB  0
01DFC:  CALL   1414
01E00:  MOVLW  0D
01E02:  BTFSS  F9E.4
01E04:  BRA    1E02
01E06:  MOVWF  FAD
01E08:  MOVLW  0A
01E0A:  BTFSS  F9E.4
01E0C:  BRA    1E0A
01E0E:  MOVWF  FAD
....................             delay_ms(50); 
01E10:  MOVLW  32
01E12:  MOVLB  1
01E14:  MOVWF  xCD
01E16:  MOVLB  0
01E18:  CALL   0C5A
....................             fprintf(ESP8266, "HTTP/1.1 200 OK\n\n%s\n\r",response); 
01E1C:  MOVLW  42
01E1E:  MOVWF  FF6
01E20:  MOVLW  02
01E22:  MOVWF  FF7
01E24:  MOVLW  11
01E26:  MOVLB  1
01E28:  MOVWF  xCC
01E2A:  MOVLB  0
01E2C:  CALL   0F38
01E30:  MOVLW  01
01E32:  MOVWF  FEA
01E34:  MOVLW  77
01E36:  MOVWF  FE9
01E38:  CALL   1052
01E3C:  MOVLW  0A
01E3E:  BTFSS  F9E.4
01E40:  BRA    1E3E
01E42:  MOVWF  FAD
01E44:  MOVLW  0D
01E46:  BTFSS  F9E.4
01E48:  BRA    1E46
01E4A:  MOVWF  FAD
....................          } 
....................           
....................           
....................          delay_ms(120); 
01E4C:  MOVLW  78
01E4E:  MOVLB  1
01E50:  MOVWF  xCD
01E52:  MOVLB  0
01E54:  CALL   0C5A
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01E58:  MOVLW  58
01E5A:  MOVWF  FF6
01E5C:  MOVLW  02
01E5E:  MOVWF  FF7
01E60:  MOVLW  0C
01E62:  MOVLB  1
01E64:  MOVWF  xCC
01E66:  MOVLB  0
01E68:  CALL   0F38
01E6C:  MOVF   1C,W
01E6E:  BTFSS  F9E.4
01E70:  BRA    1E6E
01E72:  MOVWF  FAD
01E74:  MOVLW  0D
01E76:  BTFSS  F9E.4
01E78:  BRA    1E76
01E7A:  MOVWF  FAD
01E7C:  MOVLW  0A
01E7E:  BTFSS  F9E.4
01E80:  BRA    1E7E
01E82:  MOVWF  FAD
....................          delay_ms(100); 
01E84:  MOVLW  64
01E86:  MOVLB  1
01E88:  MOVWF  xCD
01E8A:  MOVLB  0
01E8C:  CALL   0C5A
01E90:  MOVLB  1
....................       } 
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
01E92:  CLRF   xCB
01E94:  MOVF   53,F
01E96:  BNZ   1E9E
01E98:  MOVF   xCB,W
01E9A:  SUBWF  52,W
01E9C:  BNC   1EB2
....................          DATA_COMMAND[idxCb] = 0x00; 
01E9E:  CLRF   03
01EA0:  MOVF   xCB,W
01EA2:  ADDLW  20
01EA4:  MOVWF  FE9
01EA6:  MOVLW  00
01EA8:  ADDWFC 03,W
01EAA:  MOVWF  FEA
01EAC:  CLRF   FEF
01EAE:  INCF   xCB,F
01EB0:  BRA    1E94
....................       } 
....................       for(idxCb=0;idxCb<=56;idxCb++){ 
01EB2:  CLRF   xCB
01EB4:  MOVF   xCB,W
01EB6:  SUBLW  38
01EB8:  BNC   1ECE
....................       response[idxCb] = 0x00; 
01EBA:  CLRF   03
01EBC:  MOVF   xCB,W
01EBE:  ADDLW  77
01EC0:  MOVWF  FE9
01EC2:  MOVLW  01
01EC4:  ADDWFC 03,W
01EC6:  MOVWF  FEA
01EC8:  CLRF   FEF
01ECA:  INCF   xCB,F
01ECC:  BRA    1EB4
....................       } 
....................       COMMAND[0]       = 0x00; 
01ECE:  CLRF   1E
....................       COMMAND[1]       = 0x00; 
01ED0:  CLRF   1F
....................       ID_CONNETION[0]  = 0x00; 
01ED2:  CLRF   1C
....................        
....................       flag_Resp_Ready  = 0x00; 
01ED4:  CLRF   57
....................       LEN_DATA_COMMAND = 0x00; 
01ED6:  CLRF   53
01ED8:  CLRF   52
....................        
....................       if(reset==1){ 
01EDA:  DECFSZ x71,W
01EDC:  BRA    1EE2
....................          reset = 0; 
01EDE:  CLRF   x71
....................           // Reinicia el dispositivo 
....................          reset_cpu(); 
01EE0:  RESET
....................       } 
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return reset; 
01EE2:  MOVFF  171,01
01EE6:  MOVLB  0
01EE8:  RETURN 0
.................... } // Fin de la Funcion run_command_wifi() 
....................  
.................... #include "header/esp8266.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          esp8266.H: Inicializa el Modulo esp8266 y 
....................                              maneja las interrupciones USART 
....................                              para procesar los comandos wifi. 
....................  
.................... *******************************************************/ 
....................  
.................... /* 
....................      **  Funcionamiento de las funciones de Busqueda y comparacion  
....................      **  de String. 
....................      ** 
....................  
.................... Cuenta el numero de aciertos de manera secuencial cuando compara los  
.................... caracteres que recibe por el usart vs una cadena constante. Si el  
.................... numero de aciertos es igual a la cadena entonces las cadenas son iguales 
.................... y almacena en una estructura los siguientes caracteres recibidos hasta  
.................... que encuentre el caracter del fin de la cadena (":"). 
....................  
.................... */ 
.................... #define  CHPD_ESP8266               PIN_B3 
.................... #define  CMD_MODE                   1 
.................... #define  CMD_DO_CONN                2 
.................... #define  CMD_CONN                   3 
.................... #define  READY_RESPONSE_WIFI        4 
.................... #define  CMD_GET_IP_FROM_MENU       5 
.................... #define  CMD_GET_AP_INFO_FROM_MENU  6 
.................... #define  CMD_GET_STA_INFO_FROM_MENU 7 
....................  
.................... /* Key flag responses */ 
.................... const int   Valid      = 0; 
.................... const int   CWJAP      = 1; 
.................... const int   NoAp       = 2; 
.................... const int   Connected  = 3; 
.................... const int   Fail       = 4; 
.................... const int   Error      = 5; 
....................  
.................... /* Declaracion de Funciones */ 
.................... void getIP(int buffer); 
.................... void getAPInfo(int buffer); 
.................... void getSTAInfo(int buffer); 
.................... int  waitResp(void); 
.................... void waitRespMajor(int buffer,int flag_resp); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int resp_Pos   = 1; 
.................... int resp_Flag  = 0; 
.................... int countResp  = 5;     //Conteo de Respuestas esperadas 
....................  
.................... char buffer_flag_Resp[2][6]   =   
.................... { 
....................    {0,0,0,0,0,0}, // Flag_Responses Command valid 
....................    {0,0,0,0,0,0}  // Flag_Pos_Responses 
.................... }; 
....................  
.................... char buffer_Resp_CMD[5][16]   = 
.................... { 
....................    {"0.0.0.0"},   // IP    AP 
....................    {"0.0.0.0"},   // IP    STA 
....................    {"               "},   // SSID  AP 
....................    {"               "},   // Key   AP 
....................    {"               "}    // SSID  STA 
.................... }; 
....................  
.................... int flag_Resp_Get_IP_CMD = 0; 
.................... int flag_Pos_Get_IP_CMD  = 0; 
....................  
.................... int flag_Resp_Get_AP_Info_CMD = 0; 
.................... int flag_Pos_Get_AP_Info_CMD  = 0; 
....................  
.................... int flag_Resp_Get_STA_Info_CMD = 0; 
.................... int flag_Pos_Get_STA_Info_CMD  = 0; 
....................  
.................... /* Variables que se setean con la data de la EEPROM */ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
*
010DE:  MOVLB  1
010E0:  CLRF   x6A
.................... { 
....................    int resp=0; 
....................  
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
010E2:  MOVFF  FF2,16C
010E6:  BCF    FF2.7
010E8:  CLRF   FAA
010EA:  CLRF   FA9
010EC:  BCF    FA6.6
010EE:  BCF    FA6.7
010F0:  BSF    FA6.0
010F2:  MOVF   FA8,W
010F4:  BTFSC  x6C.7
010F6:  BSF    FF2.7
010F8:  MOVLB  0
010FA:  MOVWF  xC1
....................    delay_ms(10); 
010FC:  MOVLW  0A
010FE:  MOVLB  1
01100:  MOVWF  xCD
01102:  MOVLB  0
01104:  RCALL  0C5A
....................    switch(modeStar){ 
01106:  MOVF   xC1,W
01108:  XORLW  31
0110A:  BZ    1116
0110C:  XORLW  03
0110E:  BZ    1116
01110:  XORLW  01
01112:  BZ    1116
01114:  BRA    1118
....................       case '1': 
....................       case '2': 
....................       case '3': 
....................          break; 
01116:  BRA    1150
....................       default: 
....................          write_eeprom(0x00,'3'); 
01118:  MOVF   FF2,W
0111A:  MOVWF  00
0111C:  BCF    FF2.7
0111E:  CLRF   FAA
01120:  CLRF   FA9
01122:  MOVLW  33
01124:  MOVWF  FA8
01126:  BCF    FA6.6
01128:  BCF    FA6.7
0112A:  BSF    FA6.2
0112C:  MOVLB  F
0112E:  MOVLW  55
01130:  MOVWF  FA7
01132:  MOVLW  AA
01134:  MOVWF  FA7
01136:  BSF    FA6.1
01138:  BTFSC  FA6.1
0113A:  BRA    1138
0113C:  BCF    FA6.2
0113E:  MOVF   00,W
01140:  IORWF  FF2,F
....................          delay_ms(10); 
01142:  MOVLW  0A
01144:  MOVLB  1
01146:  MOVWF  xCD
01148:  MOVLB  0
0114A:  RCALL  0C5A
....................          modeStar = '3'; 
0114C:  MOVLW  33
0114E:  MOVWF  xC1
....................          break; 
....................    } 
....................    // Lanza el comando para configurar el modo de conexion 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeStar); 
01150:  MOVLW  6A
01152:  MOVWF  FF6
01154:  MOVLW  02
01156:  MOVWF  FF7
01158:  MOVLW  0A
0115A:  MOVLB  1
0115C:  MOVWF  xCC
0115E:  MOVLB  0
01160:  RCALL  0F38
01162:  MOVF   xC1,W
01164:  BTFSS  F9E.4
01166:  BRA    1164
01168:  MOVWF  FAD
0116A:  MOVLW  0D
0116C:  BTFSS  F9E.4
0116E:  BRA    116C
01170:  MOVWF  FAD
01172:  MOVLW  0A
01174:  BTFSS  F9E.4
01176:  BRA    1174
01178:  MOVWF  FAD
....................    CMD_RUN =  CMD_MODE;  
0117A:  MOVLW  01
0117C:  MOVWF  5B
....................    delay_ms(50); 
0117E:  MOVLW  32
01180:  MOVLB  1
01182:  MOVWF  xCD
01184:  MOVLB  0
01186:  RCALL  0C5A
....................     
....................    // Lanza el comando para verificar si el modulo ya se encuentra conectado 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
01188:  MOVLW  7A
0118A:  MOVWF  FF6
0118C:  MOVLW  02
0118E:  MOVWF  FF7
01190:  RCALL  0C82
....................    CMD_RUN  =  CMD_DO_CONN; 
01192:  MOVLW  02
01194:  MOVWF  5B
....................    resp     = waitResp(); 
01196:  RCALL  0F62
01198:  MOVFF  01,16A
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
0119C:  MOVLB  1
0119E:  MOVF   x6A,W
011A0:  SUBLW  02
011A2:  BTFSS  FD8.2
011A4:  BRA    12A8
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
011A6:  CLRF   x6B
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
011A8:  CLRF   03
011AA:  MOVF   x6B,W
011AC:  ADDLW  C2
011AE:  MOVWF  FE9
011B0:  MOVLW  00
011B2:  ADDWFC 03,W
011B4:  MOVWF  FEA
011B6:  MOVF   FEF,W
011B8:  SUBLW  0A
011BA:  BZ    1226
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
011BC:  CLRF   03
011BE:  MOVF   x6B,W
011C0:  ADDLW  C2
011C2:  MOVWF  FE9
011C4:  MOVLW  00
011C6:  ADDWFC 03,W
011C8:  MOVWF  FEA
011CA:  MOVLW  01
011CC:  ADDWF  x6B,W
011CE:  MOVWF  x6E
011D0:  MOVFF  FF2,16F
011D4:  BCF    FF2.7
011D6:  CLRF   FAA
011D8:  MOVFF  16E,FA9
011DC:  BCF    FA6.6
011DE:  BCF    FA6.7
011E0:  BSF    FA6.0
011E2:  MOVF   FA8,W
011E4:  BTFSC  x6F.7
011E6:  BSF    FF2.7
011E8:  MOVWF  FEF
....................          delay_ms(10); 
011EA:  MOVLW  0A
011EC:  MOVWF  xCD
011EE:  MOVLB  0
011F0:  RCALL  0C5A
....................          if(SSIDAndKey[idxRE]==0xFF){ 
011F2:  CLRF   03
011F4:  MOVLB  1
011F6:  MOVF   x6B,W
011F8:  ADDLW  C2
011FA:  MOVWF  FE9
011FC:  MOVLW  00
011FE:  ADDWFC 03,W
01200:  MOVWF  FEA
01202:  INCFSZ FEF,W
01204:  BRA    120C
....................             resp = 5; 
01206:  MOVLW  05
01208:  MOVWF  x6A
....................             break; 
0120A:  BRA    1226
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
0120C:  CLRF   03
0120E:  MOVF   x6B,W
01210:  ADDLW  C2
01212:  MOVWF  FE9
01214:  MOVLW  00
01216:  ADDWFC 03,W
01218:  MOVWF  FEA
0121A:  MOVF   FEF,W
0121C:  SUBLW  0A
0121E:  BNZ   1222
....................             break; 
01220:  BRA    1226
....................          } 
....................          idxRE++; 
01222:  INCF   x6B,F
01224:  BRA    11A8
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
01226:  MOVF   x6A,W
01228:  SUBLW  05
0122A:  BZ    125A
....................          fprintf(ESP8266, "AT+CWJAP=%s",SSIDAndKey); 
0122C:  MOVLW  86
0122E:  MOVWF  FF6
01230:  MOVLW  02
01232:  MOVWF  FF7
01234:  MOVLW  09
01236:  MOVWF  xCC
01238:  MOVLB  0
0123A:  RCALL  0F38
0123C:  CLRF   FEA
0123E:  MOVLW  C2
01240:  MOVWF  FE9
01242:  RCALL  1052
....................          CMD_RUN = CMD_CONN; 
01244:  MOVLW  03
01246:  MOVWF  5B
....................          fprintf(console,"Lanza comando Para conectarse a una red \r\n"); 
01248:  MOVLW  92
0124A:  MOVWF  FF6
0124C:  MOVLW  02
0124E:  MOVWF  FF7
01250:  RCALL  10BE
....................          resp    = waitResp(); 
01252:  RCALL  0F62
01254:  MOVFF  01,16A
01258:  MOVLB  1
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
0125A:  MOVF   x6A,W
0125C:  SUBLW  04
0125E:  BZ    1266
01260:  MOVF   x6A,W
01262:  SUBLW  05
01264:  BNZ   12A8
....................          fprintf(console,"Sin red entonces activa Modo AP \r\n"); 
01266:  MOVLW  BE
01268:  MOVWF  FF6
0126A:  MOVLW  02
0126C:  MOVWF  FF7
0126E:  MOVLB  0
01270:  RCALL  10BE
....................          fprintf(ESP8266, "AT+CWMODE=%c\r\n","3"); 
01272:  MOVLW  E2
01274:  MOVWF  FF6
01276:  MOVLW  02
01278:  MOVWF  FF7
0127A:  MOVLW  0A
0127C:  MOVLB  1
0127E:  MOVWF  xCC
01280:  MOVLB  0
01282:  RCALL  0F38
01284:  MOVLB  4
01286:  MOVF   xCC,W
01288:  BTFSS  F9E.4
0128A:  BRA    1288
0128C:  MOVWF  FAD
0128E:  MOVLW  0D
01290:  BTFSS  F9E.4
01292:  BRA    1290
01294:  MOVWF  FAD
01296:  MOVLW  0A
01298:  BTFSS  F9E.4
0129A:  BRA    1298
0129C:  MOVWF  FAD
....................          CMD_RUN = CMD_MODE; 
0129E:  MOVLW  01
012A0:  MOVWF  5B
....................          waitResp(); 
012A2:  MOVLB  0
012A4:  RCALL  0F62
012A6:  MOVLB  1
....................       } 
....................    } // Fin del if(doConnect) 
....................  
....................    // Configura el modulo como server 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
012A8:  MOVLW  F2
012AA:  MOVWF  FF6
012AC:  MOVLW  02
012AE:  MOVWF  FF7
012B0:  MOVLB  0
012B2:  RCALL  0C82
....................    delay_ms(1000); 
012B4:  MOVLW  04
012B6:  MOVLB  1
012B8:  MOVWF  x6C
012BA:  MOVLW  FA
012BC:  MOVWF  xCD
012BE:  MOVLB  0
012C0:  RCALL  0C5A
012C2:  MOVLB  1
012C4:  DECFSZ x6C,F
012C6:  BRA    12BA
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
012C8:  MOVLW  00
012CA:  MOVWF  FF6
012CC:  MOVLW  03
012CE:  MOVWF  FF7
012D0:  MOVLB  0
012D2:  RCALL  0C82
....................    delay_ms(1000); 
012D4:  MOVLW  04
012D6:  MOVLB  1
012D8:  MOVWF  x6C
012DA:  MOVLW  FA
012DC:  MOVWF  xCD
012DE:  MOVLB  0
012E0:  RCALL  0C5A
012E2:  MOVLB  1
012E4:  DECFSZ x6C,F
012E6:  BRA    12DA
....................     
....................    CMD_RUN = READY_RESPONSE_WIFI; 
012E8:  MOVLW  04
012EA:  MOVWF  5B
012EC:  MOVLB  0
012EE:  GOTO   2DD0 (RETURN)
.................... } 
....................  
.................... /********************************************************** 
....................    Funcion encangada de procesar las respuestas del modulo,  
....................    debe ser llamada durante la interrupcion del USART 
.................... ***********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................  
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
00B00:  MOVF   5B,W
00B02:  XORLW  01
00B04:  BZ    0B20
00B06:  XORLW  03
00B08:  BZ    0B2E
00B0A:  XORLW  01
00B0C:  BZ    0B58
00B0E:  XORLW  06
00B10:  BZ    0B82
00B12:  XORLW  03
00B14:  BZ    0B96
00B16:  XORLW  01
00B18:  BZ    0BAA
00B1A:  XORLW  03
00B1C:  BZ    0BBE
00B1E:  BRA    0BBE
....................             case CMD_MODE: 
....................                   waitRespMajor(buffer,Valid); 
00B20:  MOVFF  1D5,1D6
00B24:  MOVLB  1
00B26:  CLRF   xD7
00B28:  MOVLB  0
00B2A:  RCALL  0620
....................                   break; 
00B2C:  BRA    0BE4
....................  
....................             case CMD_DO_CONN: 
....................                   waitRespMajor(buffer,NoAp); 
00B2E:  MOVFF  1D5,1D6
00B32:  MOVLW  02
00B34:  MOVLB  1
00B36:  MOVWF  xD7
00B38:  MOVLB  0
00B3A:  RCALL  0620
....................                   waitRespMajor(buffer,CWJAP); 
00B3C:  MOVFF  1D5,1D6
00B40:  MOVLW  01
00B42:  MOVLB  1
00B44:  MOVWF  xD7
00B46:  MOVLB  0
00B48:  RCALL  0620
....................                   waitRespMajor(buffer,Valid); 
00B4A:  MOVFF  1D5,1D6
00B4E:  MOVLB  1
00B50:  CLRF   xD7
00B52:  MOVLB  0
00B54:  RCALL  0620
....................                   break; 
00B56:  BRA    0BE4
....................  
....................             case CMD_CONN: 
....................                   waitRespMajor(buffer,Connected); 
00B58:  MOVFF  1D5,1D6
00B5C:  MOVLW  03
00B5E:  MOVLB  1
00B60:  MOVWF  xD7
00B62:  MOVLB  0
00B64:  RCALL  0620
....................                   waitRespMajor(buffer,Fail); 
00B66:  MOVFF  1D5,1D6
00B6A:  MOVLW  04
00B6C:  MOVLB  1
00B6E:  MOVWF  xD7
00B70:  MOVLB  0
00B72:  RCALL  0620
....................                   waitRespMajor(buffer,Valid); 
00B74:  MOVFF  1D5,1D6
00B78:  MOVLB  1
00B7A:  CLRF   xD7
00B7C:  MOVLB  0
00B7E:  RCALL  0620
....................                   break; 
00B80:  BRA    0BE4
....................              
....................             case CMD_GET_IP_FROM_MENU: 
....................                   getIP(buffer); 
00B82:  MOVFF  1D5,1D6
00B86:  BRA    0836
....................                   waitRespMajor(buffer,Valid); 
00B88:  MOVFF  1D5,1D6
00B8C:  MOVLB  1
00B8E:  CLRF   xD7
00B90:  MOVLB  0
00B92:  RCALL  0620
....................                   break; 
00B94:  BRA    0BE4
....................                    
....................             case CMD_GET_AP_INFO_FROM_MENU: 
....................                   getAPInfo(buffer); 
00B96:  MOVFF  1D5,1D6
00B9A:  BRA    0906
....................                   waitRespMajor(buffer,Valid); 
00B9C:  MOVFF  1D5,1D6
00BA0:  MOVLB  1
00BA2:  CLRF   xD7
00BA4:  MOVLB  0
00BA6:  RCALL  0620
....................                   break; 
00BA8:  BRA    0BE4
....................              
....................             case CMD_GET_STA_INFO_FROM_MENU: 
....................                   getSTAInfo(buffer); 
00BAA:  MOVFF  1D5,1D6
00BAE:  BRA    099E
....................                   waitRespMajor(buffer,Valid); 
00BB0:  MOVFF  1D5,1D6
00BB4:  MOVLB  1
00BB6:  CLRF   xD7
00BB8:  MOVLB  0
00BBA:  RCALL  0620
....................                   break; 
00BBC:  BRA    0BE4
....................                    
....................             case READY_RESPONSE_WIFI: 
....................             default: 
....................                   ESP8266_Get_IPD(buffer); 
00BBE:  MOVLB  1
00BC0:  CLRF   xD7
00BC2:  MOVFF  1D5,1D6
00BC6:  MOVLB  0
00BC8:  BRA    09E0
....................                   ESP8266_Get_CMD(buffer); 
00BCA:  MOVLB  1
00BCC:  CLRF   xD7
00BCE:  MOVFF  1D5,1D6
00BD2:  MOVLB  0
00BD4:  BRA    0A48
....................                   ESP8266_Get_Data(buffer); 
00BD6:  MOVLB  1
00BD8:  CLRF   xD7
00BDA:  MOVFF  1D5,1D6
00BDE:  MOVLB  0
00BE0:  BRA    0AB4
....................                   CMD_RUN = 0x00; 
00BE2:  CLRF   5B
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
00BE4:  GOTO   0BFA (RETURN)
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
00F62:  MOVLB  1
00F64:  CLRF   x6E
00F66:  CLRF   x6F
.................... { 
....................    int ret=0,idx=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(buffer_flag_Resp[resp_Flag][Valid]==0){ 
00F68:  MOVF   5D,W
00F6A:  MULLW  06
00F6C:  MOVF   FF3,W
00F6E:  CLRF   x71
00F70:  MOVWF  x70
00F72:  MOVLW  5F
00F74:  ADDWF  x70,W
00F76:  MOVWF  FE9
00F78:  MOVLW  00
00F7A:  ADDWFC x71,W
00F7C:  MOVWF  FEA
00F7E:  MOVF   FEF,F
00F80:  BNZ   1026
....................       idx++; 
00F82:  INCF   x6F,F
....................       if(buffer_flag_Resp[resp_Flag][idx]==1){ 
00F84:  MOVF   5D,W
00F86:  MULLW  06
00F88:  MOVF   FF3,W
00F8A:  CLRF   x71
00F8C:  MOVWF  x70
00F8E:  CLRF   03
00F90:  MOVF   x6F,W
00F92:  ADDWF  x70,W
00F94:  MOVWF  01
00F96:  MOVF   x71,W
00F98:  ADDWFC 03,F
00F9A:  MOVF   01,W
00F9C:  ADDLW  5F
00F9E:  MOVWF  FE9
00FA0:  MOVLW  00
00FA2:  ADDWFC 03,W
00FA4:  MOVWF  FEA
00FA6:  DECFSZ FEF,W
00FA8:  BRA    101C
....................          buffer_flag_Resp[resp_Pos][idx]   = 0; 
00FAA:  MOVF   5C,W
00FAC:  MULLW  06
00FAE:  MOVF   FF3,W
00FB0:  CLRF   x71
00FB2:  MOVWF  x70
00FB4:  CLRF   03
00FB6:  MOVF   x6F,W
00FB8:  ADDWF  x70,W
00FBA:  MOVWF  01
00FBC:  MOVF   x71,W
00FBE:  ADDWFC 03,F
00FC0:  MOVF   01,W
00FC2:  ADDLW  5F
00FC4:  MOVWF  FE9
00FC6:  MOVLW  00
00FC8:  ADDWFC 03,W
00FCA:  MOVWF  FEA
00FCC:  CLRF   FEF
....................          buffer_flag_Resp[resp_Flag][idx]  = 0; 
00FCE:  MOVF   5D,W
00FD0:  MULLW  06
00FD2:  MOVF   FF3,W
00FD4:  CLRF   x71
00FD6:  MOVWF  x70
00FD8:  CLRF   03
00FDA:  MOVF   x6F,W
00FDC:  ADDWF  x70,W
00FDE:  MOVWF  01
00FE0:  MOVF   x71,W
00FE2:  ADDWFC 03,F
00FE4:  MOVF   01,W
00FE6:  ADDLW  5F
00FE8:  MOVWF  FE9
00FEA:  MOVLW  00
00FEC:  ADDWFC 03,W
00FEE:  MOVWF  FEA
00FF0:  CLRF   FEF
....................  
....................          if(idx == Fail || idx == Error){ 
00FF2:  MOVF   x6F,W
00FF4:  SUBLW  04
00FF6:  BZ    0FFE
00FF8:  MOVF   x6F,W
00FFA:  SUBLW  05
00FFC:  BNZ   1018
....................             buffer_flag_Resp[resp_Flag][Valid]  = 1; 
00FFE:  MOVF   5D,W
01000:  MULLW  06
01002:  MOVF   FF3,W
01004:  CLRF   x71
01006:  MOVWF  x70
01008:  MOVLW  5F
0100A:  ADDWF  x70,W
0100C:  MOVWF  FE9
0100E:  MOVLW  00
01010:  ADDWFC x71,W
01012:  MOVWF  FEA
01014:  MOVLW  01
01016:  MOVWF  FEF
....................          } 
....................          ret = idx; 
01018:  MOVFF  16F,16E
....................       } 
....................       // Reinicia el contador para no desbordar el array de flag_resp 
....................       if(idx>=countResp){ 
0101C:  MOVF   5E,W
0101E:  SUBWF  x6F,W
01020:  BNC   1024
....................          idx = 0; 
01022:  CLRF   x6F
....................       } 
01024:  BRA    0F68
....................    }; // Fin del loop 
....................    buffer_flag_Resp[resp_Flag][Valid] = 0; 
01026:  MOVF   5D,W
01028:  MULLW  06
0102A:  MOVF   FF3,W
0102C:  CLRF   x71
0102E:  MOVWF  x70
01030:  MOVLW  5F
01032:  ADDWF  x70,W
01034:  MOVWF  FE9
01036:  MOVLW  00
01038:  ADDWFC x71,W
0103A:  MOVWF  FEA
0103C:  CLRF   FEF
....................    CMD_RUN = 0x00; 
0103E:  CLRF   5B
....................    delay_ms(10); 
01040:  MOVLW  0A
01042:  MOVWF  xCD
01044:  MOVLB  0
01046:  RCALL  0C5A
....................    return ret; 
01048:  MOVLB  1
0104A:  MOVFF  16E,01
0104E:  MOVLB  0
01050:  RETURN 0
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
.................... void waitRespMajor(int buffer,int flag_resp) 
*
00620:  MOVLB  1
00622:  CLRF   xE2
00624:  CLRF   xE3
.................... { 
....................    char  strResp[10]; 
....................    int   lenResp = 0,restartFlag = 0; 
....................  
....................    switch(flag_resp) 
00626:  MOVF   xD7,W
00628:  ADDLW  FB
0062A:  BTFSC  FD8.0
0062C:  BRA    0712
0062E:  ADDLW  05
00630:  MOVLB  0
00632:  GOTO   0812
....................    { 
....................       case Valid: 
....................          strResp = "OK\r\n"; 
00636:  MOVLW  01
00638:  MOVWF  FEA
0063A:  MOVLW  D8
0063C:  MOVWF  FE9
0063E:  MOVFF  FF2,1E4
00642:  BCF    FF2.7
00644:  MOVLW  00
00646:  RCALL  00EA
00648:  TBLRD*-
0064A:  TBLRD*+
0064C:  MOVF   FF5,W
0064E:  MOVWF  FEE
00650:  IORLW  00
00652:  BNZ   064A
00654:  MOVLB  1
00656:  BTFSC  xE4.7
00658:  BSF    FF2.7
....................          lenResp = 4; 
0065A:  MOVLW  04
0065C:  MOVWF  xE2
....................          restartFlag = 1; 
0065E:  MOVLW  01
00660:  MOVWF  xE3
....................          break; 
00662:  BRA    0712
....................  
....................       case NoAp: 
....................          strResp = "No AP"; 
00664:  MOVLW  01
00666:  MOVWF  FEA
00668:  MOVLW  D8
0066A:  MOVWF  FE9
0066C:  MOVFF  FF2,1E4
00670:  BCF    FF2.7
00672:  MOVLW  00
00674:  RCALL  0100
00676:  TBLRD*-
00678:  TBLRD*+
0067A:  MOVF   FF5,W
0067C:  MOVWF  FEE
0067E:  IORLW  00
00680:  BNZ   0678
00682:  MOVLB  1
00684:  BTFSC  xE4.7
00686:  BSF    FF2.7
....................          lenResp = 5; 
00688:  MOVLW  05
0068A:  MOVWF  xE2
....................          break; 
0068C:  BRA    0712
....................  
....................       case CWJAP: 
....................          strResp = "+CWJAP:"; 
0068E:  MOVLW  01
00690:  MOVWF  FEA
00692:  MOVLW  D8
00694:  MOVWF  FE9
00696:  MOVFF  FF2,1E4
0069A:  BCF    FF2.7
0069C:  MOVLW  00
0069E:  RCALL  0116
006A0:  TBLRD*-
006A2:  TBLRD*+
006A4:  MOVF   FF5,W
006A6:  MOVWF  FEE
006A8:  IORLW  00
006AA:  BNZ   06A2
006AC:  MOVLB  1
006AE:  BTFSC  xE4.7
006B0:  BSF    FF2.7
....................          lenResp = 7; 
006B2:  MOVLW  07
006B4:  MOVWF  xE2
....................          break; 
006B6:  BRA    0712
....................           
....................       case Connected: 
....................          strResp = "CONNECTED"; 
006B8:  MOVLW  01
006BA:  MOVWF  FEA
006BC:  MOVLW  D8
006BE:  MOVWF  FE9
006C0:  MOVFF  FF2,1E4
006C4:  BCF    FF2.7
006C6:  MOVLW  00
006C8:  RCALL  012E
006CA:  TBLRD*-
006CC:  TBLRD*+
006CE:  MOVF   FF5,W
006D0:  MOVWF  FEE
006D2:  IORLW  00
006D4:  BNZ   06CC
006D6:  MOVLB  1
006D8:  BTFSC  xE4.7
006DA:  BSF    FF2.7
....................          lenResp = 9; 
006DC:  MOVLW  09
006DE:  MOVWF  xE2
....................          break; 
006E0:  BRA    0712
....................        
....................       case Fail: 
....................          strResp = "FAIL"; 
006E2:  MOVLW  01
006E4:  MOVWF  FEA
006E6:  MOVLW  D8
006E8:  MOVWF  FE9
006EA:  MOVFF  FF2,1E4
006EE:  BCF    FF2.7
006F0:  MOVLW  00
006F2:  RCALL  0148
006F4:  TBLRD*-
006F6:  TBLRD*+
006F8:  MOVF   FF5,W
006FA:  MOVWF  FEE
006FC:  IORLW  00
006FE:  BNZ   06F6
00700:  MOVLB  1
00702:  BTFSC  xE4.7
00704:  BSF    FF2.7
....................          lenResp = 4; 
00706:  MOVLW  04
00708:  MOVWF  xE2
....................          restartFlag = 1; 
0070A:  MOVLW  01
0070C:  MOVWF  xE3
....................          break; 
0070E:  BRA    0712
00710:  MOVLB  1
....................    } 
....................  
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................  
....................    if(buffer == strResp[buffer_flag_Resp[resp_Pos][flag_resp]]) 
00712:  MOVF   5C,W
00714:  MULLW  06
00716:  MOVF   FF3,W
00718:  CLRF   xE5
0071A:  MOVWF  xE4
0071C:  CLRF   03
0071E:  MOVF   xD7,W
00720:  ADDWF  xE4,W
00722:  MOVWF  01
00724:  MOVF   xE5,W
00726:  ADDWFC 03,F
00728:  MOVF   01,W
0072A:  ADDLW  5F
0072C:  MOVWF  FE9
0072E:  MOVLW  00
00730:  ADDWFC 03,W
00732:  MOVWF  FEA
00734:  CLRF   03
00736:  MOVF   FEF,W
00738:  ADDLW  D8
0073A:  MOVWF  FE9
0073C:  MOVLW  01
0073E:  ADDWFC 03,W
00740:  MOVWF  FEA
00742:  MOVF   FEF,W
00744:  SUBWF  xD6,W
00746:  BNZ   07C2
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       buffer_flag_Resp[resp_Pos][flag_resp]++; 
00748:  MOVF   5C,W
0074A:  MULLW  06
0074C:  MOVF   FF3,W
0074E:  CLRF   xE5
00750:  MOVWF  xE4
00752:  CLRF   03
00754:  MOVF   xD7,W
00756:  ADDWF  xE4,W
00758:  MOVWF  01
0075A:  MOVF   xE5,W
0075C:  ADDWFC 03,F
0075E:  MOVF   01,W
00760:  ADDLW  5F
00762:  MOVWF  FE9
00764:  MOVLW  00
00766:  ADDWFC 03,W
00768:  MOVWF  FEA
0076A:  INCF   FEF,F
....................        
....................       if(buffer_flag_Resp[resp_Pos][flag_resp]==lenResp){ 
0076C:  MOVF   5C,W
0076E:  MULLW  06
00770:  MOVF   FF3,W
00772:  CLRF   xE5
00774:  MOVWF  xE4
00776:  CLRF   03
00778:  MOVF   xD7,W
0077A:  ADDWF  xE4,W
0077C:  MOVWF  01
0077E:  MOVF   xE5,W
00780:  ADDWFC 03,F
00782:  MOVF   01,W
00784:  ADDLW  5F
00786:  MOVWF  FE9
00788:  MOVLW  00
0078A:  ADDWFC 03,W
0078C:  MOVWF  FEA
0078E:  MOVF   xE2,W
00790:  SUBWF  FEF,W
00792:  BNZ   07BC
....................          // Respuesta es valida 
....................          buffer_flag_Resp[resp_Flag][flag_resp]  = 1; 
00794:  MOVF   5D,W
00796:  MULLW  06
00798:  MOVF   FF3,W
0079A:  CLRF   xE5
0079C:  MOVWF  xE4
0079E:  CLRF   03
007A0:  MOVF   xD7,W
007A2:  ADDWF  xE4,W
007A4:  MOVWF  01
007A6:  MOVF   xE5,W
007A8:  ADDWFC 03,F
007AA:  MOVF   01,W
007AC:  ADDLW  5F
007AE:  MOVWF  FE9
007B0:  MOVLW  00
007B2:  ADDWFC 03,W
007B4:  MOVWF  FEA
007B6:  MOVLW  01
007B8:  MOVWF  FEF
....................       }else if(flag_resp == Valid) { 
007BA:  BRA    07C0
007BC:  MOVF   xD7,F
007BE:  BNZ   07C0
....................          // Reinicia la bandera para indicar el final del comando 
....................          //buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
....................       } 
....................         
....................    }else{ 
007C0:  BRA    080E
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       buffer_flag_Resp[resp_Pos][flag_resp]   = 0; 
007C2:  MOVF   5C,W
007C4:  MULLW  06
007C6:  MOVF   FF3,W
007C8:  CLRF   xE5
007CA:  MOVWF  xE4
007CC:  CLRF   03
007CE:  MOVF   xD7,W
007D0:  ADDWF  xE4,W
007D2:  MOVWF  01
007D4:  MOVF   xE5,W
007D6:  ADDWFC 03,F
007D8:  MOVF   01,W
007DA:  ADDLW  5F
007DC:  MOVWF  FE9
007DE:  MOVLW  00
007E0:  ADDWFC 03,W
007E2:  MOVWF  FEA
007E4:  CLRF   FEF
....................  
....................       // Banderas que se reinician 
....................       if(restartFlag == 1){ 
007E6:  DECFSZ xE3,W
007E8:  BRA    080E
....................          buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
007EA:  MOVF   5D,W
007EC:  MULLW  06
007EE:  MOVF   FF3,W
007F0:  CLRF   xE5
007F2:  MOVWF  xE4
007F4:  CLRF   03
007F6:  MOVF   xD7,W
007F8:  ADDWF  xE4,W
007FA:  MOVWF  01
007FC:  MOVF   xE5,W
007FE:  ADDWFC 03,F
00800:  MOVF   01,W
00802:  ADDLW  5F
00804:  MOVWF  FE9
00806:  MOVLW  00
00808:  ADDWFC 03,W
0080A:  MOVWF  FEA
0080C:  CLRF   FEF
....................       } 
....................        
....................    } 
0080E:  MOVLB  0
00810:  RETURN 0
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la IP del modo AP, STA, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getIP(int buffer) 
.................... { 
....................    const int END_GET_IP_CMD = 6; 
....................     
....................    // bandera de IP_First esta habilita 
....................    if(flag_Resp_Get_IP_CMD==1){ 
*
00836:  DECFSZ xBB,W
00838:  BRA    0890
....................       // Fin de Get First IP 
....................       if(buffer == '"'){ 
0083A:  MOVLB  1
0083C:  MOVF   xD6,W
0083E:  SUBLW  22
00840:  BNZ   085E
....................          // Finaliza el almacenamiento en el buffer 
....................          if( modeStar=='1' || modeStar=='2' ){ 
00842:  MOVLB  0
00844:  MOVF   xC1,W
00846:  SUBLW  31
00848:  BZ    0850
0084A:  MOVF   xC1,W
0084C:  SUBLW  32
0084E:  BNZ   0858
....................             flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
00850:  MOVLW  06
00852:  MOVWF  xBB
....................             flag_Pos_Get_IP_CMD =0; 
00854:  CLRF   xBC
....................          }else{ 
00856:  BRA    085A
....................             // Activa Bandera de IP_STACION, reinicia el contador de Pos 
....................             flag_Pos_Get_IP_CMD =0; 
00858:  CLRF   xBC
....................          } 
....................  
....................       }else{ 
0085A:  BRA    088E
0085C:  MOVLB  1
....................          if(modeStar=='1'){ 
0085E:  MOVLB  0
00860:  MOVF   xC1,W
00862:  SUBLW  31
00864:  BNZ   087A
....................             // IP Estacion 
....................             buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
00866:  CLRF   03
00868:  MOVF   xBC,W
0086A:  ADDLW  7B
0086C:  MOVWF  FE9
0086E:  MOVLW  00
00870:  ADDWFC 03,W
00872:  MOVWF  FEA
00874:  MOVFF  1D6,FEF
....................          }else{ 
00878:  BRA    088C
....................             // IP AP 
....................              buffer_Resp_CMD[0][flag_Pos_Get_IP_CMD] = buffer; 
0087A:  CLRF   03
0087C:  MOVF   xBC,W
0087E:  ADDLW  6B
00880:  MOVWF  FE9
00882:  MOVLW  00
00884:  ADDWFC 03,W
00886:  MOVWF  FEA
00888:  MOVFF  1D6,FEF
....................          } 
....................          flag_Pos_Get_IP_CMD++; 
0088C:  INCF   xBC,F
....................       } // Fin del if(buffer == '"') 
....................     
....................    // bandera de IP_Second(Estacion) esta habilita 
....................    }else if(flag_Resp_Get_IP_CMD==5){ 
0088E:  BRA    08C0
00890:  MOVF   xBB,W
00892:  SUBLW  05
00894:  BNZ   08C0
....................        if(buffer == '"'){ 
00896:  MOVLB  1
00898:  MOVF   xD6,W
0089A:  SUBLW  22
0089C:  BNZ   08AA
....................          flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
0089E:  MOVLW  06
008A0:  MOVLB  0
008A2:  MOVWF  xBB
....................          flag_Pos_Get_IP_CMD =0; 
008A4:  CLRF   xBC
....................        }else{ 
008A6:  BRA    08C0
008A8:  MOVLB  1
....................          buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
008AA:  CLRF   03
008AC:  MOVLB  0
008AE:  MOVF   xBC,W
008B0:  ADDLW  7B
008B2:  MOVWF  FE9
008B4:  MOVLW  00
008B6:  ADDWFC 03,W
008B8:  MOVWF  FEA
008BA:  MOVFF  1D6,FEF
....................          flag_Pos_Get_IP_CMD++; 
008BE:  INCF   xBC,F
....................        } 
....................    } // Fin de if(flag_Resp_Get_IP_CMD) 
....................        
....................    if( buffer == '"'){ 
008C0:  MOVLB  1
008C2:  MOVF   xD6,W
008C4:  SUBLW  22
008C6:  BNZ   08DC
....................       switch(flag_Resp_Get_IP_CMD){ 
008C8:  MOVLB  0
008CA:  MOVF   xBB,W
008CC:  ADDLW  FB
008CE:  BC    08DA
008D0:  ADDLW  05
008D2:  GOTO   08E2
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................          case 4: 
....................             flag_Resp_Get_IP_CMD++; 
008D6:  INCF   xBB,F
....................             flag_Pos_Get_IP_CMD =0; 
008D8:  CLRF   xBC
....................             break; 
008DA:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
008DC:  MOVLB  0
008DE:  GOTO   0B88 (RETURN)
.................... } // Fin de la funcion getIP() 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo AP, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getAPInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_AP_Info_CMD==1){ 
*
00906:  DECFSZ xBD,W
00908:  BRA    092E
....................        
....................       if(buffer != '"'){ 
0090A:  MOVLB  1
0090C:  MOVF   xD6,W
0090E:  SUBLW  22
00910:  BZ    092A
....................          buffer_Resp_CMD[2][flag_Pos_Get_AP_Info_CMD] = buffer; 
00912:  CLRF   03
00914:  MOVLB  0
00916:  MOVF   xBE,W
00918:  ADDLW  8B
0091A:  MOVWF  FE9
0091C:  MOVLW  00
0091E:  ADDWFC 03,W
00920:  MOVWF  FEA
00922:  MOVFF  1D6,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
00926:  INCF   xBE,F
00928:  MOVLB  1
....................       } 
....................  
....................    }else if(flag_Resp_Get_AP_Info_CMD==3){ 
0092A:  BRA    095C
0092C:  MOVLB  0
0092E:  MOVF   xBD,W
00930:  SUBLW  03
00932:  BNZ   095A
....................        
....................       if(buffer != '"'){ 
00934:  MOVLB  1
00936:  MOVF   xD6,W
00938:  SUBLW  22
0093A:  BZ    0956
....................          buffer_Resp_CMD[3][flag_Pos_Get_AP_Info_CMD] = buffer; 
0093C:  CLRF   03
0093E:  MOVLB  0
00940:  MOVF   xBE,W
00942:  ADDLW  9B
00944:  MOVWF  FE9
00946:  MOVLW  00
00948:  ADDWFC 03,W
0094A:  MOVWF  FEA
0094C:  MOVFF  1D6,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
00950:  INCF   xBE,F
....................       }else{ 
00952:  BRA    095A
00954:  MOVLB  1
....................          flag_Pos_Get_AP_Info_CMD =0; 
00956:  MOVLB  0
00958:  CLRF   xBE
0095A:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
0095C:  MOVF   xD6,W
0095E:  SUBLW  22
00960:  BNZ   0976
....................       switch(flag_Resp_Get_AP_Info_CMD){ 
00962:  MOVLB  0
00964:  MOVF   xBD,W
00966:  ADDLW  FC
00968:  BC    0974
0096A:  ADDLW  04
0096C:  GOTO   097C
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................             flag_Resp_Get_AP_Info_CMD++; 
00970:  INCF   xBD,F
....................             flag_Pos_Get_AP_Info_CMD =0; 
00972:  CLRF   xBE
....................             break; 
00974:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
00976:  MOVLB  0
00978:  GOTO   0B9C (RETURN)
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo STA 
....................  *     
....................  *********************************************************/ 
.................... void getSTAInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_STA_Info_CMD==1){ 
*
0099E:  DECFSZ xBF,W
009A0:  BRA    09C0
....................        
....................       if(buffer != '"'){ 
009A2:  MOVLB  1
009A4:  MOVF   xD6,W
009A6:  SUBLW  22
009A8:  BZ    09C2
....................          buffer_Resp_CMD[4][flag_Pos_Get_STA_Info_CMD] = buffer; 
009AA:  CLRF   03
009AC:  MOVLB  0
009AE:  MOVF   xC0,W
009B0:  ADDLW  AB
009B2:  MOVWF  FE9
009B4:  MOVLW  00
009B6:  ADDWFC 03,W
009B8:  MOVWF  FEA
009BA:  MOVFF  1D6,FEF
....................          flag_Pos_Get_STA_Info_CMD++; 
009BE:  INCF   xC0,F
009C0:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
009C2:  MOVF   xD6,W
009C4:  SUBLW  22
009C6:  BNZ   09DA
....................       switch(flag_Resp_Get_STA_Info_CMD){ 
009C8:  MOVLB  0
009CA:  MOVF   xBF,W
009CC:  BZ    09D4
009CE:  XORLW  01
009D0:  BZ    09D4
009D2:  BRA    09D8
....................          case 0: 
....................          case 1: 
....................             flag_Resp_Get_STA_Info_CMD++; 
009D4:  INCF   xBF,F
....................             flag_Pos_Get_STA_Info_CMD =0; 
009D6:  CLRF   xC0
....................             break; 
009D8:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_STA_Info_CMD) 
....................    } // Fin del if(buffer == '"')  
009DA:  MOVLB  0
009DC:  GOTO   0BB0 (RETURN)
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /******************************************************* 
....................  
....................    Company Name:  KRIVER DEVICE  
....................    Product Name:  KRIVER SMART HOME 
....................     
....................    Developer:     CRHISTIAN DAVID VERGARA 
....................    Date:          21 Diciembre de 2017 
....................     
....................    FILE:          menu.H: contiene las funciones que 
....................                           muestran y ejecutan las 
....................                           operaciones de los menus 
....................  
.................... *******************************************************/ 
....................  
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_STA_IP     0 
....................   #define OPT_SHOW_STA_SSID   1 
....................   #define OPT_SHOW_AP_SSID    2 
....................   #define OPT_SHOW_AP_KEY     3 
....................   #define OPT_SHOW_AP_IP      4 
....................   #define OPT_MODE_AP         5 
....................   #define OPT_RESET_ALL       6 
....................   #define OPT_BACKLIGH        7 
....................   #define OPT_EXIT            8 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................     #define MODE_EXIT       3 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... char  optMenuOn[10][11]            =   {{"Output 1  "}, 
....................                                         {"Output 2  "}, 
....................                                         {"Output 3  "}, 
....................                                         {"Output 4  "}, 
....................                                         {"Output 5  "}, 
....................                                         {"Output 6  "}, 
....................                                         {"Output 7  "}, 
....................                                         {"Output 8  "}, 
....................                                         {"SALIR     "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[9][17]    =  { {"ESTACION IP     "}, 
....................                                         {"ESTACION SSID   "}, 
....................                                         {"AP SSID         "}, 
....................                                         {"AP KEY          "}, 
....................                                         {"AP IP           "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"Borrar a Fabrica"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacion     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 8; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo   = 3; 
....................  
....................  
.................... /*************************************************** 
....................    Carga el nombre de las opciones del menu On y Off 
.................... ***************************************************/ 
.................... void getNameMenusOutput(){ 
*
012F2:  MOVLB  1
012F4:  CLRF   x6A
012F6:  SETF   x6B
....................    int posIni = 0; 
....................    int hasData = 0xFF; 
....................    posIni = read_eeprom(0x00); 
012F8:  MOVFF  FF2,16E
012FC:  BCF    FF2.7
012FE:  CLRF   FAA
01300:  CLRF   FA9
01302:  BCF    FA6.6
01304:  BCF    FA6.7
01306:  BSF    FA6.0
01308:  MOVF   FA8,W
0130A:  BTFSC  x6E.7
0130C:  BSF    FF2.7
0130E:  MOVWF  x6A
....................     
....................    if(posIni!=0xFF){ 
01310:  INCFSZ x6A,W
01312:  BRA    1316
01314:  BRA    13C8
....................       posIni =0; 
01316:  CLRF   x6A
....................       for(int idx=0;idx<8;idx++){ 
01318:  CLRF   x6C
0131A:  MOVF   x6C,W
0131C:  SUBLW  07
0131E:  BNC   13B0
....................           
....................          posIni =( 10 * idx ) + 40; 
01320:  MOVF   x6C,W
01322:  MULLW  0A
01324:  MOVF   FF3,W
01326:  ADDLW  28
01328:  MOVWF  x6A
....................          hasData = read_eeprom(posIni); 
0132A:  MOVFF  FF2,16E
0132E:  BCF    FF2.7
01330:  CLRF   FAA
01332:  MOVFF  16A,FA9
01336:  BCF    FA6.6
01338:  BCF    FA6.7
0133A:  BSF    FA6.0
0133C:  MOVF   FA8,W
0133E:  BTFSC  x6E.7
01340:  BSF    FF2.7
01342:  MOVWF  x6B
....................          delay_ms(10); 
01344:  MOVLW  0A
01346:  MOVWF  xCD
01348:  MOVLB  0
0134A:  RCALL  0C5A
....................           
....................          if(hasData!=0xFF){ 
0134C:  MOVLB  1
0134E:  INCFSZ x6B,W
01350:  BRA    1354
01352:  BRA    13AC
....................             for(int idxChar=0;idxChar<=9;idxChar++){ 
01354:  CLRF   x6D
01356:  MOVF   x6D,W
01358:  SUBLW  09
0135A:  BNC   13AC
....................                optMenuOn[idx][idxChar]=read_eeprom(posIni+idxChar); 
0135C:  MOVF   x6C,W
0135E:  MULLW  0B
01360:  MOVF   FF3,W
01362:  CLRF   x6F
01364:  MOVWF  x6E
01366:  CLRF   03
01368:  MOVF   x6D,W
0136A:  ADDWF  x6E,W
0136C:  MOVWF  01
0136E:  MOVF   x6F,W
01370:  ADDWFC 03,F
01372:  MOVF   01,W
01374:  ADDLW  F4
01376:  MOVWF  FE9
01378:  MOVLW  00
0137A:  ADDWFC 03,W
0137C:  MOVWF  FEA
0137E:  MOVF   x6D,W
01380:  ADDWF  x6A,W
01382:  MOVWF  x70
01384:  MOVFF  FF2,171
01388:  BCF    FF2.7
0138A:  CLRF   FAA
0138C:  MOVFF  170,FA9
01390:  BCF    FA6.6
01392:  BCF    FA6.7
01394:  BSF    FA6.0
01396:  MOVF   FA8,W
01398:  BTFSC  x71.7
0139A:  BSF    FF2.7
0139C:  MOVWF  FEF
....................                delay_ms(10); 
0139E:  MOVLW  0A
013A0:  MOVWF  xCD
013A2:  MOVLB  0
013A4:  RCALL  0C5A
013A6:  MOVLB  1
013A8:  INCF   x6D,F
013AA:  BRA    1356
....................             } 
....................          } 
013AC:  INCF   x6C,F
013AE:  BRA    131A
....................       } 
....................        
....................       optMenuOn[8][0]='\f'; 
013B0:  MOVLW  0C
013B2:  MOVWF  x4C
....................       optMenuOn[8][1]='S'; 
013B4:  MOVLW  53
013B6:  MOVWF  x4D
....................       optMenuOn[8][2]='A'; 
013B8:  MOVLW  41
013BA:  MOVWF  x4E
....................       optMenuOn[8][3]='L'; 
013BC:  MOVLW  4C
013BE:  MOVWF  x4F
....................       optMenuOn[8][4]='I'; 
013C0:  MOVLW  49
013C2:  MOVWF  x50
....................       optMenuOn[8][5]='R'; 
013C4:  MOVLW  52
013C6:  MOVWF  x51
....................    }    
013C8:  MOVLB  0
013CA:  GOTO   2DD4 (RETURN)
.................... } // FIn de la funcion getNameMenusOutput 
....................  
.................... /*************************************************** 
....................    Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
02144:  MOVLB  1
02146:  CLRF   x6A
02148:  CLRF   x6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
0214A:  MOVF   x6A,W
0214C:  MULLW  10
0214E:  MOVF   FF3,W
02150:  CLRF   03
02152:  MOVWF  x6C
02154:  MOVLW  0C
02156:  MOVWF  x73
02158:  MOVLB  0
0215A:  CALL   0EAC
0215E:  MOVLW  14
02160:  MOVWF  FF6
02162:  MOVLW  03
02164:  MOVWF  FF7
02166:  MOVLB  1
02168:  MOVF   x6C,W
0216A:  ADDWF  FF6,F
0216C:  MOVLW  00
0216E:  ADDWFC FF7,F
02170:  MOVLB  0
02172:  CALL   0F18
....................    showBottonMenu(); 
02176:  CALL   13CE
....................    while(!exit){ 
0217A:  MOVLB  1
0217C:  MOVF   x6B,F
0217E:  BNZ   222A
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02180:  MOVLB  0
02182:  CALL   1492
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
02186:  BSF    F93.4
02188:  BTFSC  F81.4
0218A:  BRA    21F0
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0218C:  MOVLW  02
0218E:  MOVLB  1
02190:  MOVWF  x6C
02192:  MOVLW  FA
02194:  MOVWF  xCD
02196:  MOVLB  0
02198:  CALL   0C5A
0219C:  MOVLB  1
0219E:  DECFSZ x6C,F
021A0:  BRA    2192
....................          BEEP; 
021A2:  MOVLW  04
021A4:  MOVWF  x71
021A6:  MOVLW  B9
021A8:  MOVWF  x70
021AA:  CLRF   x73
021AC:  MOVLW  14
021AE:  MOVWF  x72
021B0:  MOVLB  0
021B2:  RCALL  1FFC
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
021B4:  MOVLB  1
021B6:  INCF   x6A,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuStart){ 
021B8:  MOVF   x6A,W
021BA:  SUBWF  x62,W
021BC:  BC    21C0
....................             optSelected = 0; 
021BE:  CLRF   x6A
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
021C0:  MOVF   x6A,W
021C2:  MULLW  10
021C4:  MOVF   FF3,W
021C6:  CLRF   03
021C8:  MOVWF  x6C
021CA:  MOVLW  0C
021CC:  MOVWF  x73
021CE:  MOVLB  0
021D0:  CALL   0EAC
021D4:  MOVLW  14
021D6:  MOVWF  FF6
021D8:  MOVLW  03
021DA:  MOVWF  FF7
021DC:  MOVLB  1
021DE:  MOVF   x6C,W
021E0:  ADDWF  FF6,F
021E2:  MOVLW  00
021E4:  ADDWFC FF7,F
021E6:  MOVLB  0
021E8:  CALL   0F18
....................          showBottonMenu(); 
021EC:  CALL   13CE
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
021F0:  BSF    F93.5
021F2:  BTFSC  F81.5
021F4:  BRA    2226
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
021F6:  MOVLW  02
021F8:  MOVLB  1
021FA:  MOVWF  x6C
021FC:  MOVLW  FA
021FE:  MOVWF  xCD
02200:  MOVLB  0
02202:  CALL   0C5A
02206:  MOVLB  1
02208:  DECFSZ x6C,F
0220A:  BRA    21FC
....................          BEEP; 
0220C:  MOVLW  04
0220E:  MOVWF  x71
02210:  MOVLW  B9
02212:  MOVWF  x70
02214:  CLRF   x73
02216:  MOVLW  14
02218:  MOVWF  x72
0221A:  MOVLB  0
0221C:  RCALL  1FFC
....................          // Rompe el Loop 
....................          exit = 1; 
0221E:  MOVLW  01
02220:  MOVLB  1
02222:  MOVWF  x6B
02224:  MOVLB  0
....................       } // Fin KEY_OK 
02226:  BRA    217A
02228:  MOVLB  1
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
0222A:  MOVLW  01
0222C:  ADDWF  x6A,W
0222E:  MOVWF  01
02230:  MOVLB  0
02232:  GOTO   2DF0 (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
*
02528:  MOVLB  1
0252A:  CLRF   x70
....................   int exit=0; 
....................   lcd_gotoxy(12,2); 
0252C:  MOVLW  0C
0252E:  MOVWF  x74
02530:  MOVLW  02
02532:  MOVWF  x75
02534:  MOVLB  0
02536:  CALL   0E86
....................   printf(lcd_putc, "SALIR"); 
0253A:  MOVLW  34
0253C:  MOVWF  FF6
0253E:  MOVLW  04
02540:  MOVWF  FF7
02542:  CALL   0F18
....................    
....................   while(exit==0){ 
02546:  MOVLB  1
02548:  MOVF   x70,F
0254A:  BNZ   2578
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
0254C:  MOVLB  0
0254E:  CALL   1492
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
02552:  BSF    F93.5
02554:  BTFSC  F81.5
02556:  BRA    2574
....................            // Elimina el rebote 
....................            delay_ms(500); 
02558:  MOVLW  02
0255A:  MOVLB  1
0255C:  MOVWF  x71
0255E:  MOVLW  FA
02560:  MOVWF  xCD
02562:  MOVLB  0
02564:  CALL   0C5A
02568:  MOVLB  1
0256A:  DECFSZ x71,F
0256C:  BRA    255E
....................            exit=1; 
0256E:  MOVLW  01
02570:  MOVWF  x70
02572:  MOVLB  0
....................            //break; 
....................      } 
02574:  BRA    2546
02576:  MOVLB  1
....................   } 
02578:  MOVLB  0
0257A:  RETURN 0
.................... } // Fin de la funcion pressExit 
.................... /*************************************************** 
....................    Dibuja en la parte inferior del Display los botones de 
....................    Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
013CE:  MOVLW  01
013D0:  MOVLB  1
013D2:  MOVWF  x74
013D4:  MOVLW  02
013D6:  MOVWF  x75
013D8:  MOVLB  0
013DA:  RCALL  0E86
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
013DC:  MOVLW  3A
013DE:  MOVWF  FF6
013E0:  MOVLW  04
013E2:  MOVWF  FF7
013E4:  RCALL  0F18
013E6:  RETURN 0
.................... } 
....................  
.................... /*************************************************** 
....................    Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
02286:  MOVLB  1
02288:  CLRF   x6A
0228A:  CLRF   x6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\fOn -> %s",optMenuOn[optSelected]); 
0228C:  MOVF   x6A,W
0228E:  MULLW  0B
02290:  MOVF   FF3,W
02292:  CLRF   03
02294:  ADDLW  F4
02296:  MOVWF  01
02298:  MOVLW  00
0229A:  ADDWFC 03,F
0229C:  MOVFF  01,16C
022A0:  MOVFF  03,16D
022A4:  MOVLW  4C
022A6:  MOVWF  FF6
022A8:  MOVLW  04
022AA:  MOVWF  FF7
022AC:  MOVLW  07
022AE:  MOVWF  x6E
022B0:  MOVLB  0
022B2:  RCALL  2236
022B4:  MOVFF  16D,FEA
022B8:  MOVFF  16C,FE9
022BC:  RCALL  2260
....................    showBottonMenu(); 
022BE:  CALL   13CE
....................     
....................    while(!exit){ 
022C2:  MOVLB  1
022C4:  MOVF   x6B,F
022C6:  BTFSS  FD8.2
022C8:  BRA    23CE
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
022CA:  MOVLB  0
022CC:  CALL   1492
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
022D0:  BSF    F93.4
022D2:  BTFSC  F81.4
022D4:  BRA    2340
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
022D6:  MOVLW  02
022D8:  MOVLB  1
022DA:  MOVWF  x6C
022DC:  MOVLW  FA
022DE:  MOVWF  xCD
022E0:  MOVLB  0
022E2:  CALL   0C5A
022E6:  MOVLB  1
022E8:  DECFSZ x6C,F
022EA:  BRA    22DC
....................          BEEP; 
022EC:  MOVLW  04
022EE:  MOVWF  x71
022F0:  MOVLW  B9
022F2:  MOVWF  x70
022F4:  CLRF   x73
022F6:  MOVLW  14
022F8:  MOVWF  x72
022FA:  MOVLB  0
022FC:  RCALL  1FFC
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
022FE:  MOVLB  1
02300:  INCF   x6A,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
02302:  MOVF   x6A,W
02304:  SUBWF  x63,W
02306:  BC    230A
....................             optSelected = 0; 
02308:  CLRF   x6A
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\fOn -> %s",optMenuOn[optSelected]); 
0230A:  MOVF   x6A,W
0230C:  MULLW  0B
0230E:  MOVF   FF3,W
02310:  CLRF   03
02312:  ADDLW  F4
02314:  MOVWF  01
02316:  MOVLW  00
02318:  ADDWFC 03,F
0231A:  MOVFF  01,16C
0231E:  MOVFF  03,16D
02322:  MOVLW  56
02324:  MOVWF  FF6
02326:  MOVLW  04
02328:  MOVWF  FF7
0232A:  MOVLW  07
0232C:  MOVWF  x6E
0232E:  MOVLB  0
02330:  RCALL  2236
02332:  MOVFF  16D,FEA
02336:  MOVFF  16C,FE9
0233A:  RCALL  2260
....................          showBottonMenu(); 
0233C:  CALL   13CE
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
02340:  BSF    F93.5
02342:  BTFSC  F81.5
02344:  BRA    23CA
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02346:  MOVLW  02
02348:  MOVLB  1
0234A:  MOVWF  x6C
0234C:  MOVLW  FA
0234E:  MOVWF  xCD
02350:  MOVLB  0
02352:  CALL   0C5A
02356:  MOVLB  1
02358:  DECFSZ x6C,F
0235A:  BRA    234C
....................          BEEP; 
0235C:  MOVLW  04
0235E:  MOVWF  x71
02360:  MOVLW  B9
02362:  MOVWF  x70
02364:  CLRF   x73
02366:  MOVLW  14
02368:  MOVWF  x72
0236A:  MOVLB  0
0236C:  RCALL  1FFC
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuOn){ 
0236E:  MOVLB  1
02370:  MOVF   x63,W
02372:  SUBWF  x6A,W
02374:  BNZ   237C
....................             exit = 1; 
02376:  MOVLW  01
02378:  MOVWF  x6B
....................          }else{ 
0237A:  BRA    23CC
....................             output_high(PIN_OUT[optSelected]); 
0237C:  BCF    FD8.0
0237E:  RLCF   x6A,W
02380:  CLRF   03
02382:  MOVFF  FF2,16C
02386:  BCF    FF2.7
02388:  MOVLB  0
0238A:  CALL   0096
0238E:  TBLRD*+
02390:  MOVFF  FF5,03
02394:  MOVLB  1
02396:  BTFSC  x6C.7
02398:  BSF    FF2.7
0239A:  MOVWF  x6C
0239C:  MOVFF  03,16D
023A0:  MOVWF  xCE
023A2:  MOVLW  01
023A4:  MOVWF  xCF
023A6:  MOVLW  0F
023A8:  MOVWF  xD1
023AA:  MOVLW  89
023AC:  MOVWF  xD0
023AE:  MOVLB  0
023B0:  CALL   0C18
023B4:  MOVFF  16C,1CE
023B8:  MOVLB  1
023BA:  CLRF   xCF
023BC:  MOVLW  0F
023BE:  MOVWF  xD1
023C0:  MOVLW  92
023C2:  MOVWF  xD0
023C4:  MOVLB  0
023C6:  CALL   0C18
023CA:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
023CC:  BRA    22C4
....................    } // FIN While Infinito 
....................  
....................    return 0; 
023CE:  MOVLW  00
023D0:  MOVWF  01
023D2:  MOVLB  0
023D4:  GOTO   2DFC (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
....................    Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
023D8:  MOVLB  1
023DA:  CLRF   x6A
023DC:  CLRF   x6B
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\fOff-> %s",optMenuOn[optSelected]); 
023DE:  MOVF   x6A,W
023E0:  MULLW  0B
023E2:  MOVF   FF3,W
023E4:  CLRF   03
023E6:  ADDLW  F4
023E8:  MOVWF  01
023EA:  MOVLW  00
023EC:  ADDWFC 03,F
023EE:  MOVFF  01,16C
023F2:  MOVFF  03,16D
023F6:  MOVLW  60
023F8:  MOVWF  FF6
023FA:  MOVLW  04
023FC:  MOVWF  FF7
023FE:  MOVLW  07
02400:  MOVWF  x6E
02402:  MOVLB  0
02404:  RCALL  2236
02406:  MOVFF  16D,FEA
0240A:  MOVFF  16C,FE9
0240E:  RCALL  2260
....................    showBottonMenu(); 
02410:  CALL   13CE
....................     
....................    while(!exit){ 
02414:  MOVLB  1
02416:  MOVF   x6B,F
02418:  BTFSS  FD8.2
0241A:  BRA    251E
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
0241C:  MOVLB  0
0241E:  CALL   1492
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
02422:  BSF    F93.4
02424:  BTFSC  F81.4
02426:  BRA    2492
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02428:  MOVLW  02
0242A:  MOVLB  1
0242C:  MOVWF  x6C
0242E:  MOVLW  FA
02430:  MOVWF  xCD
02432:  MOVLB  0
02434:  CALL   0C5A
02438:  MOVLB  1
0243A:  DECFSZ x6C,F
0243C:  BRA    242E
....................          BEEP; 
0243E:  MOVLW  04
02440:  MOVWF  x71
02442:  MOVLW  B9
02444:  MOVWF  x70
02446:  CLRF   x73
02448:  MOVLW  14
0244A:  MOVWF  x72
0244C:  MOVLB  0
0244E:  RCALL  1FFC
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
02450:  MOVLB  1
02452:  INCF   x6A,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
02454:  MOVF   x6A,W
02456:  SUBWF  x64,W
02458:  BC    245C
....................             optSelected = 0; 
0245A:  CLRF   x6A
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\fOff-> %s",optMenuOn[optSelected]); 
0245C:  MOVF   x6A,W
0245E:  MULLW  0B
02460:  MOVF   FF3,W
02462:  CLRF   03
02464:  ADDLW  F4
02466:  MOVWF  01
02468:  MOVLW  00
0246A:  ADDWFC 03,F
0246C:  MOVFF  01,16C
02470:  MOVFF  03,16D
02474:  MOVLW  6A
02476:  MOVWF  FF6
02478:  MOVLW  04
0247A:  MOVWF  FF7
0247C:  MOVLW  07
0247E:  MOVWF  x6E
02480:  MOVLB  0
02482:  RCALL  2236
02484:  MOVFF  16D,FEA
02488:  MOVFF  16C,FE9
0248C:  RCALL  2260
....................          showBottonMenu(); 
0248E:  CALL   13CE
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
02492:  BSF    F93.5
02494:  BTFSC  F81.5
02496:  BRA    251A
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02498:  MOVLW  02
0249A:  MOVLB  1
0249C:  MOVWF  x6C
0249E:  MOVLW  FA
024A0:  MOVWF  xCD
024A2:  MOVLB  0
024A4:  CALL   0C5A
024A8:  MOVLB  1
024AA:  DECFSZ x6C,F
024AC:  BRA    249E
....................          BEEP; 
024AE:  MOVLW  04
024B0:  MOVWF  x71
024B2:  MOVLW  B9
024B4:  MOVWF  x70
024B6:  CLRF   x73
024B8:  MOVLW  14
024BA:  MOVWF  x72
024BC:  MOVLB  0
024BE:  RCALL  1FFC
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuOff){ 
024C0:  MOVLB  1
024C2:  MOVF   x64,W
024C4:  SUBWF  x6A,W
024C6:  BNZ   24CE
....................             exit = 1; 
024C8:  MOVLW  01
024CA:  MOVWF  x6B
....................          }else{ 
024CC:  BRA    251C
....................             output_low(PIN_OUT[optSelected]); 
024CE:  BCF    FD8.0
024D0:  RLCF   x6A,W
024D2:  CLRF   03
024D4:  MOVFF  FF2,16C
024D8:  BCF    FF2.7
024DA:  MOVLB  0
024DC:  CALL   0096
024E0:  TBLRD*+
024E2:  MOVFF  FF5,03
024E6:  MOVLB  1
024E8:  BTFSC  x6C.7
024EA:  BSF    FF2.7
024EC:  MOVWF  x6C
024EE:  MOVFF  03,16D
024F2:  MOVWF  xCE
024F4:  CLRF   xCF
024F6:  MOVLW  0F
024F8:  MOVWF  xD1
024FA:  MOVLW  89
024FC:  MOVWF  xD0
024FE:  MOVLB  0
02500:  CALL   0C18
02504:  MOVFF  16C,1CE
02508:  MOVLB  1
0250A:  CLRF   xCF
0250C:  MOVLW  0F
0250E:  MOVWF  xD1
02510:  MOVLW  92
02512:  MOVWF  xD0
02514:  MOVLB  0
02516:  CALL   0C18
0251A:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0251C:  BRA    2416
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0251E:  MOVLW  00
02520:  MOVWF  01
02522:  MOVLB  0
02524:  GOTO   2E08 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
....................    Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
*
02A96:  MOVLB  1
02A98:  CLRF   x6A
02A9A:  CLRF   x6B
....................  
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02A9C:  MOVF   x6A,W
02A9E:  MULLW  11
02AA0:  MOVF   FF3,W
02AA2:  CLRF   03
02AA4:  MOVWF  x6C
02AA6:  MOVLW  0C
02AA8:  MOVWF  x73
02AAA:  MOVLB  0
02AAC:  CALL   0EAC
02AB0:  MOVLW  54
02AB2:  MOVWF  FF6
02AB4:  MOVLW  03
02AB6:  MOVWF  FF7
02AB8:  MOVLB  1
02ABA:  MOVF   x6C,W
02ABC:  ADDWF  FF6,F
02ABE:  MOVLW  00
02AC0:  ADDWFC FF7,F
02AC2:  MOVLB  0
02AC4:  CALL   0F18
....................    showBottonMenu(); 
02AC8:  CALL   13CE
....................     
....................    while(!exit){ 
02ACC:  MOVLB  1
02ACE:  MOVF   x6B,F
02AD0:  BTFSS  FD8.2
02AD2:  BRA    2BC2
....................  
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02AD4:  MOVLB  0
02AD6:  CALL   1492
....................       /********************************************/ 
....................     
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
02ADA:  BSF    F93.4
02ADC:  BTFSC  F81.4
02ADE:  BRA    2B46
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02AE0:  MOVLW  02
02AE2:  MOVLB  1
02AE4:  MOVWF  x6C
02AE6:  MOVLW  FA
02AE8:  MOVWF  xCD
02AEA:  MOVLB  0
02AEC:  CALL   0C5A
02AF0:  MOVLB  1
02AF2:  DECFSZ x6C,F
02AF4:  BRA    2AE6
....................          BEEP; 
02AF6:  MOVLW  04
02AF8:  MOVWF  x71
02AFA:  MOVLW  B9
02AFC:  MOVWF  x70
02AFE:  CLRF   x73
02B00:  MOVLW  14
02B02:  MOVWF  x72
02B04:  MOVLB  0
02B06:  CALL   1FFC
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
02B0A:  MOVLB  1
02B0C:  INCF   x6A,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuSetup){ 
02B0E:  MOVF   x6A,W
02B10:  SUBWF  x65,W
02B12:  BC    2B16
....................             optSelected = 0; 
02B14:  CLRF   x6A
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02B16:  MOVF   x6A,W
02B18:  MULLW  11
02B1A:  MOVF   FF3,W
02B1C:  CLRF   03
02B1E:  MOVWF  x6C
02B20:  MOVLW  0C
02B22:  MOVWF  x73
02B24:  MOVLB  0
02B26:  CALL   0EAC
02B2A:  MOVLW  54
02B2C:  MOVWF  FF6
02B2E:  MOVLW  03
02B30:  MOVWF  FF7
02B32:  MOVLB  1
02B34:  MOVF   x6C,W
02B36:  ADDWF  FF6,F
02B38:  MOVLW  00
02B3A:  ADDWFC FF7,F
02B3C:  MOVLB  0
02B3E:  CALL   0F18
....................          showBottonMenu(); 
02B42:  CALL   13CE
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
02B46:  BSF    F93.5
02B48:  BTFSC  F81.5
02B4A:  BRA    2BBE
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02B4C:  MOVLW  02
02B4E:  MOVLB  1
02B50:  MOVWF  x6C
02B52:  MOVLW  FA
02B54:  MOVWF  xCD
02B56:  MOVLB  0
02B58:  CALL   0C5A
02B5C:  MOVLB  1
02B5E:  DECFSZ x6C,F
02B60:  BRA    2B52
....................          BEEP; 
02B62:  MOVLW  04
02B64:  MOVWF  x71
02B66:  MOVLW  B9
02B68:  MOVWF  x70
02B6A:  CLRF   x73
02B6C:  MOVLW  14
02B6E:  MOVWF  x72
02B70:  MOVLB  0
02B72:  CALL   1FFC
....................           
....................          // Si optSelected = countOptMenuSetup entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuSetup){ 
02B76:  MOVLB  1
02B78:  MOVF   x65,W
02B7A:  SUBWF  x6A,W
02B7C:  BNZ   2B84
....................             exit = 1; 
02B7E:  MOVLW  01
02B80:  MOVWF  x6B
....................          }else{ 
02B82:  BRA    2BC0
....................             executeSetup(optSelected); 
02B84:  MOVFF  16A,16C
02B88:  MOVLB  0
02B8A:  BRA    27D8
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02B8C:  MOVLB  1
02B8E:  MOVF   x6A,W
02B90:  MULLW  11
02B92:  MOVF   FF3,W
02B94:  CLRF   03
02B96:  MOVWF  x6C
02B98:  MOVLW  0C
02B9A:  MOVWF  x73
02B9C:  MOVLB  0
02B9E:  CALL   0EAC
02BA2:  MOVLW  54
02BA4:  MOVWF  FF6
02BA6:  MOVLW  03
02BA8:  MOVWF  FF7
02BAA:  MOVLB  1
02BAC:  MOVF   x6C,W
02BAE:  ADDWF  FF6,F
02BB0:  MOVLW  00
02BB2:  ADDWFC FF7,F
02BB4:  MOVLB  0
02BB6:  CALL   0F18
....................             showBottonMenu(); 
02BBA:  CALL   13CE
02BBE:  MOVLB  1
....................          } 
....................       } // Fin KEY_OK 
02BC0:  BRA    2ACE
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02BC2:  MOVLW  00
02BC4:  MOVWF  01
02BC6:  MOVLB  0
02BC8:  GOTO   2E12 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
....................    Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................     
....................    
....................   switch(optSelect){ 
*
027D8:  MOVLB  1
027DA:  MOVF   x6C,W
027DC:  ADDLW  F7
027DE:  BTFSC  FD8.0
027E0:  BRA    2A48
027E2:  ADDLW  09
027E4:  MOVLB  0
027E6:  GOTO   2A60
....................    
....................      case OPT_SHOW_AP_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
027EA:  MOVLW  74
027EC:  MOVWF  FF6
027EE:  MOVLW  04
027F0:  MOVWF  FF7
027F2:  CALL   0C82
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
027F6:  MOVLW  05
027F8:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
027FA:  MOVLW  80
027FC:  MOVWF  FF6
027FE:  MOVLW  04
02800:  MOVWF  FF7
02802:  CALL   0F18
....................         waitResp(); 
02806:  CALL   0F62
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[0]); 
0280A:  MOVLW  0C
0280C:  MOVLB  1
0280E:  MOVWF  x73
02810:  MOVLB  0
02812:  CALL   0EAC
02816:  CLRF   FEA
02818:  MOVLW  6B
0281A:  MOVWF  FE9
0281C:  RCALL  2260
....................         flag_Resp_Get_IP_CMD = 0; 
0281E:  CLRF   xBB
....................         break; 
02820:  MOVLB  1
02822:  BRA    2A48
....................          
....................      case OPT_SHOW_STA_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
02824:  MOVLW  8E
02826:  MOVWF  FF6
02828:  MOVLW  04
0282A:  MOVWF  FF7
0282C:  CALL   0C82
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
02830:  MOVLW  05
02832:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
02834:  MOVLW  9A
02836:  MOVWF  FF6
02838:  MOVLW  04
0283A:  MOVWF  FF7
0283C:  CALL   0F18
....................         waitResp(); 
02840:  CALL   0F62
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[1]); 
02844:  MOVLW  0C
02846:  MOVLB  1
02848:  MOVWF  x73
0284A:  MOVLB  0
0284C:  CALL   0EAC
02850:  CLRF   FEA
02852:  MOVLW  7B
02854:  MOVWF  FE9
02856:  RCALL  2260
....................         flag_Resp_Get_IP_CMD = 0; 
02858:  CLRF   xBB
....................         break; 
0285A:  MOVLB  1
0285C:  BRA    2A48
....................          
....................      case OPT_SHOW_STA_SSID: 
....................         if(modeStar!='2'){ 
0285E:  MOVF   xC1,W
02860:  SUBLW  32
02862:  BZ    289C
....................            fprintf(ESP8266, "AT+CWJAP?\r\n"); 
02864:  MOVLW  A8
02866:  MOVWF  FF6
02868:  MOVLW  04
0286A:  MOVWF  FF7
0286C:  CALL   0C82
....................            CMD_RUN = CMD_GET_STA_INFO_FROM_MENU; 
02870:  MOVLW  07
02872:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
02874:  MOVLW  B4
02876:  MOVWF  FF6
02878:  MOVLW  04
0287A:  MOVWF  FF7
0287C:  CALL   0F18
....................            waitResp(); 
02880:  CALL   0F62
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[4]); 
02884:  MOVLW  0C
02886:  MOVLB  1
02888:  MOVWF  x73
0288A:  MOVLB  0
0288C:  CALL   0EAC
02890:  CLRF   FEA
02892:  MOVLW  AB
02894:  MOVWF  FE9
02896:  RCALL  2260
....................            flag_Resp_Get_STA_Info_CMD=0; 
02898:  CLRF   xBF
....................         }else{ 
0289A:  BRA    28A8
....................            printf(lcd_putc, "\fDeshabilitado"); 
0289C:  MOVLW  C2
0289E:  MOVWF  FF6
028A0:  MOVLW  04
028A2:  MOVWF  FF7
028A4:  CALL   0F18
....................         } 
....................         break; 
028A8:  MOVLB  1
028AA:  BRA    2A48
....................          
....................      case OPT_SHOW_AP_SSID: 
....................         if(modeStar!='1'){ 
028AC:  MOVF   xC1,W
028AE:  SUBLW  31
028B0:  BZ    28EA
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
028B2:  MOVLW  D2
028B4:  MOVWF  FF6
028B6:  MOVLW  04
028B8:  MOVWF  FF7
028BA:  CALL   0C82
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
028BE:  MOVLW  06
028C0:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
028C2:  MOVLW  DE
028C4:  MOVWF  FF6
028C6:  MOVLW  04
028C8:  MOVWF  FF7
028CA:  CALL   0F18
....................            waitResp(); 
028CE:  CALL   0F62
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[2]); 
028D2:  MOVLW  0C
028D4:  MOVLB  1
028D6:  MOVWF  x73
028D8:  MOVLB  0
028DA:  CALL   0EAC
028DE:  CLRF   FEA
028E0:  MOVLW  8B
028E2:  MOVWF  FE9
028E4:  RCALL  2260
....................            flag_Resp_Get_AP_Info_CMD=0; 
028E6:  CLRF   xBD
....................         }else{ 
028E8:  BRA    28F6
....................            printf(lcd_putc, "\fDeshabilitado"); 
028EA:  MOVLW  EC
028EC:  MOVWF  FF6
028EE:  MOVLW  04
028F0:  MOVWF  FF7
028F2:  CALL   0F18
....................         } 
....................         break; 
028F6:  MOVLB  1
028F8:  BRA    2A48
....................          
....................      case OPT_SHOW_AP_KEY: 
....................         if(modeStar!='1'){ 
028FA:  MOVF   xC1,W
028FC:  SUBLW  31
028FE:  BZ    2938
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
02900:  MOVLW  FC
02902:  MOVWF  FF6
02904:  MOVLW  04
02906:  MOVWF  FF7
02908:  CALL   0C82
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
0290C:  MOVLW  06
0290E:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
02910:  MOVLW  08
02912:  MOVWF  FF6
02914:  MOVLW  05
02916:  MOVWF  FF7
02918:  CALL   0F18
....................            waitResp(); 
0291C:  CALL   0F62
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[3]); 
02920:  MOVLW  0C
02922:  MOVLB  1
02924:  MOVWF  x73
02926:  MOVLB  0
02928:  CALL   0EAC
0292C:  CLRF   FEA
0292E:  MOVLW  9B
02930:  MOVWF  FE9
02932:  RCALL  2260
....................            flag_Resp_Get_AP_Info_CMD=0; 
02934:  CLRF   xBD
....................         }else{ 
02936:  BRA    2944
....................            printf(lcd_putc, "\fDeshabilitado"); 
02938:  MOVLW  16
0293A:  MOVWF  FF6
0293C:  MOVLW  05
0293E:  MOVWF  FF7
02940:  CALL   0F18
....................         } 
....................         break; 
02944:  MOVLB  1
02946:  BRA    2A48
....................          
....................      case OPT_RESET_ALL: 
....................          printf(lcd_putc, "\fBorrando EEEPROM"); 
02948:  MOVLW  26
0294A:  MOVWF  FF6
0294C:  MOVLW  05
0294E:  MOVWF  FF7
02950:  CALL   0F18
....................          for(int idxNC=0x00;idxNC<=0x6E;idxNC++){ 
02954:  MOVLB  1
02956:  CLRF   x6D
02958:  MOVF   x6D,W
0295A:  SUBLW  6E
0295C:  BNC   299A
....................             write_eeprom(idxNC,0xFF); 
0295E:  MOVF   FF2,W
02960:  MOVWF  00
02962:  BCF    FF2.7
02964:  CLRF   FAA
02966:  MOVFF  16D,FA9
0296A:  SETF   FA8
0296C:  BCF    FA6.6
0296E:  BCF    FA6.7
02970:  BSF    FA6.2
02972:  MOVLB  F
02974:  MOVLW  55
02976:  MOVWF  FA7
02978:  MOVLW  AA
0297A:  MOVWF  FA7
0297C:  BSF    FA6.1
0297E:  BTFSC  FA6.1
02980:  BRA    297E
02982:  BCF    FA6.2
02984:  MOVF   00,W
02986:  IORWF  FF2,F
....................             delay_ms(10); 
02988:  MOVLW  0A
0298A:  MOVLB  1
0298C:  MOVWF  xCD
0298E:  MOVLB  0
02990:  CALL   0C5A
02994:  MOVLB  1
02996:  INCF   x6D,F
02998:  BRA    2958
....................          } 
....................          printf(lcd_putc, "\fBorrando RED"); 
0299A:  MOVLW  38
0299C:  MOVWF  FF6
0299E:  MOVLW  05
029A0:  MOVWF  FF7
029A2:  MOVLB  0
029A4:  CALL   0F18
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
029A8:  MOVLW  46
029AA:  MOVWF  FF6
029AC:  MOVLW  05
029AE:  MOVWF  FF7
029B0:  CALL   0C82
....................          delay_ms(1000); 
029B4:  MOVLW  04
029B6:  MOVLB  1
029B8:  MOVWF  x6E
029BA:  MOVLW  FA
029BC:  MOVWF  xCD
029BE:  MOVLB  0
029C0:  CALL   0C5A
029C4:  MOVLB  1
029C6:  DECFSZ x6E,F
029C8:  BRA    29BA
....................          fprintf(ESP8266, "AT+RST\n\r"); 
029CA:  MOVLW  52
029CC:  MOVWF  FF6
029CE:  MOVLW  05
029D0:  MOVWF  FF7
029D2:  MOVLB  0
029D4:  CALL   0C82
....................          delay_ms(2000); 
029D8:  MOVLW  08
029DA:  MOVLB  1
029DC:  MOVWF  x6E
029DE:  MOVLW  FA
029E0:  MOVWF  xCD
029E2:  MOVLB  0
029E4:  CALL   0C5A
029E8:  MOVLB  1
029EA:  DECFSZ x6E,F
029EC:  BRA    29DE
....................          fprintf(ESP8266, "AT+CWSAP_DEF=\"Kriver SmartHome\",\"kriver56106\",1,4\r\n"); 
029EE:  MOVLW  5C
029F0:  MOVWF  FF6
029F2:  MOVLW  05
029F4:  MOVWF  FF7
029F6:  MOVLB  0
029F8:  CALL   0C82
....................          delay_ms(2000); 
029FC:  MOVLW  08
029FE:  MOVLB  1
02A00:  MOVWF  x6E
02A02:  MOVLW  FA
02A04:  MOVWF  xCD
02A06:  MOVLB  0
02A08:  CALL   0C5A
02A0C:  MOVLB  1
02A0E:  DECFSZ x6E,F
02A10:  BRA    2A02
....................          reset_cpu(); 
02A12:  RESET
....................         break; 
02A14:  BRA    2A48
....................      
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
02A16:  BRA    257C
....................         break; 
02A18:  MOVLB  1
02A1A:  BRA    2A48
....................          
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
02A1C:  BCF    F95.3
02A1E:  BTG    F8C.3
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
02A20:  BTFSS  F83.3
02A22:  BRA    2A32
....................            printf(lcd_putc, "\fBacklight On"); 
02A24:  MOVLW  90
02A26:  MOVWF  FF6
02A28:  MOVLW  05
02A2A:  MOVWF  FF7
02A2C:  CALL   0F18
....................         }else{ 
02A30:  BRA    2A3E
....................            printf(lcd_putc, "\fBacklight Off"); 
02A32:  MOVLW  9E
02A34:  MOVWF  FF6
02A36:  MOVLW  05
02A38:  MOVWF  FF7
02A3A:  CALL   0F18
....................         } 
....................         break; 
02A3E:  MOVLB  1
02A40:  BRA    2A48
....................          
....................      case OPT_EXIT: 
....................         break; 
02A42:  MOVLB  1
02A44:  BRA    2A48
02A46:  MOVLB  1
....................          
....................   } 
....................    
....................   if(optSelect!=OPT_EXIT && optSelect!=OPT_MODE_AP){ 
02A48:  MOVF   x6C,W
02A4A:  SUBLW  08
02A4C:  BZ    2A5A
02A4E:  MOVF   x6C,W
02A50:  SUBLW  05
02A52:  BZ    2A5A
....................    pressExit(); 
02A54:  MOVLB  0
02A56:  RCALL  2528
02A58:  MOVLB  1
....................   } 
02A5A:  MOVLB  0
02A5C:  GOTO   2B8C (RETURN)
.................... } 
....................    
.................... /*************************************************** 
....................    Despliega el menu MODE 
.................... ***************************************************/ 
.................... void setMenuModo(void){ 
*
0257C:  MOVLB  1
0257E:  CLRF   x6E
02580:  CLRF   x6F
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
02582:  MOVF   x6E,W
02584:  MULLW  0E
02586:  MOVF   FF3,W
02588:  CLRF   03
0258A:  MOVWF  x70
0258C:  MOVLW  0C
0258E:  MOVWF  x73
02590:  MOVLB  0
02592:  CALL   0EAC
02596:  MOVLW  EE
02598:  MOVWF  FF6
0259A:  MOVLW  03
0259C:  MOVWF  FF7
0259E:  MOVLB  1
025A0:  MOVF   x70,W
025A2:  ADDWF  FF6,F
025A4:  MOVLW  00
025A6:  ADDWFC FF7,F
025A8:  MOVLB  0
025AA:  CALL   0F18
....................   showBottonMenu(); 
025AE:  CALL   13CE
....................    
....................   while(exit==0){ 
025B2:  MOVLB  1
025B4:  MOVF   x6F,F
025B6:  BTFSS  FD8.2
025B8:  BRA    27A6
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
025BA:  MOVLB  0
025BC:  CALL   1492
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
025C0:  BSF    F93.4
025C2:  BTFSC  F81.4
025C4:  BRA    262A
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
025C6:  MOVLW  02
025C8:  MOVLB  1
025CA:  MOVWF  x70
025CC:  MOVLW  FA
025CE:  MOVWF  xCD
025D0:  MOVLB  0
025D2:  CALL   0C5A
025D6:  MOVLB  1
025D8:  DECFSZ x70,F
025DA:  BRA    25CC
....................         BEEP; 
025DC:  MOVLW  04
025DE:  MOVWF  x71
025E0:  MOVLW  B9
025E2:  MOVWF  x70
025E4:  CLRF   x73
025E6:  MOVLW  14
025E8:  MOVWF  x72
025EA:  MOVLB  0
025EC:  RCALL  1FFC
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
025EE:  MOVLB  1
025F0:  INCF   x6E,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
025F2:  MOVF   x6E,W
025F4:  SUBWF  x66,W
025F6:  BC    25FA
....................            optSelected = 0; 
025F8:  CLRF   x6E
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
025FA:  MOVF   x6E,W
025FC:  MULLW  0E
025FE:  MOVF   FF3,W
02600:  CLRF   03
02602:  MOVWF  x70
02604:  MOVLW  0C
02606:  MOVWF  x73
02608:  MOVLB  0
0260A:  CALL   0EAC
0260E:  MOVLW  EE
02610:  MOVWF  FF6
02612:  MOVLW  03
02614:  MOVWF  FF7
02616:  MOVLB  1
02618:  MOVF   x70,W
0261A:  ADDWF  FF6,F
0261C:  MOVLW  00
0261E:  ADDWFC FF7,F
02620:  MOVLB  0
02622:  CALL   0F18
....................         showBottonMenu(); 
02626:  CALL   13CE
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
0262A:  BSF    F93.5
0262C:  BTFSC  F81.5
0262E:  BRA    27A2
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
02630:  MOVLW  02
02632:  MOVLB  1
02634:  MOVWF  x70
02636:  MOVLW  FA
02638:  MOVWF  xCD
0263A:  MOVLB  0
0263C:  CALL   0C5A
02640:  MOVLB  1
02642:  DECFSZ x70,F
02644:  BRA    2636
....................         BEEP; 
02646:  MOVLW  04
02648:  MOVWF  x71
0264A:  MOVLW  B9
0264C:  MOVWF  x70
0264E:  CLRF   x73
02650:  MOVLW  14
02652:  MOVWF  x72
02654:  MOVLB  0
02656:  RCALL  1FFC
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){          
02658:  MOVLB  1
0265A:  MOVF   x66,W
0265C:  SUBWF  x6E,W
0265E:  BNZ   2666
....................            exit = 1; 
02660:  MOVLW  01
02662:  MOVWF  x6F
....................         }else{ 
02664:  BRA    27A0
....................            switch(optSelected){ 
02666:  MOVF   x6E,W
02668:  ADDLW  FC
0266A:  BTFSC  FD8.0
0266C:  BRA    2772
0266E:  ADDLW  04
02670:  MOVLB  0
02672:  GOTO   27AC
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
02676:  MOVLW  AE
02678:  MOVWF  FF6
0267A:  MOVLW  05
0267C:  MOVWF  FF7
0267E:  CALL   0C82
....................                  write_eeprom(0,'1'); 
02682:  MOVF   FF2,W
02684:  MOVWF  00
02686:  BCF    FF2.7
02688:  CLRF   FAA
0268A:  CLRF   FA9
0268C:  MOVLW  31
0268E:  MOVWF  FA8
02690:  BCF    FA6.6
02692:  BCF    FA6.7
02694:  BSF    FA6.2
02696:  MOVLB  F
02698:  MOVLW  55
0269A:  MOVWF  FA7
0269C:  MOVLW  AA
0269E:  MOVWF  FA7
026A0:  BSF    FA6.1
026A2:  BTFSC  FA6.1
026A4:  BRA    26A2
026A6:  BCF    FA6.2
026A8:  MOVF   00,W
026AA:  IORWF  FF2,F
....................                  delay_ms(10); 
026AC:  MOVLW  0A
026AE:  MOVLB  1
026B0:  MOVWF  xCD
026B2:  MOVLB  0
026B4:  CALL   0C5A
....................                  printf(lcd_putc, "\fConfig Cliente"); 
026B8:  MOVLW  C0
026BA:  MOVWF  FF6
026BC:  MOVLW  05
026BE:  MOVWF  FF7
026C0:  CALL   0F18
....................                  break; 
026C4:  MOVLB  1
026C6:  BRA    2772
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
026C8:  MOVLW  D0
026CA:  MOVWF  FF6
026CC:  MOVLW  05
026CE:  MOVWF  FF7
026D0:  CALL   0C82
....................                  write_eeprom(0,'2'); 
026D4:  MOVF   FF2,W
026D6:  MOVWF  00
026D8:  BCF    FF2.7
026DA:  CLRF   FAA
026DC:  CLRF   FA9
026DE:  MOVLW  32
026E0:  MOVWF  FA8
026E2:  BCF    FA6.6
026E4:  BCF    FA6.7
026E6:  BSF    FA6.2
026E8:  MOVLB  F
026EA:  MOVLW  55
026EC:  MOVWF  FA7
026EE:  MOVLW  AA
026F0:  MOVWF  FA7
026F2:  BSF    FA6.1
026F4:  BTFSC  FA6.1
026F6:  BRA    26F4
026F8:  BCF    FA6.2
026FA:  MOVF   00,W
026FC:  IORWF  FF2,F
....................                  delay_ms(10); 
026FE:  MOVLW  0A
02700:  MOVLB  1
02702:  MOVWF  xCD
02704:  MOVLB  0
02706:  CALL   0C5A
....................                  printf(lcd_putc, "\fConfig AP"); 
0270A:  MOVLW  E2
0270C:  MOVWF  FF6
0270E:  MOVLW  05
02710:  MOVWF  FF7
02712:  CALL   0F18
....................                  break; 
02716:  MOVLB  1
02718:  BRA    2772
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
0271A:  MOVLW  EE
0271C:  MOVWF  FF6
0271E:  MOVLW  05
02720:  MOVWF  FF7
02722:  CALL   0C82
....................                  write_eeprom(0,'3'); 
02726:  MOVF   FF2,W
02728:  MOVWF  00
0272A:  BCF    FF2.7
0272C:  CLRF   FAA
0272E:  CLRF   FA9
02730:  MOVLW  33
02732:  MOVWF  FA8
02734:  BCF    FA6.6
02736:  BCF    FA6.7
02738:  BSF    FA6.2
0273A:  MOVLB  F
0273C:  MOVLW  55
0273E:  MOVWF  FA7
02740:  MOVLW  AA
02742:  MOVWF  FA7
02744:  BSF    FA6.1
02746:  BTFSC  FA6.1
02748:  BRA    2746
0274A:  BCF    FA6.2
0274C:  MOVF   00,W
0274E:  IORWF  FF2,F
....................                  delay_ms(10); 
02750:  MOVLW  0A
02752:  MOVLB  1
02754:  MOVWF  xCD
02756:  MOVLB  0
02758:  CALL   0C5A
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
0275C:  MOVLW  00
0275E:  MOVWF  FF6
02760:  MOVLW  06
02762:  MOVWF  FF7
02764:  CALL   0F18
....................                  break; 
02768:  MOVLB  1
0276A:  BRA    2772
....................              case MODE_EXIT: 
....................                  break; 
0276C:  MOVLB  1
0276E:  BRA    2772
02770:  MOVLB  1
....................                   
....................            } 
....................             
....................            if(optSelected!=MODE_EXIT){ 
02772:  MOVF   x6E,W
02774:  SUBLW  03
02776:  BZ    27A0
....................               pressExit(); 
02778:  MOVLB  0
0277A:  RCALL  2528
....................               printf(lcd_putc, "\fReiniciando"); 
0277C:  MOVLW  12
0277E:  MOVWF  FF6
02780:  MOVLW  06
02782:  MOVWF  FF7
02784:  CALL   0F18
....................               delay_ms(3000); 
02788:  MOVLW  0C
0278A:  MOVLB  1
0278C:  MOVWF  x70
0278E:  MOVLW  FA
02790:  MOVWF  xCD
02792:  MOVLB  0
02794:  CALL   0C5A
02798:  MOVLB  1
0279A:  DECFSZ x70,F
0279C:  BRA    278E
....................               reset_cpu(); 
0279E:  RESET
027A0:  MOVLB  0
....................               // Muestra la ultima opcion del menu seleccionada 
....................               //printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
....................               //showBottonMenu(); 
....................            } 
....................         } 
....................      } // Fin KEY_OK 
027A2:  BRA    25B2
027A4:  MOVLB  1
....................   } // FIN While Infinito 
027A6:  MOVLB  0
027A8:  GOTO   2A18 (RETURN)
.................... } // Fin funcion setMenuModo 
....................  
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
....................    se dispara cuando se detectan datos de 
....................    llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
00BE8:  BTFSS  F9E.5
00BEA:  BRA    0BE8
00BEC:  MOVFF  FAE,1D4
00BF0:  MOVLB  1
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
00BF2:  MOVFF  1D4,1D5
00BF6:  MOVLB  0
00BF8:  BRA    0B00
00BFA:  BCF    F9E.5
00BFC:  GOTO   0054
.................... } 
....................    /************************ 
....................    ***      INIT         *** 
....................    *************************/ 
....................  
....................    void main() 
*
02BCC:  CLRF   FF8
02BCE:  BCF    FD0.7
02BD0:  BSF    07.7
02BD2:  BSF    FB8.3
02BD4:  MOVLW  2A
02BD6:  MOVWF  FAF
02BD8:  MOVLW  00
02BDA:  MOVWF  FB0
02BDC:  MOVLW  A6
02BDE:  MOVWF  FAC
02BE0:  MOVLW  90
02BE2:  MOVWF  FAB
02BE4:  BCF    F93.0
02BE6:  BSF    F8A.0
02BE8:  CLRF   53
02BEA:  CLRF   52
02BEC:  CLRF   54
02BEE:  CLRF   55
02BF0:  CLRF   56
02BF2:  CLRF   57
02BF4:  CLRF   58
02BF6:  CLRF   59
02BF8:  CLRF   5A
02BFA:  CLRF   5B
02BFC:  MOVLW  01
02BFE:  MOVWF  5C
02C00:  CLRF   5D
02C02:  MOVLW  05
02C04:  MOVWF  5E
02C06:  CLRF   xBB
02C08:  CLRF   xBC
02C0A:  CLRF   xBD
02C0C:  CLRF   xBE
02C0E:  CLRF   xBF
02C10:  CLRF   xC0
02C12:  MOVLW  02
02C14:  MOVLB  1
02C16:  MOVWF  x62
02C18:  MOVLW  08
02C1A:  MOVWF  x63
02C1C:  MOVWF  x64
02C1E:  MOVWF  x65
02C20:  MOVLW  03
02C22:  MOVWF  x66
02C24:  CLRF   x67
02C26:  MOVF   FC1,W
02C28:  ANDLW  C0
02C2A:  IORLW  0F
02C2C:  MOVWF  FC1
02C2E:  MOVLW  07
02C30:  MOVWF  FB4
02C32:  BRA    2CCE
02C34:  DATA 02,00
02C36:  DATA 16,00
02C38:  DATA 00,0C
02C3A:  DATA 40,5F
02C3C:  DATA 00,07
02C3E:  DATA 80,30
02C40:  DATA 2E,30
02C42:  DATA 2E,30
02C44:  DATA 2E,30
02C46:  DATA 09,C0
02C48:  DATA 00,07
02C4A:  DATA 80,30
02C4C:  DATA 2E,30
02C4E:  DATA 2E,30
02C50:  DATA 2E,30
02C52:  DATA 09,C0
02C54:  DATA 00,0F
02C56:  DATA C0,20
02C58:  DATA 01,80
02C5A:  DATA 00,0F
02C5C:  DATA C0,20
02C5E:  DATA 01,80
02C60:  DATA 00,0F
02C62:  DATA C0,20
02C64:  DATA 01,80
02C66:  DATA 00,5D
02C68:  DATA 00,F4
02C6A:  DATA 4F,75
02C6C:  DATA 74,70
02C6E:  DATA 75,74
02C70:  DATA 20,31
02C72:  DATA 20,20
02C74:  DATA 00,4F
02C76:  DATA 75,74
02C78:  DATA 70,75
02C7A:  DATA 74,20
02C7C:  DATA 32,20
02C7E:  DATA 20,00
02C80:  DATA 4F,75
02C82:  DATA 74,70
02C84:  DATA 75,74
02C86:  DATA 20,33
02C88:  DATA 20,20
02C8A:  DATA 00,4F
02C8C:  DATA 75,74
02C8E:  DATA 70,75
02C90:  DATA 74,20
02C92:  DATA 34,20
02C94:  DATA 20,00
02C96:  DATA 4F,75
02C98:  DATA 74,70
02C9A:  DATA 75,74
02C9C:  DATA 20,35
02C9E:  DATA 20,20
02CA0:  DATA 00,4F
02CA2:  DATA 75,74
02CA4:  DATA 70,75
02CA6:  DATA 74,20
02CA8:  DATA 36,20
02CAA:  DATA 20,00
02CAC:  DATA 4F,75
02CAE:  DATA 74,70
02CB0:  DATA 75,74
02CB2:  DATA 20,37
02CB4:  DATA 20,20
02CB6:  DATA 00,4F
02CB8:  DATA 75,74
02CBA:  DATA 70,75
02CBC:  DATA 74,20
02CBE:  DATA 38,20
02CC0:  DATA 20,00
02CC2:  DATA 53,41
02CC4:  DATA 4C,49
02CC6:  DATA 52,05
02CC8:  DATA C0,20
02CCA:  DATA 0C,C0
02CCC:  DATA 00,00
02CCE:  MOVLW  00
02CD0:  MOVWF  FF8
02CD2:  MOVLW  2C
02CD4:  MOVWF  FF7
02CD6:  MOVLW  34
02CD8:  MOVWF  FF6
02CDA:  TBLRD*+
02CDC:  MOVF   FF5,W
02CDE:  MOVWF  00
02CE0:  XORLW  00
02CE2:  BZ    2D0A
02CE4:  TBLRD*+
02CE6:  MOVF   FF5,W
02CE8:  MOVWF  01
02CEA:  BTFSC  FE8.7
02CEC:  BRA    2CF8
02CEE:  ANDLW  0F
02CF0:  MOVWF  FEA
02CF2:  TBLRD*+
02CF4:  MOVFF  FF5,FE9
02CF8:  BTFSC  01.6
02CFA:  TBLRD*+
02CFC:  BTFSS  01.6
02CFE:  TBLRD*+
02D00:  MOVFF  FF5,FEE
02D04:  DCFSNZ 00,F
02D06:  BRA    2CDA
02D08:  BRA    2CFC
02D0A:  CLRF   FF8
....................    {       
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
02D0C:  BCF    FF1.7
....................       set_tris_b(0b00110010); 
02D0E:  MOVLW  32
02D10:  MOVWF  F93
....................        
....................       // Configura el Estado inicial de los Puertos 
....................       output_low(CHPD_ESP8266); 
02D12:  BCF    F93.3
02D14:  BCF    F8A.3
....................       output_low(Speaker); 
02D16:  BCF    F93.2
02D18:  BCF    F8A.2
....................       output_high(LCD_LIGHT_PIN); 
02D1A:  BCF    F95.3
02D1C:  BSF    F8C.3
....................        
....................       for(int idxOff=0;idxOff<8;idxOff++){ 
02D1E:  CLRF   x68
02D20:  MOVF   x68,W
02D22:  SUBLW  07
02D24:  BNC   2D78
....................          output_low(PIN_OUT[idxOff]); 
02D26:  BCF    FD8.0
02D28:  RLCF   x68,W
02D2A:  CLRF   03
02D2C:  MOVFF  FF2,16A
02D30:  BCF    FF2.7
02D32:  MOVLB  0
02D34:  CALL   0096
02D38:  TBLRD*+
02D3A:  MOVFF  FF5,03
02D3E:  MOVLB  1
02D40:  BTFSC  x6A.7
02D42:  BSF    FF2.7
02D44:  MOVWF  x6A
02D46:  MOVFF  03,16B
02D4A:  MOVWF  xCE
02D4C:  CLRF   xCF
02D4E:  MOVLW  0F
02D50:  MOVWF  xD1
02D52:  MOVLW  89
02D54:  MOVWF  xD0
02D56:  MOVLB  0
02D58:  CALL   0C18
02D5C:  MOVFF  16A,1CE
02D60:  MOVLB  1
02D62:  CLRF   xCF
02D64:  MOVLW  0F
02D66:  MOVWF  xD1
02D68:  MOVLW  92
02D6A:  MOVWF  xD0
02D6C:  MOVLB  0
02D6E:  CALL   0C18
02D72:  MOVLB  1
02D74:  INCF   x68,F
02D76:  BRA    2D20
....................       } 
....................        
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       clear_interrupt(INT_RDA);  
....................       enable_interrupts(INT_RDA); 
02D78:  BSF    F9D.5
....................       enable_interrupts(GLOBAL);  
02D7A:  MOVLW  C0
02D7C:  IORWF  FF2,F
....................       delay_ms(1000); 
02D7E:  MOVLW  04
02D80:  MOVWF  x6A
02D82:  MOVLW  FA
02D84:  MOVWF  xCD
02D86:  MOVLB  0
02D88:  CALL   0C5A
02D8C:  MOVLB  1
02D8E:  DECFSZ x6A,F
02D90:  BRA    2D82
....................        
....................       output_high(CHPD_ESP8266); 
02D92:  BCF    F93.3
02D94:  BSF    F8A.3
....................       // @TODO: Usar este comando solo en produccion 
....................       //        comentarlo durante etapa de desarrollo 
....................       //        Configurar el USART a 9600bps 
....................       fprintf(ESP8266, "AT+RST\r\n"); 
02D96:  MOVLW  00
02D98:  MOVWF  FF6
02D9A:  MOVLW  0C
02D9C:  MOVWF  FF7
02D9E:  MOVLB  0
02DA0:  CALL   0C82
....................              
....................       // Inicializa la LCD 
....................       lcd_init(); 
02DA4:  GOTO   0DEA
....................       printf(lcd_putc, "\fIniciando..."); 
02DA8:  MOVLW  0A
02DAA:  MOVWF  FF6
02DAC:  MOVLW  0C
02DAE:  MOVWF  FF7
02DB0:  CALL   0F18
....................  
....................       delay_ms(5000); 
02DB4:  MOVLW  14
02DB6:  MOVLB  1
02DB8:  MOVWF  x6A
02DBA:  MOVLW  FA
02DBC:  MOVWF  xCD
02DBE:  MOVLB  0
02DC0:  CALL   0C5A
02DC4:  MOVLB  1
02DC6:  DECFSZ x6A,F
02DC8:  BRA    2DBA
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
02DCA:  MOVLB  0
02DCC:  GOTO   10DE
....................  
....................       // Carga el nombre personalizado del puerto desde la eeprom 
....................       getNameMenusOutput(); 
02DD0:  GOTO   12F2
....................        
....................       // Ciclo infinito para mantener el programa activo 
....................       int loop=1; 
02DD4:  MOVLW  01
02DD6:  MOVLB  1
02DD8:  MOVWF  x69
....................       while(loop==1) 
02DDA:  DECFSZ x69,W
02DDC:  BRA    2E1E
....................       { 
....................          switch(menuActive){ 
02DDE:  MOVF   x67,W
02DE0:  ADDLW  FC
02DE2:  BC    2E1C
02DE4:  ADDLW  04
02DE6:  MOVLB  0
02DE8:  GOTO   2E20
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
02DEC:  GOTO   2144
02DF0:  MOVFF  01,167
....................                break; 
02DF4:  MOVLB  1
02DF6:  BRA    2E1C
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
02DF8:  GOTO   2286
02DFC:  MOVFF  01,167
....................                break; 
02E00:  MOVLB  1
02E02:  BRA    2E1C
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
02E04:  GOTO   23D8
02E08:  MOVFF  01,167
....................                break; 
02E0C:  MOVLB  1
02E0E:  BRA    2E1C
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
02E10:  BRA    2A96
02E12:  MOVFF  01,167
....................                break; 
02E16:  MOVLB  1
02E18:  BRA    2E1C
02E1A:  MOVLB  1
....................          } // Fin del Switch(menuActive) 
02E1C:  BRA    2DDA
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
02E1E:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
