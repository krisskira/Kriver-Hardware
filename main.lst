CCS PCM C Compiler, Version 5.015, 5967               23-nov.-17 22:08

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   3572 words (44%)
                           Largest free fragment is 2048
               RAM used:   93 (25%) at main() level
                           131 (36%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0D
0001:  MOVWF  0A
0002:  GOTO   500
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   2EF
.................... #include "header/config.h" 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  RETLW  43
0052:  RETLW  6C
0053:  RETLW  69
0054:  RETLW  65
0055:  RETLW  6E
0056:  RETLW  74
0057:  RETLW  65
0058:  RETLW  20
0059:  RETLW  20
005A:  RETLW  20
005B:  RETLW  20
005C:  RETLW  20
005D:  RETLW  00
005E:  RETLW  41
005F:  RETLW  63
0060:  RETLW  63
0061:  RETLW  65
0062:  RETLW  73
0063:  RETLW  73
0064:  RETLW  20
0065:  RETLW  50
0066:  RETLW  6F
0067:  RETLW  69
0068:  RETLW  6E
0069:  RETLW  74
006A:  RETLW  00
006B:  RETLW  43
006C:  RETLW  6C
006D:  RETLW  69
006E:  RETLW  65
006F:  RETLW  6E
0070:  RETLW  74
0071:  RETLW  65
0072:  RETLW  20
0073:  RETLW  2B
0074:  RETLW  20
0075:  RETLW  41
0076:  RETLW  50
0077:  RETLW  00
0078:  RETLW  53
0079:  RETLW  41
007A:  RETLW  4C
007B:  RETLW  49
007C:  RETLW  52
007D:  RETLW  20
007E:  RETLW  20
007F:  RETLW  20
0080:  RETLW  20
0081:  RETLW  20
0082:  RETLW  20
0083:  RETLW  20
0084:  RETLW  00
0085:  RETLW  00
0086:  RETLW  00
0087:  RETLW  00
0088:  RETLW  00
0089:  RETLW  00
008A:  RETLW  00
008B:  RETLW  00
008C:  RETLW  00
008D:  RETLW  00
008E:  RETLW  00
008F:  RETLW  00
0090:  RETLW  00
0091:  RETLW  00
0092:  DATA D3,20
0093:  DATA CC,24
0094:  DATA 52,00
0095:  DATA DB,29
0096:  DATA C9,23
0097:  DATA 5D,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA A0,2D
009B:  DATA 45,27
009C:  DATA D4,2E
009D:  DATA 00,00
009E:  DATA 41,2A
009F:  DATA AB,21
00A0:  DATA D7,26
00A1:  DATA 4F,22
00A2:  DATA C5,2F
00A3:  DATA C4,22
00A4:  DATA C6,1E
00A5:  DATA B1,12
00A6:  DATA E3,12
00A7:  DATA 63,00
00A8:  DATA 8C,21
00A9:  DATA 6F,37
00AA:  DATA E6,34
00AB:  DATA 67,10
00AC:  DATA 43,36
00AD:  DATA E9,32
00AE:  DATA 6E,3A
00AF:  DATA 65,00
00B0:  DATA 41,2A
00B1:  DATA AB,21
00B2:  DATA D7,26
00B3:  DATA 4F,22
00B4:  DATA C5,2F
00B5:  DATA C4,22
00B6:  DATA C6,1E
00B7:  DATA B2,12
00B8:  DATA E3,12
00B9:  DATA 63,00
00BA:  DATA 8C,21
00BB:  DATA 6F,37
00BC:  DATA E6,34
00BD:  DATA 67,10
00BE:  DATA 41,28
00BF:  DATA 00,01
00C0:  DATA 41,2A
00C1:  DATA AB,21
00C2:  DATA D7,26
00C3:  DATA 4F,22
00C4:  DATA C5,2F
00C5:  DATA C4,22
00C6:  DATA C6,1E
00C7:  DATA B3,12
00C8:  DATA E3,12
00C9:  DATA 63,00
00CA:  DATA 8C,21
00CB:  DATA 6F,37
00CC:  DATA E6,34
00CD:  DATA 67,10
00CE:  DATA 43,36
00CF:  DATA E9,32
00D0:  DATA 6E,3A
00D1:  DATA E5,20
00D2:  DATA 50,00
00D3:  DATA B1,1C
00D4:  DATA 32,17
00D5:  DATA 31,1B
00D6:  DATA 38,17
00D7:  DATA 30,17
00D8:  DATA 31,00
00D9:  DATA 8C,18
00DA:  DATA 39,19
00DB:  DATA AE,18
00DC:  DATA 36,1C
00DD:  DATA 2E,18
00DE:  DATA AE,18
00DF:  DATA 00,01
00E0:  DATA 43,18
00E1:  DATA C7,19
00E2:  DATA DF,2A
00E3:  DATA CE,22
00E4:  DATA 00,01
00E5:  DATA 8C,21
00E6:  DATA B0,23
00E7:  DATA B3,2F
00E8:  DATA 55,27
00E9:  DATA 45,00
00EA:  DATA 31,19
00EB:  DATA 33,1A
00EC:  DATA 41,3D
00ED:  DATA 21,00
00EE:  DATA 8C,18
00EF:  DATA B2,19
00F0:  DATA B4,20
00F1:  DATA FA,10
00F2:  DATA 00,01
00F3:  DATA 0C,21
00F4:  DATA E1,31
00F5:  DATA 6B,36
00F6:  DATA E9,33
00F7:  DATA 68,3A
00F8:  DATA A0,27
00F9:  DATA 6E,00
00FA:  DATA 0C,21
00FB:  DATA E1,31
00FC:  DATA 6B,36
00FD:  DATA E9,33
00FE:  DATA 68,3A
00FF:  DATA A0,27
0100:  DATA 66,33
0101:  DATA 00,01
0102:  RETLW  45
0103:  RETLW  6E
0104:  RETLW  63
0105:  RETLW  65
0106:  RETLW  6E
0107:  RETLW  64
0108:  RETLW  65
0109:  RETLW  72
010A:  RETLW  20
010B:  RETLW  4D
010C:  RETLW  61
010D:  RETLW  6E
010E:  RETLW  75
010F:  RETLW  61
0110:  RETLW  6C
0111:  RETLW  00
0112:  RETLW  41
0113:  RETLW  70
0114:  RETLW  61
0115:  RETLW  67
0116:  RETLW  61
0117:  RETLW  64
0118:  RETLW  6F
0119:  RETLW  20
011A:  RETLW  4D
011B:  RETLW  61
011C:  RETLW  6E
011D:  RETLW  75
011E:  RETLW  61
011F:  RETLW  6C
0120:  RETLW  20
0121:  RETLW  00
0122:  RETLW  43
0123:  RETLW  6F
0124:  RETLW  6E
0125:  RETLW  66
0126:  RETLW  69
0127:  RETLW  67
0128:  RETLW  75
0129:  RETLW  72
012A:  RETLW  61
012B:  RETLW  63
012C:  RETLW  69
012D:  RETLW  6F
012E:  RETLW  6E
012F:  RETLW  20
0130:  RETLW  20
0131:  RETLW  00
0132:  RETLW  00
0133:  RETLW  00
0134:  RETLW  00
0135:  RETLW  00
0136:  RETLW  00
0137:  RETLW  00
0138:  RETLW  00
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  00
013C:  RETLW  00
013D:  RETLW  00
013E:  RETLW  00
013F:  RETLW  00
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  4F
0143:  RETLW  6E
0144:  RETLW  20
0145:  RETLW  2D
0146:  RETLW  3E
0147:  RETLW  20
0148:  RETLW  53
0149:  RETLW  61
014A:  RETLW  6C
014B:  RETLW  69
014C:  RETLW  64
014D:  RETLW  61
014E:  RETLW  20
014F:  RETLW  31
0150:  RETLW  00
0151:  RETLW  4F
0152:  RETLW  6E
0153:  RETLW  20
0154:  RETLW  2D
0155:  RETLW  3E
0156:  RETLW  20
0157:  RETLW  53
0158:  RETLW  61
0159:  RETLW  6C
015A:  RETLW  69
015B:  RETLW  64
015C:  RETLW  61
015D:  RETLW  20
015E:  RETLW  32
015F:  RETLW  00
0160:  RETLW  4F
0161:  RETLW  6E
0162:  RETLW  20
0163:  RETLW  2D
0164:  RETLW  3E
0165:  RETLW  20
0166:  RETLW  53
0167:  RETLW  61
0168:  RETLW  6C
0169:  RETLW  69
016A:  RETLW  64
016B:  RETLW  61
016C:  RETLW  20
016D:  RETLW  33
016E:  RETLW  00
016F:  RETLW  4F
0170:  RETLW  6E
0171:  RETLW  20
0172:  RETLW  2D
0173:  RETLW  3E
0174:  RETLW  20
0175:  RETLW  53
0176:  RETLW  61
0177:  RETLW  6C
0178:  RETLW  69
0179:  RETLW  64
017A:  RETLW  61
017B:  RETLW  20
017C:  RETLW  34
017D:  RETLW  00
017E:  RETLW  4F
017F:  RETLW  6E
0180:  RETLW  20
0181:  RETLW  2D
0182:  RETLW  3E
0183:  RETLW  20
0184:  RETLW  53
0185:  RETLW  61
0186:  RETLW  6C
0187:  RETLW  69
0188:  RETLW  64
0189:  RETLW  61
018A:  RETLW  20
018B:  RETLW  35
018C:  RETLW  00
018D:  RETLW  4F
018E:  RETLW  6E
018F:  RETLW  20
0190:  RETLW  2D
0191:  RETLW  3E
0192:  RETLW  20
0193:  RETLW  53
0194:  RETLW  61
0195:  RETLW  6C
0196:  RETLW  69
0197:  RETLW  64
0198:  RETLW  61
0199:  RETLW  20
019A:  RETLW  36
019B:  RETLW  00
019C:  RETLW  4F
019D:  RETLW  6E
019E:  RETLW  20
019F:  RETLW  2D
01A0:  RETLW  3E
01A1:  RETLW  20
01A2:  RETLW  53
01A3:  RETLW  61
01A4:  RETLW  6C
01A5:  RETLW  69
01A6:  RETLW  64
01A7:  RETLW  61
01A8:  RETLW  20
01A9:  RETLW  37
01AA:  RETLW  00
01AB:  RETLW  4F
01AC:  RETLW  6E
01AD:  RETLW  20
01AE:  RETLW  2D
01AF:  RETLW  3E
01B0:  RETLW  20
01B1:  RETLW  53
01B2:  RETLW  61
01B3:  RETLW  6C
01B4:  RETLW  69
01B5:  RETLW  64
01B6:  RETLW  61
01B7:  RETLW  20
01B8:  RETLW  38
01B9:  RETLW  00
01BA:  RETLW  53
01BB:  RETLW  41
01BC:  RETLW  4C
01BD:  RETLW  49
01BE:  RETLW  52
01BF:  RETLW  20
01C0:  RETLW  20
01C1:  RETLW  20
01C2:  RETLW  20
01C3:  RETLW  20
01C4:  RETLW  20
01C5:  RETLW  20
01C6:  RETLW  20
01C7:  RETLW  20
01C8:  RETLW  00
01C9:  RETLW  00
01CA:  RETLW  00
01CB:  RETLW  00
01CC:  RETLW  00
01CD:  RETLW  00
01CE:  RETLW  00
01CF:  RETLW  00
01D0:  RETLW  00
01D1:  RETLW  00
01D2:  RETLW  00
01D3:  RETLW  00
01D4:  RETLW  00
01D5:  RETLW  00
01D6:  RETLW  00
01D7:  RETLW  00
01D8:  RETLW  4F
01D9:  RETLW  66
01DA:  RETLW  66
01DB:  RETLW  20
01DC:  RETLW  2D
01DD:  RETLW  3E
01DE:  RETLW  20
01DF:  RETLW  53
01E0:  RETLW  61
01E1:  RETLW  6C
01E2:  RETLW  69
01E3:  RETLW  64
01E4:  RETLW  61
01E5:  RETLW  20
01E6:  RETLW  31
01E7:  RETLW  00
01E8:  RETLW  4F
01E9:  RETLW  66
01EA:  RETLW  66
01EB:  RETLW  20
01EC:  RETLW  2D
01ED:  RETLW  3E
01EE:  RETLW  20
01EF:  RETLW  53
01F0:  RETLW  61
01F1:  RETLW  6C
01F2:  RETLW  69
01F3:  RETLW  64
01F4:  RETLW  61
01F5:  RETLW  20
01F6:  RETLW  32
01F7:  RETLW  00
01F8:  RETLW  4F
01F9:  RETLW  66
01FA:  RETLW  66
01FB:  RETLW  20
01FC:  RETLW  2D
01FD:  RETLW  3E
01FE:  RETLW  20
01FF:  RETLW  53
0200:  RETLW  61
0201:  RETLW  6C
0202:  RETLW  69
0203:  RETLW  64
0204:  RETLW  61
0205:  RETLW  20
0206:  RETLW  33
0207:  RETLW  00
0208:  RETLW  4F
0209:  RETLW  66
020A:  RETLW  66
020B:  RETLW  20
020C:  RETLW  2D
020D:  RETLW  3E
020E:  RETLW  20
020F:  RETLW  53
0210:  RETLW  61
0211:  RETLW  6C
0212:  RETLW  69
0213:  RETLW  64
0214:  RETLW  61
0215:  RETLW  20
0216:  RETLW  34
0217:  RETLW  00
0218:  RETLW  4F
0219:  RETLW  66
021A:  RETLW  66
021B:  RETLW  20
021C:  RETLW  2D
021D:  RETLW  3E
021E:  RETLW  20
021F:  RETLW  53
0220:  RETLW  61
0221:  RETLW  6C
0222:  RETLW  69
0223:  RETLW  64
0224:  RETLW  61
0225:  RETLW  20
0226:  RETLW  35
0227:  RETLW  00
0228:  RETLW  4F
0229:  RETLW  66
022A:  RETLW  66
022B:  RETLW  20
022C:  RETLW  2D
022D:  RETLW  3E
022E:  RETLW  20
022F:  RETLW  53
0230:  RETLW  61
0231:  RETLW  6C
0232:  RETLW  69
0233:  RETLW  64
0234:  RETLW  61
0235:  RETLW  20
0236:  RETLW  36
0237:  RETLW  00
0238:  RETLW  4F
0239:  RETLW  66
023A:  RETLW  66
023B:  RETLW  20
023C:  RETLW  2D
023D:  RETLW  3E
023E:  RETLW  20
023F:  RETLW  53
0240:  RETLW  61
0241:  RETLW  6C
0242:  RETLW  69
0243:  RETLW  64
0244:  RETLW  61
0245:  RETLW  20
0246:  RETLW  37
0247:  RETLW  00
0248:  RETLW  4F
0249:  RETLW  66
024A:  RETLW  66
024B:  RETLW  20
024C:  RETLW  2D
024D:  RETLW  3E
024E:  RETLW  20
024F:  RETLW  53
0250:  RETLW  61
0251:  RETLW  6C
0252:  RETLW  69
0253:  RETLW  64
0254:  RETLW  61
0255:  RETLW  20
0256:  RETLW  38
0257:  RETLW  00
0258:  RETLW  53
0259:  RETLW  41
025A:  RETLW  4C
025B:  RETLW  49
025C:  RETLW  52
025D:  RETLW  20
025E:  RETLW  20
025F:  RETLW  20
0260:  RETLW  20
0261:  RETLW  20
0262:  RETLW  20
0263:  RETLW  20
0264:  RETLW  20
0265:  RETLW  20
0266:  RETLW  20
0267:  RETLW  00
0268:  RETLW  00
0269:  RETLW  00
026A:  RETLW  00
026B:  RETLW  00
026C:  RETLW  00
026D:  RETLW  00
026E:  RETLW  00
026F:  RETLW  00
0270:  RETLW  00
0271:  RETLW  00
0272:  RETLW  00
0273:  RETLW  00
0274:  RETLW  00
0275:  RETLW  00
0276:  RETLW  00
0277:  RETLW  00
0278:  RETLW  56
0279:  RETLW  45
027A:  RETLW  52
027B:  RETLW  20
027C:  RETLW  49
027D:  RETLW  50
027E:  RETLW  20
027F:  RETLW  20
0280:  RETLW  20
0281:  RETLW  20
0282:  RETLW  20
0283:  RETLW  20
0284:  RETLW  20
0285:  RETLW  20
0286:  RETLW  20
0287:  RETLW  20
0288:  RETLW  00
0289:  RETLW  56
028A:  RETLW  45
028B:  RETLW  52
028C:  RETLW  20
028D:  RETLW  53
028E:  RETLW  53
028F:  RETLW  49
0290:  RETLW  44
0291:  RETLW  20
0292:  RETLW  20
0293:  RETLW  20
0294:  RETLW  20
0295:  RETLW  20
0296:  RETLW  20
0297:  RETLW  20
0298:  RETLW  20
0299:  RETLW  00
029A:  RETLW  56
029B:  RETLW  45
029C:  RETLW  52
029D:  RETLW  20
029E:  RETLW  4B
029F:  RETLW  45
02A0:  RETLW  59
02A1:  RETLW  20
02A2:  RETLW  20
02A3:  RETLW  20
02A4:  RETLW  20
02A5:  RETLW  20
02A6:  RETLW  20
02A7:  RETLW  20
02A8:  RETLW  20
02A9:  RETLW  20
02AA:  RETLW  00
02AB:  RETLW  43
02AC:  RETLW  6F
02AD:  RETLW  6E
02AE:  RETLW  66
02AF:  RETLW  20
02B0:  RETLW  41
02B1:  RETLW  63
02B2:  RETLW  63
02B3:  RETLW  65
02B4:  RETLW  73
02B5:  RETLW  73
02B6:  RETLW  6F
02B7:  RETLW  20
02B8:  RETLW  52
02B9:  RETLW  65
02BA:  RETLW  64
02BB:  RETLW  00
02BC:  RETLW  4F
02BD:  RETLW  6E
02BE:  RETLW  2F
02BF:  RETLW  4F
02C0:  RETLW  66
02C1:  RETLW  66
02C2:  RETLW  20
02C3:  RETLW  42
02C4:  RETLW  61
02C5:  RETLW  63
02C6:  RETLW  6B
02C7:  RETLW  6C
02C8:  RETLW  69
02C9:  RETLW  67
02CA:  RETLW  68
02CB:  RETLW  74
02CC:  RETLW  00
02CD:  RETLW  53
02CE:  RETLW  41
02CF:  RETLW  4C
02D0:  RETLW  49
02D1:  RETLW  52
02D2:  RETLW  20
02D3:  RETLW  20
02D4:  RETLW  20
02D5:  RETLW  20
02D6:  RETLW  20
02D7:  RETLW  20
02D8:  RETLW  20
02D9:  RETLW  20
02DA:  RETLW  20
02DB:  RETLW  20
02DC:  RETLW  20
02DD:  RETLW  00
02DE:  RETLW  00
02DF:  RETLW  00
02E0:  RETLW  00
02E1:  RETLW  00
02E2:  RETLW  00
02E3:  RETLW  00
02E4:  RETLW  00
02E5:  RETLW  00
02E6:  RETLW  00
02E7:  RETLW  00
02E8:  RETLW  00
02E9:  RETLW  00
02EA:  RETLW  00
02EB:  RETLW  00
02EC:  RETLW  00
02ED:  RETLW  00
02EE:  RETLW  00
*
02F3:  DATA 53,3A
02F4:  DATA 61,39
02F5:  DATA F4,12
02F6:  DATA E3,12
02F7:  DATA 63,00
*
047A:  MOVF   0B,W
047B:  BSF    03.5
047C:  MOVWF  20
047D:  BCF    03.5
047E:  BCF    0B.7
047F:  BSF    03.5
0480:  BSF    03.6
0481:  BSF    0C.7
0482:  BSF    0C.0
0483:  NOP
0484:  NOP
0485:  BCF    03.6
0486:  BTFSS  20.7
0487:  GOTO   48B
0488:  BCF    03.5
0489:  BSF    0B.7
048A:  BSF    03.5
048B:  BTFSC  03.0
048C:  GOTO   4C4
048D:  BCF    03.5
048E:  BSF    03.6
048F:  MOVF   0C,W
0490:  ANDLW  7F
0491:  BSF    03.5
0492:  BCF    03.6
0493:  MOVWF  20
0494:  BCF    03.5
0495:  BSF    03.6
0496:  MOVF   0D,W
0497:  BSF    03.5
0498:  BCF    03.6
0499:  MOVWF  21
049A:  BCF    03.5
049B:  BSF    03.6
049C:  MOVF   0F,W
049D:  BSF    03.5
049E:  BCF    03.6
049F:  MOVWF  22
04A0:  MOVF   20,W
04A1:  MOVWF  23
04A2:  BCF    03.5
04A3:  CALL   456
04A4:  BSF    03.5
04A5:  MOVF   21,W
04A6:  BCF    03.5
04A7:  BSF    03.6
04A8:  MOVWF  0D
04A9:  BSF    03.5
04AA:  BCF    03.6
04AB:  MOVF   22,W
04AC:  BCF    03.5
04AD:  BSF    03.6
04AE:  MOVWF  0F
04AF:  BCF    03.6
04B0:  MOVF   0B,W
04B1:  BSF    03.5
04B2:  MOVWF  23
04B3:  BCF    03.5
04B4:  BCF    0B.7
04B5:  BSF    03.5
04B6:  BSF    03.6
04B7:  BSF    0C.7
04B8:  BSF    0C.0
04B9:  NOP
04BA:  NOP
04BB:  BCF    03.6
04BC:  BTFSS  23.7
04BD:  GOTO   4C1
04BE:  BCF    03.5
04BF:  BSF    0B.7
04C0:  BSF    03.5
04C1:  DECFSZ 7B,F
04C2:  GOTO   4C4
04C3:  GOTO   4F2
04C4:  BCF    03.5
04C5:  BSF    03.6
04C6:  RLF    0C,W
04C7:  RLF    0E,W
04C8:  ANDLW  7F
04C9:  BSF    03.5
04CA:  BCF    03.6
04CB:  MOVWF  20
04CC:  BCF    03.5
04CD:  BSF    03.6
04CE:  MOVF   0D,W
04CF:  BSF    03.5
04D0:  BCF    03.6
04D1:  MOVWF  21
04D2:  BCF    03.5
04D3:  BSF    03.6
04D4:  MOVF   0F,W
04D5:  BSF    03.5
04D6:  BCF    03.6
04D7:  MOVWF  22
04D8:  MOVF   20,W
04D9:  MOVWF  23
04DA:  BCF    03.5
04DB:  CALL   456
04DC:  BSF    03.5
04DD:  MOVF   21,W
04DE:  BCF    03.5
04DF:  BSF    03.6
04E0:  MOVWF  0D
04E1:  BSF    03.5
04E2:  BCF    03.6
04E3:  MOVF   22,W
04E4:  BCF    03.5
04E5:  BSF    03.6
04E6:  MOVWF  0F
04E7:  INCF   0D,F
04E8:  BTFSC  03.2
04E9:  INCF   0F,F
04EA:  BCF    03.0
04EB:  DECFSZ 7B,F
04EC:  GOTO   4EE
04ED:  GOTO   4F0
04EE:  BCF    03.6
04EF:  GOTO   47A
04F0:  BSF    03.5
04F1:  BCF    03.6
04F2:  BCF    03.5
04F3:  BSF    0A.3
04F4:  BCF    0A.4
04F5:  GOTO   5B9 (RETURN)
*
0550:  MOVF   0B,W
0551:  BSF    03.5
0552:  MOVWF  22
0553:  BCF    03.5
0554:  BCF    0B.7
0555:  BSF    03.5
0556:  BSF    03.6
0557:  BSF    0C.7
0558:  BSF    0C.0
0559:  NOP
055A:  NOP
055B:  BCF    03.6
055C:  BTFSS  22.7
055D:  GOTO   561
055E:  BCF    03.5
055F:  BSF    0B.7
0560:  BSF    03.5
0561:  BCF    03.5
0562:  BSF    03.6
0563:  MOVF   0C,F
0564:  BTFSC  03.2
0565:  GOTO   589
0566:  MOVF   0D,W
0567:  BSF    03.5
0568:  BCF    03.6
0569:  MOVWF  22
056A:  BCF    03.5
056B:  BSF    03.6
056C:  MOVF   0F,W
056D:  BSF    03.5
056E:  BCF    03.6
056F:  MOVWF  23
0570:  BCF    03.5
0571:  BSF    03.6
0572:  MOVF   0C,W
0573:  BSF    03.5
0574:  BCF    03.6
0575:  MOVWF  24
0576:  BCF    03.5
0577:  CALL   4F6
0578:  BSF    03.5
0579:  MOVF   22,W
057A:  BCF    03.5
057B:  BSF    03.6
057C:  MOVWF  0D
057D:  BSF    03.5
057E:  BCF    03.6
057F:  MOVF   23,W
0580:  BCF    03.5
0581:  BSF    03.6
0582:  MOVWF  0F
0583:  INCF   0D,F
0584:  BTFSC  03.2
0585:  INCF   0F,F
0586:  BCF    03.6
0587:  GOTO   550
0588:  BSF    03.6
0589:  BCF    03.6
058A:  RETURN
058B:  MOVF   0B,W
058C:  BSF    03.5
058D:  MOVWF  21
058E:  BCF    03.5
058F:  BCF    0B.7
0590:  BSF    03.5
0591:  BSF    03.6
0592:  BSF    0C.7
0593:  BSF    0C.0
0594:  NOP
0595:  NOP
0596:  BCF    03.6
0597:  BTFSS  21.7
0598:  GOTO   59C
0599:  BCF    03.5
059A:  BSF    0B.7
059B:  BSF    03.5
059C:  BCF    03.5
059D:  BSF    03.6
059E:  MOVF   0C,W
059F:  ANDLW  7F
05A0:  BTFSC  03.2
05A1:  GOTO   5FD
05A2:  BSF    03.5
05A3:  BCF    03.6
05A4:  MOVWF  21
05A5:  BCF    03.5
05A6:  BSF    03.6
05A7:  MOVF   0D,W
05A8:  BSF    03.5
05A9:  BCF    03.6
05AA:  MOVWF  22
05AB:  BCF    03.5
05AC:  BSF    03.6
05AD:  MOVF   0F,W
05AE:  BSF    03.5
05AF:  BCF    03.6
05B0:  MOVWF  23
05B1:  MOVF   21,W
05B2:  MOVWF  24
05B3:  BCF    03.5
05B4:  CALL   4F6
05B5:  BSF    03.5
05B6:  MOVF   22,W
05B7:  BCF    03.5
05B8:  BSF    03.6
05B9:  MOVWF  0D
05BA:  BSF    03.5
05BB:  BCF    03.6
05BC:  MOVF   23,W
05BD:  BCF    03.5
05BE:  BSF    03.6
05BF:  MOVWF  0F
05C0:  BCF    03.6
05C1:  MOVF   0B,W
05C2:  BSF    03.5
05C3:  MOVWF  24
05C4:  BCF    03.5
05C5:  BCF    0B.7
05C6:  BSF    03.5
05C7:  BSF    03.6
05C8:  BSF    0C.7
05C9:  BSF    0C.0
05CA:  NOP
05CB:  NOP
05CC:  BCF    03.6
05CD:  BTFSS  24.7
05CE:  GOTO   5D2
05CF:  BCF    03.5
05D0:  BSF    0B.7
05D1:  BSF    03.5
05D2:  BCF    03.5
05D3:  BSF    03.6
05D4:  RLF    0C,W
05D5:  RLF    0E,W
05D6:  ANDLW  7F
05D7:  BTFSC  03.2
05D8:  GOTO   5FD
05D9:  BSF    03.5
05DA:  BCF    03.6
05DB:  MOVWF  21
05DC:  BCF    03.5
05DD:  BSF    03.6
05DE:  MOVF   0D,W
05DF:  BSF    03.5
05E0:  BCF    03.6
05E1:  MOVWF  22
05E2:  BCF    03.5
05E3:  BSF    03.6
05E4:  MOVF   0F,W
05E5:  BSF    03.5
05E6:  BCF    03.6
05E7:  MOVWF  23
05E8:  MOVF   21,W
05E9:  MOVWF  24
05EA:  BCF    03.5
05EB:  CALL   4F6
05EC:  BSF    03.5
05ED:  MOVF   22,W
05EE:  BCF    03.5
05EF:  BSF    03.6
05F0:  MOVWF  0D
05F1:  BSF    03.5
05F2:  BCF    03.6
05F3:  MOVF   23,W
05F4:  BCF    03.5
05F5:  BSF    03.6
05F6:  MOVWF  0F
05F7:  INCF   0D,F
05F8:  BTFSC  03.2
05F9:  INCF   0F,F
05FA:  BCF    03.6
05FB:  GOTO   58B
05FC:  BSF    03.6
05FD:  BCF    03.6
05FE:  RETURN
*
064A:  BTFSC  03.1
064B:  GOTO   64F
064C:  MOVLW  B7
064D:  MOVWF  04
064E:  BCF    03.7
064F:  CLRF   77
0650:  CLRF   78
0651:  CLRF   79
0652:  CLRF   7A
0653:  CLRF   37
0654:  CLRF   38
0655:  CLRF   39
0656:  CLRF   3A
0657:  MOVF   36,W
0658:  IORWF  35,W
0659:  IORWF  34,W
065A:  IORWF  33,W
065B:  BTFSC  03.2
065C:  GOTO   68D
065D:  MOVLW  20
065E:  MOVWF  3B
065F:  BCF    03.0
0660:  RLF    2F,F
0661:  RLF    30,F
0662:  RLF    31,F
0663:  RLF    32,F
0664:  RLF    37,F
0665:  RLF    38,F
0666:  RLF    39,F
0667:  RLF    3A,F
0668:  MOVF   36,W
0669:  SUBWF  3A,W
066A:  BTFSS  03.2
066B:  GOTO   676
066C:  MOVF   35,W
066D:  SUBWF  39,W
066E:  BTFSS  03.2
066F:  GOTO   676
0670:  MOVF   34,W
0671:  SUBWF  38,W
0672:  BTFSS  03.2
0673:  GOTO   676
0674:  MOVF   33,W
0675:  SUBWF  37,W
0676:  BTFSS  03.0
0677:  GOTO   687
0678:  MOVF   33,W
0679:  SUBWF  37,F
067A:  MOVF   34,W
067B:  BTFSS  03.0
067C:  INCFSZ 34,W
067D:  SUBWF  38,F
067E:  MOVF   35,W
067F:  BTFSS  03.0
0680:  INCFSZ 35,W
0681:  SUBWF  39,F
0682:  MOVF   36,W
0683:  BTFSS  03.0
0684:  INCFSZ 36,W
0685:  SUBWF  3A,F
0686:  BSF    03.0
0687:  RLF    77,F
0688:  RLF    78,F
0689:  RLF    79,F
068A:  RLF    7A,F
068B:  DECFSZ 3B,F
068C:  GOTO   65F
068D:  MOVF   37,W
068E:  MOVWF  00
068F:  INCF   04,F
0690:  MOVF   38,W
0691:  MOVWF  00
0692:  INCF   04,F
0693:  MOVF   39,W
0694:  MOVWF  00
0695:  INCF   04,F
0696:  MOVF   3A,W
0697:  MOVWF  00
*
06AD:  MOVLW  20
06AE:  MOVWF  3B
06AF:  CLRF   37
06B0:  CLRF   38
06B1:  CLRF   39
06B2:  CLRF   3A
06B3:  MOVF   32,W
06B4:  MOVWF  7A
06B5:  MOVF   31,W
06B6:  MOVWF  79
06B7:  MOVF   30,W
06B8:  MOVWF  78
06B9:  MOVF   2F,W
06BA:  MOVWF  77
06BB:  BCF    03.0
06BC:  BTFSS  77.0
06BD:  GOTO   6CC
06BE:  MOVF   33,W
06BF:  ADDWF  37,F
06C0:  MOVF   34,W
06C1:  BTFSC  03.0
06C2:  INCFSZ 34,W
06C3:  ADDWF  38,F
06C4:  MOVF   35,W
06C5:  BTFSC  03.0
06C6:  INCFSZ 35,W
06C7:  ADDWF  39,F
06C8:  MOVF   36,W
06C9:  BTFSC  03.0
06CA:  INCFSZ 36,W
06CB:  ADDWF  3A,F
06CC:  RRF    3A,F
06CD:  RRF    39,F
06CE:  RRF    38,F
06CF:  RRF    37,F
06D0:  RRF    7A,F
06D1:  RRF    79,F
06D2:  RRF    78,F
06D3:  RRF    77,F
06D4:  DECFSZ 3B,F
06D5:  GOTO   6BB
*
07DE:  BSF    03.5
07DF:  MOVF   20,W
07E0:  ANDLW  07
07E1:  MOVWF  77
07E2:  RRF    20,W
07E3:  MOVWF  78
07E4:  RRF    78,F
07E5:  RRF    78,F
07E6:  MOVLW  1F
07E7:  ANDWF  78,F
07E8:  MOVF   78,W
07E9:  ADDWF  22,W
07EA:  MOVWF  04
07EB:  BCF    03.7
07EC:  BTFSC  23.0
07ED:  BSF    03.7
07EE:  CLRF   78
07EF:  INCF   78,F
07F0:  INCF   77,F
07F1:  GOTO   7F3
07F2:  RLF    78,F
07F3:  DECFSZ 77,F
07F4:  GOTO   7F2
07F5:  MOVF   21,F
07F6:  BTFSC  03.2
07F7:  GOTO   7FB
07F8:  MOVF   78,W
07F9:  IORWF  00,F
07FA:  GOTO   7FE
07FB:  COMF   78,F
07FC:  MOVF   78,W
07FD:  ANDWF  00,F
07FE:  BCF    03.5
07FF:  RETURN
0800:  CLRF   77
0801:  CLRF   78
0802:  BSF    03.5
0803:  MOVF   21,W
0804:  BCF    03.0
0805:  BTFSC  22.0
0806:  ADDWF  77,F
0807:  RRF    77,F
0808:  RRF    78,F
0809:  BTFSC  22.1
080A:  ADDWF  77,F
080B:  RRF    77,F
080C:  RRF    78,F
080D:  BTFSC  22.2
080E:  ADDWF  77,F
080F:  RRF    77,F
0810:  RRF    78,F
0811:  BTFSC  22.3
0812:  ADDWF  77,F
0813:  RRF    77,F
0814:  RRF    78,F
0815:  BTFSC  22.4
0816:  ADDWF  77,F
0817:  RRF    77,F
0818:  RRF    78,F
0819:  BTFSC  22.5
081A:  ADDWF  77,F
081B:  RRF    77,F
081C:  RRF    78,F
081D:  BTFSC  22.6
081E:  ADDWF  77,F
081F:  RRF    77,F
0820:  RRF    78,F
0821:  BTFSC  22.7
0822:  ADDWF  77,F
0823:  RRF    77,F
0824:  RRF    78,F
0825:  BCF    03.5
0826:  RETURN
*
097E:  MOVF   0B,W
097F:  BSF    03.5
0980:  MOVWF  20
0981:  BCF    03.5
0982:  BCF    0B.7
0983:  BSF    03.5
0984:  BSF    03.6
0985:  BSF    0C.7
0986:  BSF    0C.0
0987:  NOP
0988:  NOP
0989:  BCF    03.6
098A:  BTFSS  20.7
098B:  GOTO   18F
098C:  BCF    03.5
098D:  BSF    0B.7
098E:  BSF    03.5
098F:  BCF    03.5
0990:  BSF    03.6
0991:  MOVF   0C,W
0992:  ANDLW  7F
0993:  BTFSC  03.2
0994:  GOTO   1F4
0995:  BSF    03.5
0996:  BCF    03.6
0997:  MOVWF  20
0998:  BCF    03.5
0999:  BSF    03.6
099A:  MOVF   0D,W
099B:  BSF    03.5
099C:  BCF    03.6
099D:  MOVWF  21
099E:  BCF    03.5
099F:  BSF    03.6
09A0:  MOVF   0F,W
09A1:  BSF    03.5
09A2:  BCF    03.6
09A3:  MOVWF  22
09A4:  MOVF   20,W
09A5:  MOVWF  23
09A6:  BCF    0A.3
09A7:  BCF    03.5
09A8:  CALL   456
09A9:  BSF    0A.3
09AA:  BSF    03.5
09AB:  MOVF   21,W
09AC:  BCF    03.5
09AD:  BSF    03.6
09AE:  MOVWF  0D
09AF:  BSF    03.5
09B0:  BCF    03.6
09B1:  MOVF   22,W
09B2:  BCF    03.5
09B3:  BSF    03.6
09B4:  MOVWF  0F
09B5:  BCF    03.6
09B6:  MOVF   0B,W
09B7:  BSF    03.5
09B8:  MOVWF  23
09B9:  BCF    03.5
09BA:  BCF    0B.7
09BB:  BSF    03.5
09BC:  BSF    03.6
09BD:  BSF    0C.7
09BE:  BSF    0C.0
09BF:  NOP
09C0:  NOP
09C1:  BCF    03.6
09C2:  BTFSS  23.7
09C3:  GOTO   1C7
09C4:  BCF    03.5
09C5:  BSF    0B.7
09C6:  BSF    03.5
09C7:  BCF    03.5
09C8:  BSF    03.6
09C9:  RLF    0C,W
09CA:  RLF    0E,W
09CB:  ANDLW  7F
09CC:  BTFSC  03.2
09CD:  GOTO   1F4
09CE:  BSF    03.5
09CF:  BCF    03.6
09D0:  MOVWF  20
09D1:  BCF    03.5
09D2:  BSF    03.6
09D3:  MOVF   0D,W
09D4:  BSF    03.5
09D5:  BCF    03.6
09D6:  MOVWF  21
09D7:  BCF    03.5
09D8:  BSF    03.6
09D9:  MOVF   0F,W
09DA:  BSF    03.5
09DB:  BCF    03.6
09DC:  MOVWF  22
09DD:  MOVF   20,W
09DE:  MOVWF  23
09DF:  BCF    0A.3
09E0:  BCF    03.5
09E1:  CALL   456
09E2:  BSF    0A.3
09E3:  BSF    03.5
09E4:  MOVF   21,W
09E5:  BCF    03.5
09E6:  BSF    03.6
09E7:  MOVWF  0D
09E8:  BSF    03.5
09E9:  BCF    03.6
09EA:  MOVF   22,W
09EB:  BCF    03.5
09EC:  BSF    03.6
09ED:  MOVWF  0F
09EE:  INCF   0D,F
09EF:  BTFSC  03.2
09F0:  INCF   0F,F
09F1:  BCF    03.6
09F2:  GOTO   17E
09F3:  BSF    03.6
09F4:  BCF    03.6
09F5:  RETURN
*
0A30:  MOVF   00,F
0A31:  BTFSC  03.2
0A32:  GOTO   24C
0A33:  CLRF   22
0A34:  MOVF   04,W
0A35:  MOVWF  21
0A36:  BCF    22.0
0A37:  BTFSC  03.7
0A38:  BSF    22.0
0A39:  MOVF   00,W
0A3A:  MOVWF  23
0A3B:  BCF    0A.3
0A3C:  BCF    03.5
0A3D:  CALL   456
0A3E:  BSF    0A.3
0A3F:  BSF    03.5
0A40:  MOVF   21,W
0A41:  MOVWF  04
0A42:  BCF    03.7
0A43:  BTFSC  22.0
0A44:  BSF    03.7
0A45:  INCF   04,F
0A46:  BTFSS  03.2
0A47:  GOTO   24B
0A48:  BCF    03.5
0A49:  INCF   05,F
0A4A:  BSF    03.5
0A4B:  GOTO   230
*
0A4E:  MOVF   0B,W
0A4F:  BSF    03.5
0A50:  MOVWF  22
0A51:  BCF    03.5
0A52:  BCF    0B.7
0A53:  BSF    03.5
0A54:  BSF    03.6
0A55:  BSF    0C.7
0A56:  BSF    0C.0
0A57:  NOP
0A58:  NOP
0A59:  BCF    03.6
0A5A:  BTFSS  22.7
0A5B:  GOTO   25F
0A5C:  BCF    03.5
0A5D:  BSF    0B.7
0A5E:  BSF    03.5
0A5F:  BTFSC  03.0
0A60:  GOTO   299
0A61:  BCF    03.5
0A62:  BSF    03.6
0A63:  MOVF   0C,W
0A64:  ANDLW  7F
0A65:  BSF    03.5
0A66:  BCF    03.6
0A67:  MOVWF  22
0A68:  BCF    03.5
0A69:  BSF    03.6
0A6A:  MOVF   0D,W
0A6B:  BSF    03.5
0A6C:  BCF    03.6
0A6D:  MOVWF  23
0A6E:  BCF    03.5
0A6F:  BSF    03.6
0A70:  MOVF   0F,W
0A71:  BSF    03.5
0A72:  BCF    03.6
0A73:  MOVWF  24
0A74:  MOVF   22,W
0A75:  BCF    03.5
0A76:  BTFSS  0C.4
0A77:  GOTO   276
0A78:  MOVWF  19
0A79:  BSF    03.5
0A7A:  MOVF   23,W
0A7B:  BCF    03.5
0A7C:  BSF    03.6
0A7D:  MOVWF  0D
0A7E:  BSF    03.5
0A7F:  BCF    03.6
0A80:  MOVF   24,W
0A81:  BCF    03.5
0A82:  BSF    03.6
0A83:  MOVWF  0F
0A84:  BCF    03.6
0A85:  MOVF   0B,W
0A86:  BSF    03.5
0A87:  MOVWF  25
0A88:  BCF    03.5
0A89:  BCF    0B.7
0A8A:  BSF    03.5
0A8B:  BSF    03.6
0A8C:  BSF    0C.7
0A8D:  BSF    0C.0
0A8E:  NOP
0A8F:  NOP
0A90:  BCF    03.6
0A91:  BTFSS  25.7
0A92:  GOTO   296
0A93:  BCF    03.5
0A94:  BSF    0B.7
0A95:  BSF    03.5
0A96:  DECFSZ 21,F
0A97:  GOTO   299
0A98:  GOTO   2C8
0A99:  BCF    03.5
0A9A:  BSF    03.6
0A9B:  RLF    0C,W
0A9C:  RLF    0E,W
0A9D:  ANDLW  7F
0A9E:  BSF    03.5
0A9F:  BCF    03.6
0AA0:  MOVWF  22
0AA1:  BCF    03.5
0AA2:  BSF    03.6
0AA3:  MOVF   0D,W
0AA4:  BSF    03.5
0AA5:  BCF    03.6
0AA6:  MOVWF  23
0AA7:  BCF    03.5
0AA8:  BSF    03.6
0AA9:  MOVF   0F,W
0AAA:  BSF    03.5
0AAB:  BCF    03.6
0AAC:  MOVWF  24
0AAD:  MOVF   22,W
0AAE:  BCF    03.5
0AAF:  BTFSS  0C.4
0AB0:  GOTO   2AF
0AB1:  MOVWF  19
0AB2:  BSF    03.5
0AB3:  MOVF   23,W
0AB4:  BCF    03.5
0AB5:  BSF    03.6
0AB6:  MOVWF  0D
0AB7:  BSF    03.5
0AB8:  BCF    03.6
0AB9:  MOVF   24,W
0ABA:  BCF    03.5
0ABB:  BSF    03.6
0ABC:  MOVWF  0F
0ABD:  INCF   0D,F
0ABE:  BTFSC  03.2
0ABF:  INCF   0F,F
0AC0:  BCF    03.0
0AC1:  BSF    03.5
0AC2:  BCF    03.6
0AC3:  DECFSZ 21,F
0AC4:  GOTO   2C6
0AC5:  GOTO   2C8
0AC6:  BCF    03.5
0AC7:  GOTO   24E
0AC8:  BCF    03.5
0AC9:  RETURN
*
0C44:  BCF    0A.0
0C45:  BCF    0A.1
0C46:  BSF    0A.2
0C47:  ADDWF  02,F
0C48:  GOTO   2D0
0C49:  GOTO   2E2
0C4A:  GOTO   2F4
0C4B:  GOTO   306
0C4C:  GOTO   425
0C4D:  GOTO   441
*
0DEC:  BSF    0A.0
0DED:  BCF    0A.1
0DEE:  BSF    0A.2
0DEF:  ADDWF  02,F
0DF0:  GOTO   5D9
0DF1:  GOTO   5DF
0DF2:  GOTO   5E3
0DF3:  GOTO   5E7
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20000000) 
*
02F8:  MOVLW  A5
02F9:  MOVWF  04
02FA:  BCF    03.7
02FB:  MOVF   00,W
02FC:  BTFSC  03.2
02FD:  GOTO   30B
02FE:  MOVLW  06
02FF:  MOVWF  78
0300:  CLRF   77
0301:  DECFSZ 77,F
0302:  GOTO   301
0303:  DECFSZ 78,F
0304:  GOTO   300
0305:  MOVLW  7B
0306:  MOVWF  77
0307:  DECFSZ 77,F
0308:  GOTO   307
0309:  DECFSZ 00,F
030A:  GOTO   2FE
030B:  RETURN
*
06EE:  MOVLW  03
06EF:  SUBWF  30,F
06F0:  BTFSS  03.0
06F1:  GOTO   6FC
06F2:  MOVLW  B0
06F3:  MOVWF  04
06F4:  BCF    03.7
06F5:  MOVF   00,W
06F6:  BTFSC  03.2
06F7:  GOTO   6FC
06F8:  GOTO   6FA
06F9:  GOTO   6FA
06FA:  DECFSZ 00,F
06FB:  GOTO   6F9
*
06FF:  MOVLW  03
0700:  SUBWF  30,F
0701:  BTFSS  03.0
0702:  GOTO   70D
0703:  MOVLW  B0
0704:  MOVWF  04
0705:  BCF    03.7
0706:  MOVF   00,W
0707:  BTFSC  03.2
0708:  GOTO   70D
0709:  GOTO   70B
070A:  GOTO   70B
070B:  DECFSZ 00,F
070C:  GOTO   70A
*
071F:  MOVLW  03
0720:  SUBWF  30,F
0721:  BTFSS  03.0
0722:  GOTO   72D
0723:  MOVLW  B0
0724:  MOVWF  04
0725:  BCF    03.7
0726:  MOVF   00,W
0727:  BTFSC  03.2
0728:  GOTO   72D
0729:  GOTO   72B
072A:  GOTO   72B
072B:  DECFSZ 00,F
072C:  GOTO   72A
*
0730:  MOVLW  03
0731:  SUBWF  30,F
0732:  BTFSS  03.0
0733:  GOTO   73E
0734:  MOVLW  B0
0735:  MOVWF  04
0736:  BCF    03.7
0737:  MOVF   00,W
0738:  BTFSC  03.2
0739:  GOTO   73E
073A:  GOTO   73C
073B:  GOTO   73C
073C:  DECFSZ 00,F
073D:  GOTO   73B
.................... /* RS232 */ 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
*
0456:  BSF    03.5
0457:  BCF    06.0
0458:  BCF    03.5
0459:  BCF    06.0
045A:  MOVLW  08
045B:  MOVWF  78
045C:  GOTO   45D
045D:  NOP
045E:  BSF    78.7
045F:  GOTO   470
0460:  BCF    78.7
0461:  BSF    03.5
0462:  RRF    23,F
0463:  BCF    03.5
0464:  BTFSC  03.0
0465:  BSF    06.0
0466:  BTFSS  03.0
0467:  BCF    06.0
0468:  BSF    78.6
0469:  GOTO   470
046A:  BCF    78.6
046B:  DECFSZ 78,F
046C:  GOTO   461
046D:  GOTO   46E
046E:  NOP
046F:  BSF    06.0
0470:  MOVLW  08
0471:  MOVWF  04
0472:  DECFSZ 04,F
0473:  GOTO   472
0474:  NOP
0475:  BTFSC  78.7
0476:  GOTO   460
0477:  BTFSC  78.6
0478:  GOTO   46A
0479:  RETURN
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... char NL  = 0x0A; 
.................... char CR  = 0x0D; 
....................  
.................... /*const char OUT_END_CMD[2] = { 
....................                               0x0D, // CR 
....................                               0x0A,  // NL 
....................                               0x00   // End String 
....................                             }; 
....................  
.................... const char INP_END_CMD[4] = { 
....................                               0x4F, // O 
....................                               0x4B, // K 
....................                               0x0D, // CR 
....................                               0x0A,  // NL 
....................                               0x00   // End String 
....................                             };*/ 
.................... char buffer[] = 0x0; 
*
0D33:  BCF    03.6
0D34:  CLRF   2D
.................... int16 PIN_OUT[8]={ 
....................                   PIN_E2, 
....................                   PIN_E1, 
....................                   PIN_E0, 
....................                   PIN_A4, 
....................                   PIN_A0, 
....................                   PIN_A1, 
....................                   PIN_A2, 
....................                   PIN_A3 
.................... }; 
0D35:  MOVLW  4A
0D36:  MOVWF  2E
0D37:  CLRF   2F
0D38:  MOVLW  49
0D39:  MOVWF  30
0D3A:  CLRF   31
0D3B:  MOVLW  48
0D3C:  MOVWF  32
0D3D:  CLRF   33
0D3E:  MOVLW  2C
0D3F:  MOVWF  34
0D40:  CLRF   35
0D41:  MOVLW  28
0D42:  MOVWF  36
0D43:  CLRF   37
0D44:  MOVLW  29
0D45:  MOVWF  38
0D46:  CLRF   39
0D47:  MOVLW  2A
0D48:  MOVWF  3A
0D49:  CLRF   3B
0D4A:  MOVLW  2B
0D4B:  MOVWF  3C
0D4C:  CLRF   3D
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
0D4D:  CLRF   3E
0D4E:  CLRF   3F
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
034E:  BSF    08.4
....................    output_float(LCD_DATA5); 
034F:  BSF    08.5
....................    output_float(LCD_DATA6); 
0350:  BSF    08.6
....................    output_float(LCD_DATA7); 
0351:  BSF    08.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0352:  BCF    03.5
0353:  BSF    08.1
0354:  BSF    03.5
0355:  BCF    08.1
....................    delay_cycles(1); 
0356:  NOP
....................    lcd_output_enable(1); 
0357:  BCF    03.5
0358:  BSF    08.0
0359:  BSF    03.5
035A:  BCF    08.0
....................    delay_cycles(1); 
035B:  NOP
....................    high = lcd_read_nibble(); 
*
038C:  MOVF   78,W
038D:  MOVWF  2C
....................        
....................    lcd_output_enable(0); 
038E:  BCF    03.5
038F:  BCF    08.0
0390:  BSF    03.5
0391:  BCF    08.0
....................    delay_cycles(1); 
0392:  NOP
....................    lcd_output_enable(1); 
0393:  BCF    03.5
0394:  BSF    08.0
0395:  BSF    03.5
0396:  BCF    08.0
....................    delay_us(1); 
0397:  GOTO   398
0398:  GOTO   399
0399:  NOP
....................    low = lcd_read_nibble(); 
*
03CA:  MOVF   78,W
03CB:  MOVWF  2B
....................        
....................    lcd_output_enable(0); 
03CC:  BCF    03.5
03CD:  BCF    08.0
03CE:  BSF    03.5
03CF:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
03D0:  BCF    08.4
....................    output_drive(LCD_DATA5); 
03D1:  BCF    08.5
....................    output_drive(LCD_DATA6); 
03D2:  BCF    08.6
....................    output_drive(LCD_DATA7); 
03D3:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
03D4:  SWAPF  2C,W
03D5:  MOVWF  77
03D6:  MOVLW  F0
03D7:  ANDWF  77,F
03D8:  MOVF   77,W
03D9:  IORWF  2B,W
03DA:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
035C:  CLRF   2D
*
039A:  CLRF   2D
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
035D:  BSF    08.4
035E:  MOVLW  00
035F:  BCF    03.5
0360:  BTFSC  08.4
0361:  MOVLW  01
0362:  BSF    03.5
0363:  IORWF  2D,F
*
039B:  BSF    08.4
039C:  MOVLW  00
039D:  BCF    03.5
039E:  BTFSC  08.4
039F:  MOVLW  01
03A0:  BSF    03.5
03A1:  IORWF  2D,F
....................    n |= input(LCD_DATA5) << 1; 
*
0364:  BSF    08.5
0365:  MOVLW  00
0366:  BCF    03.5
0367:  BTFSC  08.5
0368:  MOVLW  01
0369:  MOVWF  77
036A:  BCF    03.0
036B:  RLF    77,F
036C:  MOVF   77,W
036D:  BSF    03.5
036E:  IORWF  2D,F
*
03A2:  BSF    08.5
03A3:  MOVLW  00
03A4:  BCF    03.5
03A5:  BTFSC  08.5
03A6:  MOVLW  01
03A7:  MOVWF  77
03A8:  BCF    03.0
03A9:  RLF    77,F
03AA:  MOVF   77,W
03AB:  BSF    03.5
03AC:  IORWF  2D,F
....................    n |= input(LCD_DATA6) << 2; 
*
036F:  BSF    08.6
0370:  MOVLW  00
0371:  BCF    03.5
0372:  BTFSC  08.6
0373:  MOVLW  01
0374:  MOVWF  77
0375:  RLF    77,F
0376:  RLF    77,F
0377:  MOVLW  FC
0378:  ANDWF  77,F
0379:  MOVF   77,W
037A:  BSF    03.5
037B:  IORWF  2D,F
*
03AD:  BSF    08.6
03AE:  MOVLW  00
03AF:  BCF    03.5
03B0:  BTFSC  08.6
03B1:  MOVLW  01
03B2:  MOVWF  77
03B3:  RLF    77,F
03B4:  RLF    77,F
03B5:  MOVLW  FC
03B6:  ANDWF  77,F
03B7:  MOVF   77,W
03B8:  BSF    03.5
03B9:  IORWF  2D,F
....................    n |= input(LCD_DATA7) << 3; 
*
037C:  BSF    08.7
037D:  MOVLW  00
037E:  BCF    03.5
037F:  BTFSC  08.7
0380:  MOVLW  01
0381:  MOVWF  77
0382:  RLF    77,F
0383:  RLF    77,F
0384:  RLF    77,F
0385:  MOVLW  F8
0386:  ANDWF  77,F
0387:  MOVF   77,W
0388:  BSF    03.5
0389:  IORWF  2D,F
*
03BA:  BSF    08.7
03BB:  MOVLW  00
03BC:  BCF    03.5
03BD:  BTFSC  08.7
03BE:  MOVLW  01
03BF:  MOVWF  77
03C0:  RLF    77,F
03C1:  RLF    77,F
03C2:  RLF    77,F
03C3:  MOVLW  F8
03C4:  ANDWF  77,F
03C5:  MOVF   77,W
03C6:  BSF    03.5
03C7:  IORWF  2D,F
....................     
....................    return(n); 
*
038A:  MOVF   2D,W
038B:  MOVWF  78
*
03C8:  MOVF   2D,W
03C9:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
030C:  BSF    03.5
030D:  BTFSC  2C.0
030E:  GOTO   313
030F:  BCF    03.5
0310:  BCF    08.4
0311:  GOTO   315
0312:  BSF    03.5
0313:  BCF    03.5
0314:  BSF    08.4
0315:  BSF    03.5
0316:  BCF    08.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0317:  BTFSC  2C.1
0318:  GOTO   31D
0319:  BCF    03.5
031A:  BCF    08.5
031B:  GOTO   31F
031C:  BSF    03.5
031D:  BCF    03.5
031E:  BSF    08.5
031F:  BSF    03.5
0320:  BCF    08.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0321:  BTFSC  2C.2
0322:  GOTO   327
0323:  BCF    03.5
0324:  BCF    08.6
0325:  GOTO   329
0326:  BSF    03.5
0327:  BCF    03.5
0328:  BSF    08.6
0329:  BSF    03.5
032A:  BCF    08.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
032B:  BTFSC  2C.3
032C:  GOTO   331
032D:  BCF    03.5
032E:  BCF    08.7
032F:  GOTO   333
0330:  BSF    03.5
0331:  BCF    03.5
0332:  BSF    08.7
0333:  BSF    03.5
0334:  BCF    08.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0335:  NOP
....................    lcd_output_enable(1); 
0336:  BCF    03.5
0337:  BSF    08.0
0338:  BSF    03.5
0339:  BCF    08.0
....................    delay_us(2); 
033A:  MOVLW  02
033B:  MOVWF  77
033C:  DECFSZ 77,F
033D:  GOTO   33C
033E:  GOTO   33F
033F:  NOP
....................    lcd_output_enable(0); 
0340:  BCF    03.5
0341:  BCF    08.0
0342:  BSF    03.5
0343:  BCF    08.0
0344:  BCF    03.5
0345:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
0346:  BSF    03.5
0347:  BCF    08.0
....................    lcd_rs_tris(); 
0348:  BCF    08.2
....................    lcd_rw_tris(); 
0349:  BCF    08.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
034A:  BCF    03.5
034B:  BCF    08.2
034C:  BSF    03.5
034D:  BCF    08.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
03DB:  MOVF   78,W
03DC:  MOVWF  2B
03DD:  BTFSC  2B.7
03DE:  GOTO   34E
....................    lcd_output_rs(address); 
03DF:  MOVF   29,F
03E0:  BTFSS  03.2
03E1:  GOTO   3E6
03E2:  BCF    03.5
03E3:  BCF    08.2
03E4:  GOTO   3E8
03E5:  BSF    03.5
03E6:  BCF    03.5
03E7:  BSF    08.2
03E8:  BSF    03.5
03E9:  BCF    08.2
....................    delay_cycles(1); 
03EA:  NOP
....................    lcd_output_rw(0); 
03EB:  BCF    03.5
03EC:  BCF    08.1
03ED:  BSF    03.5
03EE:  BCF    08.1
....................    delay_cycles(1); 
03EF:  NOP
....................    lcd_output_enable(0); 
03F0:  BCF    03.5
03F1:  BCF    08.0
03F2:  BSF    03.5
03F3:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
03F4:  SWAPF  2A,W
03F5:  MOVWF  2B
03F6:  MOVLW  0F
03F7:  ANDWF  2B,F
03F8:  MOVF   2B,W
03F9:  MOVWF  2C
03FA:  BCF    03.5
03FB:  CALL   30C
....................    lcd_send_nibble(n & 0xf); 
03FC:  BSF    03.5
03FD:  MOVF   2A,W
03FE:  ANDLW  0F
03FF:  MOVWF  2B
0400:  MOVWF  2C
0401:  BCF    03.5
0402:  CALL   30C
0403:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0404:  MOVLW  28
0405:  BSF    03.5
0406:  MOVWF  20
0407:  MOVLW  0C
0408:  MOVWF  21
0409:  MOVLW  01
040A:  MOVWF  22
040B:  MOVLW  06
040C:  MOVWF  23
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
040D:  BCF    03.5
040E:  BCF    08.0
040F:  BSF    03.5
0410:  BCF    08.0
....................    lcd_output_rs(0); 
0411:  BCF    03.5
0412:  BCF    08.2
0413:  BSF    03.5
0414:  BCF    08.2
....................    lcd_output_rw(0); 
0415:  BCF    03.5
0416:  BCF    08.1
0417:  BSF    03.5
0418:  BCF    08.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0419:  BCF    08.4
....................    output_drive(LCD_DATA5); 
041A:  BCF    08.5
....................    output_drive(LCD_DATA6); 
041B:  BCF    08.6
....................    output_drive(LCD_DATA7); 
041C:  BCF    08.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
041D:  BCF    08.0
....................    lcd_rs_tris(); 
041E:  BCF    08.2
....................    lcd_rw_tris(); 
041F:  BCF    08.1
....................  #endif 
....................      
....................    delay_ms(15); 
0420:  MOVLW  0F
0421:  MOVWF  25
0422:  BCF    03.5
0423:  CALL   2F8
....................    for(i=1;i<=3;++i) 
0424:  MOVLW  01
0425:  MOVWF  7B
0426:  MOVF   7B,W
0427:  SUBLW  03
0428:  BTFSS  03.0
0429:  GOTO   436
....................    { 
....................        lcd_send_nibble(3); 
042A:  MOVLW  03
042B:  BSF    03.5
042C:  MOVWF  2C
042D:  BCF    03.5
042E:  CALL   30C
....................        delay_ms(5); 
042F:  MOVLW  05
0430:  BSF    03.5
0431:  MOVWF  25
0432:  BCF    03.5
0433:  CALL   2F8
0434:  INCF   7B,F
0435:  GOTO   426
....................    } 
....................     
....................    lcd_send_nibble(2); 
0436:  MOVLW  02
0437:  BSF    03.5
0438:  MOVWF  2C
0439:  BCF    03.5
043A:  CALL   30C
....................    delay_ms(5); 
043B:  MOVLW  05
043C:  BSF    03.5
043D:  MOVWF  25
043E:  BCF    03.5
043F:  CALL   2F8
....................    for(i=0;i<=3;++i) 
0440:  CLRF   7B
0441:  MOVF   7B,W
0442:  SUBLW  03
0443:  BTFSS  03.0
0444:  GOTO   453
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0445:  MOVLW  A0
0446:  ADDWF  7B,W
0447:  MOVWF  04
0448:  BCF    03.7
0449:  MOVF   00,W
044A:  MOVWF  7C
044B:  BSF    03.5
044C:  CLRF   29
044D:  MOVF   7C,W
044E:  MOVWF  2A
044F:  BCF    03.5
0450:  CALL   346
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0451:  INCF   7B,F
0452:  GOTO   441
0453:  BSF    0A.3
0454:  BCF    0A.4
0455:  GOTO   5A9 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
050A:  DECFSZ 26,W
050B:  GOTO   50D
050C:  GOTO   510
*
052E:  DECFSZ 26,W
052F:  GOTO   531
0530:  GOTO   534
*
0604:  DECFSZ 26,W
0605:  GOTO   607
0606:  GOTO   60A
*
09FB:  DECFSZ 26,W
09FC:  GOTO   1FE
09FD:  GOTO   201
....................       address=LCD_LINE_TWO; 
*
050D:  MOVLW  40
050E:  MOVWF  27
050F:  GOTO   511
*
0531:  MOVLW  40
0532:  MOVWF  27
0533:  GOTO   535
*
0607:  MOVLW  40
0608:  MOVWF  27
0609:  GOTO   60B
*
09FE:  MOVLW  40
09FF:  MOVWF  27
0A00:  GOTO   202
....................    else 
....................       address=0; 
*
0510:  CLRF   27
*
0534:  CLRF   27
*
060A:  CLRF   27
*
0A01:  CLRF   27
....................       
....................    address+=x-1; 
*
0511:  MOVLW  01
0512:  SUBWF  25,W
0513:  ADDWF  27,F
*
0535:  MOVLW  01
0536:  SUBWF  25,W
0537:  ADDWF  27,F
*
060B:  MOVLW  01
060C:  SUBWF  25,W
060D:  ADDWF  27,F
*
0A02:  MOVLW  01
0A03:  SUBWF  25,W
0A04:  ADDWF  27,F
....................    lcd_send_byte(0,0x80|address); 
*
0514:  MOVF   27,W
0515:  IORLW  80
0516:  MOVWF  28
0517:  CLRF   29
0518:  MOVF   28,W
0519:  MOVWF  2A
051A:  BCF    03.5
051B:  CALL   346
*
0538:  MOVF   27,W
0539:  IORLW  80
053A:  MOVWF  28
053B:  CLRF   29
053C:  MOVF   28,W
053D:  MOVWF  2A
053E:  BCF    03.5
053F:  CALL   346
*
060E:  MOVF   27,W
060F:  IORLW  80
0610:  MOVWF  28
0611:  CLRF   29
0612:  MOVF   28,W
0613:  MOVWF  2A
0614:  BCF    03.5
0615:  CALL   346
*
0A05:  MOVF   27,W
0A06:  IORLW  80
0A07:  MOVWF  28
0A08:  CLRF   29
0A09:  MOVF   28,W
0A0A:  MOVWF  2A
0A0B:  BCF    0A.3
0A0C:  BCF    03.5
0A0D:  CALL   346
0A0E:  BSF    0A.3
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
04F6:  BSF    03.5
04F7:  MOVF   24,W
04F8:  XORLW  07
04F9:  BCF    03.5
04FA:  BTFSC  03.2
04FB:  GOTO   506
04FC:  XORLW  0B
04FD:  BTFSC  03.2
04FE:  GOTO   51D
04FF:  XORLW  06
0500:  BTFSC  03.2
0501:  GOTO   529
0502:  XORLW  02
0503:  BTFSC  03.2
0504:  GOTO   541
0505:  GOTO   548
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0506:  MOVLW  01
0507:  BSF    03.5
0508:  MOVWF  25
0509:  MOVWF  26
*
051C:  GOTO   54F
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
051D:  BSF    03.5
051E:  CLRF   29
051F:  MOVLW  01
0520:  MOVWF  2A
0521:  BCF    03.5
0522:  CALL   346
....................                      delay_ms(2); 
0523:  MOVLW  02
0524:  BSF    03.5
0525:  MOVWF  25
0526:  BCF    03.5
0527:  CALL   2F8
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0528:  GOTO   54F
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0529:  MOVLW  01
052A:  BSF    03.5
052B:  MOVWF  25
052C:  MOVLW  02
052D:  MOVWF  26
*
0540:  GOTO   54F
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0541:  BSF    03.5
0542:  CLRF   29
0543:  MOVLW  10
0544:  MOVWF  2A
0545:  BCF    03.5
0546:  CALL   346
0547:  GOTO   54F
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0548:  MOVLW  01
0549:  BSF    03.5
054A:  MOVWF  29
054B:  MOVF   24,W
054C:  MOVWF  2A
054D:  BCF    03.5
054E:  CALL   346
....................      #endif 
....................    } 
054F:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
....................  
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
*
0D4F:  MOVLW  B9
0D50:  MOVWF  44
0D51:  MOVLW  3B
0D52:  MOVWF  45
0D53:  MOVLW  5E
0D54:  MOVWF  46
0D55:  MOVLW  38
0D56:  MOVWF  47
0D57:  MOVLW  34
0D58:  MOVWF  48
0D59:  MOVLW  35
0D5A:  MOVWF  49
0D5B:  MOVLW  38
0D5C:  MOVWF  4A
0D5D:  MOVLW  32
0D5E:  MOVWF  4B
0D5F:  MOVLW  66
0D60:  MOVWF  4C
0D61:  MOVLW  2F
0D62:  MOVWF  4D
0D63:  MOVLW  BD
0D64:  MOVWF  4E
0D65:  MOVLW  2C
0D66:  MOVWF  4F
0D67:  MOVLW  3A
0D68:  MOVWF  50
0D69:  MOVLW  2A
0D6A:  MOVWF  51
0D6B:  MOVLW  DC
0D6C:  MOVWF  52
0D6D:  MOVLW  27
0D6E:  MOVWF  53
0D6F:  MOVLW  9F
0D70:  MOVWF  54
0D71:  MOVLW  25
0D72:  MOVWF  55
0D73:  MOVLW  82
0D74:  MOVWF  56
0D75:  MOVLW  23
0D76:  MOVWF  57
0D77:  MOVLW  84
0D78:  MOVWF  58
0D79:  MOVLW  21
0D7A:  MOVWF  59
0D7B:  MOVLW  A3
0D7C:  MOVWF  5A
0D7D:  MOVLW  1F
0D7E:  MOVWF  5B
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
....................  
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
061E:  BSF    03.5
061F:  CLRF   26
0620:  CLRF   25
0621:  CLRF   28
0622:  CLRF   27
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
0623:  MOVF   22,F
0624:  BTFSS  03.2
0625:  GOTO   62A
0626:  MOVF   21,W
0627:  SUBLW  13
0628:  BTFSC  03.0
0629:  GOTO   76B
062A:  MOVF   22,W
062B:  SUBLW  4E
062C:  BTFSS  03.0
062D:  GOTO   76B
062E:  BTFSS  03.2
062F:  GOTO   634
0630:  MOVF   21,W
0631:  SUBLW  20
0632:  BTFSS  03.0
0633:  GOTO   76B
....................       tmp=100000; 
0634:  CLRF   2E
0635:  MOVLW  01
0636:  MOVWF  2D
0637:  MOVLW  86
0638:  MOVWF  2C
0639:  MOVLW  A0
063A:  MOVWF  2B
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
063B:  BCF    03.1
063C:  MOVF   2E,W
063D:  MOVWF  32
063E:  MOVF   2D,W
063F:  MOVWF  31
0640:  MOVF   2C,W
0641:  MOVWF  30
0642:  MOVF   2B,W
0643:  MOVWF  2F
0644:  CLRF   36
0645:  CLRF   35
0646:  MOVF   22,W
0647:  MOVWF  34
0648:  MOVF   21,W
0649:  MOVWF  33
*
0698:  MOVF   7A,W
0699:  MOVWF  2E
069A:  MOVF   79,W
069B:  MOVWF  2D
069C:  MOVF   78,W
069D:  MOVWF  2C
069E:  MOVF   77,W
069F:  MOVWF  2B
....................       tmp*=5;    
06A0:  MOVF   2E,W
06A1:  MOVWF  32
06A2:  MOVF   2D,W
06A3:  MOVWF  31
06A4:  MOVF   2C,W
06A5:  MOVWF  30
06A6:  MOVF   2B,W
06A7:  MOVWF  2F
06A8:  CLRF   36
06A9:  CLRF   35
06AA:  CLRF   34
06AB:  MOVLW  05
06AC:  MOVWF  33
*
06D6:  MOVF   7A,W
06D7:  MOVWF  2E
06D8:  MOVF   79,W
06D9:  MOVWF  2D
06DA:  MOVF   78,W
06DB:  MOVWF  2C
06DC:  MOVF   77,W
06DD:  MOVWF  2B
....................       uS=tmp; 
06DE:  MOVF   2C,W
06DF:  MOVWF  2A
06E0:  MOVF   2B,W
06E1:  MOVWF  29
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
06E2:  BCF    06.2
06E3:  BCF    03.5
06E4:  BSF    06.2
....................          delay_us(uS);           // con los retardos mientras 
06E5:  BSF    03.5
06E6:  MOVF   2A,W
06E7:  MOVWF  2F
06E8:  INCF   2F,F
06E9:  DECF   2F,F
06EA:  BTFSC  03.2
06EB:  GOTO   6FD
06EC:  MOVLW  FF
06ED:  MOVWF  30
*
06FC:  GOTO   6E9
06FD:  MOVF   29,W
06FE:  MOVWF  30
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
*
070D:  MOVF   29,W
070E:  ADDWF  27,F
070F:  MOVF   2A,W
0710:  BTFSC  03.0
0711:  INCFSZ 2A,W
0712:  ADDWF  28,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
0713:  BCF    06.2
0714:  BCF    03.5
0715:  BCF    06.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
0716:  BSF    03.5
0717:  MOVF   2A,W
0718:  MOVWF  2F
0719:  INCF   2F,F
071A:  DECF   2F,F
071B:  BTFSC  03.2
071C:  GOTO   72E
071D:  MOVLW  FF
071E:  MOVWF  30
*
072D:  GOTO   71A
072E:  MOVF   29,W
072F:  MOVWF  30
....................          CiclosL+=(uS);          //  
*
073E:  MOVF   29,W
073F:  ADDWF  27,F
0740:  MOVF   2A,W
0741:  BTFSC  03.0
0742:  INCFSZ 2A,W
0743:  ADDWF  28,F
....................          CiclosL+=25;            // Compensador. 
0744:  MOVLW  19
0745:  ADDWF  27,F
0746:  BTFSC  03.0
0747:  INCF   28,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
0748:  MOVF   28,W
0749:  SUBLW  02
074A:  BTFSC  03.0
074B:  GOTO   761
074C:  XORLW  FF
074D:  BTFSS  03.2
074E:  GOTO   753
074F:  MOVF   27,W
0750:  SUBLW  E7
0751:  BTFSC  03.0
0752:  GOTO   761
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
0753:  MOVLW  E8
0754:  SUBWF  27,F
0755:  MOVLW  03
0756:  BTFSS  03.0
0757:  MOVLW  04
0758:  SUBWF  28,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
0759:  INCF   25,F
075A:  BTFSC  03.2
075B:  INCF   26,F
....................             CiclosL+=25;         // Compensador. 
075C:  MOVLW  19
075D:  ADDWF  27,F
075E:  BTFSC  03.0
075F:  INCF   28,F
0760:  GOTO   748
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
0761:  MOVF   26,W
0762:  SUBWF  24,W
0763:  BTFSS  03.0
0764:  GOTO   76B
0765:  BTFSS  03.2
0766:  GOTO   6E2
0767:  MOVF   23,W
0768:  SUBWF  25,W
0769:  BTFSS  03.0
076A:  GOTO   6E2
....................                                          // tiempo indicado. 
....................    } 
076B:  BCF    03.5
076C:  RETURN
.................... } 
....................  
.................... #include "header/func_menu_setup.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
.................... /** DIRECTIVAS **/ 
.................... #define OPT_SHOW_IP     0 
.................... #define OPT_SHOW_SSID   1 
.................... #define OPT_SHOW_KEY    2 
.................... #define OPT_MODE_AP     3 
.................... #define OPT_BACKLIGH    4 
.................... #define OPT_EXIT        5 
....................  
.................... //Flag, Modo Cliente(1), Access Point(2), Cliente + AP (3) 
.................... #define MODE_CLIENT     0 
.................... #define MODE_AP         1 
.................... #define MODE_CLIENT_AP  2 
....................  
.................... int8 countOptMenuModo = 3; 
....................  
.................... //Contiene las opciones del menu optMenuModo[pos][lenString] 
.................... const char  optMenuModo[5][13]    =  { {"Cliente     "}, 
....................                                        {"Access Point"}, 
....................                                        {"Cliente + AP"}, 
....................                                        {"SALIR       "} 
....................                                      }; 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................    lcd_gotoxy(12,2); 
*
09F6:  MOVLW  0C
09F7:  BSF    03.5
09F8:  MOVWF  25
09F9:  MOVLW  02
09FA:  MOVWF  26
....................    printf(lcd_putc, "SALIR"); 
*
0A0F:  MOVLW  92
0A10:  BSF    03.6
0A11:  MOVWF  0D
0A12:  MOVLW  00
0A13:  MOVWF  0F
0A14:  BCF    0A.3
0A15:  BCF    03.6
0A16:  CALL   58B
0A17:  BSF    0A.3
....................    while(1){ 
....................           
....................       if(input(KEY_OK)==0){ 
0A18:  BSF    03.5
0A19:  BSF    06.5
0A1A:  BCF    03.5
0A1B:  BTFSC  06.5
0A1C:  GOTO   22B
....................             // Elimina el rebote 
....................             delay_ms(500); 
0A1D:  MOVLW  02
0A1E:  BSF    03.5
0A1F:  MOVWF  21
0A20:  MOVLW  FA
0A21:  MOVWF  25
0A22:  BCF    0A.3
0A23:  BCF    03.5
0A24:  CALL   2F8
0A25:  BSF    0A.3
0A26:  BSF    03.5
0A27:  DECFSZ 21,F
0A28:  GOTO   220
....................             break; 
0A29:  GOTO   22D
0A2A:  BCF    03.5
....................       } 
0A2B:  GOTO   218
0A2C:  BSF    03.5
....................    } 
....................    fprintf(console,"%s",buffer); 
0A2D:  MOVLW  2D
0A2E:  MOVWF  04
0A2F:  BCF    03.7
*
0A4C:  BCF    03.5
0A4D:  RETURN
.................... } 
....................  
.................... void showBottonMenu(void){ 
....................    lcd_gotoxy(1,2); 
*
05FF:  MOVLW  01
0600:  BSF    03.5
0601:  MOVWF  25
0602:  MOVLW  02
0603:  MOVWF  26
....................    printf(lcd_putc, "[SIG]      [ENT]"); 
*
0616:  MOVLW  95
0617:  BSF    03.6
0618:  MOVWF  0D
0619:  MOVLW  00
061A:  MOVWF  0F
061B:  BCF    03.6
061C:  CALL   58B
061D:  RETURN
.................... } 
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
.................... void setMenuModo(void){ 
*
0B06:  CLRF   7E
0B07:  BSF    03.5
0B08:  CLRF   20
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
0B09:  MOVF   7E,W
0B0A:  MOVWF  21
0B0B:  MOVLW  0D
0B0C:  MOVWF  22
0B0D:  BCF    03.5
0B0E:  CALL   000
0B0F:  MOVF   78,W
0B10:  BSF    03.5
0B11:  MOVWF  21
0B12:  MOVLW  0C
0B13:  MOVWF  24
0B14:  BCF    0A.3
0B15:  BCF    03.5
0B16:  CALL   4F6
0B17:  BSF    0A.3
0B18:  MOVLW  51
0B19:  BSF    03.6
0B1A:  MOVWF  0D
0B1B:  MOVLW  00
0B1C:  MOVWF  0F
0B1D:  BSF    03.5
0B1E:  BCF    03.6
0B1F:  MOVF   21,W
0B20:  BCF    03.5
0B21:  BSF    03.6
0B22:  ADDWF  0D,F
0B23:  BTFSC  03.0
0B24:  INCF   0F,F
0B25:  BCF    0A.3
0B26:  BCF    03.6
0B27:  CALL   550
0B28:  BSF    0A.3
....................    showBottonMenu(); 
0B29:  BCF    0A.3
0B2A:  CALL   5FF
0B2B:  BSF    0A.3
....................     
....................    while(!exit){ 
0B2C:  BSF    03.5
0B2D:  MOVF   20,F
0B2E:  BTFSS  03.2
0B2F:  GOTO   423
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0B30:  BSF    06.4
0B31:  BCF    03.5
0B32:  BTFSC  06.4
0B33:  GOTO   374
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0B34:  MOVLW  02
0B35:  BSF    03.5
0B36:  MOVWF  21
0B37:  MOVLW  FA
0B38:  MOVWF  25
0B39:  BCF    0A.3
0B3A:  BCF    03.5
0B3B:  CALL   2F8
0B3C:  BSF    0A.3
0B3D:  BSF    03.5
0B3E:  DECFSZ 21,F
0B3F:  GOTO   337
....................          BEEP; 
0B40:  MOVLW  04
0B41:  MOVWF  22
0B42:  MOVLW  B9
0B43:  MOVWF  21
0B44:  CLRF   24
0B45:  MOVLW  14
0B46:  MOVWF  23
0B47:  BCF    0A.3
0B48:  BCF    03.5
0B49:  CALL   61E
0B4A:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0B4B:  INCF   7E,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuModo){ 
0B4C:  MOVF   7E,W
0B4D:  SUBWF  5C,W
0B4E:  BTFSS  03.0
....................             optSelected = 0; 
0B4F:  CLRF   7E
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
0B50:  MOVF   7E,W
0B51:  BSF    03.5
0B52:  MOVWF  21
0B53:  MOVLW  0D
0B54:  MOVWF  22
0B55:  BCF    03.5
0B56:  CALL   000
0B57:  MOVF   78,W
0B58:  BSF    03.5
0B59:  MOVWF  21
0B5A:  MOVLW  0C
0B5B:  MOVWF  24
0B5C:  BCF    0A.3
0B5D:  BCF    03.5
0B5E:  CALL   4F6
0B5F:  BSF    0A.3
0B60:  MOVLW  51
0B61:  BSF    03.6
0B62:  MOVWF  0D
0B63:  MOVLW  00
0B64:  MOVWF  0F
0B65:  BSF    03.5
0B66:  BCF    03.6
0B67:  MOVF   21,W
0B68:  BCF    03.5
0B69:  BSF    03.6
0B6A:  ADDWF  0D,F
0B6B:  BTFSC  03.0
0B6C:  INCF   0F,F
0B6D:  BCF    0A.3
0B6E:  BCF    03.6
0B6F:  CALL   550
0B70:  BSF    0A.3
....................          showBottonMenu(); 
0B71:  BCF    0A.3
0B72:  CALL   5FF
0B73:  BSF    0A.3
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0B74:  BSF    03.5
0B75:  BSF    06.5
0B76:  BCF    03.5
0B77:  BTFSC  06.5
0B78:  GOTO   421
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0B79:  MOVLW  02
0B7A:  BSF    03.5
0B7B:  MOVWF  21
0B7C:  MOVLW  FA
0B7D:  MOVWF  25
0B7E:  BCF    0A.3
0B7F:  BCF    03.5
0B80:  CALL   2F8
0B81:  BSF    0A.3
0B82:  BSF    03.5
0B83:  DECFSZ 21,F
0B84:  GOTO   37C
....................          BEEP; 
0B85:  MOVLW  04
0B86:  MOVWF  22
0B87:  MOVLW  B9
0B88:  MOVWF  21
0B89:  CLRF   24
0B8A:  MOVLW  14
0B8B:  MOVWF  23
0B8C:  BCF    0A.3
0B8D:  BCF    03.5
0B8E:  CALL   61E
0B8F:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuModo){ 
0B90:  MOVF   5C,W
0B91:  SUBWF  7E,W
0B92:  BTFSS  03.2
0B93:  GOTO   399
....................             exit = 1; 
0B94:  MOVLW  01
0B95:  BSF    03.5
0B96:  MOVWF  20
....................          }else{ 
0B97:  GOTO   422
0B98:  BCF    03.5
....................             switch(optSelected){ 
0B99:  MOVF   7E,W
0B9A:  BTFSC  03.2
0B9B:  GOTO   3A3
0B9C:  XORLW  01
0B9D:  BTFSC  03.2
0B9E:  GOTO   3C1
0B9F:  XORLW  03
0BA0:  BTFSC  03.2
0BA1:  GOTO   3DF
0BA2:  GOTO   3FC
....................                case MODE_CLIENT: 
....................                   fprintf(ESP8266,"AT+CWMODE_DEF=1%c%c",NL,CR); 
0BA3:  MOVLW  9E
0BA4:  BSF    03.6
0BA5:  MOVWF  0D
0BA6:  MOVLW  00
0BA7:  MOVWF  0F
0BA8:  BCF    03.0
0BA9:  MOVLW  0F
0BAA:  BSF    03.5
0BAB:  BCF    03.6
0BAC:  MOVWF  21
0BAD:  BCF    03.5
0BAE:  CALL   24E
0BAF:  MOVF   2B,W
0BB0:  BTFSS  0C.4
0BB1:  GOTO   3B0
0BB2:  MOVWF  19
0BB3:  MOVF   2C,W
0BB4:  BTFSS  0C.4
0BB5:  GOTO   3B4
0BB6:  MOVWF  19
....................                   printf(lcd_putc, "\fConfig Cliente"); 
0BB7:  MOVLW  A8
0BB8:  BSF    03.6
0BB9:  MOVWF  0D
0BBA:  MOVLW  00
0BBB:  MOVWF  0F
0BBC:  BCF    0A.3
0BBD:  BCF    03.6
0BBE:  CALL   58B
0BBF:  BSF    0A.3
....................                   break; 
0BC0:  GOTO   3FC
....................                case MODE_AP: 
....................                   fprintf(ESP8266,"AT+CWMODE_DEF=2%c%c",NL,CR); 
0BC1:  MOVLW  B0
0BC2:  BSF    03.6
0BC3:  MOVWF  0D
0BC4:  MOVLW  00
0BC5:  MOVWF  0F
0BC6:  BCF    03.0
0BC7:  MOVLW  0F
0BC8:  BSF    03.5
0BC9:  BCF    03.6
0BCA:  MOVWF  21
0BCB:  BCF    03.5
0BCC:  CALL   24E
0BCD:  MOVF   2B,W
0BCE:  BTFSS  0C.4
0BCF:  GOTO   3CE
0BD0:  MOVWF  19
0BD1:  MOVF   2C,W
0BD2:  BTFSS  0C.4
0BD3:  GOTO   3D2
0BD4:  MOVWF  19
....................                   printf(lcd_putc, "\fConfig AP"); 
0BD5:  MOVLW  BA
0BD6:  BSF    03.6
0BD7:  MOVWF  0D
0BD8:  MOVLW  00
0BD9:  MOVWF  0F
0BDA:  BCF    0A.3
0BDB:  BCF    03.6
0BDC:  CALL   58B
0BDD:  BSF    0A.3
....................                   break; 
0BDE:  GOTO   3FC
....................                case MODE_CLIENT_AP: 
....................                   fprintf(ESP8266,"AT+CWMODE_DEF=3%c%c",NL,CR); 
0BDF:  MOVLW  C0
0BE0:  BSF    03.6
0BE1:  MOVWF  0D
0BE2:  MOVLW  00
0BE3:  MOVWF  0F
0BE4:  BCF    03.0
0BE5:  MOVLW  0F
0BE6:  BSF    03.5
0BE7:  BCF    03.6
0BE8:  MOVWF  21
0BE9:  BCF    03.5
0BEA:  CALL   24E
0BEB:  MOVF   2B,W
0BEC:  BTFSS  0C.4
0BED:  GOTO   3EC
0BEE:  MOVWF  19
0BEF:  MOVF   2C,W
0BF0:  BTFSS  0C.4
0BF1:  GOTO   3F0
0BF2:  MOVWF  19
....................                   printf(lcd_putc, "\fConfig ClienteAP"); 
0BF3:  MOVLW  CA
0BF4:  BSF    03.6
0BF5:  MOVWF  0D
0BF6:  MOVLW  00
0BF7:  MOVWF  0F
0BF8:  BCF    0A.3
0BF9:  BCF    03.6
0BFA:  CALL   58B
0BFB:  BSF    0A.3
....................                   break; 
....................             } 
....................             pressExit(); 
0BFC:  CALL   1F6
....................             // Muestra la ultima opcion del menu seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
0BFD:  MOVF   7E,W
0BFE:  BSF    03.5
0BFF:  MOVWF  21
0C00:  MOVLW  0D
0C01:  MOVWF  22
0C02:  BCF    03.5
0C03:  CALL   000
0C04:  MOVF   78,W
0C05:  BSF    03.5
0C06:  MOVWF  21
0C07:  MOVLW  0C
0C08:  MOVWF  24
0C09:  BCF    0A.3
0C0A:  BCF    03.5
0C0B:  CALL   4F6
0C0C:  BSF    0A.3
0C0D:  MOVLW  51
0C0E:  BSF    03.6
0C0F:  MOVWF  0D
0C10:  MOVLW  00
0C11:  MOVWF  0F
0C12:  BSF    03.5
0C13:  BCF    03.6
0C14:  MOVF   21,W
0C15:  BCF    03.5
0C16:  BSF    03.6
0C17:  ADDWF  0D,F
0C18:  BTFSC  03.0
0C19:  INCF   0F,F
0C1A:  BCF    0A.3
0C1B:  BCF    03.6
0C1C:  CALL   550
0C1D:  BSF    0A.3
....................             showBottonMenu(); 
0C1E:  BCF    0A.3
0C1F:  CALL   5FF
0C20:  BSF    0A.3
0C21:  BSF    03.5
....................          } 
....................       } // Fin KEY_OK 
0C22:  GOTO   32D
....................    } // FIN While Infinito 
.................... } // Fin funcion setMenuModo 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................    switch(optSelect){ 
*
0ACA:  MOVF   7D,W
0ACB:  ADDLW  FA
0ACC:  BTFSC  03.0
0ACD:  GOTO   441
0ACE:  ADDLW  06
0ACF:  GOTO   444
....................        
....................       case OPT_SHOW_IP: 
....................          fprintf(console,"192.168.0.1"); 
0AD0:  MOVLW  D3
0AD1:  BSF    03.6
0AD2:  MOVWF  0D
0AD3:  MOVLW  00
0AD4:  MOVWF  0F
0AD5:  BCF    03.6
0AD6:  CALL   17E
....................          printf(lcd_putc, "\f192.168.0.1"); 
0AD7:  MOVLW  D9
0AD8:  BSF    03.6
0AD9:  MOVWF  0D
0ADA:  MOVLW  00
0ADB:  MOVWF  0F
0ADC:  BCF    0A.3
0ADD:  BCF    03.6
0ADE:  CALL   58B
0ADF:  BSF    0A.3
....................          pressExit(); 
0AE0:  CALL   1F6
....................          break; 
0AE1:  GOTO   441
....................       case OPT_SHOW_SSID: 
....................          fprintf(console,"C0G3_UNE"); 
0AE2:  MOVLW  E0
0AE3:  BSF    03.6
0AE4:  MOVWF  0D
0AE5:  MOVLW  00
0AE6:  MOVWF  0F
0AE7:  BCF    03.6
0AE8:  CALL   17E
....................          printf(lcd_putc, "\fC0G3_UNE"); 
0AE9:  MOVLW  E5
0AEA:  BSF    03.6
0AEB:  MOVWF  0D
0AEC:  MOVLW  00
0AED:  MOVWF  0F
0AEE:  BCF    0A.3
0AEF:  BCF    03.6
0AF0:  CALL   58B
0AF1:  BSF    0A.3
....................          pressExit();          
0AF2:  CALL   1F6
....................          break; 
0AF3:  GOTO   441
....................       case OPT_SHOW_KEY: 
....................          fprintf(console,"1234Az!"); 
0AF4:  MOVLW  EA
0AF5:  BSF    03.6
0AF6:  MOVWF  0D
0AF7:  MOVLW  00
0AF8:  MOVWF  0F
0AF9:  BCF    03.6
0AFA:  CALL   17E
....................          printf(lcd_putc, "\f1234Az!"); 
0AFB:  MOVLW  EE
0AFC:  BSF    03.6
0AFD:  MOVWF  0D
0AFE:  MOVLW  00
0AFF:  MOVWF  0F
0B00:  BCF    0A.3
0B01:  BCF    03.6
0B02:  CALL   58B
0B03:  BSF    0A.3
....................          pressExit(); 
0B04:  CALL   1F6
....................          break; 
0B05:  GOTO   441
....................       case OPT_MODE_AP: 
....................          setMenuModo(); 
....................          break; 
*
0C23:  BCF    03.5
0C24:  GOTO   441
....................       case OPT_BACKLIGH: 
....................          output_toggle(LCD_LIGHT_PIN); 
0C25:  BSF    03.5
0C26:  BCF    08.3
0C27:  MOVLW  08
0C28:  BCF    03.5
0C29:  XORWF  08,F
....................          if(input_state(LCD_LIGHT_PIN)==1){ 
0C2A:  BTFSS  08.3
0C2B:  GOTO   436
....................             printf(lcd_putc, "\fBacklight On"); 
0C2C:  MOVLW  F3
0C2D:  BSF    03.6
0C2E:  MOVWF  0D
0C2F:  MOVLW  00
0C30:  MOVWF  0F
0C31:  BCF    0A.3
0C32:  BCF    03.6
0C33:  CALL   58B
0C34:  BSF    0A.3
....................          }else{ 
0C35:  GOTO   43F
....................             printf(lcd_putc, "\fBacklight Off"); 
0C36:  MOVLW  FA
0C37:  BSF    03.6
0C38:  MOVWF  0D
0C39:  MOVLW  00
0C3A:  MOVWF  0F
0C3B:  BCF    0A.3
0C3C:  BCF    03.6
0C3D:  CALL   58B
0C3E:  BSF    0A.3
....................          } 
....................          pressExit(); 
0C3F:  CALL   1F6
....................          break; 
0C40:  GOTO   441
....................       case OPT_EXIT: 
....................          break; 
....................           
....................    } 
0C41:  BSF    0A.3
0C42:  BCF    0A.4
0C43:  GOTO   4DA (RETURN)
....................  
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuSetup  = 5; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... const char  optMenuOn[10][15]      =  {{"On -> Salida 1"}, 
....................                                        {"On -> Salida 2"}, 
....................                                        {"On -> Salida 3"}, 
....................                                        {"On -> Salida 4"}, 
....................                                        {"On -> Salida 5"}, 
....................                                        {"On -> Salida 6"}, 
....................                                        {"On -> Salida 7"}, 
....................                                        {"On -> Salida 8"}, 
....................                                        {"SALIR         "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Apagar [pos][lenString] 
.................... const char  optMenuOff[10][16]     =  {{"Off -> Salida 1"}, 
....................                                        {"Off -> Salida 2"}, 
....................                                        {"Off -> Salida 3"}, 
....................                                        {"Off -> Salida 4"}, 
....................                                        {"Off -> Salida 5"}, 
....................                                        {"Off -> Salida 6"}, 
....................                                        {"Off -> Salida 7"}, 
....................                                        {"Off -> Salida 8"}, 
....................                                        {"SALIR          "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[7][17]    =  { {"VER IP          "}, 
....................                                         {"VER SSID        "}, 
....................                                         {"VER KEY         "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................                                        
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
076D:  CLRF   7B
076E:  CLRF   7C
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
076F:  SWAPF  7B,W
0770:  MOVWF  77
0771:  MOVLW  F0
0772:  ANDWF  77,F
0773:  MOVF   77,W
0774:  MOVWF  7D
0775:  MOVLW  0C
0776:  BSF    03.5
0777:  MOVWF  24
0778:  BCF    03.5
0779:  CALL   4F6
077A:  MOVLW  02
077B:  BSF    03.6
077C:  MOVWF  0D
077D:  MOVLW  01
077E:  MOVWF  0F
077F:  MOVF   7D,W
0780:  ADDWF  0D,F
0781:  BTFSC  03.0
0782:  INCF   0F,F
0783:  BCF    03.6
0784:  CALL   550
....................    showBottonMenu(); 
0785:  CALL   5FF
....................    while(!exit){ 
0786:  MOVF   7C,F
0787:  BTFSS  03.2
0788:  GOTO   7D8
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0789:  BSF    03.5
078A:  BSF    06.4
078B:  BCF    03.5
078C:  BTFSC  06.4
078D:  GOTO   7BD
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
078E:  MOVLW  02
078F:  MOVWF  7D
0790:  MOVLW  FA
0791:  BSF    03.5
0792:  MOVWF  25
0793:  BCF    03.5
0794:  CALL   2F8
0795:  DECFSZ 7D,F
0796:  GOTO   790
....................          BEEP; 
0797:  MOVLW  04
0798:  BSF    03.5
0799:  MOVWF  22
079A:  MOVLW  B9
079B:  MOVWF  21
079C:  CLRF   24
079D:  MOVLW  14
079E:  MOVWF  23
079F:  BCF    03.5
07A0:  CALL   61E
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
07A1:  INCF   7B,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
07A2:  MOVF   7B,W
07A3:  SUBWF  5D,W
07A4:  BTFSS  03.0
....................             optSelected = 0; 
07A5:  CLRF   7B
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
07A6:  SWAPF  7B,W
07A7:  MOVWF  77
07A8:  MOVLW  F0
07A9:  ANDWF  77,F
07AA:  MOVF   77,W
07AB:  MOVWF  7D
07AC:  MOVLW  0C
07AD:  BSF    03.5
07AE:  MOVWF  24
07AF:  BCF    03.5
07B0:  CALL   4F6
07B1:  MOVLW  02
07B2:  BSF    03.6
07B3:  MOVWF  0D
07B4:  MOVLW  01
07B5:  MOVWF  0F
07B6:  MOVF   7D,W
07B7:  ADDWF  0D,F
07B8:  BTFSC  03.0
07B9:  INCF   0F,F
07BA:  BCF    03.6
07BB:  CALL   550
....................          showBottonMenu(); 
07BC:  CALL   5FF
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
07BD:  BSF    03.5
07BE:  BSF    06.5
07BF:  BCF    03.5
07C0:  BTFSC  06.5
07C1:  GOTO   7D7
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
07C2:  MOVLW  02
07C3:  MOVWF  7D
07C4:  MOVLW  FA
07C5:  BSF    03.5
07C6:  MOVWF  25
07C7:  BCF    03.5
07C8:  CALL   2F8
07C9:  DECFSZ 7D,F
07CA:  GOTO   7C4
....................          BEEP; 
07CB:  MOVLW  04
07CC:  BSF    03.5
07CD:  MOVWF  22
07CE:  MOVLW  B9
07CF:  MOVWF  21
07D0:  CLRF   24
07D1:  MOVLW  14
07D2:  MOVWF  23
07D3:  BCF    03.5
07D4:  CALL   61E
....................          // Rompe el Loop 
....................          exit = 1; 
07D5:  MOVLW  01
07D6:  MOVWF  7C
....................       } // Fin KEY_OK 
07D7:  GOTO   786
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
07D8:  MOVLW  01
07D9:  ADDWF  7B,W
07DA:  MOVWF  78
07DB:  BSF    0A.3
07DC:  BCF    0A.4
07DD:  GOTO   5DB (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
0827:  CLRF   7B
0828:  CLRF   7C
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
0829:  MOVF   7B,W
082A:  BSF    03.5
082B:  MOVWF  21
082C:  MOVLW  0F
082D:  MOVWF  22
082E:  BCF    03.5
082F:  CALL   000
0830:  MOVF   78,W
0831:  MOVWF  7D
0832:  MOVLW  0C
0833:  BSF    03.5
0834:  MOVWF  24
0835:  BCF    0A.3
0836:  BCF    03.5
0837:  CALL   4F6
0838:  BSF    0A.3
0839:  MOVLW  42
083A:  BSF    03.6
083B:  MOVWF  0D
083C:  MOVLW  01
083D:  MOVWF  0F
083E:  MOVF   7D,W
083F:  ADDWF  0D,F
0840:  BTFSC  03.0
0841:  INCF   0F,F
0842:  BCF    0A.3
0843:  BCF    03.6
0844:  CALL   550
0845:  BSF    0A.3
....................    showBottonMenu(); 
0846:  BCF    0A.3
0847:  CALL   5FF
0848:  BSF    0A.3
....................     
....................    while(!exit){ 
0849:  MOVF   7C,F
084A:  BTFSS  03.2
084B:  GOTO   0D1
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
084C:  BSF    03.5
084D:  BSF    06.4
084E:  BCF    03.5
084F:  BTFSC  06.4
0850:  GOTO   08D
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0851:  MOVLW  02
0852:  MOVWF  7D
0853:  MOVLW  FA
0854:  BSF    03.5
0855:  MOVWF  25
0856:  BCF    0A.3
0857:  BCF    03.5
0858:  CALL   2F8
0859:  BSF    0A.3
085A:  DECFSZ 7D,F
085B:  GOTO   053
....................          BEEP; 
085C:  MOVLW  04
085D:  BSF    03.5
085E:  MOVWF  22
085F:  MOVLW  B9
0860:  MOVWF  21
0861:  CLRF   24
0862:  MOVLW  14
0863:  MOVWF  23
0864:  BCF    0A.3
0865:  BCF    03.5
0866:  CALL   61E
0867:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0868:  INCF   7B,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
0869:  MOVF   7B,W
086A:  SUBWF  5F,W
086B:  BTFSS  03.0
....................             optSelected = 0; 
086C:  CLRF   7B
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOn[optSelected]); 
086D:  MOVF   7B,W
086E:  BSF    03.5
086F:  MOVWF  21
0870:  MOVLW  0F
0871:  MOVWF  22
0872:  BCF    03.5
0873:  CALL   000
0874:  MOVF   78,W
0875:  MOVWF  7D
0876:  MOVLW  0C
0877:  BSF    03.5
0878:  MOVWF  24
0879:  BCF    0A.3
087A:  BCF    03.5
087B:  CALL   4F6
087C:  BSF    0A.3
087D:  MOVLW  42
087E:  BSF    03.6
087F:  MOVWF  0D
0880:  MOVLW  01
0881:  MOVWF  0F
0882:  MOVF   7D,W
0883:  ADDWF  0D,F
0884:  BTFSC  03.0
0885:  INCF   0F,F
0886:  BCF    0A.3
0887:  BCF    03.6
0888:  CALL   550
0889:  BSF    0A.3
....................          showBottonMenu(); 
088A:  BCF    0A.3
088B:  CALL   5FF
088C:  BSF    0A.3
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
088D:  BSF    03.5
088E:  BSF    06.5
088F:  BCF    03.5
0890:  BTFSC  06.5
0891:  GOTO   0D0
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0892:  MOVLW  02
0893:  MOVWF  7D
0894:  MOVLW  FA
0895:  BSF    03.5
0896:  MOVWF  25
0897:  BCF    0A.3
0898:  BCF    03.5
0899:  CALL   2F8
089A:  BSF    0A.3
089B:  DECFSZ 7D,F
089C:  GOTO   094
....................          BEEP; 
089D:  MOVLW  04
089E:  BSF    03.5
089F:  MOVWF  22
08A0:  MOVLW  B9
08A1:  MOVWF  21
08A2:  CLRF   24
08A3:  MOVLW  14
08A4:  MOVWF  23
08A5:  BCF    0A.3
08A6:  BCF    03.5
08A7:  CALL   61E
08A8:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOn){ 
08A9:  MOVF   5F,W
08AA:  SUBWF  7B,W
08AB:  BTFSS  03.2
08AC:  GOTO   0B0
....................             exit = 1; 
08AD:  MOVLW  01
08AE:  MOVWF  7C
....................          }else{ 
08AF:  GOTO   0D0
....................             output_high(PIN_OUT[optSelected]); 
08B0:  BCF    03.0
08B1:  RLF    7B,W
08B2:  ADDLW  2E
08B3:  MOVWF  04
08B4:  BCF    03.7
08B5:  INCF   04,F
08B6:  MOVF   00,W
08B7:  MOVWF  7E
08B8:  DECF   04,F
08B9:  MOVF   00,W
08BA:  MOVWF  7D
08BB:  BSF    03.5
08BC:  MOVWF  20
08BD:  MOVLW  01
08BE:  MOVWF  21
08BF:  CLRF   23
08C0:  CLRF   22
08C1:  BCF    0A.3
08C2:  BCF    03.5
08C3:  CALL   7DE
08C4:  BSF    0A.3
08C5:  MOVF   7D,W
08C6:  BSF    03.5
08C7:  MOVWF  20
08C8:  CLRF   21
08C9:  CLRF   23
08CA:  MOVLW  80
08CB:  MOVWF  22
08CC:  BCF    0A.3
08CD:  BCF    03.5
08CE:  CALL   7DE
08CF:  BSF    0A.3
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
08D0:  GOTO   049
....................    } // FIN While Infinito 
....................  
....................    return 0; 
08D1:  MOVLW  00
08D2:  MOVWF  78
08D3:  BSF    0A.3
08D4:  BCF    0A.4
08D5:  GOTO   5E0 (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
08D6:  CLRF   7B
08D7:  CLRF   7C
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
08D8:  SWAPF  7B,W
08D9:  MOVWF  77
08DA:  MOVLW  F0
08DB:  ANDWF  77,F
08DC:  MOVF   77,W
08DD:  MOVWF  7D
08DE:  MOVLW  0C
08DF:  BSF    03.5
08E0:  MOVWF  24
08E1:  BCF    0A.3
08E2:  BCF    03.5
08E3:  CALL   4F6
08E4:  BSF    0A.3
08E5:  MOVLW  D8
08E6:  BSF    03.6
08E7:  MOVWF  0D
08E8:  MOVLW  01
08E9:  MOVWF  0F
08EA:  MOVF   7D,W
08EB:  ADDWF  0D,F
08EC:  BTFSC  03.0
08ED:  INCF   0F,F
08EE:  BCF    0A.3
08EF:  BCF    03.6
08F0:  CALL   550
08F1:  BSF    0A.3
....................    showBottonMenu(); 
08F2:  BCF    0A.3
08F3:  CALL   5FF
08F4:  BSF    0A.3
....................     
....................    while(!exit){ 
08F5:  MOVF   7C,F
08F6:  BTFSS  03.2
08F7:  GOTO   179
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
08F8:  BSF    03.5
08F9:  BSF    06.4
08FA:  BCF    03.5
08FB:  BTFSC  06.4
08FC:  GOTO   136
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
08FD:  MOVLW  02
08FE:  MOVWF  7D
08FF:  MOVLW  FA
0900:  BSF    03.5
0901:  MOVWF  25
0902:  BCF    0A.3
0903:  BCF    03.5
0904:  CALL   2F8
0905:  BSF    0A.3
0906:  DECFSZ 7D,F
0907:  GOTO   0FF
....................          BEEP; 
0908:  MOVLW  04
0909:  BSF    03.5
090A:  MOVWF  22
090B:  MOVLW  B9
090C:  MOVWF  21
090D:  CLRF   24
090E:  MOVLW  14
090F:  MOVWF  23
0910:  BCF    0A.3
0911:  BCF    03.5
0912:  CALL   61E
0913:  BSF    0A.3
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0914:  INCF   7B,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
0915:  MOVF   7B,W
0916:  SUBWF  60,W
0917:  BTFSS  03.0
....................             optSelected = 0; 
0918:  CLRF   7B
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuOff[optSelected]); 
0919:  SWAPF  7B,W
091A:  MOVWF  77
091B:  MOVLW  F0
091C:  ANDWF  77,F
091D:  MOVF   77,W
091E:  MOVWF  7D
091F:  MOVLW  0C
0920:  BSF    03.5
0921:  MOVWF  24
0922:  BCF    0A.3
0923:  BCF    03.5
0924:  CALL   4F6
0925:  BSF    0A.3
0926:  MOVLW  D8
0927:  BSF    03.6
0928:  MOVWF  0D
0929:  MOVLW  01
092A:  MOVWF  0F
092B:  MOVF   7D,W
092C:  ADDWF  0D,F
092D:  BTFSC  03.0
092E:  INCF   0F,F
092F:  BCF    0A.3
0930:  BCF    03.6
0931:  CALL   550
0932:  BSF    0A.3
....................          showBottonMenu(); 
0933:  BCF    0A.3
0934:  CALL   5FF
0935:  BSF    0A.3
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0936:  BSF    03.5
0937:  BSF    06.5
0938:  BCF    03.5
0939:  BTFSC  06.5
093A:  GOTO   178
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
093B:  MOVLW  02
093C:  MOVWF  7D
093D:  MOVLW  FA
093E:  BSF    03.5
093F:  MOVWF  25
0940:  BCF    0A.3
0941:  BCF    03.5
0942:  CALL   2F8
0943:  BSF    0A.3
0944:  DECFSZ 7D,F
0945:  GOTO   13D
....................          BEEP; 
0946:  MOVLW  04
0947:  BSF    03.5
0948:  MOVWF  22
0949:  MOVLW  B9
094A:  MOVWF  21
094B:  CLRF   24
094C:  MOVLW  14
094D:  MOVWF  23
094E:  BCF    0A.3
094F:  BCF    03.5
0950:  CALL   61E
0951:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
0952:  MOVF   60,W
0953:  SUBWF  7B,W
0954:  BTFSS  03.2
0955:  GOTO   159
....................             exit = 1; 
0956:  MOVLW  01
0957:  MOVWF  7C
....................          }else{ 
0958:  GOTO   178
....................             output_low(PIN_OUT[optSelected]); 
0959:  BCF    03.0
095A:  RLF    7B,W
095B:  ADDLW  2E
095C:  MOVWF  04
095D:  BCF    03.7
095E:  INCF   04,F
095F:  MOVF   00,W
0960:  MOVWF  7E
0961:  DECF   04,F
0962:  MOVF   00,W
0963:  MOVWF  7D
0964:  BSF    03.5
0965:  MOVWF  20
0966:  CLRF   21
0967:  CLRF   23
0968:  CLRF   22
0969:  BCF    0A.3
096A:  BCF    03.5
096B:  CALL   7DE
096C:  BSF    0A.3
096D:  MOVF   7D,W
096E:  BSF    03.5
096F:  MOVWF  20
0970:  CLRF   21
0971:  CLRF   23
0972:  MOVLW  80
0973:  MOVWF  22
0974:  BCF    0A.3
0975:  BCF    03.5
0976:  CALL   7DE
0977:  BSF    0A.3
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
0978:  GOTO   0F5
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0979:  MOVLW  00
097A:  MOVWF  78
097B:  BSF    0A.3
097C:  BCF    0A.4
097D:  GOTO   5E4 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
.................... int getMenuSetup(void){ 
*
0C4E:  CLRF   7B
0C4F:  CLRF   7C
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0C50:  MOVF   7B,W
0C51:  BSF    03.5
0C52:  MOVWF  21
0C53:  MOVLW  11
0C54:  MOVWF  22
0C55:  BCF    03.5
0C56:  CALL   000
0C57:  MOVF   78,W
0C58:  MOVWF  7D
0C59:  MOVLW  0C
0C5A:  BSF    03.5
0C5B:  MOVWF  24
0C5C:  BCF    0A.3
0C5D:  BCF    03.5
0C5E:  CALL   4F6
0C5F:  BSF    0A.3
0C60:  MOVLW  78
0C61:  BSF    03.6
0C62:  MOVWF  0D
0C63:  MOVLW  02
0C64:  MOVWF  0F
0C65:  MOVF   7D,W
0C66:  ADDWF  0D,F
0C67:  BTFSC  03.0
0C68:  INCF   0F,F
0C69:  BCF    0A.3
0C6A:  BCF    03.6
0C6B:  CALL   550
0C6C:  BSF    0A.3
....................    showBottonMenu(); 
0C6D:  BCF    0A.3
0C6E:  CALL   5FF
0C6F:  BSF    0A.3
....................     
....................    while(!exit){ 
0C70:  MOVF   7C,F
0C71:  BTFSS  03.2
0C72:  GOTO   4FB
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
0C73:  BSF    03.5
0C74:  BSF    06.4
0C75:  BCF    03.5
0C76:  BTFSC  06.4
0C77:  GOTO   4B4
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0C78:  MOVLW  02
0C79:  MOVWF  7D
0C7A:  MOVLW  FA
0C7B:  BSF    03.5
0C7C:  MOVWF  25
0C7D:  BCF    0A.3
0C7E:  BCF    03.5
0C7F:  CALL   2F8
0C80:  BSF    0A.3
0C81:  DECFSZ 7D,F
0C82:  GOTO   47A
....................          BEEP; 
0C83:  MOVLW  04
0C84:  BSF    03.5
0C85:  MOVWF  22
0C86:  MOVLW  B9
0C87:  MOVWF  21
0C88:  CLRF   24
0C89:  MOVLW  14
0C8A:  MOVWF  23
0C8B:  BCF    0A.3
0C8C:  BCF    03.5
0C8D:  CALL   61E
0C8E:  BSF    0A.3
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
0C8F:  INCF   7B,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
0C90:  MOVF   7B,W
0C91:  SUBWF  5E,W
0C92:  BTFSS  03.0
....................             optSelected = 0; 
0C93:  CLRF   7B
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0C94:  MOVF   7B,W
0C95:  BSF    03.5
0C96:  MOVWF  21
0C97:  MOVLW  11
0C98:  MOVWF  22
0C99:  BCF    03.5
0C9A:  CALL   000
0C9B:  MOVF   78,W
0C9C:  MOVWF  7D
0C9D:  MOVLW  0C
0C9E:  BSF    03.5
0C9F:  MOVWF  24
0CA0:  BCF    0A.3
0CA1:  BCF    03.5
0CA2:  CALL   4F6
0CA3:  BSF    0A.3
0CA4:  MOVLW  78
0CA5:  BSF    03.6
0CA6:  MOVWF  0D
0CA7:  MOVLW  02
0CA8:  MOVWF  0F
0CA9:  MOVF   7D,W
0CAA:  ADDWF  0D,F
0CAB:  BTFSC  03.0
0CAC:  INCF   0F,F
0CAD:  BCF    0A.3
0CAE:  BCF    03.6
0CAF:  CALL   550
0CB0:  BSF    0A.3
....................          showBottonMenu(); 
0CB1:  BCF    0A.3
0CB2:  CALL   5FF
0CB3:  BSF    0A.3
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0CB4:  BSF    03.5
0CB5:  BSF    06.5
0CB6:  BCF    03.5
0CB7:  BTFSC  06.5
0CB8:  GOTO   4FA
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0CB9:  MOVLW  02
0CBA:  MOVWF  7D
0CBB:  MOVLW  FA
0CBC:  BSF    03.5
0CBD:  MOVWF  25
0CBE:  BCF    0A.3
0CBF:  BCF    03.5
0CC0:  CALL   2F8
0CC1:  BSF    0A.3
0CC2:  DECFSZ 7D,F
0CC3:  GOTO   4BB
....................          BEEP; 
0CC4:  MOVLW  04
0CC5:  BSF    03.5
0CC6:  MOVWF  22
0CC7:  MOVLW  B9
0CC8:  MOVWF  21
0CC9:  CLRF   24
0CCA:  MOVLW  14
0CCB:  MOVWF  23
0CCC:  BCF    0A.3
0CCD:  BCF    03.5
0CCE:  CALL   61E
0CCF:  BSF    0A.3
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
0CD0:  MOVF   5E,W
0CD1:  SUBWF  7B,W
0CD2:  BTFSS  03.2
0CD3:  GOTO   4D7
....................             exit = 1; 
0CD4:  MOVLW  01
0CD5:  MOVWF  7C
....................          }else{ 
0CD6:  GOTO   4FA
....................             executeSetup(optSelected); 
0CD7:  MOVF   7B,W
0CD8:  MOVWF  7D
0CD9:  GOTO   2CA
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0CDA:  MOVF   7B,W
0CDB:  BSF    03.5
0CDC:  MOVWF  21
0CDD:  MOVLW  11
0CDE:  MOVWF  22
0CDF:  BCF    03.5
0CE0:  CALL   000
0CE1:  MOVF   78,W
0CE2:  MOVWF  7D
0CE3:  MOVLW  0C
0CE4:  BSF    03.5
0CE5:  MOVWF  24
0CE6:  BCF    0A.3
0CE7:  BCF    03.5
0CE8:  CALL   4F6
0CE9:  BSF    0A.3
0CEA:  MOVLW  78
0CEB:  BSF    03.6
0CEC:  MOVWF  0D
0CED:  MOVLW  02
0CEE:  MOVWF  0F
0CEF:  MOVF   7D,W
0CF0:  ADDWF  0D,F
0CF1:  BTFSC  03.0
0CF2:  INCF   0F,F
0CF3:  BCF    0A.3
0CF4:  BCF    03.6
0CF5:  CALL   550
0CF6:  BSF    0A.3
....................             showBottonMenu(); 
0CF7:  BCF    0A.3
0CF8:  CALL   5FF
0CF9:  BSF    0A.3
....................          } 
....................       } // Fin KEY_OK 
0CFA:  GOTO   470
....................    } // FIN While Infinito 
....................  
....................    return 0; 
0CFB:  MOVLW  00
0CFC:  MOVWF  78
0CFD:  BSF    0A.3
0CFE:  BCF    0A.4
0CFF:  GOTO   5E8 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... #include "header/esp8266.h" 
.................... /* 
....................  
....................    ****  AT+CWLAP\r\n            : Este comando nos proporciona una lista con las redes WiFi disponibles e informacin adicional de estas. 
....................    ****  41542B43574C41500D0A    : hexadecimal 
....................     
.................... Respuesta del comando AT+CWLAP 
.................... ============================================================== 
.................... AT+CWLAP 
.................... +CWLAP:(3,"HOME-C4C9",-79,"cc:35:40:55:c4:c9",1) 
.................... +CWLAP:(4,"UNE_C06E",-42,"c4:27:95:89:60:cf",1) 
.................... +CWLAP:(3,"SAMUEL",-89,"80:c6:ab:5f:97:72",11) 
.................... +CWLAP:(3,"UNE4GREVOLUTION703147",-88,"24:db:ac:58:47:95",2) 
.................... +CWLAP:(1,"60172707",-87,"90:00:4e:2b:f7:74",11) 
.................... +CWLAP:(3,"DTVNET_D61792",-59,"e4:3e:d7:d6:17:92",4) 
.................... +CWLAP:(3,".FLIA-SOLARTE",-94,"14:ab:f0:1d:48:f0",11) 
.................... +CWLAP:(4,"UNE_62D5",-93,"e0:88:5d:51:9f:81",6) 
.................... +CWLAP:(4,"UNE_HFC_3B30",-70,"ac:20:2e:3a:3b:38",6) 
.................... +CWLAP:(3,"FLIA NAZARI",-93,"44:32:c8:35:0e:3f",6) 
....................  
.................... OK 
.................... =============================================================== 
.................... El comando responde con una cadena de caracteres que incluye: 
.................... +CWLAP: <ecn>, <ssid>, <rssi>, <mac>, <canal>  OK 
....................  <ecn>: 
.................... 0 - Red abierta (sin contrasea). 
.................... 1 - Red con contrasea WEP. 
.................... 2 - Red con contrasea WPA_PSK. 
.................... 3 - Red con contrasea WPA2_PSK 
.................... 4 - Red con contrasea WPA_WPA2_PSK 
.................... <ssid>: 
.................... String con el nombre de la Red. 
.................... <rssi>:   
....................  String con el nivel (potencia) de la seal. 
.................... <mac>: 
.................... String con la direccin MAC de la Red.  
....................  
.................... */ 
.................... char *CWLAP[10]={                        
.................... 65, 84, 43, 67, 87, 76, 65, 80, 10, 13 
.................... }; 
*
0D7F:  MOVLW  41
0D80:  MOVWF  61
0D81:  CLRF   62
0D82:  MOVLW  54
0D83:  MOVWF  63
0D84:  CLRF   64
0D85:  MOVLW  2B
0D86:  MOVWF  65
0D87:  CLRF   66
0D88:  MOVLW  43
0D89:  MOVWF  67
0D8A:  CLRF   68
0D8B:  MOVLW  57
0D8C:  MOVWF  69
0D8D:  CLRF   6A
0D8E:  MOVLW  4C
0D8F:  MOVWF  6B
0D90:  CLRF   6C
0D91:  MOVLW  41
0D92:  MOVWF  6D
0D93:  CLRF   6E
0D94:  MOVLW  50
0D95:  MOVWF  6F
0D96:  CLRF   70
0D97:  MOVLW  0A
0D98:  MOVWF  71
0D99:  CLRF   72
0D9A:  MOVLW  0D
0D9B:  MOVWF  73
0D9C:  CLRF   74
....................  
....................  
.................... /** VARIABLES GLOBALS **/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
.................... // Flag usada para almacenar las respuestas de las opciones de menu 
.................... int optSelect  = 0; 
....................  
.................... /** INTERRUPCIONES **/ 
....................  
.................... //@hint: se dispara cuando se detectan datos de llegada al puerto serie portWF 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................    //buffer = strcat (buffer,getchar()); 
....................    //buffer = getchar(); 
*
02EF:  BCF    0C.5
02F0:  BCF    0A.3
02F1:  BCF    0A.4
02F2:  GOTO   02D
.................... } 
....................  
.................... /** INIT **/ 
....................  
....................    void main() 
*
0D00:  MOVF   03,W
0D01:  ANDLW  1F
0D02:  MOVWF  03
0D03:  BSF    03.5
0D04:  BSF    03.6
0D05:  BSF    07.3
0D06:  MOVLW  2A
0D07:  BCF    03.6
0D08:  MOVWF  19
0D09:  MOVLW  00
0D0A:  MOVWF  1A
0D0B:  MOVLW  A6
0D0C:  MOVWF  18
0D0D:  MOVLW  90
0D0E:  BCF    03.5
0D0F:  MOVWF  18
0D10:  BSF    03.5
0D11:  BCF    06.0
0D12:  BCF    03.5
0D13:  BSF    06.0
0D14:  MOVLW  0A
0D15:  MOVWF  2B
0D16:  MOVLW  0D
0D17:  MOVWF  2C
0D18:  MOVLW  03
0D19:  MOVWF  5C
0D1A:  MOVLW  02
0D1B:  MOVWF  5D
0D1C:  MOVLW  05
0D1D:  MOVWF  5E
0D1E:  MOVLW  08
0D1F:  MOVWF  5F
0D20:  MOVWF  60
0D21:  CLRF   75
0D22:  CLRF   76
0D23:  BSF    03.5
0D24:  BSF    03.6
0D25:  MOVF   09,W
0D26:  ANDLW  C0
0D27:  MOVWF  09
0D28:  BCF    03.6
0D29:  BCF    1F.4
0D2A:  BCF    1F.5
0D2B:  MOVLW  00
0D2C:  BSF    03.6
0D2D:  MOVWF  08
0D2E:  BCF    03.5
0D2F:  CLRF   07
0D30:  CLRF   08
0D31:  CLRF   09
0D32:  BCF    03.7
....................    { 
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
*
0D9D:  MOVLW  30
0D9E:  BSF    03.5
0D9F:  MOVWF  15
0DA0:  BCF    01.7
....................       set_tris_b(0b00110010); 
0DA1:  MOVLW  32
0DA2:  MOVWF  06
....................        
....................       enable_interrupts(INT_RDA);  
0DA3:  BSF    0C.5
....................       enable_interrupts(GLOBAL);  
0DA4:  MOVLW  C0
0DA5:  BCF    03.5
0DA6:  IORWF  0B,F
....................      
....................       // Inicializa la lcd 
....................       lcd_init(); 
0DA7:  BCF    0A.3
0DA8:  GOTO   404
0DA9:  BSF    0A.3
....................       output_high(LCD_LIGHT_PIN); 
0DAA:  BSF    03.5
0DAB:  BCF    08.3
0DAC:  BCF    03.5
0DAD:  BSF    08.3
....................       fprintf(console,"Start%c%c",NL,CR); 
0DAE:  MOVLW  F3
0DAF:  BSF    03.6
0DB0:  MOVWF  0D
0DB1:  MOVLW  02
0DB2:  MOVWF  0F
0DB3:  BCF    03.0
0DB4:  MOVLW  05
0DB5:  MOVWF  7B
0DB6:  BCF    0A.3
0DB7:  BCF    03.6
0DB8:  GOTO   47A
0DB9:  BSF    0A.3
0DBA:  MOVF   2B,W
0DBB:  BSF    03.5
0DBC:  MOVWF  23
0DBD:  BCF    0A.3
0DBE:  BCF    03.5
0DBF:  CALL   456
0DC0:  BSF    0A.3
0DC1:  MOVF   2C,W
0DC2:  BSF    03.5
0DC3:  MOVWF  23
0DC4:  BCF    0A.3
0DC5:  BCF    03.5
0DC6:  CALL   456
0DC7:  BSF    0A.3
....................       //Estabiliza el inicio del programa 
....................       delay_ms(500); 
0DC8:  MOVLW  02
0DC9:  MOVWF  7B
0DCA:  MOVLW  FA
0DCB:  BSF    03.5
0DCC:  MOVWF  25
0DCD:  BCF    0A.3
0DCE:  BCF    03.5
0DCF:  CALL   2F8
0DD0:  BSF    0A.3
0DD1:  DECFSZ 7B,F
0DD2:  GOTO   5CA
....................        
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
0DD3:  MOVF   75,W
0DD4:  ADDLW  FC
0DD5:  BTFSC  03.0
0DD6:  GOTO   5EA
0DD7:  ADDLW  04
0DD8:  GOTO   5EC
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
0DD9:  BCF    0A.3
0DDA:  GOTO   76D
0DDB:  BSF    0A.3
0DDC:  MOVF   78,W
0DDD:  MOVWF  75
....................                break; 
0DDE:  GOTO   5EA
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
0DDF:  GOTO   027
0DE0:  MOVF   78,W
0DE1:  MOVWF  75
....................                break; 
0DE2:  GOTO   5EA
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
0DE3:  GOTO   0D6
0DE4:  MOVF   78,W
0DE5:  MOVWF  75
....................                break; 
0DE6:  GOTO   5EA
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
0DE7:  GOTO   44E
0DE8:  MOVF   78,W
0DE9:  MOVWF  75
....................                break; 
....................          } // Fin del Switch(menuActive) 
0DEA:  GOTO   5D3
....................           
....................       } // End loop while -> true 
....................    } // Fin del main 
....................  
0DEB:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3EFF   BORV21 NOWRT
