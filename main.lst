CCS PCH C Compiler, Version 5.015, 5967               21-dic.-17 00:51

               Filename:   D:\DAVID\Documents\GitHub\Kriver-Hardware\main.lst

               ROM used:   10262 bytes (16%)
                           Largest free fragment is 55270
               RAM used:   361 (9%) at main() level
                           457 (12%) worst case
               Stack used: 14 locations (10 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   2692
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  00,0E
0003C:  MOVFF  01,0F
00040:  MOVFF  02,10
00044:  MOVFF  03,11
00048:  BTFSS  F9D.5
0004A:  GOTO   0054
0004E:  BTFSC  F9E.5
00050:  GOTO   0ACE
00054:  MOVFF  0E,00
00058:  MOVFF  0F,01
0005C:  MOVFF  10,02
00060:  MOVFF  11,03
00064:  MOVFF  0C,FE9
00068:  MOVFF  07,FEA
0006C:  BSF    07.7
0006E:  MOVFF  08,FE1
00072:  MOVFF  09,FE2
00076:  MOVFF  0A,FD9
0007A:  MOVFF  0B,FDA
0007E:  MOVFF  12,FF3
00082:  MOVFF  13,FF4
00086:  MOVFF  14,FFA
0008A:  MOVF   04,W
0008C:  MOVFF  06,FE0
00090:  MOVFF  05,FD8
00094:  RETFIE 0
.................... #include "header/config.h" 
.................... #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
00096:  MOVFF  FF2,0D
0009A:  BCF    FF2.7
0009C:  CLRF   FF7
0009E:  ADDLW  B0
000A0:  MOVWF  FF6
000A2:  MOVLW  00
000A4:  ADDWFC FF7,F
000A6:  TBLRD*+
000A8:  MOVF   FF5,W
000AA:  BTFSC  0D.7
000AC:  BSF    FF2.7
000AE:  RETURN 0
000B0:  DATA 22,7C
000B2:  DATA 21,7C
000B4:  DATA 20,7C
000B6:  DATA 04,7C
000B8:  DATA 00,7C
000BA:  DATA 01,7C
000BC:  DATA 02,7C
000BE:  DATA 03,7C
000C0:  CLRF   FF7
000C2:  ADDLW  D0
000C4:  MOVWF  FF6
000C6:  MOVLW  00
000C8:  ADDWFC FF7,F
000CA:  TBLRD*+
000CC:  MOVF   FF5,W
000CE:  RETURN 0
000D0:  DATA 2B,49
000D2:  DATA 50,44
000D4:  DATA 2C,00
000D6:  CLRF   FF7
000D8:  ADDLW  E6
000DA:  MOVWF  FF6
000DC:  MOVLW  00
000DE:  ADDWFC FF7,F
000E0:  TBLRD*+
000E2:  MOVF   FF5,W
000E4:  RETURN 0
000E6:  DATA 43,4D
000E8:  DATA 44,3A
000EA:  CLRF   FF7
000EC:  ADDLW  FA
000EE:  MOVWF  FF6
000F0:  MOVLW  00
000F2:  ADDWFC FF7,F
000F4:  TBLRD*+
000F6:  MOVF   FF5,W
000F8:  RETURN 0
000FA:  DATA 4F,4B
000FC:  DATA 0D,0A
000FE:  DATA 00,00
00100:  CLRF   FF7
00102:  ADDLW  10
00104:  MOVWF  FF6
00106:  MOVLW  01
00108:  ADDWFC FF7,F
0010A:  TBLRD*+
0010C:  MOVF   FF5,W
0010E:  RETURN 0
00110:  DATA 4E,6F
00112:  DATA 20,41
00114:  DATA 70,00
00116:  CLRF   FF7
00118:  ADDLW  26
0011A:  MOVWF  FF6
0011C:  MOVLW  01
0011E:  ADDWFC FF7,F
00120:  TBLRD*+
00122:  MOVF   FF5,W
00124:  RETURN 0
00126:  DATA 2B,43
00128:  DATA 57,4A
0012A:  DATA 41,50
0012C:  DATA 3A,00
0012E:  CLRF   FF7
00130:  ADDLW  3E
00132:  MOVWF  FF6
00134:  MOVLW  01
00136:  ADDWFC FF7,F
00138:  TBLRD*+
0013A:  MOVF   FF5,W
0013C:  RETURN 0
0013E:  DATA 43,4F
00140:  DATA 4E,4E
00142:  DATA 45,43
00144:  DATA 54,45
00146:  DATA 44,00
00148:  CLRF   FF7
0014A:  ADDLW  58
0014C:  MOVWF  FF6
0014E:  MOVLW  01
00150:  ADDWFC FF7,F
00152:  TBLRD*+
00154:  MOVF   FF5,W
00156:  RETURN 0
00158:  DATA 46,41
0015A:  DATA 49,4C
0015C:  DATA 00,00
0015E:  DATA 41,54
00160:  DATA 2B,43
00162:  DATA 49,50
00164:  DATA 53,45
00166:  DATA 4E,44
00168:  DATA 3D,25
0016A:  DATA 63,2C
0016C:  DATA 25,75
0016E:  DATA 0D,0A
00170:  DATA 00,00
00172:  DATA 41,54
00174:  DATA 2B,43
00176:  DATA 49,50
00178:  DATA 43,4C
0017A:  DATA 4F,53
0017C:  DATA 45,3D
0017E:  DATA 25,63
00180:  DATA 0D,0A
00182:  DATA 00,00
00184:  DATA 41,54
00186:  DATA 2B,43
00188:  DATA 57,51
0018A:  DATA 41,50
0018C:  DATA 0A,0D
0018E:  DATA 00,00
00190:  DATA 41,54
00192:  DATA 2B,43
00194:  DATA 49,50
00196:  DATA 53,45
00198:  DATA 4E,44
0019A:  DATA 3D,25
0019C:  DATA 63,2C
0019E:  DATA 25,75
001A0:  DATA 0D,0A
001A2:  DATA 00,00
001A4:  DATA 41,54
001A6:  DATA 2B,43
001A8:  DATA 49,50
001AA:  DATA 43,4C
001AC:  DATA 4F,53
001AE:  DATA 45,3D
001B0:  DATA 25,63
001B2:  DATA 0D,0A
001B4:  DATA 00,00
001B6:  DATA 41,54
001B8:  DATA 2B,43
001BA:  DATA 57,53
001BC:  DATA 41,50
001BE:  DATA 5F,44
001C0:  DATA 45,46
001C2:  DATA 3D,25
001C4:  DATA 73,2C
001C6:  DATA 31,2C
001C8:  DATA 34,0D
001CA:  DATA 0A,00
001CC:  DATA 41,54
001CE:  DATA 2B,43
001D0:  DATA 49,50
001D2:  DATA 53,45
001D4:  DATA 4E,44
001D6:  DATA 3D,25
001D8:  DATA 63,2C
001DA:  DATA 25,75
001DC:  DATA 0D,0A
001DE:  DATA 00,00
001E0:  DATA 41,54
001E2:  DATA 2B,43
001E4:  DATA 49,50
001E6:  DATA 43,4C
001E8:  DATA 4F,53
001EA:  DATA 45,3D
001EC:  DATA 25,63
001EE:  DATA 0D,0A
001F0:  DATA 00,00
001F2:  DATA 41,54
001F4:  DATA 2B,43
001F6:  DATA 49,50
001F8:  DATA 53,45
001FA:  DATA 4E,44
001FC:  DATA 3D,25
001FE:  DATA 63,2C
00200:  DATA 25,75
00202:  DATA 0D,0A
00204:  DATA 00,00
00206:  DATA 41,54
00208:  DATA 2B,43
0020A:  DATA 49,50
0020C:  DATA 43,4C
0020E:  DATA 4F,53
00210:  DATA 45,3D
00212:  DATA 25,63
00214:  DATA 0D,0A
00216:  DATA 00,00
00218:  DATA 41,54
0021A:  DATA 2B,43
0021C:  DATA 57,4D
0021E:  DATA 4F,44
00220:  DATA 45,3D
00222:  DATA 25,63
00224:  DATA 0D,0A
00226:  DATA 00,00
00228:  DATA 41,54
0022A:  DATA 2B,43
0022C:  DATA 57,4A
0022E:  DATA 41,50
00230:  DATA 3F,0D
00232:  DATA 0A,00
00234:  DATA 41,54
00236:  DATA 2B,43
00238:  DATA 57,4A
0023A:  DATA 41,50
0023C:  DATA 3D,25
0023E:  DATA 73,00
00240:  DATA 41,54
00242:  DATA 2B,43
00244:  DATA 57,4D
00246:  DATA 4F,44
00248:  DATA 45,3D
0024A:  DATA 25,63
0024C:  DATA 0D,0A
0024E:  DATA 00,00
00250:  DATA 41,54
00252:  DATA 2B,43
00254:  DATA 49,50
00256:  DATA 4D,55
00258:  DATA 58,3D
0025A:  DATA 31,0D
0025C:  DATA 0A,00
0025E:  DATA 41,54
00260:  DATA 2B,43
00262:  DATA 49,50
00264:  DATA 53,45
00266:  DATA 52,56
00268:  DATA 45,52
0026A:  DATA 3D,31
0026C:  DATA 2C,38
0026E:  DATA 30,0D
00270:  DATA 0A,00
00272:  DATA 45,6E
00274:  DATA 63,65
00276:  DATA 6E,64
00278:  DATA 65,72
0027A:  DATA 20,4D
0027C:  DATA 61,6E
0027E:  DATA 75,61
00280:  DATA 6C,00
00282:  DATA 41,70
00284:  DATA 61,67
00286:  DATA 61,64
00288:  DATA 6F,20
0028A:  DATA 4D,61
0028C:  DATA 6E,75
0028E:  DATA 61,6C
00290:  DATA 20,00
00292:  DATA 43,6F
00294:  DATA 6E,66
00296:  DATA 69,67
00298:  DATA 75,72
0029A:  DATA 61,63
0029C:  DATA 69,6F
0029E:  DATA 6E,20
002A0:  DATA 20,00
002A2:  DATA 00,00
002A4:  DATA 00,00
002A6:  DATA 00,00
002A8:  DATA 00,00
002AA:  DATA 00,00
002AC:  DATA 00,00
002AE:  DATA 00,00
002B0:  DATA 00,00
002B2:  DATA 45,53
002B4:  DATA 54,41
002B6:  DATA 43,49
002B8:  DATA 4F,4E
002BA:  DATA 20,49
002BC:  DATA 50,20
002BE:  DATA 20,20
002C0:  DATA 20,20
002C2:  DATA 00,45
002C4:  DATA 53,54
002C6:  DATA 41,43
002C8:  DATA 49,4F
002CA:  DATA 4E,20
002CC:  DATA 53,53
002CE:  DATA 49,44
002D0:  DATA 20,20
002D2:  DATA 20,00
002D4:  DATA 41,50
002D6:  DATA 20,53
002D8:  DATA 53,49
002DA:  DATA 44,20
002DC:  DATA 20,20
002DE:  DATA 20,20
002E0:  DATA 20,20
002E2:  DATA 20,20
002E4:  DATA 00,41
002E6:  DATA 50,20
002E8:  DATA 4B,45
002EA:  DATA 59,20
002EC:  DATA 20,20
002EE:  DATA 20,20
002F0:  DATA 20,20
002F2:  DATA 20,20
002F4:  DATA 20,00
002F6:  DATA 41,50
002F8:  DATA 20,49
002FA:  DATA 50,20
002FC:  DATA 20,20
002FE:  DATA 20,20
00300:  DATA 20,20
00302:  DATA 20,20
00304:  DATA 20,20
00306:  DATA 00,43
00308:  DATA 6F,6E
0030A:  DATA 66,20
0030C:  DATA 41,63
0030E:  DATA 63,65
00310:  DATA 73,73
00312:  DATA 6F,20
00314:  DATA 52,65
00316:  DATA 64,00
00318:  DATA 4F,6E
0031A:  DATA 2F,4F
0031C:  DATA 66,66
0031E:  DATA 20,42
00320:  DATA 61,63
00322:  DATA 6B,6C
00324:  DATA 69,67
00326:  DATA 68,74
00328:  DATA 00,53
0032A:  DATA 41,4C
0032C:  DATA 49,52
0032E:  DATA 20,20
00330:  DATA 20,20
00332:  DATA 20,20
00334:  DATA 20,20
00336:  DATA 20,20
00338:  DATA 20,00
0033A:  DATA 00,00
0033C:  DATA 00,00
0033E:  DATA 00,00
00340:  DATA 00,00
00342:  DATA 00,00
00344:  DATA 00,00
00346:  DATA 00,00
00348:  DATA 00,00
0034A:  DATA 00,00
0034C:  DATA 45,73
0034E:  DATA 74,61
00350:  DATA 63,69
00352:  DATA F3,6E
00354:  DATA 20,20
00356:  DATA 20,20
00358:  DATA 20,00
0035A:  DATA 41,63
0035C:  DATA 63,65
0035E:  DATA 73,73
00360:  DATA 20,50
00362:  DATA 6F,69
00364:  DATA 6E,74
00366:  DATA 20,00
00368:  DATA 45,73
0036A:  DATA 74,61
0036C:  DATA 63,69
0036E:  DATA 6F,6E
00370:  DATA 20,2B
00372:  DATA 20,41
00374:  DATA 50,00
00376:  DATA 53,41
00378:  DATA 4C,49
0037A:  DATA 52,20
0037C:  DATA 20,20
0037E:  DATA 20,20
00380:  DATA 20,20
00382:  DATA 20,00
00384:  DATA 00,00
00386:  DATA 00,00
00388:  DATA 00,00
0038A:  DATA 00,00
0038C:  DATA 00,00
0038E:  DATA 00,00
00390:  DATA 00,00
00392:  DATA 53,41
00394:  DATA 4C,49
00396:  DATA 52,00
00398:  DATA 5B,53
0039A:  DATA 49,47
0039C:  DATA 5D,20
0039E:  DATA 20,20
003A0:  DATA 20,20
003A2:  DATA 20,5B
003A4:  DATA 45,4E
003A6:  DATA 54,5D
003A8:  DATA 00,00
003AA:  DATA 0C,4F
003AC:  DATA 6E,20
003AE:  DATA 2D,3E
003B0:  DATA 20,25
003B2:  DATA 73,00
003B4:  DATA 0C,4F
003B6:  DATA 6E,20
003B8:  DATA 2D,3E
003BA:  DATA 20,25
003BC:  DATA 73,00
003BE:  DATA 0C,4F
003C0:  DATA 66,66
003C2:  DATA 2D,3E
003C4:  DATA 20,25
003C6:  DATA 73,00
003C8:  DATA 0C,4F
003CA:  DATA 66,66
003CC:  DATA 2D,3E
003CE:  DATA 20,25
003D0:  DATA 73,00
003D2:  DATA 41,54
003D4:  DATA 2B,43
003D6:  DATA 49,46
003D8:  DATA 53,52
003DA:  DATA 0D,0A
003DC:  DATA 00,00
003DE:  DATA 0C,43
003E0:  DATA 61,72
003E2:  DATA 67,61
003E4:  DATA 6E,64
003E6:  DATA 6F,2E
003E8:  DATA 2E,2E
003EA:  DATA 00,00
003EC:  DATA 41,54
003EE:  DATA 2B,43
003F0:  DATA 49,46
003F2:  DATA 53,52
003F4:  DATA 0D,0A
003F6:  DATA 00,00
003F8:  DATA 0C,43
003FA:  DATA 61,72
003FC:  DATA 67,61
003FE:  DATA 6E,64
00400:  DATA 6F,2E
00402:  DATA 2E,2E
00404:  DATA 00,00
00406:  DATA 41,54
00408:  DATA 2B,43
0040A:  DATA 57,4A
0040C:  DATA 41,50
0040E:  DATA 3F,0D
00410:  DATA 0A,00
00412:  DATA 0C,43
00414:  DATA 61,72
00416:  DATA 67,61
00418:  DATA 6E,64
0041A:  DATA 6F,2E
0041C:  DATA 2E,2E
0041E:  DATA 00,00
00420:  DATA 0C,44
00422:  DATA 65,73
00424:  DATA 68,61
00426:  DATA 62,69
00428:  DATA 6C,69
0042A:  DATA 74,61
0042C:  DATA 64,6F
0042E:  DATA 00,00
00430:  DATA 41,54
00432:  DATA 2B,43
00434:  DATA 57,53
00436:  DATA 41,50
00438:  DATA 3F,0D
0043A:  DATA 0A,00
0043C:  DATA 0C,43
0043E:  DATA 61,72
00440:  DATA 67,61
00442:  DATA 6E,64
00444:  DATA 6F,2E
00446:  DATA 2E,2E
00448:  DATA 00,00
0044A:  DATA 0C,44
0044C:  DATA 65,73
0044E:  DATA 68,61
00450:  DATA 62,69
00452:  DATA 6C,69
00454:  DATA 74,61
00456:  DATA 64,6F
00458:  DATA 00,00
0045A:  DATA 41,54
0045C:  DATA 2B,43
0045E:  DATA 57,53
00460:  DATA 41,50
00462:  DATA 3F,0D
00464:  DATA 0A,00
00466:  DATA 0C,43
00468:  DATA 61,72
0046A:  DATA 67,61
0046C:  DATA 6E,64
0046E:  DATA 6F,2E
00470:  DATA 2E,2E
00472:  DATA 00,00
00474:  DATA 0C,44
00476:  DATA 65,73
00478:  DATA 68,61
0047A:  DATA 62,69
0047C:  DATA 6C,69
0047E:  DATA 74,61
00480:  DATA 64,6F
00482:  DATA 00,00
00484:  DATA 0C,42
00486:  DATA 61,63
00488:  DATA 6B,6C
0048A:  DATA 69,67
0048C:  DATA 68,74
0048E:  DATA 20,4F
00490:  DATA 6E,00
00492:  DATA 0C,42
00494:  DATA 61,63
00496:  DATA 6B,6C
00498:  DATA 69,67
0049A:  DATA 68,74
0049C:  DATA 20,4F
0049E:  DATA 66,66
004A0:  DATA 00,00
004A2:  DATA 41,54
004A4:  DATA 2B,43
004A6:  DATA 57,4D
004A8:  DATA 4F,44
004AA:  DATA 45,5F
004AC:  DATA 44,45
004AE:  DATA 46,3D
004B0:  DATA 31,0D
004B2:  DATA 0A,00
004B4:  DATA 0C,43
004B6:  DATA 6F,6E
004B8:  DATA 66,69
004BA:  DATA 67,20
004BC:  DATA 43,6C
004BE:  DATA 69,65
004C0:  DATA 6E,74
004C2:  DATA 65,00
004C4:  DATA 41,54
004C6:  DATA 2B,43
004C8:  DATA 57,4D
004CA:  DATA 4F,44
004CC:  DATA 45,5F
004CE:  DATA 44,45
004D0:  DATA 46,3D
004D2:  DATA 32,0D
004D4:  DATA 0A,00
004D6:  DATA 0C,43
004D8:  DATA 6F,6E
004DA:  DATA 66,69
004DC:  DATA 67,20
004DE:  DATA 41,50
004E0:  DATA 00,00
004E2:  DATA 41,54
004E4:  DATA 2B,43
004E6:  DATA 57,4D
004E8:  DATA 4F,44
004EA:  DATA 45,5F
004EC:  DATA 44,45
004EE:  DATA 46,3D
004F0:  DATA 33,0D
004F2:  DATA 0A,00
004F4:  DATA 0C,43
004F6:  DATA 6F,6E
004F8:  DATA 66,69
004FA:  DATA 67,20
004FC:  DATA 43,6C
004FE:  DATA 69,65
00500:  DATA 6E,74
00502:  DATA 65,41
00504:  DATA 50,00
*
006F8:  ADDWF  FE8,W
006FA:  CLRF   FF7
006FC:  RLCF   FF7,F
006FE:  ADDLW  13
00700:  MOVWF  FF6
00702:  MOVLW  07
00704:  ADDWFC FF7,F
00706:  TBLRD*-
00708:  MOVF   FF5,W
0070A:  MOVWF  FFA
0070C:  TBLRD*
0070E:  MOVF   FF5,W
00710:  MOVWF  FF9
00712:  DATA 1C,05
00714:  DATA 74,05
00716:  DATA 4A,05
00718:  DATA 9E,05
0071A:  DATA C8,05
*
007C8:  ADDWF  FE8,W
007CA:  CLRF   FF7
007CC:  RLCF   FF7,F
007CE:  ADDLW  E3
007D0:  MOVWF  FF6
007D2:  MOVLW  07
007D4:  ADDWFC FF7,F
007D6:  TBLRD*-
007D8:  MOVF   FF5,W
007DA:  MOVWF  FFA
007DC:  TBLRD*
007DE:  MOVF   FF5,W
007E0:  MOVWF  FF9
007E2:  DATA BC,07
007E4:  DATA BC,07
007E6:  DATA BC,07
007E8:  DATA BC,07
007EA:  DATA BC,07
*
00862:  ADDWF  FE8,W
00864:  CLRF   FF7
00866:  RLCF   FF7,F
00868:  ADDLW  7D
0086A:  MOVWF  FF6
0086C:  MOVLW  08
0086E:  ADDWFC FF7,F
00870:  TBLRD*-
00872:  MOVF   FF5,W
00874:  MOVWF  FFA
00876:  TBLRD*
00878:  MOVF   FF5,W
0087A:  MOVWF  FF9
0087C:  DATA 56,08
0087E:  DATA 56,08
00880:  DATA 56,08
00882:  DATA 56,08
*
00AE6:  DATA 0C,43
00AE8:  DATA 6F,6E
00AEA:  DATA 66,69
00AEC:  DATA 67,75
00AEE:  DATA 72,61
00AF0:  DATA 6E,64
00AF2:  DATA 6F,2E
00AF4:  DATA 2E,2E
00AF6:  DATA 00,00
*
00E24:  TBLRD*+
00E26:  MOVF   FF5,F
00E28:  BZ    0E42
00E2A:  MOVFF  FF6,16E
00E2E:  MOVFF  FF7,16F
00E32:  MOVFF  FF5,170
00E36:  RCALL  0DB8
00E38:  MOVFF  16E,FF6
00E3C:  MOVFF  16F,FF7
00E40:  BRA    0E24
00E42:  RETURN 0
00E44:  TBLRD*+
00E46:  MOVFF  FF6,1B0
00E4A:  MOVFF  FF7,1B1
00E4E:  MOVF   FF5,W
00E50:  BTFSS  F9E.4
00E52:  BRA    0E50
00E54:  MOVWF  FAD
00E56:  MOVFF  1B0,FF6
00E5A:  MOVFF  1B1,FF7
00E5E:  MOVLB  1
00E60:  DECFSZ xAF,F
00E62:  BRA    0E66
00E64:  BRA    0E6A
00E66:  MOVLB  0
00E68:  BRA    0E44
00E6A:  MOVLB  0
00E6C:  RETURN 0
00E6E:  TBLRD*+
00E70:  MOVF   FF5,F
00E72:  BZ    0E8E
00E74:  MOVFF  FF6,1AF
00E78:  MOVFF  FF7,1B0
00E7C:  MOVF   FF5,W
00E7E:  BTFSS  F9E.4
00E80:  BRA    0E7E
00E82:  MOVWF  FAD
00E84:  MOVFF  1AF,FF6
00E88:  MOVFF  1B0,FF7
00E8C:  BRA    0E6E
00E8E:  RETURN 0
*
00F80:  MOVF   FEF,F
00F82:  BZ    0FA4
00F84:  MOVFF  FEA,1B0
00F88:  MOVFF  FE9,1AF
00F8C:  MOVF   FEF,W
00F8E:  BTFSS  F9E.4
00F90:  BRA    0F8E
00F92:  MOVWF  FAD
00F94:  MOVFF  1B0,FEA
00F98:  MOVFF  1AF,FE9
00F9C:  INCF   FE9,F
00F9E:  BTFSC  FD8.2
00FA0:  INCF   FEA,F
00FA2:  BRA    0F80
00FA4:  RETURN 0
*
011BA:  MOVLB  1
011BC:  MOVF   xB1,W
011BE:  ANDLW  07
011C0:  MOVWF  00
011C2:  RRCF   xB1,W
011C4:  MOVWF  01
011C6:  RRCF   01,F
011C8:  RRCF   01,F
011CA:  MOVLW  1F
011CC:  ANDWF  01,F
011CE:  MOVF   01,W
011D0:  ADDWF  xB3,W
011D2:  MOVWF  FE9
011D4:  MOVLW  00
011D6:  ADDWFC xB4,W
011D8:  MOVWF  FEA
011DA:  CLRF   01
011DC:  INCF   01,F
011DE:  INCF   00,F
011E0:  BRA    11E4
011E2:  RLCF   01,F
011E4:  DECFSZ 00,F
011E6:  BRA    11E2
011E8:  MOVF   xB2,F
011EA:  BZ    11F2
011EC:  MOVF   01,W
011EE:  IORWF  FEF,F
011F0:  BRA    11F8
011F2:  COMF   01,F
011F4:  MOVF   01,W
011F6:  ANDWF  FEF,F
011F8:  MOVLB  0
011FA:  RETURN 0
011FC:  MOVLB  1
011FE:  MOVF   xB2,W
01200:  CLRF   01
01202:  SUBWF  xB1,W
01204:  BC    120C
01206:  MOVFF  1B1,00
0120A:  BRA    1224
0120C:  CLRF   00
0120E:  MOVLW  08
01210:  MOVWF  xB3
01212:  RLCF   xB1,F
01214:  RLCF   00,F
01216:  MOVF   xB2,W
01218:  SUBWF  00,W
0121A:  BTFSC  FD8.0
0121C:  MOVWF  00
0121E:  RLCF   01,F
01220:  DECFSZ xB3,F
01222:  BRA    1212
01224:  MOVLB  0
01226:  RETURN 0
01228:  MOVF   01,W
0122A:  MOVFF  1AF,1B1
0122E:  MOVLW  64
01230:  MOVLB  1
01232:  MOVWF  xB2
01234:  MOVLB  0
01236:  RCALL  11FC
01238:  MOVFF  00,1AF
0123C:  MOVF   01,W
0123E:  MOVLW  30
01240:  BNZ   1252
01242:  MOVLB  1
01244:  BTFSS  xB0.1
01246:  BRA    1264
01248:  BTFSC  xB0.3
0124A:  BRA    1264
0124C:  BTFSC  xB0.4
0124E:  MOVLW  20
01250:  BRA    125A
01252:  MOVLB  1
01254:  BCF    xB0.3
01256:  BCF    xB0.4
01258:  BSF    xB0.0
0125A:  ADDWF  01,F
0125C:  MOVF   01,W
0125E:  BTFSS  F9E.4
01260:  BRA    125E
01262:  MOVWF  FAD
01264:  MOVFF  1AF,1B1
01268:  MOVLW  0A
0126A:  MOVWF  xB2
0126C:  MOVLB  0
0126E:  RCALL  11FC
01270:  MOVFF  00,1AF
01274:  MOVF   01,W
01276:  MOVLW  30
01278:  BNZ   128A
0127A:  MOVLB  1
0127C:  BTFSC  xB0.3
0127E:  BRA    1296
01280:  BTFSS  xB0.0
01282:  BRA    1296
01284:  BTFSC  xB0.4
01286:  MOVLW  20
01288:  MOVLB  0
0128A:  ADDWF  01,F
0128C:  MOVF   01,W
0128E:  BTFSS  F9E.4
01290:  BRA    128E
01292:  MOVWF  FAD
01294:  MOVLB  1
01296:  MOVLW  30
01298:  ADDWF  xAF,F
0129A:  MOVF   xAF,W
0129C:  BTFSS  F9E.4
0129E:  BRA    129C
012A0:  MOVWF  FAD
012A2:  MOVLB  0
012A4:  RETURN 0
*
01ACC:  BTFSC  FD8.1
01ACE:  BRA    1AD8
01AD0:  MOVLW  01
01AD2:  MOVWF  FEA
01AD4:  MOVLW  83
01AD6:  MOVWF  FE9
01AD8:  CLRF   00
01ADA:  CLRF   01
01ADC:  CLRF   02
01ADE:  CLRF   03
01AE0:  MOVLB  1
01AE2:  CLRF   x83
01AE4:  CLRF   x84
01AE6:  CLRF   x85
01AE8:  CLRF   x86
01AEA:  MOVF   x82,W
01AEC:  IORWF  x81,W
01AEE:  IORWF  x80,W
01AF0:  IORWF  x7F,W
01AF2:  BZ    1B4C
01AF4:  MOVLW  20
01AF6:  MOVWF  x87
01AF8:  BCF    FD8.0
01AFA:  RLCF   x7B,F
01AFC:  RLCF   x7C,F
01AFE:  RLCF   x7D,F
01B00:  RLCF   x7E,F
01B02:  RLCF   x83,F
01B04:  RLCF   x84,F
01B06:  RLCF   x85,F
01B08:  RLCF   x86,F
01B0A:  MOVF   x82,W
01B0C:  SUBWF  x86,W
01B0E:  BNZ   1B20
01B10:  MOVF   x81,W
01B12:  SUBWF  x85,W
01B14:  BNZ   1B20
01B16:  MOVF   x80,W
01B18:  SUBWF  x84,W
01B1A:  BNZ   1B20
01B1C:  MOVF   x7F,W
01B1E:  SUBWF  x83,W
01B20:  BNC   1B40
01B22:  MOVF   x7F,W
01B24:  SUBWF  x83,F
01B26:  MOVF   x80,W
01B28:  BTFSS  FD8.0
01B2A:  INCFSZ x80,W
01B2C:  SUBWF  x84,F
01B2E:  MOVF   x81,W
01B30:  BTFSS  FD8.0
01B32:  INCFSZ x81,W
01B34:  SUBWF  x85,F
01B36:  MOVF   x82,W
01B38:  BTFSS  FD8.0
01B3A:  INCFSZ x82,W
01B3C:  SUBWF  x86,F
01B3E:  BSF    FD8.0
01B40:  RLCF   00,F
01B42:  RLCF   01,F
01B44:  RLCF   02,F
01B46:  RLCF   03,F
01B48:  DECFSZ x87,F
01B4A:  BRA    1AF8
01B4C:  MOVFF  183,FEF
01B50:  MOVFF  184,FEC
01B54:  MOVFF  185,FEC
01B58:  MOVFF  186,FEC
01B5C:  MOVLB  0
01B5E:  GOTO   1C36 (RETURN)
01B62:  MOVLB  1
01B64:  CLRF   x83
01B66:  CLRF   x84
01B68:  MOVLW  01
01B6A:  MOVWF  x85
01B6C:  CLRF   FDA
01B6E:  CLRF   FD9
01B70:  MOVWF  x88
01B72:  MOVLW  7B
01B74:  MOVWF  x87
01B76:  MOVLW  01
01B78:  MOVWF  FEA
01B7A:  MOVLW  7F
01B7C:  MOVWF  FE9
01B7E:  MOVFF  188,FE2
01B82:  MOVFF  187,FE1
01B86:  MOVFF  185,186
01B8A:  BCF    FD8.0
01B8C:  MOVF   FE5,W
01B8E:  MULWF  FEE
01B90:  MOVF   FF3,W
01B92:  ADDWFC x83,F
01B94:  MOVF   FF4,W
01B96:  ADDWFC x84,F
01B98:  DECFSZ x86,F
01B9A:  BRA    1B8A
01B9C:  MOVFF  183,FDE
01BA0:  MOVFF  184,183
01BA4:  CLRF   x84
01BA6:  BTFSC  FD8.0
01BA8:  INCF   x84,F
01BAA:  INCF   x87,F
01BAC:  BTFSC  FD8.2
01BAE:  INCF   x88,F
01BB0:  INCF   x85,F
01BB2:  MOVF   x85,W
01BB4:  SUBLW  05
01BB6:  BNZ   1B76
01BB8:  MOVLB  0
01BBA:  GOTO   1C66 (RETURN)
*
01E18:  TBLRD*+
01E1A:  MOVFF  FF6,16D
01E1E:  MOVFF  FF7,16E
01E22:  MOVFF  FF5,170
01E26:  CALL   0DB8
01E2A:  MOVFF  16D,FF6
01E2E:  MOVFF  16E,FF7
01E32:  MOVLB  1
01E34:  DECFSZ x6C,F
01E36:  BRA    1E3A
01E38:  BRA    1E3E
01E3A:  MOVLB  0
01E3C:  BRA    1E18
01E3E:  MOVLB  0
01E40:  RETURN 0
01E42:  MOVF   FEF,F
01E44:  BZ    1E66
01E46:  MOVFF  FEA,16D
01E4A:  MOVFF  FE9,16C
01E4E:  MOVFF  FEF,170
01E52:  CALL   0DB8
01E56:  MOVFF  16D,FEA
01E5A:  MOVFF  16C,FE9
01E5E:  INCF   FE9,F
01E60:  BTFSC  FD8.2
01E62:  INCF   FEA,F
01E64:  BRA    1E42
01E66:  RETURN 0
*
0252E:  MOVFF  FF2,0D
02532:  BCF    FF2.7
02534:  ADDWF  FE8,W
02536:  CLRF   FF7
02538:  RLCF   FF7,F
0253A:  ADDLW  53
0253C:  MOVWF  FF6
0253E:  MOVLW  25
02540:  ADDWFC FF7,F
02542:  TBLRD*-
02544:  MOVF   FF5,W
02546:  MOVWF  FFA
02548:  TBLRD*
0254A:  MOVF   FF5,W
0254C:  BTFSC  0D.7
0254E:  BSF    FF2.7
02550:  MOVWF  FF9
02552:  DATA C6,23
02554:  DATA 00,24
02556:  DATA 4E,24
02558:  DATA 9C,24
0255A:  DATA 8C,23
0255C:  DATA EA,24
0255E:  DATA F0,24
02560:  DATA 16,25
*
027EE:  MOVFF  FF2,0D
027F2:  BCF    FF2.7
027F4:  ADDWF  FE8,W
027F6:  CLRF   FF7
027F8:  RLCF   FF7,F
027FA:  ADDLW  13
027FC:  MOVWF  FF6
027FE:  MOVLW  28
02800:  ADDWFC FF7,F
02802:  TBLRD*-
02804:  MOVF   FF5,W
02806:  MOVWF  FFA
02808:  TBLRD*
0280A:  MOVF   FF5,W
0280C:  BTFSC  0D.7
0280E:  BSF    FF2.7
02810:  MOVWF  FF9
02812:  DATA BA,27
02814:  DATA C6,27
02816:  DATA D2,27
02818:  DATA DE,27
....................  
.................... #list 
....................  
....................  
.................... #FUSES XT,BROWNOUT 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
....................  
.................... #use delay(crystal=20M) 
*
00AF8:  MOVLW  01
00AFA:  MOVWF  FEA
00AFC:  MOVLW  B0
00AFE:  MOVWF  FE9
00B00:  MOVF   FEF,W
00B02:  BZ    0B1E
00B04:  MOVLW  06
00B06:  MOVWF  01
00B08:  CLRF   00
00B0A:  DECFSZ 00,F
00B0C:  BRA    0B0A
00B0E:  DECFSZ 01,F
00B10:  BRA    0B08
00B12:  MOVLW  7B
00B14:  MOVWF  00
00B16:  DECFSZ 00,F
00B18:  BRA    0B16
00B1A:  DECFSZ FEF,F
00B1C:  BRA    0B04
00B1E:  RETURN 0
*
01BBE:  MOVLW  03
01BC0:  MOVLB  1
01BC2:  SUBWF  x7C,F
01BC4:  BNC   1BDA
01BC6:  MOVLW  01
01BC8:  MOVWF  FEA
01BCA:  MOVLW  7C
01BCC:  MOVWF  FE9
01BCE:  MOVF   FEF,W
01BD0:  BZ    1BDA
01BD2:  BRA    1BD6
01BD4:  BRA    1BD6
01BD6:  DECFSZ FEF,F
01BD8:  BRA    1BD4
01BDA:  MOVLB  0
01BDC:  RETURN 0
.................... /* RS232 */ 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=ESP8266) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_B0,rcv=PIN_B1,bits=8,stream=console) 
....................  
.................... // Puertos de salida 
.................... #use FIXED_IO( A_outputs=PIN_A0,PIN_A1,PIN_A2,PIN_A3,PIN_A4) 
.................... #use FIXED_IO( E_outputs=PIN_E0,PIN_E1,PIN_E2) 
....................  
.................... #define PIN_OUT_1       PIN_E2 
.................... #define PIN_OUT_2       PIN_E1 
.................... #define PIN_OUT_3       PIN_E0 
.................... #define PIN_OUT_4       PIN_A4 
.................... #define PIN_OUT_5       PIN_A0 
.................... #define PIN_OUT_6       PIN_A1 
.................... #define PIN_OUT_7       PIN_A2 
.................... #define PIN_OUT_8       PIN_A3 
....................  
.................... #define KEY_NEXT        PIN_B4 
.................... #define KEY_OK          PIN_B5 
....................  
.................... const int16 PIN_OUT[8]={ 
....................                         PIN_E2, 
....................                         PIN_E1, 
....................                         PIN_E0, 
....................                         PIN_A4, 
....................                         PIN_A0, 
....................                         PIN_A1, 
....................                         PIN_A2, 
....................                         PIN_A3 
....................                         }; 
....................  
.................... /* LCD 2x16 */ 
.................... #define LCD_LIGHT_PIN   PIN_D3 
.................... #define LCD_RS_PIN      PIN_D2 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D0 
.................... #define LCD_DATA4       PIN_D4 
.................... #define LCD_DATA5       PIN_D5 
.................... #define LCD_DATA6       PIN_D6 
.................... #define LCD_DATA7       PIN_D7   
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00C52:  BSF    F95.4
....................    output_float(LCD_DATA5); 
00C54:  BSF    F95.5
....................    output_float(LCD_DATA6); 
00C56:  BSF    F95.6
....................    output_float(LCD_DATA7); 
00C58:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00C5A:  BSF    F8C.1
00C5C:  BCF    F95.1
....................    delay_cycles(1); 
00C5E:  NOP   
....................    lcd_output_enable(1); 
00C60:  BSF    F8C.0
00C62:  BCF    F95.0
....................    delay_cycles(1); 
00C64:  NOP   
....................    high = lcd_read_nibble(); 
00C66:  RCALL  0BFC
00C68:  MOVFF  01,178
....................        
....................    lcd_output_enable(0); 
00C6C:  BCF    F8C.0
00C6E:  BCF    F95.0
....................    delay_cycles(1); 
00C70:  NOP   
....................    lcd_output_enable(1); 
00C72:  BSF    F8C.0
00C74:  BCF    F95.0
....................    delay_us(1); 
00C76:  BRA    0C78
00C78:  BRA    0C7A
00C7A:  NOP   
....................    low = lcd_read_nibble(); 
00C7C:  RCALL  0BFC
00C7E:  MOVFF  01,177
....................        
....................    lcd_output_enable(0); 
00C82:  BCF    F8C.0
00C84:  BCF    F95.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00C86:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00C88:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00C8A:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00C8C:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00C8E:  MOVLB  1
00C90:  SWAPF  x78,W
00C92:  MOVWF  00
00C94:  MOVLW  F0
00C96:  ANDWF  00,F
00C98:  MOVF   00,W
00C9A:  IORWF  x77,W
00C9C:  MOVWF  01
00C9E:  MOVLB  0
00CA0:  GOTO   0CB0 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00BFC:  MOVLB  1
00BFE:  CLRF   x79
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00C00:  BSF    F95.4
00C02:  MOVLW  00
00C04:  BTFSC  F83.4
00C06:  MOVLW  01
00C08:  IORWF  x79,F
....................    n |= input(LCD_DATA5) << 1; 
00C0A:  BSF    F95.5
00C0C:  MOVLW  00
00C0E:  BTFSC  F83.5
00C10:  MOVLW  01
00C12:  MOVWF  00
00C14:  BCF    FD8.0
00C16:  RLCF   00,F
00C18:  MOVF   00,W
00C1A:  IORWF  x79,F
....................    n |= input(LCD_DATA6) << 2; 
00C1C:  BSF    F95.6
00C1E:  MOVLW  00
00C20:  BTFSC  F83.6
00C22:  MOVLW  01
00C24:  MOVWF  00
00C26:  RLCF   00,F
00C28:  RLCF   00,F
00C2A:  MOVLW  FC
00C2C:  ANDWF  00,F
00C2E:  MOVF   00,W
00C30:  IORWF  x79,F
....................    n |= input(LCD_DATA7) << 3; 
00C32:  BSF    F95.7
00C34:  MOVLW  00
00C36:  BTFSC  F83.7
00C38:  MOVLW  01
00C3A:  MOVWF  00
00C3C:  RLCF   00,F
00C3E:  RLCF   00,F
00C40:  RLCF   00,F
00C42:  MOVLW  F8
00C44:  ANDWF  00,F
00C46:  MOVF   00,W
00C48:  IORWF  x79,F
....................     
....................    return(n); 
00C4A:  MOVFF  179,01
....................   #else 
00C4E:  MOVLB  0
00C50:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00BB0:  MOVLB  1
00BB2:  BTFSC  x78.0
00BB4:  BRA    0BBA
00BB6:  BCF    F8C.4
00BB8:  BRA    0BBC
00BBA:  BSF    F8C.4
00BBC:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00BBE:  BTFSC  x78.1
00BC0:  BRA    0BC6
00BC2:  BCF    F8C.5
00BC4:  BRA    0BC8
00BC6:  BSF    F8C.5
00BC8:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00BCA:  BTFSC  x78.2
00BCC:  BRA    0BD2
00BCE:  BCF    F8C.6
00BD0:  BRA    0BD4
00BD2:  BSF    F8C.6
00BD4:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00BD6:  BTFSC  x78.3
00BD8:  BRA    0BDE
00BDA:  BCF    F8C.7
00BDC:  BRA    0BE0
00BDE:  BSF    F8C.7
00BE0:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00BE2:  NOP   
....................    lcd_output_enable(1); 
00BE4:  BSF    F8C.0
00BE6:  BCF    F95.0
....................    delay_us(2); 
00BE8:  MOVLW  02
00BEA:  MOVWF  00
00BEC:  DECFSZ 00,F
00BEE:  BRA    0BEC
00BF0:  BRA    0BF2
00BF2:  NOP   
....................    lcd_output_enable(0); 
00BF4:  BCF    F8C.0
00BF6:  BCF    F95.0
00BF8:  MOVLB  0
00BFA:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00CA4:  BCF    F95.0
....................    lcd_rs_tris(); 
00CA6:  BCF    F95.2
....................    lcd_rw_tris(); 
00CA8:  BCF    F95.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00CAA:  BCF    F8C.2
00CAC:  BCF    F95.2
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
00CAE:  BRA    0C52
00CB0:  MOVFF  01,177
00CB4:  MOVLB  1
00CB6:  BTFSS  01.7
00CB8:  BRA    0CBE
00CBA:  MOVLB  0
00CBC:  BRA    0CAE
....................    lcd_output_rs(address); 
00CBE:  MOVF   x75,F
00CC0:  BNZ   0CC6
00CC2:  BCF    F8C.2
00CC4:  BRA    0CC8
00CC6:  BSF    F8C.2
00CC8:  BCF    F95.2
....................    delay_cycles(1); 
00CCA:  NOP   
....................    lcd_output_rw(0); 
00CCC:  BCF    F8C.1
00CCE:  BCF    F95.1
....................    delay_cycles(1); 
00CD0:  NOP   
....................    lcd_output_enable(0); 
00CD2:  BCF    F8C.0
00CD4:  BCF    F95.0
....................    lcd_send_nibble(n >> 4); 
00CD6:  SWAPF  x76,W
00CD8:  MOVWF  x77
00CDA:  MOVLW  0F
00CDC:  ANDWF  x77,F
00CDE:  MOVFF  177,178
00CE2:  MOVLB  0
00CE4:  RCALL  0BB0
....................    lcd_send_nibble(n & 0xf); 
00CE6:  MOVLB  1
00CE8:  MOVF   x76,W
00CEA:  ANDLW  0F
00CEC:  MOVWF  x77
00CEE:  MOVWF  x78
00CF0:  MOVLB  0
00CF2:  RCALL  0BB0
00CF4:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
00CF6:  MOVLW  28
00CF8:  MOVLB  1
00CFA:  MOVWF  x69
00CFC:  MOVLW  0C
00CFE:  MOVWF  x6A
00D00:  MOVLW  01
00D02:  MOVWF  x6B
00D04:  MOVLW  06
00D06:  MOVWF  x6C
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
00D08:  BCF    F8C.0
00D0A:  BCF    F95.0
....................    lcd_output_rs(0); 
00D0C:  BCF    F8C.2
00D0E:  BCF    F95.2
....................    lcd_output_rw(0); 
00D10:  BCF    F8C.1
00D12:  BCF    F95.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00D14:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
00D16:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
00D18:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
00D1A:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
00D1C:  BCF    F95.0
....................    lcd_rs_tris(); 
00D1E:  BCF    F95.2
....................    lcd_rw_tris(); 
00D20:  BCF    F95.1
....................  #endif 
....................      
....................    delay_ms(15); 
00D22:  MOVLW  0F
00D24:  MOVWF  xB0
00D26:  MOVLB  0
00D28:  RCALL  0AF8
....................    for(i=1;i<=3;++i) 
00D2A:  MOVLW  01
00D2C:  MOVLB  1
00D2E:  MOVWF  x68
00D30:  MOVF   x68,W
00D32:  SUBLW  03
00D34:  BNC   0D4E
....................    { 
....................        lcd_send_nibble(3); 
00D36:  MOVLW  03
00D38:  MOVWF  x78
00D3A:  MOVLB  0
00D3C:  RCALL  0BB0
....................        delay_ms(5); 
00D3E:  MOVLW  05
00D40:  MOVLB  1
00D42:  MOVWF  xB0
00D44:  MOVLB  0
00D46:  RCALL  0AF8
00D48:  MOVLB  1
00D4A:  INCF   x68,F
00D4C:  BRA    0D30
....................    } 
....................     
....................    lcd_send_nibble(2); 
00D4E:  MOVLW  02
00D50:  MOVWF  x78
00D52:  MOVLB  0
00D54:  RCALL  0BB0
....................    delay_ms(5); 
00D56:  MOVLW  05
00D58:  MOVLB  1
00D5A:  MOVWF  xB0
00D5C:  MOVLB  0
00D5E:  RCALL  0AF8
....................    for(i=0;i<=3;++i) 
00D60:  MOVLB  1
00D62:  CLRF   x68
00D64:  MOVF   x68,W
00D66:  SUBLW  03
00D68:  BNC   0D8C
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00D6A:  CLRF   03
00D6C:  MOVF   x68,W
00D6E:  ADDLW  69
00D70:  MOVWF  FE9
00D72:  MOVLW  01
00D74:  ADDWFC 03,W
00D76:  MOVWF  FEA
00D78:  MOVFF  FEF,16D
00D7C:  CLRF   x75
00D7E:  MOVFF  16D,176
00D82:  MOVLB  0
00D84:  RCALL  0CA4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00D86:  MOVLB  1
00D88:  INCF   x68,F
00D8A:  BRA    0D64
00D8C:  MOVLB  0
00D8E:  GOTO   2796 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
00D92:  MOVLB  1
00D94:  DECFSZ x72,W
00D96:  BRA    0D9A
00D98:  BRA    0DA0
....................       address=LCD_LINE_TWO; 
00D9A:  MOVLW  40
00D9C:  MOVWF  x73
00D9E:  BRA    0DA2
....................    else 
....................       address=0; 
00DA0:  CLRF   x73
....................       
....................    address+=x-1; 
00DA2:  MOVLW  01
00DA4:  SUBWF  x71,W
00DA6:  ADDWF  x73,F
....................    lcd_send_byte(0,0x80|address); 
00DA8:  MOVF   x73,W
00DAA:  IORLW  80
00DAC:  MOVWF  x74
00DAE:  CLRF   x75
00DB0:  MOVWF  x76
00DB2:  MOVLB  0
00DB4:  RCALL  0CA4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00DB6:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00DB8:  MOVLB  1
00DBA:  MOVF   x70,W
00DBC:  XORLW  07
00DBE:  MOVLB  0
00DC0:  BZ    0DD0
00DC2:  XORLW  0B
00DC4:  BZ    0DDE
00DC6:  XORLW  06
00DC8:  BZ    0DF6
00DCA:  XORLW  02
00DCC:  BZ    0E06
00DCE:  BRA    0E14
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00DD0:  MOVLW  01
00DD2:  MOVLB  1
00DD4:  MOVWF  x71
00DD6:  MOVWF  x72
00DD8:  MOVLB  0
00DDA:  RCALL  0D92
00DDC:  BRA    0E22
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
00DDE:  MOVLB  1
00DE0:  CLRF   x75
00DE2:  MOVLW  01
00DE4:  MOVWF  x76
00DE6:  MOVLB  0
00DE8:  RCALL  0CA4
....................                      delay_ms(2); 
00DEA:  MOVLW  02
00DEC:  MOVLB  1
00DEE:  MOVWF  xB0
00DF0:  MOVLB  0
00DF2:  RCALL  0AF8
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
00DF4:  BRA    0E22
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
00DF6:  MOVLW  01
00DF8:  MOVLB  1
00DFA:  MOVWF  x71
00DFC:  MOVLW  02
00DFE:  MOVWF  x72
00E00:  MOVLB  0
00E02:  RCALL  0D92
00E04:  BRA    0E22
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
00E06:  MOVLB  1
00E08:  CLRF   x75
00E0A:  MOVLW  10
00E0C:  MOVWF  x76
00E0E:  MOVLB  0
00E10:  RCALL  0CA4
00E12:  BRA    0E22
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
00E14:  MOVLW  01
00E16:  MOVLB  1
00E18:  MOVWF  x75
00E1A:  MOVFF  170,176
00E1E:  MOVLB  0
00E20:  RCALL  0CA4
....................      #endif 
....................    } 
00E22:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "header/sound.h" 
.................... #define Speaker   PIN_B2      // Altavoz conectado a RB0 
.................... void Sound(int16 frecuencia, int16 duracion){ 
*
01BDE:  MOVLB  1
01BE0:  CLRF   x72
01BE2:  CLRF   x71
01BE4:  CLRF   x74
01BE6:  CLRF   x73
....................     
....................    int16 mS_Transcurridos=0; 
....................    int16 CiclosL=0; 
....................    int16 uS; 
....................    int32 tmp; 
....................    /**  
....................       si la frecuancia se encuentra entre los margenes de 20Hz y 20 KHz se ejecuta 
....................       de los contrario no. 
....................    **/ 
....................    if (frecuencia>=20&&frecuencia<=20000){  
01BE8:  MOVF   x6E,F
01BEA:  BNZ   1BF4
01BEC:  MOVF   x6D,W
01BEE:  SUBLW  13
01BF0:  BTFSC  FD8.0
01BF2:  BRA    1D22
01BF4:  MOVF   x6E,W
01BF6:  SUBLW  4E
01BF8:  BTFSS  FD8.0
01BFA:  BRA    1D22
01BFC:  BNZ   1C06
01BFE:  MOVF   x6D,W
01C00:  SUBLW  20
01C02:  BTFSS  FD8.0
01C04:  BRA    1D22
....................       tmp=100000; 
01C06:  CLRF   x7A
01C08:  MOVLW  01
01C0A:  MOVWF  x79
01C0C:  MOVLW  86
01C0E:  MOVWF  x78
01C10:  MOVLW  A0
01C12:  MOVWF  x77
....................       tmp/=frecuencia;       // convierte los Hz a microsegundos para la pausa 
01C14:  BCF    FD8.1
01C16:  MOVFF  17A,17E
01C1A:  MOVFF  179,17D
01C1E:  MOVFF  178,17C
01C22:  MOVFF  177,17B
01C26:  CLRF   x82
01C28:  CLRF   x81
01C2A:  MOVFF  16E,180
01C2E:  MOVFF  16D,17F
01C32:  MOVLB  0
01C34:  BRA    1ACC
01C36:  MOVFF  03,17A
01C3A:  MOVFF  02,179
01C3E:  MOVFF  01,178
01C42:  MOVFF  00,177
....................       tmp*=5;    
01C46:  MOVFF  17A,17E
01C4A:  MOVFF  179,17D
01C4E:  MOVFF  178,17C
01C52:  MOVFF  177,17B
01C56:  MOVLB  1
01C58:  CLRF   x82
01C5A:  CLRF   x81
01C5C:  CLRF   x80
01C5E:  MOVLW  05
01C60:  MOVWF  x7F
01C62:  MOVLB  0
01C64:  BRA    1B62
01C66:  MOVFF  03,17A
01C6A:  MOVFF  02,179
01C6E:  MOVFF  01,178
01C72:  MOVFF  00,177
....................       uS=tmp; 
01C76:  MOVFF  178,176
01C7A:  MOVFF  177,175
....................       do{ 
....................          output_high(PIN_B2);   // Genera la frecuancia deseada 
01C7E:  BCF    F93.2
01C80:  BSF    F8A.2
....................          delay_us(uS);           // con los retardos mientras 
01C82:  MOVFF  176,17B
01C86:  MOVLB  1
01C88:  INCF   x7B,F
01C8A:  DECF   x7B,F
01C8C:  BTFSC  FD8.2
01C8E:  BRA    1C9A
01C90:  SETF   x7C
01C92:  MOVLB  0
01C94:  RCALL  1BBE
01C96:  MOVLB  1
01C98:  BRA    1C8A
01C9A:  MOVFF  175,17C
01C9E:  MOVLB  0
01CA0:  RCALL  1BBE
....................          CiclosL+=(uS);          // aumenta el contador de ciclos transcurridos 
01CA2:  MOVLB  1
01CA4:  MOVF   x75,W
01CA6:  ADDWF  x73,F
01CA8:  MOVF   x76,W
01CAA:  ADDWFC x74,F
....................          output_low(PIN_B2);    // en dos partes para repartir el  
01CAC:  BCF    F93.2
01CAE:  BCF    F8A.2
....................          delay_us(uS);           // trabajo entre estado alto y bajo. 
01CB0:  MOVFF  176,17B
01CB4:  INCF   x7B,F
01CB6:  DECF   x7B,F
01CB8:  BTFSC  FD8.2
01CBA:  BRA    1CC6
01CBC:  SETF   x7C
01CBE:  MOVLB  0
01CC0:  RCALL  1BBE
01CC2:  MOVLB  1
01CC4:  BRA    1CB6
01CC6:  MOVFF  175,17C
01CCA:  MOVLB  0
01CCC:  RCALL  1BBE
....................          CiclosL+=(uS);          //  
01CCE:  MOVLB  1
01CD0:  MOVF   x75,W
01CD2:  ADDWF  x73,F
01CD4:  MOVF   x76,W
01CD6:  ADDWFC x74,F
....................          CiclosL+=25;            // Compensador. 
01CD8:  MOVLW  19
01CDA:  ADDWF  x73,F
01CDC:  MOVLW  00
01CDE:  ADDWFC x74,F
....................           
....................          while(CiclosL>999){     // Se queda en el bucle mientras CiclosL sea 
01CE0:  MOVF   x74,W
01CE2:  SUBLW  02
01CE4:  BC    1D08
01CE6:  XORLW  FF
01CE8:  BNZ   1CF0
01CEA:  MOVF   x73,W
01CEC:  SUBLW  E7
01CEE:  BC    1D08
....................                                  // menor a 1000 (1 mS) 
....................             CiclosL-=1000;       // Le resta 1000 a CiclosL  
01CF0:  MOVLW  E8
01CF2:  SUBWF  x73,F
01CF4:  MOVLW  03
01CF6:  SUBWFB x74,F
....................             mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
01CF8:  INCF   x71,F
01CFA:  BTFSC  FD8.2
01CFC:  INCF   x72,F
....................             CiclosL+=25;         // Compensador. 
01CFE:  MOVLW  19
01D00:  ADDWF  x73,F
01D02:  MOVLW  00
01D04:  ADDWFC x74,F
01D06:  BRA    1CE0
....................          } 
....................       }while (duracion>mS_Transcurridos);// Repite el bucle hasta que haya pasado el 
01D08:  MOVF   x72,W
01D0A:  SUBWF  x70,W
01D0C:  BNC   1D22
01D0E:  BTFSC  FD8.2
01D10:  BRA    1D16
01D12:  MOVLB  0
01D14:  BRA    1C7E
01D16:  MOVF   x6F,W
01D18:  SUBWF  x71,W
01D1A:  BTFSC  FD8.0
01D1C:  BRA    1D22
01D1E:  MOVLB  0
01D20:  BRA    1C7E
....................                                          // tiempo indicado. 
....................    } 
01D22:  MOVLB  0
01D24:  RETURN 0
.................... } 
....................  
.................... /* 
.................... #define nDO     0    // DO 
.................... #define nDO_    1    // DO# 
.................... #define nRE     2    // RE 
.................... #define nRE_    3    // RE# 
.................... #define nMI     4    // MI 
.................... #define nFA     5    // FA 
.................... #define nFA_    6    // FA# 
.................... #define nSOL    7    // SOL 
.................... #define nSOL_   8    // SOL# 
.................... #define nLA     9    // LA 
.................... #define nLA_    10   // LA# 
.................... #define nSI     11   // SI 
....................  
.................... int16 FreqNota[12]={  // retardos entre estado alto 
....................                       // y bajo para generar las notas 
.................... 15289, // DO 
.................... 14430, // DO# 
.................... 13620, // RE 
.................... 12856, // RE# 
.................... 12134, // MI 
.................... 11453, // FA 
.................... 10810, // FA# 
.................... 10204, // SOL 
.................... 9631,  // SOL# 
.................... 9090,  // LA 
.................... 8580,  // LA# 
.................... 8099   // SI 
.................... }; 
....................  
.................... void Play(int nota, int octava, int16 duracion){ 
....................  int16 fn; 
....................  
....................  int16 mS_Transcurridos=0;  // Contadores necesarios 
....................                             // para controlar la duracin 
....................  int16 CiclosL=0;           // Contandor de uS 
....................  
....................  fn=FreqNota[nota];         // Define los retardos para generar 
....................                             // la frecuencia de cada nota 
....................  fn>>=(octava);             // Adapta la frecuencia a la octava actual 
....................                             // haciendo una rotacin 
....................                             // a la derecha por octava 
.................... do{ 
....................  
....................     output_high(Speaker);   // Genera la frecuancia 
....................     delay_us(fn);           // con los retardos mientras 
....................     CiclosL+=(fn);          // aumenta el contador de  
....................                             // ciclos transcurridos 
....................     output_low(Speaker);    // en dos partes para repartir el 
....................     delay_us(fn);           // trabajo entre estado alto y bajo. 
....................     CiclosL+=(fn);          // 
....................     CiclosL+=25;            // Compensador. 
....................  
....................     while(CiclosL>999){     // Se queda en el bucle mientras CiclosL 
....................                             // sea menor a 1000 (1 mS) 
....................        CiclosL-=1000;       // Le resta 1000 a CiclosL 
....................        mS_Transcurridos++;  // y le suma 1 a mS_Transcurridos. 
....................        CiclosL+=25;         // Compensador. 
....................     } 
....................  }while (duracion>mS_Transcurridos); // Repite el bucle hasta que haya 
....................                                      // pasado el tiempo indicado. 
.................... } 
.................... */ 
....................  
....................  
.................... #include "header/cmd_wifi.h" 
.................... /***************************************************************** 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... ****************************************************************** 
....................  
.................... ******************************************** 
.................... *   Formato de comando en la respuesta:    * 
.................... *   INICIO:COMANDO:DATOS:<-(FIN)           * 
.................... *   e.g. CMD:CMD_SSID_AND_PASS,DATA:       * 
.................... ******************************************** 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:OP,[op][port]:                 | 
.................... |-----------------------------------------------| 
.................... |> Realiaza Operaciones en el Puerto de Salida  | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,[1|0][0-7]:                       | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      op:    1   -> Encender                   | 
.................... |             0   -> Apagar                     | 
.................... |      port:  0-7 -> No. del puerto.            | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,10:  Enciende el PORT 0        | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NC,"SSID","KEY":               | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM desde la posicion 0x01 | 
.................... |  hasta la posicion 0x27 el SSID y Key de la   | 
.................... |  Red donde se conectara.                      | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NC,"SSID","KEY":                     | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      SSID:  "Nombre de la Red."               | 
.................... |                                               | 
.................... |      KEY:   "Clave."                          | 
.................... |                                               | 
.................... |** @e.g. CMD:NC,"myRed","12345678":            | 
.................... | Intentara conectarse y almacenar en la eeprom | 
.................... | al nombre de la red con key pasados como      | 
.................... | parametro.                                    | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:AP,"SSID","KEY":               | 
.................... |-----------------------------------------------| 
.................... |> Setea directamenete en el ESP8266 el SSID y  | 
.................... |  el Key de la Red en modo AccessPoint         | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:AP,"SSID","KEY":                     | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      SSID:  "Nombre de la Red."               | 
.................... |                                               | 
.................... |      KEY:   "Clave."                          | 
.................... |                                               | 
.................... |** @e.g. CMD:AP,"myRed","12345678":            | 
.................... | Establece en la memoria del ESP8266 el SSID   | 
.................... | de la red AP con key pasados como parametro.  | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:NM,[ModeConection]:            | 
.................... |-----------------------------------------------| 
.................... |> Almacena en la EEPROM el modo de la conexion | 
.................... |                                               | 
.................... |   @Sintax:                                    | 
.................... |      CMD:NM,[1|2|3]:                          | 
.................... |                                               | 
.................... |   @Param:                                     | 
.................... |      ModeConection:  "1" -> STA               | 
.................... |                      "2" -> AP                | 
.................... |                      "3" -> STA/AP            | 
.................... |                                               | 
.................... |** @e.g. CMD:NM,3:                             | 
.................... |                                               | 
.................... +-----------------------------------------------+ 
....................  
.................... +-----------------------------------------------+ 
.................... |      ****  CMD:OS,0:                          | 
.................... |-----------------------------------------------| 
.................... |> Retorna el estado de las salidas del Port    | 
.................... |  En una cadena separada por comas, el ultimo  | 
.................... |  valor hace referencia al modo de funcionami. | 
.................... |   @Sintax:                                    | 
.................... |      CMD:OP,0:                                | 
.................... |                                               | 
.................... |   @Param: "0" -> No usado                     | 
.................... |                                               | 
.................... |** @e.g. CMD:OP,0:                             | 
.................... |    Ret: 0,0,0,0,0,0,0,0,3                     | 
.................... +-----------------------------------------------+ 
.................... */ 
....................  
.................... /** VARIABLES DATOS GENERALES **/ 
.................... char  ID_CONNETION[2]; 
.................... char  COMMAND[2]; 
.................... char  DATA_COMMAND[50]; 
.................... int16 LEN_DATA_COMMAND     = 0; 
....................  
.................... /* Flag usadas para conocer si la respuesta del comando ejecutado esta completo */ 
.................... int flag_Resp_CMD          = 0x00; 
.................... int flag_Resp_IPD          = 0x00; 
.................... int flag_Resp_StartGetData = 0x00; 
.................... int flag_Resp_Ready        = 0x00; 
....................  
.................... /* Flag para contadores tamao de la respuesta */ 
.................... int flag_Pos_Resp_CMD   = 0x00; 
.................... int flag_Pos_Resp_IPD   = 0x00; 
.................... int flag_Pos_Resp_Data  = 0x00; 
....................  
.................... /********************************************************** 
....................    Funcion Busca la cadena de inicio recepcion de request,  
....................    y retorna el ID de la conexion 
.................... ***********************************************************/ 
.................... void ESP8266_Get_IPD(char buffer[]){ 
*
008C6:  MOVLW  05
008C8:  MOVLB  1
008CA:  MOVWF  xBB
....................     
....................    const char ESP8266_RESP_IPD[5] ={ '+','I', 'P', 'D', ','}; 
....................    int lenResp = 5; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_IPD==1){ 
008CC:  DECFSZ 55,W
008CE:  BRA    08F6
....................        
....................       if(buffer!=','){ 
008D0:  MOVF   xB9,W
008D2:  SUBLW  2C
008D4:  BNZ   08DA
008D6:  MOVF   xBA,F
008D8:  BZ    08F0
....................          ID_CONNETION[flag_Pos_Resp_IPD] = buffer; 
008DA:  CLRF   03
008DC:  MOVF   59,W
008DE:  ADDLW  1C
008E0:  MOVWF  FE9
008E2:  MOVLW  00
008E4:  ADDWFC 03,W
008E6:  MOVWF  FEA
008E8:  MOVFF  1B9,FEF
....................          flag_Pos_Resp_IPD++; 
008EC:  INCF   59,F
....................       }else{ 
008EE:  BRA    08F4
....................          flag_Pos_Resp_IPD       = 0x00; 
008F0:  CLRF   59
....................          flag_Resp_IPD           = 0x00; 
008F2:  CLRF   55
....................       } 
....................    }else{ 
008F4:  BRA    0928
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_IPD[flag_Pos_Resp_IPD]) 
008F6:  CLRF   03
008F8:  MOVF   59,W
008FA:  MOVFF  FF2,1BC
008FE:  BCF    FF2.7
00900:  MOVLB  0
00902:  CALL   00C0
00906:  MOVLB  1
00908:  BTFSC  xBC.7
0090A:  BSF    FF2.7
0090C:  MOVWF  01
0090E:  SUBWF  xB9,W
00910:  BNZ   0926
00912:  MOVF   xBA,F
00914:  BNZ   0926
....................       { 
....................          flag_Pos_Resp_IPD++; 
00916:  INCF   59,F
....................          if(flag_Pos_Resp_IPD==lenResp){ 
00918:  MOVF   xBB,W
0091A:  SUBWF  59,W
0091C:  BNZ   0924
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_IPD     = 1; 
0091E:  MOVLW  01
00920:  MOVWF  55
....................             flag_Pos_Resp_IPD = 0; 
00922:  CLRF   59
....................          } 
....................       }else{ 
00924:  BRA    0928
....................          // Reinicia el contador 
....................          flag_Pos_Resp_IPD  = 0; 
00926:  CLRF   59
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00928:  MOVLB  0
0092A:  GOTO   0AB0 (RETURN)
.................... } // Fin de la funcion ESP8266_Get_IPD() 
....................  
.................... /******************************************************** 
....................    Funcion Busca la cadena de inicio comando,  
....................    y retorna el Comando enviado, Activa la bandera 
....................    de recepcion de datos 
.................... *********************************************************/ 
....................  
.................... void ESP8266_Get_CMD(char buffer[]){ 
0092E:  MOVLW  04
00930:  MOVLB  1
00932:  MOVWF  xBB
....................     
....................    const char ESP8266_RESP_CMD[4] ={'C', 'M', 'D', ':'}; 
....................    int lenResp = 4; 
....................    
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena el siguiente caracter como identificador 
....................    // de la conxion hasta que sea leido el caracter ":" 
....................    if(flag_Resp_CMD==1){ 
00934:  DECFSZ 54,W
00936:  BRA    0962
....................     
....................       if(buffer!=','){ 
00938:  MOVF   xB9,W
0093A:  SUBLW  2C
0093C:  BNZ   0942
0093E:  MOVF   xBA,F
00940:  BZ    0958
....................          COMMAND[flag_Pos_Resp_CMD] = buffer; 
00942:  CLRF   03
00944:  MOVF   58,W
00946:  ADDLW  1E
00948:  MOVWF  FE9
0094A:  MOVLW  00
0094C:  ADDWFC 03,W
0094E:  MOVWF  FEA
00950:  MOVFF  1B9,FEF
....................          flag_Pos_Resp_CMD++; 
00954:  INCF   58,F
....................       }else{         
00956:  BRA    0960
....................          flag_Pos_Resp_CMD = 0x00; 
00958:  CLRF   58
....................          flag_Resp_CMD     = 0x00; 
0095A:  CLRF   54
....................           
....................          // Activa la recepcion de datos del comando 
....................          flag_Resp_StartGetData  = 1; 
0095C:  MOVLW  01
0095E:  MOVWF  56
....................       } 
....................        
....................    }else{ 
00960:  BRA    0994
....................       // Verifica si los datos que se estan recibiendo son 
....................       // son la secuencia recepcion de comando 
....................       if(buffer == ESP8266_RESP_CMD[flag_Pos_Resp_CMD]) 
00962:  CLRF   03
00964:  MOVF   58,W
00966:  MOVFF  FF2,1BC
0096A:  BCF    FF2.7
0096C:  MOVLB  0
0096E:  CALL   00D6
00972:  MOVLB  1
00974:  BTFSC  xBC.7
00976:  BSF    FF2.7
00978:  MOVWF  01
0097A:  SUBWF  xB9,W
0097C:  BNZ   0992
0097E:  MOVF   xBA,F
00980:  BNZ   0992
....................       { 
....................          flag_Pos_Resp_CMD++; 
00982:  INCF   58,F
....................           
....................          if(flag_Pos_Resp_CMD==lenResp){ 
00984:  MOVF   xBB,W
00986:  SUBWF  58,W
00988:  BNZ   0990
....................             // Activa la bandera de inicio recepcion de  
....................             // comando y reinicia el contador 
....................             flag_Resp_CMD     = 1; 
0098A:  MOVLW  01
0098C:  MOVWF  54
....................             flag_Pos_Resp_CMD = 0; 
0098E:  CLRF   58
....................          } 
....................       }else{ 
00990:  BRA    0994
....................          // Reinicia el contador 
....................          flag_Pos_Resp_CMD  = 0; 
00992:  CLRF   58
....................       } 
....................    } // Fin del if(flag_Resp_IPD) 
00994:  MOVLB  0
00996:  GOTO   0ABC (RETURN)
.................... } 
....................  
.................... /*********************************************************** 
....................    Funcion Verifica si la bandera de recepcion de datos esta 
....................    activa y almacena los datos entrantes en el arreglo 
....................    DATA_COMMAND, Finaliza la captura de caracteres cuando 
....................    encuentra el caracter ":". 
.................... ************************************************************/ 
.................... void ESP8266_Get_Data(char buffer[]){ 
....................     
....................    // Si el inicio la bandera de recepcion de comando esta 
....................    // activa, almacena lo que entra por el buffer como Data 
....................    // hasta que sea leido el caracter ":" 
....................    if(flag_Resp_StartGetData==1){ 
0099A:  DECFSZ 56,W
0099C:  BRA    09E0
....................       if(buffer!=':'){ 
0099E:  MOVLB  1
009A0:  MOVF   xB9,W
009A2:  SUBLW  3A
009A4:  BNZ   09AA
009A6:  MOVF   xBA,F
009A8:  BZ    09D8
....................          
....................          DATA_COMMAND[flag_Pos_Resp_Data] = buffer; 
009AA:  CLRF   03
009AC:  MOVF   5A,W
009AE:  ADDLW  20
009B0:  MOVWF  FE9
009B2:  MOVLW  00
009B4:  ADDWFC 03,W
009B6:  MOVWF  FEA
009B8:  MOVFF  1B9,FEF
....................          LEN_DATA_COMMAND = flag_Pos_Resp_Data; 
009BC:  CLRF   53
009BE:  MOVFF  5A,52
....................           
....................          if(flag_Pos_Resp_Data==0 && buffer==','){ 
009C2:  MOVF   5A,F
009C4:  BNZ   09D4
009C6:  MOVF   xB9,W
009C8:  SUBLW  2C
009CA:  BNZ   09D4
009CC:  MOVF   xBA,F
009CE:  BNZ   09D4
....................             flag_Pos_Resp_Data=0; 
009D0:  CLRF   5A
....................          }else{ 
009D2:  BRA    09D6
....................             flag_Pos_Resp_Data++; 
009D4:  INCF   5A,F
....................          } 
....................           
....................       }else{ 
009D6:  BRA    09E0
....................          flag_Pos_Resp_Data      = 0x00; 
009D8:  CLRF   5A
....................          flag_Resp_StartGetData  = 0x00; 
009DA:  CLRF   56
....................          flag_Resp_Ready         = 1; 
009DC:  MOVLW  01
009DE:  MOVWF  57
009E0:  MOVLB  0
....................       } 
....................    } // Fin del if(flag_Resp_StartGetData) 
009E2:  GOTO   0AC8 (RETURN)
.................... } 
....................  
.................... /***************************************************** 
....................    Verifica si se ha recibido algun comando enviado 
....................    por WiFi.  
.................... *****************************************************/ 
....................  
.................... int run_command_wifi(void){ 
*
012A6:  MOVLB  1
012A8:  CLRF   x6D
012AA:  CLRF   x6E
012AC:  CLRF   x6F
012AE:  CLRF   x70
012B0:  MOVLW  0C
012B2:  MOVWF  x71
....................    int8 reset = 0, optSelected  = 0,counter = 0, idxRSTNC = 0,lenResponse = 12; 
....................     
....................    char response[57] = "{\"cmd\":\"ok\"}"; 
012B4:  MOVLW  7B
012B6:  MOVWF  x72
012B8:  MOVLW  22
012BA:  MOVWF  x73
012BC:  MOVLW  63
012BE:  MOVWF  x74
012C0:  MOVLW  6D
012C2:  MOVWF  x75
012C4:  MOVLW  64
012C6:  MOVWF  x76
012C8:  MOVLW  22
012CA:  MOVWF  x77
012CC:  MOVLW  3A
012CE:  MOVWF  x78
012D0:  MOVLW  22
012D2:  MOVWF  x79
012D4:  MOVLW  6F
012D6:  MOVWF  x7A
012D8:  MOVLW  6B
012DA:  MOVWF  x7B
012DC:  MOVLW  22
012DE:  MOVWF  x7C
012E0:  MOVLW  7D
012E2:  MOVWF  x7D
012E4:  CLRF   x7E
....................    // Si hay un comando y datos listos para ejecutar 
....................    if(flag_Resp_Ready==1){ 
012E6:  DECFSZ 57,W
012E8:  GOTO   1AC4
....................        
....................       /************************** 
....................       *** Accede a las Salidas ** 
....................       *** CMD:OP,[0|1][0-7]:   ** 
....................       **************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='P') 
012EC:  MOVF   1E,W
012EE:  SUBLW  4F
012F0:  BNZ   13A6
012F2:  MOVF   1F,W
012F4:  SUBLW  50
012F6:  BNZ   13A6
....................       { 
....................          optSelected =(int) ( DATA_COMMAND[1] - 48); 
012F8:  MOVLW  30
012FA:  SUBWF  21,W
012FC:  MOVWF  x6E
....................           
....................          switch(DATA_COMMAND[0]){ 
012FE:  MOVF   20,W
01300:  XORLW  30
01302:  MOVLB  0
01304:  BZ    130C
01306:  XORLW  01
01308:  BZ    1358
0130A:  BRA    13A4
....................             case '0': 
....................                output_low(PIN_OUT[optSelected]); 
0130C:  BCF    FD8.0
0130E:  MOVLB  1
01310:  RLCF   x6E,W
01312:  CLRF   03
01314:  MOVFF  FF2,1AF
01318:  BCF    FF2.7
0131A:  MOVLB  0
0131C:  CALL   0096
01320:  TBLRD*+
01322:  MOVFF  FF5,03
01326:  MOVLB  1
01328:  BTFSC  xAF.7
0132A:  BSF    FF2.7
0132C:  MOVWF  xAF
0132E:  MOVFF  03,1B0
01332:  MOVWF  xB1
01334:  CLRF   xB2
01336:  MOVLW  0F
01338:  MOVWF  xB4
0133A:  MOVLW  89
0133C:  MOVWF  xB3
0133E:  MOVLB  0
01340:  RCALL  11BA
01342:  MOVFF  1AF,1B1
01346:  MOVLB  1
01348:  CLRF   xB2
0134A:  MOVLW  0F
0134C:  MOVWF  xB4
0134E:  MOVLW  92
01350:  MOVWF  xB3
01352:  MOVLB  0
01354:  RCALL  11BA
....................                break; 
01356:  BRA    13A4
....................             case '1': 
....................                output_high(PIN_OUT[optSelected]); 
01358:  BCF    FD8.0
0135A:  MOVLB  1
0135C:  RLCF   x6E,W
0135E:  CLRF   03
01360:  MOVFF  FF2,1AF
01364:  BCF    FF2.7
01366:  MOVLB  0
01368:  CALL   0096
0136C:  TBLRD*+
0136E:  MOVFF  FF5,03
01372:  MOVLB  1
01374:  BTFSC  xAF.7
01376:  BSF    FF2.7
01378:  MOVWF  xAF
0137A:  MOVFF  03,1B0
0137E:  MOVWF  xB1
01380:  MOVLW  01
01382:  MOVWF  xB2
01384:  MOVLW  0F
01386:  MOVWF  xB4
01388:  MOVLW  89
0138A:  MOVWF  xB3
0138C:  MOVLB  0
0138E:  RCALL  11BA
01390:  MOVFF  1AF,1B1
01394:  MOVLB  1
01396:  CLRF   xB2
01398:  MOVLW  0F
0139A:  MOVWF  xB4
0139C:  MOVLW  92
0139E:  MOVWF  xB3
013A0:  MOVLB  0
013A2:  RCALL  11BA
....................                break; 
013A4:  MOVLB  1
....................          } 
....................       } // Fin comando OP 
....................        
....................       /********************************** 
....................       *** Configura Conecxion a la Red ** 
....................       *** CMD:NC,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='C') 
013A6:  MOVF   1E,W
013A8:  SUBLW  4E
013AA:  BTFSS  FD8.2
013AC:  BRA    15B0
013AE:  MOVF   1F,W
013B0:  SUBLW  43
013B2:  BTFSS  FD8.2
013B4:  BRA    15B0
....................       { 
....................          // Borra la eeprom para almacenar las nuevas credenciales 
....................          // Desde la posicion 0x01 hasta 0x027 
....................          for(idxRSTNC=1;idxRSTNC<=27;idxRSTNC++){ 
013B6:  MOVLW  01
013B8:  MOVWF  x70
013BA:  MOVF   x70,W
013BC:  SUBLW  1B
013BE:  BNC   13FC
....................             write_eeprom(idxRSTNC,0xFF); 
013C0:  MOVF   FF2,W
013C2:  MOVWF  00
013C4:  BCF    FF2.7
013C6:  CLRF   FAA
013C8:  MOVFF  170,FA9
013CC:  SETF   FA8
013CE:  BCF    FA6.6
013D0:  BCF    FA6.7
013D2:  BSF    FA6.2
013D4:  MOVLB  F
013D6:  MOVLW  55
013D8:  MOVWF  FA7
013DA:  MOVLW  AA
013DC:  MOVWF  FA7
013DE:  BSF    FA6.1
013E0:  BTFSC  FA6.1
013E2:  BRA    13E0
013E4:  BCF    FA6.2
013E6:  MOVF   00,W
013E8:  IORWF  FF2,F
....................             delay_ms(10); 
013EA:  MOVLW  0A
013EC:  MOVLB  1
013EE:  MOVWF  xB0
013F0:  MOVLB  0
013F2:  CALL   0AF8
013F6:  MOVLB  1
013F8:  INCF   x70,F
013FA:  BRA    13BA
....................          } 
....................           
....................          // Guarda las nuevas credenciales 
....................          for(int idxNC=0;idxNC<=LEN_DATA_COMMAND;idxNC++){ 
013FC:  CLRF   xAB
013FE:  MOVF   53,F
01400:  BNZ   1408
01402:  MOVF   xAB,W
01404:  SUBWF  52,W
01406:  BNC   145E
....................             write_eeprom(idxNC+1,DATA_COMMAND[idxNC]); 
01408:  MOVLW  01
0140A:  ADDWF  xAB,W
0140C:  MOVWF  xAF
0140E:  CLRF   03
01410:  MOVF   xAB,W
01412:  ADDLW  20
01414:  MOVWF  FE9
01416:  MOVLW  00
01418:  ADDWFC 03,W
0141A:  MOVWF  FEA
0141C:  MOVFF  FEF,1B0
01420:  MOVF   FF2,W
01422:  MOVWF  00
01424:  BCF    FF2.7
01426:  CLRF   FAA
01428:  MOVFF  1AF,FA9
0142C:  MOVFF  1B0,FA8
01430:  BCF    FA6.6
01432:  BCF    FA6.7
01434:  BSF    FA6.2
01436:  MOVLB  F
01438:  MOVLW  55
0143A:  MOVWF  FA7
0143C:  MOVLW  AA
0143E:  MOVWF  FA7
01440:  BSF    FA6.1
01442:  BTFSC  FA6.1
01444:  BRA    1442
01446:  BCF    FA6.2
01448:  MOVF   00,W
0144A:  IORWF  FF2,F
....................             delay_ms(10); 
0144C:  MOVLW  0A
0144E:  MOVLB  1
01450:  MOVWF  xB0
01452:  MOVLB  0
01454:  CALL   0AF8
01458:  MOVLB  1
0145A:  INCF   xAB,F
0145C:  BRA    13FE
....................          } 
....................           
....................          // Banderas para fin de dato en EEPROM 
....................          write_eeprom(idxNC+1,0x0D); 
0145E:  MOVLW  01
01460:  ADDWF  xAB,W
01462:  MOVWF  xAF
01464:  MOVF   FF2,W
01466:  MOVWF  00
01468:  BCF    FF2.7
0146A:  CLRF   FAA
0146C:  MOVFF  1AF,FA9
01470:  MOVLW  0D
01472:  MOVWF  FA8
01474:  BCF    FA6.6
01476:  BCF    FA6.7
01478:  BSF    FA6.2
0147A:  MOVLB  F
0147C:  MOVLW  55
0147E:  MOVWF  FA7
01480:  MOVLW  AA
01482:  MOVWF  FA7
01484:  BSF    FA6.1
01486:  BTFSC  FA6.1
01488:  BRA    1486
0148A:  BCF    FA6.2
0148C:  MOVF   00,W
0148E:  IORWF  FF2,F
....................          delay_ms(10); 
01490:  MOVLW  0A
01492:  MOVLB  1
01494:  MOVWF  xB0
01496:  MOVLB  0
01498:  CALL   0AF8
....................          write_eeprom(idxNC+2,0x0A); 
0149C:  MOVLW  02
0149E:  MOVLB  1
014A0:  ADDWF  xAB,W
014A2:  MOVWF  xAF
014A4:  MOVF   FF2,W
014A6:  MOVWF  00
014A8:  BCF    FF2.7
014AA:  CLRF   FAA
014AC:  MOVFF  1AF,FA9
014B0:  MOVLW  0A
014B2:  MOVWF  FA8
014B4:  BCF    FA6.6
014B6:  BCF    FA6.7
014B8:  BSF    FA6.2
014BA:  MOVLB  F
014BC:  MOVLW  55
014BE:  MOVWF  FA7
014C0:  MOVLW  AA
014C2:  MOVWF  FA7
014C4:  BSF    FA6.1
014C6:  BTFSC  FA6.1
014C8:  BRA    14C6
014CA:  BCF    FA6.2
014CC:  MOVF   00,W
014CE:  IORWF  FF2,F
....................          delay_ms(10); 
014D0:  MOVLW  0A
014D2:  MOVLB  1
014D4:  MOVWF  xB0
014D6:  MOVLB  0
014D8:  CALL   0AF8
....................  
....................          // Responde la solicitud 
....................          delay_ms(30); 
014DC:  MOVLW  1E
014DE:  MOVLB  1
014E0:  MOVWF  xB0
014E2:  MOVLB  0
014E4:  CALL   0AF8
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
014E8:  MOVLW  5E
014EA:  MOVWF  FF6
014EC:  MOVLW  01
014EE:  MOVWF  FF7
014F0:  MOVLW  0B
014F2:  MOVLB  1
014F4:  MOVWF  xAF
014F6:  MOVLB  0
014F8:  RCALL  0E44
014FA:  MOVF   1C,W
014FC:  BTFSS  F9E.4
014FE:  BRA    14FC
01500:  MOVWF  FAD
01502:  MOVLW  2C
01504:  BTFSS  F9E.4
01506:  BRA    1504
01508:  MOVWF  FAD
0150A:  MOVFF  171,1AF
0150E:  MOVLW  1B
01510:  MOVLB  1
01512:  MOVWF  xB0
01514:  MOVLB  0
01516:  RCALL  1228
01518:  MOVLW  0D
0151A:  BTFSS  F9E.4
0151C:  BRA    151A
0151E:  MOVWF  FAD
01520:  MOVLW  0A
01522:  BTFSS  F9E.4
01524:  BRA    1522
01526:  MOVWF  FAD
....................          delay_ms(60); 
01528:  MOVLW  3C
0152A:  MOVLB  1
0152C:  MOVWF  xB0
0152E:  MOVLB  0
01530:  CALL   0AF8
....................          fprintf(ESP8266, "%s",response); 
01534:  MOVLW  01
01536:  MOVWF  FEA
01538:  MOVLW  72
0153A:  MOVWF  FE9
0153C:  RCALL  0F80
....................          delay_ms(120); 
0153E:  MOVLW  78
01540:  MOVLB  1
01542:  MOVWF  xB0
01544:  MOVLB  0
01546:  CALL   0AF8
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0154A:  MOVLW  72
0154C:  MOVWF  FF6
0154E:  MOVLW  01
01550:  MOVWF  FF7
01552:  MOVLW  0C
01554:  MOVLB  1
01556:  MOVWF  xAF
01558:  MOVLB  0
0155A:  RCALL  0E44
0155C:  MOVF   1C,W
0155E:  BTFSS  F9E.4
01560:  BRA    155E
01562:  MOVWF  FAD
01564:  MOVLW  0D
01566:  BTFSS  F9E.4
01568:  BRA    1566
0156A:  MOVWF  FAD
0156C:  MOVLW  0A
0156E:  BTFSS  F9E.4
01570:  BRA    156E
01572:  MOVWF  FAD
....................          delay_ms(500); 
01574:  MOVLW  02
01576:  MOVLB  1
01578:  MOVWF  xAF
0157A:  MOVLW  FA
0157C:  MOVWF  xB0
0157E:  MOVLB  0
01580:  CALL   0AF8
01584:  MOVLB  1
01586:  DECFSZ xAF,F
01588:  BRA    157A
....................           
....................          // Libera la conexion actual 
....................          fprintf(ESP8266, "AT+CWQAP\n\r"); 
0158A:  MOVLW  84
0158C:  MOVWF  FF6
0158E:  MOVLW  01
01590:  MOVWF  FF7
01592:  MOVLB  0
01594:  RCALL  0E6E
....................          delay_ms(1000); 
01596:  MOVLW  04
01598:  MOVLB  1
0159A:  MOVWF  xAF
0159C:  MOVLW  FA
0159E:  MOVWF  xB0
015A0:  MOVLB  0
015A2:  CALL   0AF8
015A6:  MOVLB  1
015A8:  DECFSZ xAF,F
015AA:  BRA    159C
....................           
....................          reset = 1; 
015AC:  MOVLW  01
015AE:  MOVWF  x6D
....................       } // Fin comando NC 
....................        
....................       /********************************** 
....................       *** Cambia el SSID y Key del AP  ** 
....................       *** CMD:AP,"SSID","KEY":         ** 
....................       **********************************/ 
....................       if(COMMAND[0]=='A' && 
....................          COMMAND[1]=='P') 
015B0:  MOVF   1E,W
015B2:  SUBLW  41
015B4:  BTFSS  FD8.2
015B6:  BRA    16B4
015B8:  MOVF   1F,W
015BA:  SUBLW  50
015BC:  BTFSS  FD8.2
015BE:  BRA    16B4
....................       { 
....................          // Responde la solicitud 
....................          delay_ms(20); 
015C0:  MOVLW  14
015C2:  MOVWF  xB0
015C4:  MOVLB  0
015C6:  CALL   0AF8
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
015CA:  MOVLW  90
015CC:  MOVWF  FF6
015CE:  MOVLW  01
015D0:  MOVWF  FF7
015D2:  MOVLW  0B
015D4:  MOVLB  1
015D6:  MOVWF  xAF
015D8:  MOVLB  0
015DA:  RCALL  0E44
015DC:  MOVF   1C,W
015DE:  BTFSS  F9E.4
015E0:  BRA    15DE
015E2:  MOVWF  FAD
015E4:  MOVLW  2C
015E6:  BTFSS  F9E.4
015E8:  BRA    15E6
015EA:  MOVWF  FAD
015EC:  MOVFF  171,1AF
015F0:  MOVLW  1B
015F2:  MOVLB  1
015F4:  MOVWF  xB0
015F6:  MOVLB  0
015F8:  RCALL  1228
015FA:  MOVLW  0D
015FC:  BTFSS  F9E.4
015FE:  BRA    15FC
01600:  MOVWF  FAD
01602:  MOVLW  0A
01604:  BTFSS  F9E.4
01606:  BRA    1604
01608:  MOVWF  FAD
....................          delay_ms(50); 
0160A:  MOVLW  32
0160C:  MOVLB  1
0160E:  MOVWF  xB0
01610:  MOVLB  0
01612:  CALL   0AF8
....................          fprintf(ESP8266, "%s",response); 
01616:  MOVLW  01
01618:  MOVWF  FEA
0161A:  MOVLW  72
0161C:  MOVWF  FE9
0161E:  RCALL  0F80
....................          delay_ms(100); 
01620:  MOVLW  64
01622:  MOVLB  1
01624:  MOVWF  xB0
01626:  MOVLB  0
01628:  CALL   0AF8
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
0162C:  MOVLW  A4
0162E:  MOVWF  FF6
01630:  MOVLW  01
01632:  MOVWF  FF7
01634:  MOVLW  0C
01636:  MOVLB  1
01638:  MOVWF  xAF
0163A:  MOVLB  0
0163C:  RCALL  0E44
0163E:  MOVF   1C,W
01640:  BTFSS  F9E.4
01642:  BRA    1640
01644:  MOVWF  FAD
01646:  MOVLW  0D
01648:  BTFSS  F9E.4
0164A:  BRA    1648
0164C:  MOVWF  FAD
0164E:  MOVLW  0A
01650:  BTFSS  F9E.4
01652:  BRA    1650
01654:  MOVWF  FAD
....................          delay_ms(500); 
01656:  MOVLW  02
01658:  MOVLB  1
0165A:  MOVWF  xAF
0165C:  MOVLW  FA
0165E:  MOVWF  xB0
01660:  MOVLB  0
01662:  CALL   0AF8
01666:  MOVLB  1
01668:  DECFSZ xAF,F
0166A:  BRA    165C
....................           
....................          fprintf(ESP8266, "AT+CWSAP_DEF=%s,1,4\r\n",DATA_COMMAND); 
0166C:  MOVLW  B6
0166E:  MOVWF  FF6
01670:  MOVLW  01
01672:  MOVWF  FF7
01674:  MOVLW  0D
01676:  MOVWF  xAF
01678:  MOVLB  0
0167A:  CALL   0E44
0167E:  CLRF   FEA
01680:  MOVLW  20
01682:  MOVWF  FE9
01684:  RCALL  0F80
01686:  MOVLW  C5
01688:  MOVWF  FF6
0168A:  MOVLW  01
0168C:  MOVWF  FF7
0168E:  MOVLW  06
01690:  MOVLB  1
01692:  MOVWF  xAF
01694:  MOVLB  0
01696:  CALL   0E44
....................          delay_ms(1000); 
0169A:  MOVLW  04
0169C:  MOVLB  1
0169E:  MOVWF  xAF
016A0:  MOVLW  FA
016A2:  MOVWF  xB0
016A4:  MOVLB  0
016A6:  CALL   0AF8
016AA:  MOVLB  1
016AC:  DECFSZ xAF,F
016AE:  BRA    16A0
....................          reset = 1; 
016B0:  MOVLW  01
016B2:  MOVWF  x6D
....................       } // Fin comando AP 
....................        
....................       /********************************* 
....................       *** Cambia el modo de conexion  ** 
....................       *** CMD:NM,[1|2|3]:             ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='M') 
016B4:  MOVF   1E,W
016B6:  SUBLW  4E
016B8:  BTFSS  FD8.2
016BA:  BRA    17A6
016BC:  MOVF   1F,W
016BE:  SUBLW  4D
016C0:  BNZ   17A6
....................       { 
....................          // Guarda en la EEPROM el modo de conexion 
....................          write_eeprom(0,DATA_COMMAND[0]); 
016C2:  MOVF   FF2,W
016C4:  MOVWF  00
016C6:  BCF    FF2.7
016C8:  CLRF   FAA
016CA:  CLRF   FA9
016CC:  MOVFF  20,FA8
016D0:  BCF    FA6.6
016D2:  BCF    FA6.7
016D4:  BSF    FA6.2
016D6:  MOVLB  F
016D8:  MOVLW  55
016DA:  MOVWF  FA7
016DC:  MOVLW  AA
016DE:  MOVWF  FA7
016E0:  BSF    FA6.1
016E2:  BTFSC  FA6.1
016E4:  BRA    16E2
016E6:  BCF    FA6.2
016E8:  MOVF   00,W
016EA:  IORWF  FF2,F
....................          delay_ms(10); 
016EC:  MOVLW  0A
016EE:  MOVLB  1
016F0:  MOVWF  xB0
016F2:  MOVLB  0
016F4:  CALL   0AF8
....................           
....................          // Responde la solicitud 
....................          delay_ms(20); 
016F8:  MOVLW  14
016FA:  MOVLB  1
016FC:  MOVWF  xB0
016FE:  MOVLB  0
01700:  CALL   0AF8
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
01704:  MOVLW  CC
01706:  MOVWF  FF6
01708:  MOVLW  01
0170A:  MOVWF  FF7
0170C:  MOVLW  0B
0170E:  MOVLB  1
01710:  MOVWF  xAF
01712:  MOVLB  0
01714:  CALL   0E44
01718:  MOVF   1C,W
0171A:  BTFSS  F9E.4
0171C:  BRA    171A
0171E:  MOVWF  FAD
01720:  MOVLW  2C
01722:  BTFSS  F9E.4
01724:  BRA    1722
01726:  MOVWF  FAD
01728:  MOVFF  171,1AF
0172C:  MOVLW  1B
0172E:  MOVLB  1
01730:  MOVWF  xB0
01732:  MOVLB  0
01734:  RCALL  1228
01736:  MOVLW  0D
01738:  BTFSS  F9E.4
0173A:  BRA    1738
0173C:  MOVWF  FAD
0173E:  MOVLW  0A
01740:  BTFSS  F9E.4
01742:  BRA    1740
01744:  MOVWF  FAD
....................          delay_ms(50); 
01746:  MOVLW  32
01748:  MOVLB  1
0174A:  MOVWF  xB0
0174C:  MOVLB  0
0174E:  CALL   0AF8
....................          fprintf(ESP8266, "%s",response); 
01752:  MOVLW  01
01754:  MOVWF  FEA
01756:  MOVLW  72
01758:  MOVWF  FE9
0175A:  RCALL  0F80
....................          delay_ms(100); 
0175C:  MOVLW  64
0175E:  MOVLB  1
01760:  MOVWF  xB0
01762:  MOVLB  0
01764:  CALL   0AF8
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01768:  MOVLW  E0
0176A:  MOVWF  FF6
0176C:  MOVLW  01
0176E:  MOVWF  FF7
01770:  MOVLW  0C
01772:  MOVLB  1
01774:  MOVWF  xAF
01776:  MOVLB  0
01778:  CALL   0E44
0177C:  MOVF   1C,W
0177E:  BTFSS  F9E.4
01780:  BRA    177E
01782:  MOVWF  FAD
01784:  MOVLW  0D
01786:  BTFSS  F9E.4
01788:  BRA    1786
0178A:  MOVWF  FAD
0178C:  MOVLW  0A
0178E:  BTFSS  F9E.4
01790:  BRA    178E
01792:  MOVWF  FAD
....................          delay_ms(100); 
01794:  MOVLW  64
01796:  MOVLB  1
01798:  MOVWF  xB0
0179A:  MOVLB  0
0179C:  CALL   0AF8
....................          reset = 1; 
017A0:  MOVLW  01
017A2:  MOVLB  1
017A4:  MOVWF  x6D
....................       } // Fin comando OP 
....................        
....................       /********************************* 
....................       *** Optiene el estado de Puerto ** 
....................       *** CMD:OS,0:                   ** 
....................       *********************************/ 
....................       if(COMMAND[0]=='O' && 
....................          COMMAND[1]=='S') 
017A6:  MOVF   1E,W
017A8:  SUBLW  4F
017AA:  BTFSS  FD8.2
017AC:  BRA    18DA
017AE:  MOVF   1F,W
017B0:  SUBLW  53
017B2:  BTFSS  FD8.2
017B4:  BRA    18DA
....................       { 
....................          //char  response[57]; 
....................           
....................          response[0]  = '{'; 
017B6:  MOVLW  7B
017B8:  MOVWF  x72
....................          response[1]  = '"'; 
017BA:  MOVLW  22
017BC:  MOVWF  x73
....................          response[2]  = '0'; 
017BE:  MOVLW  30
017C0:  MOVWF  x74
....................          response[3]  = '"'; 
017C2:  MOVLW  22
017C4:  MOVWF  x75
....................          response[4]  = ':'; 
017C6:  MOVLW  3A
017C8:  MOVWF  x76
....................          response[5]  = input_state(PIN_OUT[0])+ 48; 
017CA:  MOVLW  00
017CC:  BTFSC  F84.2
017CE:  MOVLW  01
017D0:  ADDLW  30
017D2:  MOVWF  x77
....................          response[6]  = ','; 
017D4:  MOVLW  2C
017D6:  MOVWF  x78
....................           
....................          response[7]   = '"'; 
017D8:  MOVLW  22
017DA:  MOVWF  x79
....................          response[8]   = '1'; 
017DC:  MOVLW  31
017DE:  MOVWF  x7A
....................          response[9]   = '"'; 
017E0:  MOVLW  22
017E2:  MOVWF  x7B
....................          response[10]  = ':'; 
017E4:  MOVLW  3A
017E6:  MOVWF  x7C
....................          response[11]  = input_state(PIN_OUT[1])+ 48; 
017E8:  MOVLW  00
017EA:  BTFSC  F84.1
017EC:  MOVLW  01
017EE:  ADDLW  30
017F0:  MOVWF  x7D
....................          response[12]  = ','; 
017F2:  MOVLW  2C
017F4:  MOVWF  x7E
....................           
....................          response[13]  = '"'; 
017F6:  MOVLW  22
017F8:  MOVWF  x7F
....................          response[14]  = '2'; 
017FA:  MOVLW  32
017FC:  MOVWF  x80
....................          response[15]  = '"'; 
017FE:  MOVLW  22
01800:  MOVWF  x81
....................          response[16]  = ':'; 
01802:  MOVLW  3A
01804:  MOVWF  x82
....................          response[17]  = input_state(PIN_OUT[2])+ 48; 
01806:  MOVLW  00
01808:  BTFSC  F84.0
0180A:  MOVLW  01
0180C:  ADDLW  30
0180E:  MOVWF  x83
....................          response[18]  = ','; 
01810:  MOVLW  2C
01812:  MOVWF  x84
....................           
....................          response[19]  = '"'; 
01814:  MOVLW  22
01816:  MOVWF  x85
....................          response[20]  = '3'; 
01818:  MOVLW  33
0181A:  MOVWF  x86
....................          response[21]  = '"'; 
0181C:  MOVLW  22
0181E:  MOVWF  x87
....................          response[22]  = ':'; 
01820:  MOVLW  3A
01822:  MOVWF  x88
....................          response[23]  = input_state(PIN_OUT[3])+ 48; 
01824:  MOVLW  00
01826:  BTFSC  F80.4
01828:  MOVLW  01
0182A:  ADDLW  30
0182C:  MOVWF  x89
....................          response[24]  = ','; 
0182E:  MOVLW  2C
01830:  MOVWF  x8A
....................           
....................          response[25]  = '"'; 
01832:  MOVLW  22
01834:  MOVWF  x8B
....................          response[26]  = '4'; 
01836:  MOVLW  34
01838:  MOVWF  x8C
....................          response[27]  = '"'; 
0183A:  MOVLW  22
0183C:  MOVWF  x8D
....................          response[28]  = ':'; 
0183E:  MOVLW  3A
01840:  MOVWF  x8E
....................          response[29]  = input_state(PIN_OUT[4])+ 48; 
01842:  MOVLW  00
01844:  BTFSC  F80.0
01846:  MOVLW  01
01848:  ADDLW  30
0184A:  MOVWF  x8F
....................          response[30]  = ','; 
0184C:  MOVLW  2C
0184E:  MOVWF  x90
....................           
....................          response[31]  = '"'; 
01850:  MOVLW  22
01852:  MOVWF  x91
....................          response[32]  = '5'; 
01854:  MOVLW  35
01856:  MOVWF  x92
....................          response[33]  = '"'; 
01858:  MOVLW  22
0185A:  MOVWF  x93
....................          response[34]  = ':'; 
0185C:  MOVLW  3A
0185E:  MOVWF  x94
....................          response[35]  = input_state(PIN_OUT[5])+ 48; 
01860:  MOVLW  00
01862:  BTFSC  F80.1
01864:  MOVLW  01
01866:  ADDLW  30
01868:  MOVWF  x95
....................          response[36]  = ','; 
0186A:  MOVLW  2C
0186C:  MOVWF  x96
....................           
....................          response[37]  = '"'; 
0186E:  MOVLW  22
01870:  MOVWF  x97
....................          response[38]  = '6'; 
01872:  MOVLW  36
01874:  MOVWF  x98
....................          response[39]  = '"'; 
01876:  MOVLW  22
01878:  MOVWF  x99
....................          response[40]  = ':'; 
0187A:  MOVLW  3A
0187C:  MOVWF  x9A
....................          response[41]  = input_state(PIN_OUT[6])+ 48; 
0187E:  MOVLW  00
01880:  BTFSC  F80.2
01882:  MOVLW  01
01884:  ADDLW  30
01886:  MOVWF  x9B
....................          response[42]  = ','; 
01888:  MOVLW  2C
0188A:  MOVWF  x9C
....................           
....................          response[43]  = '"'; 
0188C:  MOVLW  22
0188E:  MOVWF  x9D
....................          response[44]  = '7'; 
01890:  MOVLW  37
01892:  MOVWF  x9E
....................          response[45]  = '"'; 
01894:  MOVLW  22
01896:  MOVWF  x9F
....................          response[46]  = ':'; 
01898:  MOVLW  3A
0189A:  MOVWF  xA0
....................          response[47] = input_state(PIN_OUT[7])+ 48; 
0189C:  MOVLW  00
0189E:  BTFSC  F80.3
018A0:  MOVLW  01
018A2:  ADDLW  30
018A4:  MOVWF  xA1
....................          response[48] = ','; 
018A6:  MOVLW  2C
018A8:  MOVWF  xA2
....................           
....................          response[49]  = '"'; 
018AA:  MOVLW  22
018AC:  MOVWF  xA3
....................          response[50]  = 'M'; 
018AE:  MOVLW  4D
018B0:  MOVWF  xA4
....................          response[51]  = '"'; 
018B2:  MOVLW  22
018B4:  MOVWF  xA5
....................          response[52]  = ':'; 
018B6:  MOVLW  3A
018B8:  MOVWF  xA6
....................          response[53] = read_eeprom(0x00); 
018BA:  MOVFF  FF2,1AF
018BE:  BCF    FF2.7
018C0:  CLRF   FAA
018C2:  CLRF   FA9
018C4:  BCF    FA6.6
018C6:  BCF    FA6.7
018C8:  BSF    FA6.0
018CA:  MOVF   FA8,W
018CC:  BTFSC  xAF.7
018CE:  BSF    FF2.7
018D0:  MOVWF  xA7
....................           
....................          response[54]  = '}'; 
018D2:  MOVLW  7D
018D4:  MOVWF  xA8
....................           
....................          lenResponse = 55; 
018D6:  MOVLW  37
018D8:  MOVWF  x71
....................           
....................       } // Fin comando OS 
....................        
....................       /*********************************** 
....................       *** Cambia el Nombre de la salida ** 
....................       *** lo almacena en la EEPROM      ** 
....................       *** CMD:NO,0NombreChar[15]:       ** 
....................       ***********************************/ 
....................       if(COMMAND[0]=='N' && 
....................          COMMAND[1]=='O') 
018DA:  MOVF   1E,W
018DC:  SUBLW  4E
018DE:  BTFSS  FD8.2
018E0:  BRA    19C6
018E2:  MOVF   1F,W
018E4:  SUBLW  4F
018E6:  BNZ   19C6
....................       { 
....................           
....................          int posIni = 0, posFin = 0; 
018E8:  CLRF   xAC
018EA:  CLRF   xAD
....................          optSelected =(int) ( DATA_COMMAND[0] - 48); 
018EC:  MOVLW  30
018EE:  SUBWF  20,W
018F0:  MOVWF  x6E
....................          posIni =( 10 * optSelected ) + 40; 
018F2:  MOVF   x6E,W
018F4:  MULLW  0A
018F6:  MOVF   FF3,W
018F8:  ADDLW  28
018FA:  MOVWF  xAC
....................          posFin = posIni + 10; 
018FC:  MOVLW  0A
018FE:  ADDWF  xAC,W
01900:  MOVWF  xAD
....................           
....................          // Guarda el nuevo nombre 
....................          for(idxRSTNC=posIni;idxRSTNC<(posIni+LEN_DATA_COMMAND);idxRSTNC++){ 
01902:  MOVFF  1AC,170
01906:  MOVF   xAC,W
01908:  ADDWF  52,W
0190A:  MOVWF  01
0190C:  MOVLW  00
0190E:  ADDWFC 53,W
01910:  MOVWF  03
01912:  MOVF   01,W
01914:  MOVF   03,F
01916:  BNZ   191E
01918:  MOVF   01,W
0191A:  SUBWF  x70,W
0191C:  BC    1970
....................             counter++; 
0191E:  INCF   x6F,F
....................             write_eeprom(idxRSTNC,DATA_COMMAND[counter]); 
01920:  CLRF   03
01922:  MOVF   x6F,W
01924:  ADDLW  20
01926:  MOVWF  FE9
01928:  MOVLW  00
0192A:  ADDWFC 03,W
0192C:  MOVWF  FEA
0192E:  MOVFF  FEF,1AF
01932:  MOVF   FF2,W
01934:  MOVWF  00
01936:  BCF    FF2.7
01938:  CLRF   FAA
0193A:  MOVFF  170,FA9
0193E:  MOVFF  1AF,FA8
01942:  BCF    FA6.6
01944:  BCF    FA6.7
01946:  BSF    FA6.2
01948:  MOVLB  F
0194A:  MOVLW  55
0194C:  MOVWF  FA7
0194E:  MOVLW  AA
01950:  MOVWF  FA7
01952:  BSF    FA6.1
01954:  BTFSC  FA6.1
01956:  BRA    1954
01958:  BCF    FA6.2
0195A:  MOVF   00,W
0195C:  IORWF  FF2,F
....................             delay_ms(10); 
0195E:  MOVLW  0A
01960:  MOVLB  1
01962:  MOVWF  xB0
01964:  MOVLB  0
01966:  CALL   0AF8
0196A:  MOVLB  1
0196C:  INCF   x70,F
0196E:  BRA    1906
....................          } 
....................           
....................          // Borra el restante de la eeprom para almacenar las nuevas credenciales 
....................          for(idxRSTNC=(posIni+LEN_DATA_COMMAND+1);idxRSTNC<=posFin;idxRSTNC++){ 
01970:  MOVF   xAC,W
01972:  ADDWF  52,W
01974:  MOVWF  xAF
01976:  MOVLW  00
01978:  ADDWFC 53,W
0197A:  MOVWF  xB0
0197C:  MOVLW  01
0197E:  ADDWF  xAF,W
01980:  MOVWF  x70
01982:  MOVF   x70,W
01984:  SUBWF  xAD,W
01986:  BNC   19C4
....................             write_eeprom(idxRSTNC,0xFF); 
01988:  MOVF   FF2,W
0198A:  MOVWF  00
0198C:  BCF    FF2.7
0198E:  CLRF   FAA
01990:  MOVFF  170,FA9
01994:  SETF   FA8
01996:  BCF    FA6.6
01998:  BCF    FA6.7
0199A:  BSF    FA6.2
0199C:  MOVLB  F
0199E:  MOVLW  55
019A0:  MOVWF  FA7
019A2:  MOVLW  AA
019A4:  MOVWF  FA7
019A6:  BSF    FA6.1
019A8:  BTFSC  FA6.1
019AA:  BRA    19A8
019AC:  BCF    FA6.2
019AE:  MOVF   00,W
019B0:  IORWF  FF2,F
....................             delay_ms(10); 
019B2:  MOVLW  0A
019B4:  MOVLB  1
019B6:  MOVWF  xB0
019B8:  MOVLB  0
019BA:  CALL   0AF8
019BE:  MOVLB  1
019C0:  INCF   x70,F
019C2:  BRA    1982
....................          } 
....................           
....................          counter = 0; 
019C4:  CLRF   x6F
....................          //reset = 1; 
....................       } // Fin comando NC 
....................        
....................       /************************ 
....................       ***   FIN COMANDOS   **** 
....................       ************************/ 
....................       if(reset==0){ 
019C6:  MOVF   x6D,F
019C8:  BNZ   1A74
....................          // Responde la solicitud 
....................          delay_ms(20); 
019CA:  MOVLW  14
019CC:  MOVWF  xB0
019CE:  MOVLB  0
019D0:  CALL   0AF8
....................          fprintf(ESP8266, "AT+CIPSEND=%c,%u\r\n",ID_CONNETION[0],lenResponse); 
019D4:  MOVLW  F2
019D6:  MOVWF  FF6
019D8:  MOVLW  01
019DA:  MOVWF  FF7
019DC:  MOVLW  0B
019DE:  MOVLB  1
019E0:  MOVWF  xAF
019E2:  MOVLB  0
019E4:  CALL   0E44
019E8:  MOVF   1C,W
019EA:  BTFSS  F9E.4
019EC:  BRA    19EA
019EE:  MOVWF  FAD
019F0:  MOVLW  2C
019F2:  BTFSS  F9E.4
019F4:  BRA    19F2
019F6:  MOVWF  FAD
019F8:  MOVFF  171,1AF
019FC:  MOVLW  1B
019FE:  MOVLB  1
01A00:  MOVWF  xB0
01A02:  MOVLB  0
01A04:  RCALL  1228
01A06:  MOVLW  0D
01A08:  BTFSS  F9E.4
01A0A:  BRA    1A08
01A0C:  MOVWF  FAD
01A0E:  MOVLW  0A
01A10:  BTFSS  F9E.4
01A12:  BRA    1A10
01A14:  MOVWF  FAD
....................          delay_ms(50); 
01A16:  MOVLW  32
01A18:  MOVLB  1
01A1A:  MOVWF  xB0
01A1C:  MOVLB  0
01A1E:  CALL   0AF8
....................          fprintf(ESP8266, "%s",response); 
01A22:  MOVLW  01
01A24:  MOVWF  FEA
01A26:  MOVLW  72
01A28:  MOVWF  FE9
01A2A:  CALL   0F80
....................          delay_ms(100); 
01A2E:  MOVLW  64
01A30:  MOVLB  1
01A32:  MOVWF  xB0
01A34:  MOVLB  0
01A36:  CALL   0AF8
....................          fprintf(ESP8266, "AT+CIPCLOSE=%c\r\n",ID_CONNETION[0]); 
01A3A:  MOVLW  06
01A3C:  MOVWF  FF6
01A3E:  MOVLW  02
01A40:  MOVWF  FF7
01A42:  MOVLW  0C
01A44:  MOVLB  1
01A46:  MOVWF  xAF
01A48:  MOVLB  0
01A4A:  CALL   0E44
01A4E:  MOVF   1C,W
01A50:  BTFSS  F9E.4
01A52:  BRA    1A50
01A54:  MOVWF  FAD
01A56:  MOVLW  0D
01A58:  BTFSS  F9E.4
01A5A:  BRA    1A58
01A5C:  MOVWF  FAD
01A5E:  MOVLW  0A
01A60:  BTFSS  F9E.4
01A62:  BRA    1A60
01A64:  MOVWF  FAD
....................          delay_ms(100); 
01A66:  MOVLW  64
01A68:  MOVLB  1
01A6A:  MOVWF  xB0
01A6C:  MOVLB  0
01A6E:  CALL   0AF8
01A72:  MOVLB  1
....................       } 
....................        
....................       // Limpia el buffer 
....................       for(int idxCb=0;idxCb<=LEN_DATA_COMMAND;idxCb++){ 
01A74:  CLRF   xAE
01A76:  MOVF   53,F
01A78:  BNZ   1A80
01A7A:  MOVF   xAE,W
01A7C:  SUBWF  52,W
01A7E:  BNC   1A94
....................          DATA_COMMAND[idxCb] = 0x00; 
01A80:  CLRF   03
01A82:  MOVF   xAE,W
01A84:  ADDLW  20
01A86:  MOVWF  FE9
01A88:  MOVLW  00
01A8A:  ADDWFC 03,W
01A8C:  MOVWF  FEA
01A8E:  CLRF   FEF
01A90:  INCF   xAE,F
01A92:  BRA    1A76
....................       } 
....................       for(idxCb=0;idxCb<=56;idxCb++){ 
01A94:  CLRF   xAE
01A96:  MOVF   xAE,W
01A98:  SUBLW  38
01A9A:  BNC   1AB0
....................       response[idxCb] = 0x00; 
01A9C:  CLRF   03
01A9E:  MOVF   xAE,W
01AA0:  ADDLW  72
01AA2:  MOVWF  FE9
01AA4:  MOVLW  01
01AA6:  ADDWFC 03,W
01AA8:  MOVWF  FEA
01AAA:  CLRF   FEF
01AAC:  INCF   xAE,F
01AAE:  BRA    1A96
....................       } 
....................       COMMAND[0]       = 0x00; 
01AB0:  CLRF   1E
....................       COMMAND[1]       = 0x00; 
01AB2:  CLRF   1F
....................       ID_CONNETION[0]  = 0x00; 
01AB4:  CLRF   1C
....................        
....................       // Reinicia el buffer 
....................       flag_Resp_Ready  = 0x00; 
01AB6:  CLRF   57
....................       LEN_DATA_COMMAND = 0x00; 
01AB8:  CLRF   53
01ABA:  CLRF   52
....................        
....................       if(reset==1){ 
01ABC:  DECFSZ x6D,W
01ABE:  BRA    1AC4
....................          reset = 0; 
01AC0:  CLRF   x6D
....................           // Reinicia el dispositivo 
....................          reset_cpu(); 
01AC2:  RESET
....................       } 
....................    } // Fin del if(flag_Resp_Ready) 
....................     
....................    return reset; 
01AC4:  MOVFF  16D,01
01AC8:  MOVLB  0
01ACA:  RETURN 0
.................... } 
....................  
.................... #include "header/esp8266.h" 
.................... /****************************************************************\ 
.................... * @NOTA:   Funcionamiento de las funciones de Busqueda y         * 
.................... *         comparacion de String.                                 * 
.................... *                                                                * 
.................... * Cuenta el numero de aciertos de manera secuencial cuando       * 
.................... * compara los caracteres que recibe por el usart vs una cadena   * 
.................... * constante. Si el numero de aciertos es igual a la cadena       * 
.................... * entonces las cadenas son iguales y almacena en una estructura  * 
.................... * los siguientes caracteres recibidos hasta que encuentre el     * 
.................... * caracter del fin de la cadena (":")                            * 
.................... \****************************************************************/ 
....................  
.................... #define  CMD_MODE                   1 
.................... #define  CMD_DO_CONN                2 
.................... #define  CMD_CONN                   3 
.................... #define  READY_RESPONSE_WIFI        4  
.................... #define  CMD_GET_IP_FROM_MENU       5 
.................... #define  CMD_GET_AP_INFO_FROM_MENU  6 
.................... #define  CMD_GET_STA_INFO_FROM_MENU 7 
....................  
.................... /* Key flag responses */ 
.................... const int   Valid      = 0; 
.................... const int   CWJAP      = 1; 
.................... const int   NoAp       = 2; 
.................... const int   Connected  = 3; 
.................... const int   Fail       = 4; 
.................... const int   Error      = 5; 
....................  
.................... //#define  END_CMD_GET_IP       2 
....................  
.................... /* Declaracion de Funciones de respuestas */ 
.................... void getIP(int buffer); 
.................... void getAPInfo(int buffer); 
.................... void getSTAInfo(int buffer); 
.................... int  waitResp(void); 
.................... void waitRespMajor(int buffer,int flag_resp); 
....................  
.................... /** BANDERAS MODOS DE FUNCIONAMIENTO **/ 
.................... int CMD_RUN    = 0x00; 
.................... int resp_Pos   = 1; 
.................... int resp_Flag  = 0; 
.................... int countResp  = 5;     //Conteo de Respuestas esperadas 
....................  
.................... char buffer_flag_Resp[2][6]   =   
.................... { 
....................    {0,0,0,0,0,0}, // Flag_Responses Command valid 
....................    {0,0,0,0,0,0}  // Flag_Pos_Responses 
.................... }; 
....................  
.................... char buffer_Resp_CMD[5][16]   = 
.................... { 
....................    {"0.0.0.0"},   // IP    AP 
....................    {"0.0.0.0"},   // IP    STA 
....................    {""},          // SSID  AP 
....................    {"KEY"},       // Key   AP 
....................    {"SSID"}       // SSID  STA 
.................... }; 
....................  
.................... int flag_Resp_Get_IP_CMD = 0; 
.................... int flag_Pos_Get_IP_CMD  = 0; 
....................  
.................... int flag_Resp_Get_AP_Info_CMD = 0; 
.................... int flag_Pos_Get_AP_Info_CMD  = 0; 
....................  
.................... int flag_Resp_Get_STA_Info_CMD = 0; 
.................... int flag_Pos_Get_STA_Info_CMD  = 0; 
....................  
.................... /*Variables que se setean con la data de la EEPROM*/ 
.................... char  modeStar; 
.................... char  SSIDAndKey[50]; 
....................  
.................... /* Inicializa el modulo*/ 
.................... void esp8266_init() 
.................... { 
....................    int   resp; 
....................    
....................    // @TODO: Usar este comando solo en produccion 
....................    //fprintf(ESP8266, "AT+RST\r\n"); 
....................    //delay_ms(2000); 
....................     
....................    // Lee de la EEPROM el modo de conexion 
....................    // Si no ha sido configurado lo setea en '3' 
....................    modeStar = read_eeprom(0x00); 
*
00FA6:  MOVFF  FF2,16A
00FAA:  BCF    FF2.7
00FAC:  CLRF   FAA
00FAE:  CLRF   FA9
00FB0:  BCF    FA6.6
00FB2:  BCF    FA6.7
00FB4:  BSF    FA6.0
00FB6:  MOVF   FA8,W
00FB8:  MOVLB  1
00FBA:  BTFSC  x6A.7
00FBC:  BSF    FF2.7
00FBE:  MOVLB  0
00FC0:  MOVWF  xC1
....................    delay_ms(10); 
00FC2:  MOVLW  0A
00FC4:  MOVLB  1
00FC6:  MOVWF  xB0
00FC8:  MOVLB  0
00FCA:  RCALL  0AF8
....................    switch(modeStar){ 
00FCC:  MOVF   xC1,W
00FCE:  XORLW  31
00FD0:  BZ    0FDC
00FD2:  XORLW  03
00FD4:  BZ    0FDC
00FD6:  XORLW  01
00FD8:  BZ    0FDC
00FDA:  BRA    0FDE
....................       case '1': 
....................       case '2': 
....................       case '3': 
....................          break; 
00FDC:  BRA    1016
....................       default: 
....................          write_eeprom(0x00,'3'); 
00FDE:  MOVF   FF2,W
00FE0:  MOVWF  00
00FE2:  BCF    FF2.7
00FE4:  CLRF   FAA
00FE6:  CLRF   FA9
00FE8:  MOVLW  33
00FEA:  MOVWF  FA8
00FEC:  BCF    FA6.6
00FEE:  BCF    FA6.7
00FF0:  BSF    FA6.2
00FF2:  MOVLB  F
00FF4:  MOVLW  55
00FF6:  MOVWF  FA7
00FF8:  MOVLW  AA
00FFA:  MOVWF  FA7
00FFC:  BSF    FA6.1
00FFE:  BTFSC  FA6.1
01000:  BRA    0FFE
01002:  BCF    FA6.2
01004:  MOVF   00,W
01006:  IORWF  FF2,F
....................          delay_ms(10); 
01008:  MOVLW  0A
0100A:  MOVLB  1
0100C:  MOVWF  xB0
0100E:  MOVLB  0
01010:  RCALL  0AF8
....................          modeStar = '3'; 
01012:  MOVLW  33
01014:  MOVWF  xC1
....................          break; 
....................    } 
....................    // Lanza el comando para configurar el modo de conexion 
....................    fprintf(ESP8266, "AT+CWMODE=%c\r\n",modeStar); 
01016:  MOVLW  18
01018:  MOVWF  FF6
0101A:  MOVLW  02
0101C:  MOVWF  FF7
0101E:  MOVLW  0A
01020:  MOVLB  1
01022:  MOVWF  xAF
01024:  MOVLB  0
01026:  RCALL  0E44
01028:  MOVF   xC1,W
0102A:  BTFSS  F9E.4
0102C:  BRA    102A
0102E:  MOVWF  FAD
01030:  MOVLW  0D
01032:  BTFSS  F9E.4
01034:  BRA    1032
01036:  MOVWF  FAD
01038:  MOVLW  0A
0103A:  BTFSS  F9E.4
0103C:  BRA    103A
0103E:  MOVWF  FAD
....................    CMD_RUN =  CMD_MODE;  
01040:  MOVLW  01
01042:  MOVWF  5B
....................     
....................    // Espera por la respuesta OK del modulo 
....................    delay_ms(50); 
01044:  MOVLW  32
01046:  MOVLB  1
01048:  MOVWF  xB0
0104A:  MOVLB  0
0104C:  RCALL  0AF8
....................     
....................    // Lanza el comando para verificar si elmodulo ya se encuentra conectado 
....................    fprintf(ESP8266, "AT+CWJAP?\r\n"); 
0104E:  MOVLW  28
01050:  MOVWF  FF6
01052:  MOVLW  02
01054:  MOVWF  FF7
01056:  RCALL  0E6E
....................    CMD_RUN =  CMD_DO_CONN; 
01058:  MOVLW  02
0105A:  MOVWF  5B
....................  
....................    resp = waitResp(); 
0105C:  RCALL  0E90
0105E:  MOVFF  01,168
....................  
....................    // Si el modulo no hizo una conexion automatica la realiza de forma manual 
....................    // si no logra conectarse a una red entonces se autoconfigura en modo AP 
....................    if(resp==2){ 
01062:  MOVLB  1
01064:  MOVF   x68,W
01066:  SUBLW  02
01068:  BTFSS  FD8.2
0106A:  BRA    1156
....................           
....................       // Recupera el SSIDAndKey desde la EEPROM 
....................       int idxRE = 0; 
0106C:  CLRF   x69
....................       while(SSIDAndKey[idxRE]!=0x0A){ 
0106E:  CLRF   03
01070:  MOVF   x69,W
01072:  ADDLW  C2
01074:  MOVWF  FE9
01076:  MOVLW  00
01078:  ADDWFC 03,W
0107A:  MOVWF  FEA
0107C:  MOVF   FEF,W
0107E:  SUBLW  0A
01080:  BZ    10EC
....................          SSIDAndKey[idxRE] = read_eeprom(idxRE+1); 
01082:  CLRF   03
01084:  MOVF   x69,W
01086:  ADDLW  C2
01088:  MOVWF  FE9
0108A:  MOVLW  00
0108C:  ADDWFC 03,W
0108E:  MOVWF  FEA
01090:  MOVLW  01
01092:  ADDWF  x69,W
01094:  MOVWF  x6C
01096:  MOVFF  FF2,16D
0109A:  BCF    FF2.7
0109C:  CLRF   FAA
0109E:  MOVFF  16C,FA9
010A2:  BCF    FA6.6
010A4:  BCF    FA6.7
010A6:  BSF    FA6.0
010A8:  MOVF   FA8,W
010AA:  BTFSC  x6D.7
010AC:  BSF    FF2.7
010AE:  MOVWF  FEF
....................          delay_ms(10); 
010B0:  MOVLW  0A
010B2:  MOVWF  xB0
010B4:  MOVLB  0
010B6:  RCALL  0AF8
....................          if(SSIDAndKey[idxRE]==0xFF){ 
010B8:  CLRF   03
010BA:  MOVLB  1
010BC:  MOVF   x69,W
010BE:  ADDLW  C2
010C0:  MOVWF  FE9
010C2:  MOVLW  00
010C4:  ADDWFC 03,W
010C6:  MOVWF  FEA
010C8:  INCFSZ FEF,W
010CA:  BRA    10D2
....................             resp = 5; 
010CC:  MOVLW  05
010CE:  MOVWF  x68
....................             break; 
010D0:  BRA    10EC
....................          } 
....................          if(SSIDAndKey[idxRE]==0x0A){ 
010D2:  CLRF   03
010D4:  MOVF   x69,W
010D6:  ADDLW  C2
010D8:  MOVWF  FE9
010DA:  MOVLW  00
010DC:  ADDWFC 03,W
010DE:  MOVWF  FEA
010E0:  MOVF   FEF,W
010E2:  SUBLW  0A
010E4:  BNZ   10E8
....................             break; 
010E6:  BRA    10EC
....................          } 
....................          idxRE++; 
010E8:  INCF   x69,F
010EA:  BRA    106E
....................       } 
....................       // Lanza el comando para conectarce a la red 
....................       if(resp!=5){ 
010EC:  MOVF   x68,W
010EE:  SUBLW  05
010F0:  BZ    1116
....................          fprintf(ESP8266, "AT+CWJAP=%s",SSIDAndKey);     /** AT+CWJAP="UNE_C06E","00986344200771" **/ 
010F2:  MOVLW  34
010F4:  MOVWF  FF6
010F6:  MOVLW  02
010F8:  MOVWF  FF7
010FA:  MOVLW  09
010FC:  MOVWF  xAF
010FE:  MOVLB  0
01100:  RCALL  0E44
01102:  CLRF   FEA
01104:  MOVLW  C2
01106:  MOVWF  FE9
01108:  RCALL  0F80
....................          CMD_RUN = CMD_CONN; 
0110A:  MOVLW  03
0110C:  MOVWF  5B
....................          resp    = waitResp(); 
0110E:  RCALL  0E90
01110:  MOVFF  01,168
01114:  MOVLB  1
....................       } 
....................  
....................       // Si no se establece una conexion se configura en modo AP 
....................       if(resp==4 || resp==5){ 
01116:  MOVF   x68,W
01118:  SUBLW  04
0111A:  BZ    1122
0111C:  MOVF   x68,W
0111E:  SUBLW  05
01120:  BNZ   1156
....................          fprintf(ESP8266, "AT+CWMODE=%c\r\n","3"); 
01122:  MOVLW  40
01124:  MOVWF  FF6
01126:  MOVLW  02
01128:  MOVWF  FF7
0112A:  MOVLW  0A
0112C:  MOVWF  xAF
0112E:  MOVLB  0
01130:  RCALL  0E44
01132:  MOVLB  4
01134:  MOVF   xC2,W
01136:  BTFSS  F9E.4
01138:  BRA    1136
0113A:  MOVWF  FAD
0113C:  MOVLW  0D
0113E:  BTFSS  F9E.4
01140:  BRA    113E
01142:  MOVWF  FAD
01144:  MOVLW  0A
01146:  BTFSS  F9E.4
01148:  BRA    1146
0114A:  MOVWF  FAD
....................          CMD_RUN = CMD_MODE; 
0114C:  MOVLW  01
0114E:  MOVWF  5B
....................          waitResp(); 
01150:  MOVLB  0
01152:  RCALL  0E90
01154:  MOVLB  1
....................       } 
....................    } // Fin del if(doConnect) 
....................  
....................    // Configura el modulo como server 
....................    fprintf(ESP8266, "AT+CIPMUX=1\r\n"); 
01156:  MOVLW  50
01158:  MOVWF  FF6
0115A:  MOVLW  02
0115C:  MOVWF  FF7
0115E:  MOVLB  0
01160:  RCALL  0E6E
....................    delay_ms(1000); 
01162:  MOVLW  04
01164:  MOVLB  1
01166:  MOVWF  x6A
01168:  MOVLW  FA
0116A:  MOVWF  xB0
0116C:  MOVLB  0
0116E:  RCALL  0AF8
01170:  MOVLB  1
01172:  DECFSZ x6A,F
01174:  BRA    1168
....................    fprintf(ESP8266, "AT+CIPSERVER=1,80\r\n"); 
01176:  MOVLW  5E
01178:  MOVWF  FF6
0117A:  MOVLW  02
0117C:  MOVWF  FF7
0117E:  MOVLB  0
01180:  RCALL  0E6E
....................    delay_ms(1000); 
01182:  MOVLW  04
01184:  MOVLB  1
01186:  MOVWF  x6A
01188:  MOVLW  FA
0118A:  MOVWF  xB0
0118C:  MOVLB  0
0118E:  RCALL  0AF8
01190:  MOVLB  1
01192:  DECFSZ x6A,F
01194:  BRA    1188
....................     
....................    CMD_RUN = READY_RESPONSE_WIFI; 
01196:  MOVLW  04
01198:  MOVWF  5B
0119A:  MOVLB  0
0119C:  GOTO   27AA (RETURN)
.................... } 
....................  
.................... /******************************************************** 
.................... Funcion encangada de procesar las respuestas del modulo,  
.................... debe ser llamada durante la interrupcion del USART 
.................... *********************************************************/ 
.................... void ESP8266_PROCCESS_RESPONSE(int buffer){ 
....................     // Seleciona la funcion de confirmacion de la respuesta 
....................     switch(CMD_RUN){ 
*
009E6:  MOVF   5B,W
009E8:  XORLW  01
009EA:  BZ    0A06
009EC:  XORLW  03
009EE:  BZ    0A14
009F0:  XORLW  01
009F2:  BZ    0A3E
009F4:  XORLW  06
009F6:  BZ    0A68
009F8:  XORLW  03
009FA:  BZ    0A7C
009FC:  XORLW  01
009FE:  BZ    0A90
00A00:  XORLW  03
00A02:  BZ    0AA4
00A04:  BRA    0AA4
....................             case CMD_MODE: 
....................                   waitRespMajor(buffer,Valid); 
00A06:  MOVFF  1B8,1B9
00A0A:  MOVLB  1
00A0C:  CLRF   xBA
00A0E:  MOVLB  0
00A10:  RCALL  0506
....................                   break; 
00A12:  BRA    0ACA
....................  
....................             case CMD_DO_CONN: 
....................                   // Evalua si la respuesta del ESP8266  
....................                   // es "No AP" o "CWJAP"   
....................                   waitRespMajor(buffer,NoAp); 
00A14:  MOVFF  1B8,1B9
00A18:  MOVLW  02
00A1A:  MOVLB  1
00A1C:  MOVWF  xBA
00A1E:  MOVLB  0
00A20:  RCALL  0506
....................                   waitRespMajor(buffer,CWJAP); 
00A22:  MOVFF  1B8,1B9
00A26:  MOVLW  01
00A28:  MOVLB  1
00A2A:  MOVWF  xBA
00A2C:  MOVLB  0
00A2E:  RCALL  0506
....................                   waitRespMajor(buffer,Valid); 
00A30:  MOVFF  1B8,1B9
00A34:  MOVLB  1
00A36:  CLRF   xBA
00A38:  MOVLB  0
00A3A:  RCALL  0506
....................                   break; 
00A3C:  BRA    0ACA
....................  
....................             case CMD_CONN: 
....................                   waitRespMajor(buffer,Connected); 
00A3E:  MOVFF  1B8,1B9
00A42:  MOVLW  03
00A44:  MOVLB  1
00A46:  MOVWF  xBA
00A48:  MOVLB  0
00A4A:  RCALL  0506
....................                   waitRespMajor(buffer,Fail); 
00A4C:  MOVFF  1B8,1B9
00A50:  MOVLW  04
00A52:  MOVLB  1
00A54:  MOVWF  xBA
00A56:  MOVLB  0
00A58:  RCALL  0506
....................                   waitRespMajor(buffer,Valid); 
00A5A:  MOVFF  1B8,1B9
00A5E:  MOVLB  1
00A60:  CLRF   xBA
00A62:  MOVLB  0
00A64:  RCALL  0506
....................                   break; 
00A66:  BRA    0ACA
....................              
....................             case CMD_GET_IP_FROM_MENU: 
....................                   getIP(buffer); 
00A68:  MOVFF  1B8,1B9
00A6C:  BRA    071C
....................                   waitRespMajor(buffer,Valid); 
00A6E:  MOVFF  1B8,1B9
00A72:  MOVLB  1
00A74:  CLRF   xBA
00A76:  MOVLB  0
00A78:  RCALL  0506
....................                   break; 
00A7A:  BRA    0ACA
....................                    
....................             case CMD_GET_AP_INFO_FROM_MENU: 
....................                   getAPInfo(buffer); 
00A7C:  MOVFF  1B8,1B9
00A80:  BRA    07EC
....................                   waitRespMajor(buffer,Valid); 
00A82:  MOVFF  1B8,1B9
00A86:  MOVLB  1
00A88:  CLRF   xBA
00A8A:  MOVLB  0
00A8C:  RCALL  0506
....................                   break; 
00A8E:  BRA    0ACA
....................              
....................             case CMD_GET_STA_INFO_FROM_MENU: 
....................                   getSTAInfo(buffer); 
00A90:  MOVFF  1B8,1B9
00A94:  BRA    0884
....................                   waitRespMajor(buffer,Valid); 
00A96:  MOVFF  1B8,1B9
00A9A:  MOVLB  1
00A9C:  CLRF   xBA
00A9E:  MOVLB  0
00AA0:  RCALL  0506
....................                   break; 
00AA2:  BRA    0ACA
....................                    
....................             case READY_RESPONSE_WIFI: 
....................             default: 
....................                   ESP8266_Get_IPD(buffer); 
00AA4:  MOVLB  1
00AA6:  CLRF   xBA
00AA8:  MOVFF  1B8,1B9
00AAC:  MOVLB  0
00AAE:  BRA    08C6
....................                   ESP8266_Get_CMD(buffer); 
00AB0:  MOVLB  1
00AB2:  CLRF   xBA
00AB4:  MOVFF  1B8,1B9
00AB8:  MOVLB  0
00ABA:  BRA    092E
....................                   ESP8266_Get_Data(buffer); 
00ABC:  MOVLB  1
00ABE:  CLRF   xBA
00AC0:  MOVFF  1B8,1B9
00AC4:  MOVLB  0
00AC6:  BRA    099A
....................              
....................                   CMD_RUN = 0x00; 
00AC8:  CLRF   5B
....................                   break; 
....................       } // Fin del switch (CMD_RUN) 
00ACA:  GOTO   0AE0 (RETURN)
.................... } // Fin Funcion ESP8266_PROCCESS_RESPONSE() 
....................  
.................... /********************************************************************* 
....................  *    Bloquea el programa en un while(1) esperando la interrupcion 
....................  *    USART hasta que la bandera flag_Resp_Valid=1 que indica el fin 
....................  *    del comando. retorna el valor de la constante de respuesta para 
....................  *    el comando lanzado. 
.................... **********************************************************************/ 
.................... int waitResp(void) 
*
00E90:  MOVLB  1
00E92:  CLRF   x6B
00E94:  CLRF   x6C
.................... { 
....................    int ret=0,idx=0; 
....................    // Si la bandera flag_Resp_Valid = 1 el_ 
....................    // fin del comando ESP8266 es OK  
....................    while(buffer_flag_Resp[resp_Flag][Valid]==0){ 
00E96:  MOVF   5D,W
00E98:  MULLW  06
00E9A:  MOVF   FF3,W
00E9C:  CLRF   x6E
00E9E:  MOVWF  x6D
00EA0:  MOVLW  5F
00EA2:  ADDWF  x6D,W
00EA4:  MOVWF  FE9
00EA6:  MOVLW  00
00EA8:  ADDWFC x6E,W
00EAA:  MOVWF  FEA
00EAC:  MOVF   FEF,F
00EAE:  BNZ   0F54
....................       idx++; 
00EB0:  INCF   x6C,F
....................       if(buffer_flag_Resp[resp_Flag][idx]==1){ 
00EB2:  MOVF   5D,W
00EB4:  MULLW  06
00EB6:  MOVF   FF3,W
00EB8:  CLRF   x6E
00EBA:  MOVWF  x6D
00EBC:  CLRF   03
00EBE:  MOVF   x6C,W
00EC0:  ADDWF  x6D,W
00EC2:  MOVWF  01
00EC4:  MOVF   x6E,W
00EC6:  ADDWFC 03,F
00EC8:  MOVF   01,W
00ECA:  ADDLW  5F
00ECC:  MOVWF  FE9
00ECE:  MOVLW  00
00ED0:  ADDWFC 03,W
00ED2:  MOVWF  FEA
00ED4:  DECFSZ FEF,W
00ED6:  BRA    0F4A
....................          buffer_flag_Resp[resp_Pos][idx]   = 0; 
00ED8:  MOVF   5C,W
00EDA:  MULLW  06
00EDC:  MOVF   FF3,W
00EDE:  CLRF   x6E
00EE0:  MOVWF  x6D
00EE2:  CLRF   03
00EE4:  MOVF   x6C,W
00EE6:  ADDWF  x6D,W
00EE8:  MOVWF  01
00EEA:  MOVF   x6E,W
00EEC:  ADDWFC 03,F
00EEE:  MOVF   01,W
00EF0:  ADDLW  5F
00EF2:  MOVWF  FE9
00EF4:  MOVLW  00
00EF6:  ADDWFC 03,W
00EF8:  MOVWF  FEA
00EFA:  CLRF   FEF
....................          buffer_flag_Resp[resp_Flag][idx]  = 0; 
00EFC:  MOVF   5D,W
00EFE:  MULLW  06
00F00:  MOVF   FF3,W
00F02:  CLRF   x6E
00F04:  MOVWF  x6D
00F06:  CLRF   03
00F08:  MOVF   x6C,W
00F0A:  ADDWF  x6D,W
00F0C:  MOVWF  01
00F0E:  MOVF   x6E,W
00F10:  ADDWFC 03,F
00F12:  MOVF   01,W
00F14:  ADDLW  5F
00F16:  MOVWF  FE9
00F18:  MOVLW  00
00F1A:  ADDWFC 03,W
00F1C:  MOVWF  FEA
00F1E:  CLRF   FEF
....................          
....................          if(idx == Fail || idx == Error){ 
00F20:  MOVF   x6C,W
00F22:  SUBLW  04
00F24:  BZ    0F2C
00F26:  MOVF   x6C,W
00F28:  SUBLW  05
00F2A:  BNZ   0F46
....................             buffer_flag_Resp[resp_Flag][Valid]  = 1; 
00F2C:  MOVF   5D,W
00F2E:  MULLW  06
00F30:  MOVF   FF3,W
00F32:  CLRF   x6E
00F34:  MOVWF  x6D
00F36:  MOVLW  5F
00F38:  ADDWF  x6D,W
00F3A:  MOVWF  FE9
00F3C:  MOVLW  00
00F3E:  ADDWFC x6E,W
00F40:  MOVWF  FEA
00F42:  MOVLW  01
00F44:  MOVWF  FEF
....................          } 
....................          ret = idx; 
00F46:  MOVFF  16C,16B
....................       } 
....................       // Reinicia el contador para no desbordar el array de flag_resp 
....................       if(idx>=countResp){ 
00F4A:  MOVF   5E,W
00F4C:  SUBWF  x6C,W
00F4E:  BNC   0F52
....................          idx = 0; 
00F50:  CLRF   x6C
....................       } 
00F52:  BRA    0E96
....................        
....................    }; // Fin del loop 
....................     
....................    buffer_flag_Resp[resp_Flag][Valid] = 0; 
00F54:  MOVF   5D,W
00F56:  MULLW  06
00F58:  MOVF   FF3,W
00F5A:  CLRF   x6E
00F5C:  MOVWF  x6D
00F5E:  MOVLW  5F
00F60:  ADDWF  x6D,W
00F62:  MOVWF  FE9
00F64:  MOVLW  00
00F66:  ADDWFC x6E,W
00F68:  MOVWF  FEA
00F6A:  CLRF   FEF
....................    CMD_RUN = 0x00; 
00F6C:  CLRF   5B
....................    delay_ms(10); 
00F6E:  MOVLW  0A
00F70:  MOVWF  xB0
00F72:  MOVLB  0
00F74:  RCALL  0AF8
....................    return ret; 
00F76:  MOVLB  1
00F78:  MOVFF  16B,01
00F7C:  MOVLB  0
00F7E:  RETURN 0
.................... } // Fin de la funcion waitResp 
....................  
.................... /****************************************************************** 
....................  *  
....................  *          ***    FUNCIONES DE VERIFICACION DE RESPUESTAS 
....................  
.................... El valor que es recibido como parametro lo compara con la 
.................... constante de final de comando  de respuesta esperada del modulo 
.................... ESP8266 si este caracter es encontrado aumenta la posicion del  
.................... siguiente caracter a leer, si el siguiente caracter recibido como  
.................... parametro no coincide con el caracter esperado reinicia el contador 
.................... y vuelve a empezar la comparacion desde el inicio de la constante  
.................... de final de comando o de respuesta esperada 
....................  
.................... POSCICION DE CARACTER:                        0   1   2    3 
.................... RESPUESTA ESPERADA:    ESP8266_RESP_OK[4] = {'O','K',0x0D,0x0A} 
....................  
.................... *******************************************************************/ 
.................... void waitRespMajor(int buffer,int flag_resp) 
*
00506:  MOVLB  1
00508:  CLRF   xC5
0050A:  CLRF   xC6
.................... { 
....................     
....................    char  strResp[10]; 
....................    int   lenResp = 0,restartFlag = 0; 
....................  
....................    switch(flag_resp) 
0050C:  MOVF   xBA,W
0050E:  ADDLW  FB
00510:  BTFSC  FD8.0
00512:  BRA    05F8
00514:  ADDLW  05
00516:  MOVLB  0
00518:  GOTO   06F8
....................    { 
....................       case Valid: 
....................          strResp = "OK\r\n"; 
0051C:  MOVLW  01
0051E:  MOVWF  FEA
00520:  MOVLW  BB
00522:  MOVWF  FE9
00524:  MOVFF  FF2,1C7
00528:  BCF    FF2.7
0052A:  MOVLW  00
0052C:  RCALL  00EA
0052E:  TBLRD*-
00530:  TBLRD*+
00532:  MOVF   FF5,W
00534:  MOVWF  FEE
00536:  IORLW  00
00538:  BNZ   0530
0053A:  MOVLB  1
0053C:  BTFSC  xC7.7
0053E:  BSF    FF2.7
....................          lenResp = 4; 
00540:  MOVLW  04
00542:  MOVWF  xC5
....................          // Como esta funcion es el ultimo caracter recibido no es necesario mantener 
....................          // Activa la bandera flag_Resp_Valid 
....................          restartFlag = 1; 
00544:  MOVLW  01
00546:  MOVWF  xC6
....................          break; 
00548:  BRA    05F8
....................  
....................       case NoAp: 
....................          strResp = "No Ap"; 
0054A:  MOVLW  01
0054C:  MOVWF  FEA
0054E:  MOVLW  BB
00550:  MOVWF  FE9
00552:  MOVFF  FF2,1C7
00556:  BCF    FF2.7
00558:  MOVLW  00
0055A:  RCALL  0100
0055C:  TBLRD*-
0055E:  TBLRD*+
00560:  MOVF   FF5,W
00562:  MOVWF  FEE
00564:  IORLW  00
00566:  BNZ   055E
00568:  MOVLB  1
0056A:  BTFSC  xC7.7
0056C:  BSF    FF2.7
....................          lenResp = 5; 
0056E:  MOVLW  05
00570:  MOVWF  xC5
....................          break; 
00572:  BRA    05F8
....................  
....................       case CWJAP: 
....................          strResp = "+CWJAP:"; 
00574:  MOVLW  01
00576:  MOVWF  FEA
00578:  MOVLW  BB
0057A:  MOVWF  FE9
0057C:  MOVFF  FF2,1C7
00580:  BCF    FF2.7
00582:  MOVLW  00
00584:  RCALL  0116
00586:  TBLRD*-
00588:  TBLRD*+
0058A:  MOVF   FF5,W
0058C:  MOVWF  FEE
0058E:  IORLW  00
00590:  BNZ   0588
00592:  MOVLB  1
00594:  BTFSC  xC7.7
00596:  BSF    FF2.7
....................          lenResp = 7; 
00598:  MOVLW  07
0059A:  MOVWF  xC5
....................          break; 
0059C:  BRA    05F8
....................           
....................       case Connected: 
....................          strResp = "CONNECTED"; 
0059E:  MOVLW  01
005A0:  MOVWF  FEA
005A2:  MOVLW  BB
005A4:  MOVWF  FE9
005A6:  MOVFF  FF2,1C7
005AA:  BCF    FF2.7
005AC:  MOVLW  00
005AE:  RCALL  012E
005B0:  TBLRD*-
005B2:  TBLRD*+
005B4:  MOVF   FF5,W
005B6:  MOVWF  FEE
005B8:  IORLW  00
005BA:  BNZ   05B2
005BC:  MOVLB  1
005BE:  BTFSC  xC7.7
005C0:  BSF    FF2.7
....................          lenResp = 9; 
005C2:  MOVLW  09
005C4:  MOVWF  xC5
....................          break; 
005C6:  BRA    05F8
....................        
....................       case Fail: 
....................          strResp = "FAIL"; 
005C8:  MOVLW  01
005CA:  MOVWF  FEA
005CC:  MOVLW  BB
005CE:  MOVWF  FE9
005D0:  MOVFF  FF2,1C7
005D4:  BCF    FF2.7
005D6:  MOVLW  00
005D8:  RCALL  0148
005DA:  TBLRD*-
005DC:  TBLRD*+
005DE:  MOVF   FF5,W
005E0:  MOVWF  FEE
005E2:  IORLW  00
005E4:  BNZ   05DC
005E6:  MOVLB  1
005E8:  BTFSC  xC7.7
005EA:  BSF    FF2.7
....................          lenResp = 4; 
005EC:  MOVLW  04
005EE:  MOVWF  xC5
....................          restartFlag = 1; 
005F0:  MOVLW  01
005F2:  MOVWF  xC6
....................          break; 
005F4:  BRA    05F8
005F6:  MOVLB  1
....................    } 
....................  
....................    // Si el caracter pasado por argumento se encuentra en la posicion de la  
....................    // constante de respuesta entonces aumenta la bandera de lo contrario la 
....................    // reinicia 
....................  
....................    if(buffer == strResp[buffer_flag_Resp[resp_Pos][flag_resp]]) 
005F8:  MOVF   5C,W
005FA:  MULLW  06
005FC:  MOVF   FF3,W
005FE:  CLRF   xC8
00600:  MOVWF  xC7
00602:  CLRF   03
00604:  MOVF   xBA,W
00606:  ADDWF  xC7,W
00608:  MOVWF  01
0060A:  MOVF   xC8,W
0060C:  ADDWFC 03,F
0060E:  MOVF   01,W
00610:  ADDLW  5F
00612:  MOVWF  FE9
00614:  MOVLW  00
00616:  ADDWFC 03,W
00618:  MOVWF  FEA
0061A:  CLRF   03
0061C:  MOVF   FEF,W
0061E:  ADDLW  BB
00620:  MOVWF  FE9
00622:  MOVLW  01
00624:  ADDWFC 03,W
00626:  MOVWF  FEA
00628:  MOVF   FEF,W
0062A:  SUBWF  xB9,W
0062C:  BNZ   06A8
....................    { 
....................       // Aumenta el valor de la bandera hasta que alcance el tamao del buffer  
....................       // de respuesta, cuando esto suscede indica que la respuesta es valida 
....................       buffer_flag_Resp[resp_Pos][flag_resp]++; 
0062E:  MOVF   5C,W
00630:  MULLW  06
00632:  MOVF   FF3,W
00634:  CLRF   xC8
00636:  MOVWF  xC7
00638:  CLRF   03
0063A:  MOVF   xBA,W
0063C:  ADDWF  xC7,W
0063E:  MOVWF  01
00640:  MOVF   xC8,W
00642:  ADDWFC 03,F
00644:  MOVF   01,W
00646:  ADDLW  5F
00648:  MOVWF  FE9
0064A:  MOVLW  00
0064C:  ADDWFC 03,W
0064E:  MOVWF  FEA
00650:  INCF   FEF,F
....................        
....................       if(buffer_flag_Resp[resp_Pos][flag_resp]==lenResp){ 
00652:  MOVF   5C,W
00654:  MULLW  06
00656:  MOVF   FF3,W
00658:  CLRF   xC8
0065A:  MOVWF  xC7
0065C:  CLRF   03
0065E:  MOVF   xBA,W
00660:  ADDWF  xC7,W
00662:  MOVWF  01
00664:  MOVF   xC8,W
00666:  ADDWFC 03,F
00668:  MOVF   01,W
0066A:  ADDLW  5F
0066C:  MOVWF  FE9
0066E:  MOVLW  00
00670:  ADDWFC 03,W
00672:  MOVWF  FEA
00674:  MOVF   xC5,W
00676:  SUBWF  FEF,W
00678:  BNZ   06A2
....................          // Respuesta es valida 
....................          buffer_flag_Resp[resp_Flag][flag_resp]  = 1; 
0067A:  MOVF   5D,W
0067C:  MULLW  06
0067E:  MOVF   FF3,W
00680:  CLRF   xC8
00682:  MOVWF  xC7
00684:  CLRF   03
00686:  MOVF   xBA,W
00688:  ADDWF  xC7,W
0068A:  MOVWF  01
0068C:  MOVF   xC8,W
0068E:  ADDWFC 03,F
00690:  MOVF   01,W
00692:  ADDLW  5F
00694:  MOVWF  FE9
00696:  MOVLW  00
00698:  ADDWFC 03,W
0069A:  MOVWF  FEA
0069C:  MOVLW  01
0069E:  MOVWF  FEF
....................       }else if(flag_resp == Valid) { 
006A0:  BRA    06A6
006A2:  MOVF   xBA,F
006A4:  BNZ   06A6
....................          // Reinicia la bandera para indicar el final del comando 
....................           //buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
....................       } 
....................         
....................    }else{ 
006A6:  BRA    06F4
....................       // Si el caracter no se encuentra dentro de la cadena de la constante 
....................       // entonces reinicia las banderas de respuesta 
....................       buffer_flag_Resp[resp_Pos][flag_resp]   = 0; 
006A8:  MOVF   5C,W
006AA:  MULLW  06
006AC:  MOVF   FF3,W
006AE:  CLRF   xC8
006B0:  MOVWF  xC7
006B2:  CLRF   03
006B4:  MOVF   xBA,W
006B6:  ADDWF  xC7,W
006B8:  MOVWF  01
006BA:  MOVF   xC8,W
006BC:  ADDWFC 03,F
006BE:  MOVF   01,W
006C0:  ADDLW  5F
006C2:  MOVWF  FE9
006C4:  MOVLW  00
006C6:  ADDWFC 03,W
006C8:  MOVWF  FEA
006CA:  CLRF   FEF
....................  
....................       // Banderas que se reinician 
....................       if(restartFlag == 1){ 
006CC:  DECFSZ xC6,W
006CE:  BRA    06F4
....................          buffer_flag_Resp[resp_Flag][flag_resp] = 0; 
006D0:  MOVF   5D,W
006D2:  MULLW  06
006D4:  MOVF   FF3,W
006D6:  CLRF   xC8
006D8:  MOVWF  xC7
006DA:  CLRF   03
006DC:  MOVF   xBA,W
006DE:  ADDWF  xC7,W
006E0:  MOVWF  01
006E2:  MOVF   xC8,W
006E4:  ADDWFC 03,F
006E6:  MOVF   01,W
006E8:  ADDLW  5F
006EA:  MOVWF  FE9
006EC:  MOVLW  00
006EE:  ADDWFC 03,W
006F0:  MOVWF  FEA
006F2:  CLRF   FEF
....................       } 
....................        
....................    } 
006F4:  MOVLB  0
006F6:  RETURN 0
.................... } 
....................  
.................... /********************************************************* 
....................  *    Obtiene la IP del modo AP, STA, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getIP(int buffer) 
.................... { 
....................    const int END_GET_IP_CMD = 6; 
....................     
....................    // bandera de IP_First esta habilita 
....................    if(flag_Resp_Get_IP_CMD==1){ 
*
0071C:  DECFSZ xBB,W
0071E:  BRA    0776
....................       // Fin de Get First IP 
....................       if(buffer == '"'){ 
00720:  MOVLB  1
00722:  MOVF   xB9,W
00724:  SUBLW  22
00726:  BNZ   0744
....................          // Finaliza el almacenamiento en el buffer 
....................          if( modeStar=='1' || modeStar=='2' ){ 
00728:  MOVLB  0
0072A:  MOVF   xC1,W
0072C:  SUBLW  31
0072E:  BZ    0736
00730:  MOVF   xC1,W
00732:  SUBLW  32
00734:  BNZ   073E
....................             flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
00736:  MOVLW  06
00738:  MOVWF  xBB
....................             flag_Pos_Get_IP_CMD =0; 
0073A:  CLRF   xBC
....................          }else{ 
0073C:  BRA    0740
....................             // Activa Bandera de IP_STACION, reinicia el contador de Pos 
....................             flag_Pos_Get_IP_CMD =0; 
0073E:  CLRF   xBC
....................          } 
....................  
....................       }else{ 
00740:  BRA    0774
00742:  MOVLB  1
....................          if(modeStar=='1'){ 
00744:  MOVLB  0
00746:  MOVF   xC1,W
00748:  SUBLW  31
0074A:  BNZ   0760
....................             // IP Estacion 
....................             buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
0074C:  CLRF   03
0074E:  MOVF   xBC,W
00750:  ADDLW  7B
00752:  MOVWF  FE9
00754:  MOVLW  00
00756:  ADDWFC 03,W
00758:  MOVWF  FEA
0075A:  MOVFF  1B9,FEF
....................          }else{ 
0075E:  BRA    0772
....................             // IP AP 
....................              buffer_Resp_CMD[0][flag_Pos_Get_IP_CMD] = buffer; 
00760:  CLRF   03
00762:  MOVF   xBC,W
00764:  ADDLW  6B
00766:  MOVWF  FE9
00768:  MOVLW  00
0076A:  ADDWFC 03,W
0076C:  MOVWF  FEA
0076E:  MOVFF  1B9,FEF
....................          } 
....................          flag_Pos_Get_IP_CMD++; 
00772:  INCF   xBC,F
....................       } // Fin del if(buffer == '"') 
....................     
....................    // bandera de IP_Second(Estacion) esta habilita 
....................    }else if(flag_Resp_Get_IP_CMD==5){ 
00774:  BRA    07A6
00776:  MOVF   xBB,W
00778:  SUBLW  05
0077A:  BNZ   07A6
....................        if(buffer == '"'){ 
0077C:  MOVLB  1
0077E:  MOVF   xB9,W
00780:  SUBLW  22
00782:  BNZ   0790
....................          flag_Resp_Get_IP_CMD=END_GET_IP_CMD; 
00784:  MOVLW  06
00786:  MOVLB  0
00788:  MOVWF  xBB
....................          flag_Pos_Get_IP_CMD =0; 
0078A:  CLRF   xBC
....................        }else{ 
0078C:  BRA    07A6
0078E:  MOVLB  1
....................          buffer_Resp_CMD[1][flag_Pos_Get_IP_CMD] = buffer; 
00790:  CLRF   03
00792:  MOVLB  0
00794:  MOVF   xBC,W
00796:  ADDLW  7B
00798:  MOVWF  FE9
0079A:  MOVLW  00
0079C:  ADDWFC 03,W
0079E:  MOVWF  FEA
007A0:  MOVFF  1B9,FEF
....................          flag_Pos_Get_IP_CMD++; 
007A4:  INCF   xBC,F
....................        } 
....................    } // Fin de if(flag_Resp_Get_IP_CMD) 
....................        
....................    if( buffer == '"'){ 
007A6:  MOVLB  1
007A8:  MOVF   xB9,W
007AA:  SUBLW  22
007AC:  BNZ   07C2
....................       switch(flag_Resp_Get_IP_CMD){ 
007AE:  MOVLB  0
007B0:  MOVF   xBB,W
007B2:  ADDLW  FB
007B4:  BC    07C0
007B6:  ADDLW  05
007B8:  GOTO   07C8
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................          case 4: 
....................             flag_Resp_Get_IP_CMD++; 
007BC:  INCF   xBB,F
....................             flag_Pos_Get_IP_CMD =0; 
007BE:  CLRF   xBC
....................             break; 
007C0:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
007C2:  MOVLB  0
007C4:  GOTO   0A6E (RETURN)
.................... } // Fin de la funcion getIP() 
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo AP, AP+STA 
....................  *     
....................  *********************************************************/ 
.................... void getAPInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_AP_Info_CMD==1){ 
*
007EC:  DECFSZ xBD,W
007EE:  BRA    0814
....................        
....................       if(buffer != '"'){ 
007F0:  MOVLB  1
007F2:  MOVF   xB9,W
007F4:  SUBLW  22
007F6:  BZ    0810
....................          buffer_Resp_CMD[2][flag_Pos_Get_AP_Info_CMD] = buffer; 
007F8:  CLRF   03
007FA:  MOVLB  0
007FC:  MOVF   xBE,W
007FE:  ADDLW  8B
00800:  MOVWF  FE9
00802:  MOVLW  00
00804:  ADDWFC 03,W
00806:  MOVWF  FEA
00808:  MOVFF  1B9,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
0080C:  INCF   xBE,F
0080E:  MOVLB  1
....................       } 
....................  
....................    }else if(flag_Resp_Get_AP_Info_CMD==3){ 
00810:  BRA    0842
00812:  MOVLB  0
00814:  MOVF   xBD,W
00816:  SUBLW  03
00818:  BNZ   0840
....................        
....................       if(buffer != '"'){ 
0081A:  MOVLB  1
0081C:  MOVF   xB9,W
0081E:  SUBLW  22
00820:  BZ    083C
....................          buffer_Resp_CMD[3][flag_Pos_Get_AP_Info_CMD] = buffer; 
00822:  CLRF   03
00824:  MOVLB  0
00826:  MOVF   xBE,W
00828:  ADDLW  9B
0082A:  MOVWF  FE9
0082C:  MOVLW  00
0082E:  ADDWFC 03,W
00830:  MOVWF  FEA
00832:  MOVFF  1B9,FEF
....................          flag_Pos_Get_AP_Info_CMD++; 
00836:  INCF   xBE,F
....................       }else{ 
00838:  BRA    0840
0083A:  MOVLB  1
....................          flag_Pos_Get_AP_Info_CMD =0; 
0083C:  MOVLB  0
0083E:  CLRF   xBE
00840:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
00842:  MOVF   xB9,W
00844:  SUBLW  22
00846:  BNZ   085C
....................       switch(flag_Resp_Get_AP_Info_CMD){ 
00848:  MOVLB  0
0084A:  MOVF   xBD,W
0084C:  ADDLW  FC
0084E:  BC    085A
00850:  ADDLW  04
00852:  GOTO   0862
....................          case 0: 
....................          case 1: 
....................          case 2: 
....................          case 3: 
....................             flag_Resp_Get_AP_Info_CMD++; 
00856:  INCF   xBD,F
....................             flag_Pos_Get_AP_Info_CMD =0; 
00858:  CLRF   xBE
....................             break; 
0085A:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_IP_CMD) 
....................    } // Fin del if(buffer == '"')  
0085C:  MOVLB  0
0085E:  GOTO   0A82 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************* 
....................  *    Obtiene la SSID del modo STA 
....................  *     
....................  *********************************************************/ 
.................... void getSTAInfo(int buffer) 
.................... { 
....................    // bandera de AP_First_Data esta habilitado 
....................    if(flag_Resp_Get_STA_Info_CMD==1){ 
*
00884:  DECFSZ xBF,W
00886:  BRA    08A6
....................        
....................       if(buffer != '"'){ 
00888:  MOVLB  1
0088A:  MOVF   xB9,W
0088C:  SUBLW  22
0088E:  BZ    08A8
....................          buffer_Resp_CMD[4][flag_Pos_Get_STA_Info_CMD] = buffer; 
00890:  CLRF   03
00892:  MOVLB  0
00894:  MOVF   xC0,W
00896:  ADDLW  AB
00898:  MOVWF  FE9
0089A:  MOVLW  00
0089C:  ADDWFC 03,W
0089E:  MOVWF  FEA
008A0:  MOVFF  1B9,FEF
....................          flag_Pos_Get_STA_Info_CMD++; 
008A4:  INCF   xC0,F
008A6:  MOVLB  1
....................       } 
....................    } 
....................     
....................    if( buffer == '"'){ 
008A8:  MOVF   xB9,W
008AA:  SUBLW  22
008AC:  BNZ   08C0
....................       switch(flag_Resp_Get_STA_Info_CMD){ 
008AE:  MOVLB  0
008B0:  MOVF   xBF,W
008B2:  BZ    08BA
008B4:  XORLW  01
008B6:  BZ    08BA
008B8:  BRA    08BE
....................          case 0: 
....................          case 1: 
....................             flag_Resp_Get_STA_Info_CMD++; 
008BA:  INCF   xBF,F
....................             flag_Pos_Get_STA_Info_CMD =0; 
008BC:  CLRF   xC0
....................             break; 
008BE:  MOVLB  1
....................       } // Fin del switch(flag_Resp_Get_STA_Info_CMD) 
....................    } // Fin del if(buffer == '"')  
008C0:  MOVLB  0
008C2:  GOTO   0A96 (RETURN)
.................... } 
....................  
.................... #include "header/menu.h" 
.................... /** VARIABLES EXTERNAL **/ 
.................... #define BEEP  Sound(1209,20) 
....................  
.................... /** DIRECTIVAS **/ 
.................... #define MENU_START  0 
.................... #define MENU_ON     1 
.................... #define MENU_OFF    2 
.................... #define MENU_SETUP  3 
....................  
....................   /** DIRECTIVAS SUBMENU SETUP**/ 
....................   #define OPT_SHOW_STA_IP     0 
....................   #define OPT_SHOW_STA_SSID   1 
....................   #define OPT_SHOW_AP_SSID    2 
....................   #define OPT_SHOW_AP_KEY     3 
....................   #define OPT_SHOW_AP_IP      4 
....................   #define OPT_MODE_AP         5 
....................   #define OPT_BACKLIGH        6 
....................   #define OPT_EXIT            7 
....................  
....................     /** DIRECTIVAS SUBMENU CONF_ACCESS_RED **/ 
....................     #define MODE_CLIENT     0 
....................     #define MODE_AP         1 
....................     #define MODE_CLIENT_AP  2 
....................  
.................... //Contiene las opciones del menu principal [pos][lenString] 
.................... const char  optMenuStart[4][16]    =  { {"Encender Manual"}, 
....................                                         {"Apagado Manual "}, 
....................                                         {"Configuracion  "} 
....................                                       }; 
....................                                        
.................... //Contiene las opciones del menu Encender [pos][lenString] 
.................... char  optMenuOn[10][11]; 
....................  
.................... //Contiene las opciones del menu Configuracion [pos][lenString] 
.................... const char  optMenuSetup[9][17]    =  { {"ESTACION IP     "}, 
....................                                         {"ESTACION SSID   "}, 
....................                                         {"AP SSID         "}, 
....................                                         {"AP KEY          "}, 
....................                                         {"AP IP           "}, 
....................                                         {"Conf Accesso Red"}, 
....................                                         {"On/Off Backlight"}, 
....................                                         {"SALIR           "} 
....................                                       }; 
....................  
.................... //Contiene las opciones del subMenu CONF_ACCESS_RED [pos][lenString] 
.................... const char  optMenuModo[5][14]    =   { {"Estacin     "}, 
....................                                         {"Access Point "}, 
....................                                         {"Estacion + AP"}, 
....................                                         {"SALIR        "} 
....................                                       };    
....................  
.................... /* Declaracion de Funciones */ 
.................... int   getMenuStart(void); 
.................... void  pressExit(void); 
.................... void  showBottonMenu(void); 
.................... int   getMenuOn(void); 
.................... int   getMenuOff(void); 
.................... int   getMenuSetup(void); 
.................... void  executeSetup(int optSelect); 
.................... void  setMenuModo(void); 
....................  
.................... /** VARIABLES GENERALS **/ 
.................... int8 countOptMenuStart  = 2; 
.................... int8 countOptMenuOn     = 8; 
.................... int8 countOptMenuOff    = 8; 
.................... int8 countOptMenuSetup  = 7; 
.................... // Numero de opciones SubMenu Modo 
.................... int8 countOptMenuModo = 3; 
....................  
....................  
.................... /*************************************************** 
....................    Carga el nombre de las opciones del menu On y Off 
.................... ***************************************************/ 
.................... void getNameMenusOutput(){ 
*
00B20:  MOVLB  1
00B22:  CLRF   x68
....................    int posIni = 0; 
....................       
....................    for(int idx=0;idx<8;idx++){ 
00B24:  CLRF   x69
00B26:  MOVF   x69,W
00B28:  SUBLW  07
00B2A:  BNC   0B92
....................        
....................       posIni =( 10 * idx ) + 40; 
00B2C:  MOVF   x69,W
00B2E:  MULLW  0A
00B30:  MOVF   FF3,W
00B32:  ADDLW  28
00B34:  MOVWF  x68
....................        
....................       for(int idxChar=0;idxChar<=9;idxChar++){ 
00B36:  CLRF   x6A
00B38:  MOVF   x6A,W
00B3A:  SUBLW  09
00B3C:  BNC   0B8E
....................          optMenuOn[idx][idxChar]=read_eeprom(posIni+idxChar); 
00B3E:  MOVF   x69,W
00B40:  MULLW  0B
00B42:  MOVF   FF3,W
00B44:  CLRF   x6C
00B46:  MOVWF  x6B
00B48:  CLRF   03
00B4A:  MOVF   x6A,W
00B4C:  ADDWF  x6B,W
00B4E:  MOVWF  01
00B50:  MOVF   x6C,W
00B52:  ADDWFC 03,F
00B54:  MOVF   01,W
00B56:  ADDLW  F4
00B58:  MOVWF  FE9
00B5A:  MOVLW  00
00B5C:  ADDWFC 03,W
00B5E:  MOVWF  FEA
00B60:  MOVF   x6A,W
00B62:  ADDWF  x68,W
00B64:  MOVWF  x6D
00B66:  MOVFF  FF2,16E
00B6A:  BCF    FF2.7
00B6C:  CLRF   FAA
00B6E:  MOVFF  16D,FA9
00B72:  BCF    FA6.6
00B74:  BCF    FA6.7
00B76:  BSF    FA6.0
00B78:  MOVF   FA8,W
00B7A:  BTFSC  x6E.7
00B7C:  BSF    FF2.7
00B7E:  MOVWF  FEF
....................          delay_ms(10); 
00B80:  MOVLW  0A
00B82:  MOVWF  xB0
00B84:  MOVLB  0
00B86:  RCALL  0AF8
00B88:  MOVLB  1
00B8A:  INCF   x6A,F
00B8C:  BRA    0B38
....................       } 
00B8E:  INCF   x69,F
00B90:  BRA    0B26
....................    } 
....................     
....................    optMenuOn[8][0]='\f'; 
00B92:  MOVLW  0C
00B94:  MOVWF  x4C
....................    optMenuOn[8][1]='S'; 
00B96:  MOVLW  53
00B98:  MOVWF  x4D
....................    optMenuOn[8][2]='A'; 
00B9A:  MOVLW  41
00B9C:  MOVWF  x4E
....................    optMenuOn[8][3]='L'; 
00B9E:  MOVLW  4C
00BA0:  MOVWF  x4F
....................    optMenuOn[8][4]='I'; 
00BA2:  MOVLW  49
00BA4:  MOVWF  x50
....................    optMenuOn[8][5]='R'; 
00BA6:  MOVLW  52
00BA8:  MOVWF  x51
00BAA:  MOVLB  0
00BAC:  GOTO   2786 (RETURN)
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_START 
.................... ***************************************************/ 
.................... int getMenuStart(void){ 
*
01D26:  MOVLB  1
01D28:  CLRF   x68
01D2A:  CLRF   x69
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
01D2C:  MOVF   x68,W
01D2E:  MULLW  10
01D30:  MOVF   FF3,W
01D32:  CLRF   03
01D34:  MOVWF  x6A
01D36:  MOVLW  0C
01D38:  MOVWF  x70
01D3A:  MOVLB  0
01D3C:  CALL   0DB8
01D40:  MOVLW  72
01D42:  MOVWF  FF6
01D44:  MOVLW  02
01D46:  MOVWF  FF7
01D48:  MOVLB  1
01D4A:  MOVF   x6A,W
01D4C:  ADDWF  FF6,F
01D4E:  MOVLW  00
01D50:  ADDWFC FF7,F
01D52:  MOVLB  0
01D54:  CALL   0E24
....................    showBottonMenu(); 
01D58:  CALL   11A0
....................    while(!exit){ 
01D5C:  MOVLB  1
01D5E:  MOVF   x69,F
01D60:  BNZ   1E0C
....................        
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01D62:  MOVLB  0
01D64:  CALL   12A6
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01D68:  BSF    F93.4
01D6A:  BTFSC  F81.4
01D6C:  BRA    1DD2
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01D6E:  MOVLW  02
01D70:  MOVLB  1
01D72:  MOVWF  x6A
01D74:  MOVLW  FA
01D76:  MOVWF  xB0
01D78:  MOVLB  0
01D7A:  CALL   0AF8
01D7E:  MOVLB  1
01D80:  DECFSZ x6A,F
01D82:  BRA    1D74
....................          BEEP; 
01D84:  MOVLW  04
01D86:  MOVWF  x6E
01D88:  MOVLW  B9
01D8A:  MOVWF  x6D
01D8C:  CLRF   x70
01D8E:  MOVLW  14
01D90:  MOVWF  x6F
01D92:  MOVLB  0
01D94:  RCALL  1BDE
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
01D96:  MOVLB  1
01D98:  INCF   x68,F
....................           
....................          // Si la opcion seleccionada esta en el limite menos uno de las 
....................          // opciones entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuStart)){ 
01D9A:  MOVF   x68,W
01D9C:  SUBWF  x62,W
01D9E:  BC    1DA2
....................             optSelected = 0; 
01DA0:  CLRF   x68
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuStart[optSelected]); 
01DA2:  MOVF   x68,W
01DA4:  MULLW  10
01DA6:  MOVF   FF3,W
01DA8:  CLRF   03
01DAA:  MOVWF  x6A
01DAC:  MOVLW  0C
01DAE:  MOVWF  x70
01DB0:  MOVLB  0
01DB2:  CALL   0DB8
01DB6:  MOVLW  72
01DB8:  MOVWF  FF6
01DBA:  MOVLW  02
01DBC:  MOVWF  FF7
01DBE:  MOVLB  1
01DC0:  MOVF   x6A,W
01DC2:  ADDWF  FF6,F
01DC4:  MOVLW  00
01DC6:  ADDWFC FF7,F
01DC8:  MOVLB  0
01DCA:  CALL   0E24
....................          showBottonMenu(); 
01DCE:  CALL   11A0
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01DD2:  BSF    F93.5
01DD4:  BTFSC  F81.5
01DD6:  BRA    1E08
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01DD8:  MOVLW  02
01DDA:  MOVLB  1
01DDC:  MOVWF  x6A
01DDE:  MOVLW  FA
01DE0:  MOVWF  xB0
01DE2:  MOVLB  0
01DE4:  CALL   0AF8
01DE8:  MOVLB  1
01DEA:  DECFSZ x6A,F
01DEC:  BRA    1DDE
....................          BEEP; 
01DEE:  MOVLW  04
01DF0:  MOVWF  x6E
01DF2:  MOVLW  B9
01DF4:  MOVWF  x6D
01DF6:  CLRF   x70
01DF8:  MOVLW  14
01DFA:  MOVWF  x6F
01DFC:  MOVLB  0
01DFE:  RCALL  1BDE
....................          // Rompe el Loop 
....................          exit = 1; 
01E00:  MOVLW  01
01E02:  MOVLB  1
01E04:  MOVWF  x69
01E06:  MOVLB  0
....................       } // Fin KEY_OK 
01E08:  BRA    1D5C
01E0A:  MOVLB  1
....................    } // FIN While Infinito 
....................  
....................    return optSelected+1; 
01E0C:  MOVLW  01
01E0E:  ADDWF  x68,W
01E10:  MOVWF  01
01E12:  MOVLB  0
01E14:  GOTO   27BE (RETURN)
.................... } // Fin funcion getMenuStart 
....................  
.................... /*************************************************** 
.................... Pausa el programa hasta que se presione OK 
.................... ***************************************************/ 
.................... void pressExit(void){ 
....................   lcd_gotoxy(12,2); 
*
0210A:  MOVLW  0C
0210C:  MOVLB  1
0210E:  MOVWF  x71
02110:  MOVLW  02
02112:  MOVWF  x72
02114:  MOVLB  0
02116:  CALL   0D92
....................   printf(lcd_putc, "SALIR"); 
0211A:  MOVLW  92
0211C:  MOVWF  FF6
0211E:  MOVLW  03
02120:  MOVWF  FF7
02122:  CALL   0E24
....................    
....................   while(1){ 
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02126:  CALL   12A6
....................       /********************************************/ 
....................        
....................      if(input(KEY_OK)==0){ 
0212A:  BSF    F93.5
0212C:  BTFSC  F81.5
0212E:  BRA    214A
....................            // Elimina el rebote 
....................            delay_ms(500); 
02130:  MOVLW  02
02132:  MOVLB  1
02134:  MOVWF  x6D
02136:  MOVLW  FA
02138:  MOVWF  xB0
0213A:  MOVLB  0
0213C:  CALL   0AF8
02140:  MOVLB  1
02142:  DECFSZ x6D,F
02144:  BRA    2136
....................            break; 
02146:  BRA    214E
02148:  MOVLB  0
....................      } 
0214A:  BRA    2126
0214C:  MOVLB  1
....................   } 
0214E:  MOVLB  0
02150:  RETURN 0
.................... } 
.................... /*************************************************** 
.................... Dibuja en la parte inferior del Display los botones de 
.................... Siguiente y Entrar 
.................... ***************************************************/ 
.................... void showBottonMenu(void){ 
....................   lcd_gotoxy(1,2); 
*
011A0:  MOVLW  01
011A2:  MOVLB  1
011A4:  MOVWF  x71
011A6:  MOVLW  02
011A8:  MOVWF  x72
011AA:  MOVLB  0
011AC:  RCALL  0D92
....................   printf(lcd_putc, "[SIG]      [ENT]"); 
011AE:  MOVLW  98
011B0:  MOVWF  FF6
011B2:  MOVLW  03
011B4:  MOVWF  FF7
011B6:  RCALL  0E24
011B8:  RETURN 0
.................... } 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_ON 
.................... ***************************************************/ 
.................... int getMenuOn(void){ 
*
01E68:  MOVLB  1
01E6A:  CLRF   x68
01E6C:  CLRF   x69
....................    int optSelected = 0; 
....................    int exit = 0; 
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\fOn -> %s",optMenuOn[optSelected]); 
01E6E:  MOVF   x68,W
01E70:  MULLW  0B
01E72:  MOVF   FF3,W
01E74:  CLRF   03
01E76:  ADDLW  F4
01E78:  MOVWF  01
01E7A:  MOVLW  00
01E7C:  ADDWFC 03,F
01E7E:  MOVFF  01,16A
01E82:  MOVFF  03,16B
01E86:  MOVLW  AA
01E88:  MOVWF  FF6
01E8A:  MOVLW  03
01E8C:  MOVWF  FF7
01E8E:  MOVLW  07
01E90:  MOVWF  x6C
01E92:  MOVLB  0
01E94:  RCALL  1E18
01E96:  MOVFF  16B,FEA
01E9A:  MOVFF  16A,FE9
01E9E:  RCALL  1E42
....................    showBottonMenu(); 
01EA0:  CALL   11A0
....................     
....................    while(!exit){ 
01EA4:  MOVLB  1
01EA6:  MOVF   x69,F
01EA8:  BTFSS  FD8.2
01EAA:  BRA    1FB0
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01EAC:  MOVLB  0
01EAE:  CALL   12A6
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
01EB2:  BSF    F93.4
01EB4:  BTFSC  F81.4
01EB6:  BRA    1F22
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01EB8:  MOVLW  02
01EBA:  MOVLB  1
01EBC:  MOVWF  x6A
01EBE:  MOVLW  FA
01EC0:  MOVWF  xB0
01EC2:  MOVLB  0
01EC4:  CALL   0AF8
01EC8:  MOVLB  1
01ECA:  DECFSZ x6A,F
01ECC:  BRA    1EBE
....................          BEEP; 
01ECE:  MOVLW  04
01ED0:  MOVWF  x6E
01ED2:  MOVLW  B9
01ED4:  MOVWF  x6D
01ED6:  CLRF   x70
01ED8:  MOVLW  14
01EDA:  MOVWF  x6F
01EDC:  MOVLB  0
01EDE:  RCALL  1BDE
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
01EE0:  MOVLB  1
01EE2:  INCF   x68,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOn){ 
01EE4:  MOVF   x68,W
01EE6:  SUBWF  x63,W
01EE8:  BC    1EEC
....................             optSelected = 0; 
01EEA:  CLRF   x68
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\fOn -> %s",optMenuOn[optSelected]); 
01EEC:  MOVF   x68,W
01EEE:  MULLW  0B
01EF0:  MOVF   FF3,W
01EF2:  CLRF   03
01EF4:  ADDLW  F4
01EF6:  MOVWF  01
01EF8:  MOVLW  00
01EFA:  ADDWFC 03,F
01EFC:  MOVFF  01,16A
01F00:  MOVFF  03,16B
01F04:  MOVLW  B4
01F06:  MOVWF  FF6
01F08:  MOVLW  03
01F0A:  MOVWF  FF7
01F0C:  MOVLW  07
01F0E:  MOVWF  x6C
01F10:  MOVLB  0
01F12:  RCALL  1E18
01F14:  MOVFF  16B,FEA
01F18:  MOVFF  16A,FE9
01F1C:  RCALL  1E42
....................          showBottonMenu(); 
01F1E:  CALL   11A0
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
01F22:  BSF    F93.5
01F24:  BTFSC  F81.5
01F26:  BRA    1FAC
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
01F28:  MOVLW  02
01F2A:  MOVLB  1
01F2C:  MOVWF  x6A
01F2E:  MOVLW  FA
01F30:  MOVWF  xB0
01F32:  MOVLB  0
01F34:  CALL   0AF8
01F38:  MOVLB  1
01F3A:  DECFSZ x6A,F
01F3C:  BRA    1F2E
....................          BEEP; 
01F3E:  MOVLW  04
01F40:  MOVWF  x6E
01F42:  MOVLW  B9
01F44:  MOVWF  x6D
01F46:  CLRF   x70
01F48:  MOVLW  14
01F4A:  MOVWF  x6F
01F4C:  MOVLB  0
01F4E:  RCALL  1BDE
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if(optSelected == countOptMenuOn){ 
01F50:  MOVLB  1
01F52:  MOVF   x63,W
01F54:  SUBWF  x68,W
01F56:  BNZ   1F5E
....................             exit = 1; 
01F58:  MOVLW  01
01F5A:  MOVWF  x69
....................          }else{ 
01F5C:  BRA    1FAE
....................             output_high(PIN_OUT[optSelected]); 
01F5E:  BCF    FD8.0
01F60:  RLCF   x68,W
01F62:  CLRF   03
01F64:  MOVFF  FF2,16A
01F68:  BCF    FF2.7
01F6A:  MOVLB  0
01F6C:  CALL   0096
01F70:  TBLRD*+
01F72:  MOVFF  FF5,03
01F76:  MOVLB  1
01F78:  BTFSC  x6A.7
01F7A:  BSF    FF2.7
01F7C:  MOVWF  x6A
01F7E:  MOVFF  03,16B
01F82:  MOVWF  xB1
01F84:  MOVLW  01
01F86:  MOVWF  xB2
01F88:  MOVLW  0F
01F8A:  MOVWF  xB4
01F8C:  MOVLW  89
01F8E:  MOVWF  xB3
01F90:  MOVLB  0
01F92:  CALL   11BA
01F96:  MOVFF  16A,1B1
01F9A:  MOVLB  1
01F9C:  CLRF   xB2
01F9E:  MOVLW  0F
01FA0:  MOVWF  xB4
01FA2:  MOVLW  92
01FA4:  MOVWF  xB3
01FA6:  MOVLB  0
01FA8:  CALL   11BA
01FAC:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
01FAE:  BRA    1EA6
....................    } // FIN While Infinito 
....................  
....................    return 0; 
01FB0:  MOVLW  00
01FB2:  MOVWF  01
01FB4:  MOVLB  0
01FB6:  GOTO   27CA (RETURN)
.................... } // Fin funcion getMenuOn 
....................  
.................... /*************************************************** 
.................... Despliega el menu MENU_OFF 
.................... ***************************************************/ 
.................... int getMenuOff(void){ 
01FBA:  MOVLB  1
01FBC:  CLRF   x68
01FBE:  CLRF   x69
....................    int optSelected = 0; 
....................    int exit = 0; 
....................  
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\fOff-> %s",optMenuOn[optSelected]); 
01FC0:  MOVF   x68,W
01FC2:  MULLW  0B
01FC4:  MOVF   FF3,W
01FC6:  CLRF   03
01FC8:  ADDLW  F4
01FCA:  MOVWF  01
01FCC:  MOVLW  00
01FCE:  ADDWFC 03,F
01FD0:  MOVFF  01,16A
01FD4:  MOVFF  03,16B
01FD8:  MOVLW  BE
01FDA:  MOVWF  FF6
01FDC:  MOVLW  03
01FDE:  MOVWF  FF7
01FE0:  MOVLW  07
01FE2:  MOVWF  x6C
01FE4:  MOVLB  0
01FE6:  RCALL  1E18
01FE8:  MOVFF  16B,FEA
01FEC:  MOVFF  16A,FE9
01FF0:  RCALL  1E42
....................    showBottonMenu(); 
01FF2:  CALL   11A0
....................     
....................    while(!exit){ 
01FF6:  MOVLB  1
01FF8:  MOVF   x69,F
01FFA:  BTFSS  FD8.2
01FFC:  BRA    2100
....................     
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
01FFE:  MOVLB  0
02000:  CALL   12A6
....................       /********************************************/ 
....................        
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
02004:  BSF    F93.4
02006:  BTFSC  F81.4
02008:  BRA    2074
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0200A:  MOVLW  02
0200C:  MOVLB  1
0200E:  MOVWF  x6A
02010:  MOVLW  FA
02012:  MOVWF  xB0
02014:  MOVLB  0
02016:  CALL   0AF8
0201A:  MOVLB  1
0201C:  DECFSZ x6A,F
0201E:  BRA    2010
....................          BEEP; 
02020:  MOVLW  04
02022:  MOVWF  x6E
02024:  MOVLW  B9
02026:  MOVWF  x6D
02028:  CLRF   x70
0202A:  MOVLW  14
0202C:  MOVWF  x6F
0202E:  MOVLB  0
02030:  RCALL  1BDE
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
02032:  MOVLB  1
02034:  INCF   x68,F
....................          // Si la opcion seleccionada esta en el limite de las opciones  
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > countOptMenuOff){ 
02036:  MOVF   x68,W
02038:  SUBWF  x64,W
0203A:  BC    203E
....................             optSelected = 0; 
0203C:  CLRF   x68
....................          } 
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\fOff-> %s",optMenuOn[optSelected]); 
0203E:  MOVF   x68,W
02040:  MULLW  0B
02042:  MOVF   FF3,W
02044:  CLRF   03
02046:  ADDLW  F4
02048:  MOVWF  01
0204A:  MOVLW  00
0204C:  ADDWFC 03,F
0204E:  MOVFF  01,16A
02052:  MOVFF  03,16B
02056:  MOVLW  C8
02058:  MOVWF  FF6
0205A:  MOVLW  03
0205C:  MOVWF  FF7
0205E:  MOVLW  07
02060:  MOVWF  x6C
02062:  MOVLB  0
02064:  RCALL  1E18
02066:  MOVFF  16B,FEA
0206A:  MOVFF  16A,FE9
0206E:  RCALL  1E42
....................          showBottonMenu(); 
02070:  CALL   11A0
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
02074:  BSF    F93.5
02076:  BTFSC  F81.5
02078:  BRA    20FC
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
0207A:  MOVLW  02
0207C:  MOVLB  1
0207E:  MOVWF  x6A
02080:  MOVLW  FA
02082:  MOVWF  xB0
02084:  MOVLB  0
02086:  CALL   0AF8
0208A:  MOVLB  1
0208C:  DECFSZ x6A,F
0208E:  BRA    2080
....................          BEEP; 
02090:  MOVLW  04
02092:  MOVWF  x6E
02094:  MOVLW  B9
02096:  MOVWF  x6D
02098:  CLRF   x70
0209A:  MOVLW  14
0209C:  MOVWF  x6F
0209E:  MOVLB  0
020A0:  RCALL  1BDE
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuOff){ 
020A2:  MOVLB  1
020A4:  MOVF   x64,W
020A6:  SUBWF  x68,W
020A8:  BNZ   20B0
....................             exit = 1; 
020AA:  MOVLW  01
020AC:  MOVWF  x69
....................          }else{ 
020AE:  BRA    20FE
....................             output_low(PIN_OUT[optSelected]); 
020B0:  BCF    FD8.0
020B2:  RLCF   x68,W
020B4:  CLRF   03
020B6:  MOVFF  FF2,16A
020BA:  BCF    FF2.7
020BC:  MOVLB  0
020BE:  CALL   0096
020C2:  TBLRD*+
020C4:  MOVFF  FF5,03
020C8:  MOVLB  1
020CA:  BTFSC  x6A.7
020CC:  BSF    FF2.7
020CE:  MOVWF  x6A
020D0:  MOVFF  03,16B
020D4:  MOVWF  xB1
020D6:  CLRF   xB2
020D8:  MOVLW  0F
020DA:  MOVWF  xB4
020DC:  MOVLW  89
020DE:  MOVWF  xB3
020E0:  MOVLB  0
020E2:  CALL   11BA
020E6:  MOVFF  16A,1B1
020EA:  MOVLB  1
020EC:  CLRF   xB2
020EE:  MOVLW  0F
020F0:  MOVWF  xB4
020F2:  MOVLW  92
020F4:  MOVWF  xB3
020F6:  MOVLB  0
020F8:  CALL   11BA
020FC:  MOVLB  1
....................          } 
....................          // Rompe el Loop 
....................       } // Fin KEY_OK 
020FE:  BRA    1FF8
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02100:  MOVLW  00
02102:  MOVWF  01
02104:  MOVLB  0
02106:  GOTO   27D6 (RETURN)
.................... } // Fin funcion getMenuMain 
....................  
.................... /*************************************************** 
.................... Despliega el menu principal MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... int getMenuSetup(void){ 
....................  
....................    /******************************************** 
....................    *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................    *********************************************/ 
....................    run_command_wifi(); 
*
02562:  CALL   12A6
....................    /********************************************/ 
....................     
....................    int optSelected = 0; 
....................    int exit = 0; 
02566:  MOVLB  1
02568:  CLRF   x68
0256A:  CLRF   x69
....................     
....................    // Muestra la primera opcion del menu 
....................    printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
0256C:  MOVF   x68,W
0256E:  MULLW  11
02570:  MOVF   FF3,W
02572:  CLRF   03
02574:  MOVWF  x6A
02576:  MOVLW  0C
02578:  MOVWF  x70
0257A:  MOVLB  0
0257C:  CALL   0DB8
02580:  MOVLW  B2
02582:  MOVWF  FF6
02584:  MOVLW  02
02586:  MOVWF  FF7
02588:  MOVLB  1
0258A:  MOVF   x6A,W
0258C:  ADDWF  FF6,F
0258E:  MOVLW  00
02590:  ADDWFC FF7,F
02592:  MOVLB  0
02594:  CALL   0E24
....................    showBottonMenu(); 
02598:  CALL   11A0
....................     
....................    while(!exit){ 
0259C:  MOVLB  1
0259E:  MOVF   x69,F
025A0:  BNZ   2688
....................       // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................       if(input(KEY_NEXT)==0) 
025A2:  BSF    F93.4
025A4:  BTFSC  F81.4
025A6:  BRA    260E
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
025A8:  MOVLW  02
025AA:  MOVWF  x6A
025AC:  MOVLW  FA
025AE:  MOVWF  xB0
025B0:  MOVLB  0
025B2:  CALL   0AF8
025B6:  MOVLB  1
025B8:  DECFSZ x6A,F
025BA:  BRA    25AC
....................          BEEP; 
025BC:  MOVLW  04
025BE:  MOVWF  x6E
025C0:  MOVLW  B9
025C2:  MOVWF  x6D
025C4:  CLRF   x70
025C6:  MOVLW  14
025C8:  MOVWF  x6F
025CA:  MOVLB  0
025CC:  CALL   1BDE
....................          
....................          // incrementa la opcion seleccionada para mover el menu 
....................          optSelected++; 
025D0:  MOVLB  1
025D2:  INCF   x68,F
....................           
....................          // Si la opcion seleccionada esta en el limite de las opciones 
....................          // entonces regresa a la primera posicion del menu 
....................          if(optSelected > (countOptMenuSetup)){ 
025D4:  MOVF   x68,W
025D6:  SUBWF  x65,W
025D8:  BC    25DC
....................             optSelected = 0; 
025DA:  CLRF   x68
....................          } 
....................           
....................          // Muestra la opcion seleccionada 
....................          printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
025DC:  MOVF   x68,W
025DE:  MULLW  11
025E0:  MOVF   FF3,W
025E2:  CLRF   03
025E4:  MOVWF  x6A
025E6:  MOVLW  0C
025E8:  MOVWF  x70
025EA:  MOVLB  0
025EC:  CALL   0DB8
025F0:  MOVLW  B2
025F2:  MOVWF  FF6
025F4:  MOVLW  02
025F6:  MOVWF  FF7
025F8:  MOVLB  1
025FA:  MOVF   x6A,W
025FC:  ADDWF  FF6,F
025FE:  MOVLW  00
02600:  ADDWFC FF7,F
02602:  MOVLB  0
02604:  CALL   0E24
....................          showBottonMenu(); 
02608:  CALL   11A0
0260C:  MOVLB  1
....................       } // Fin KEY_NEXT 
....................        
....................       // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................       if(input(KEY_OK)==0) 
0260E:  BSF    F93.5
02610:  BTFSC  F81.5
02612:  BRA    2686
....................       {  
....................          // Elimina el rebote 
....................          delay_ms(500); 
02614:  MOVLW  02
02616:  MOVWF  x6A
02618:  MOVLW  FA
0261A:  MOVWF  xB0
0261C:  MOVLB  0
0261E:  CALL   0AF8
02622:  MOVLB  1
02624:  DECFSZ x6A,F
02626:  BRA    2618
....................          BEEP; 
02628:  MOVLW  04
0262A:  MOVWF  x6E
0262C:  MOVLW  B9
0262E:  MOVWF  x6D
02630:  CLRF   x70
02632:  MOVLW  14
02634:  MOVWF  x6F
02636:  MOVLB  0
02638:  CALL   1BDE
....................           
....................          // Si optSelected = countOptMenuOn entonces esta en la pos SALIR 
....................          if((optSelected) == countOptMenuSetup){ 
0263C:  MOVLB  1
0263E:  MOVF   x65,W
02640:  SUBWF  x68,W
02642:  BNZ   264A
....................             exit = 1; 
02644:  MOVLW  01
02646:  MOVWF  x69
....................          }else{ 
02648:  BRA    2686
....................             executeSetup(optSelected); 
0264A:  MOVFF  168,16A
0264E:  MOVLB  0
02650:  BRA    237A
....................             // Muestra la opcion seleccionada 
....................             printf(lcd_putc, "\f%s",optMenuSetup[optSelected]); 
02652:  MOVLB  1
02654:  MOVF   x68,W
02656:  MULLW  11
02658:  MOVF   FF3,W
0265A:  CLRF   03
0265C:  MOVWF  x6A
0265E:  MOVLW  0C
02660:  MOVWF  x70
02662:  MOVLB  0
02664:  CALL   0DB8
02668:  MOVLW  B2
0266A:  MOVWF  FF6
0266C:  MOVLW  02
0266E:  MOVWF  FF7
02670:  MOVLB  1
02672:  MOVF   x6A,W
02674:  ADDWF  FF6,F
02676:  MOVLW  00
02678:  ADDWFC FF7,F
0267A:  MOVLB  0
0267C:  CALL   0E24
....................             showBottonMenu(); 
02680:  CALL   11A0
02684:  MOVLB  1
....................          } 
....................       } // Fin KEY_OK 
02686:  BRA    259E
....................    } // FIN While Infinito 
....................  
....................    return 0; 
02688:  MOVLW  00
0268A:  MOVWF  01
0268C:  MOVLB  0
0268E:  GOTO   27E0 (RETURN)
.................... } // Fin funcion getMenuSetup 
....................  
.................... /*************************************************** 
.................... Dispacher function MENU_SETUP 
.................... ***************************************************/ 
....................  
.................... void executeSetup(int optSelect){ 
....................     
....................    
....................   switch(optSelect){ 
*
0237A:  MOVLB  1
0237C:  MOVF   x6A,W
0237E:  ADDLW  F8
02380:  BTFSC  FD8.0
02382:  BRA    251C
02384:  ADDLW  08
02386:  MOVLB  0
02388:  GOTO   252E
....................    
....................      case OPT_SHOW_AP_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
0238C:  MOVLW  D2
0238E:  MOVWF  FF6
02390:  MOVLW  03
02392:  MOVWF  FF7
02394:  CALL   0E6E
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
02398:  MOVLW  05
0239A:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
0239C:  MOVLW  DE
0239E:  MOVWF  FF6
023A0:  MOVLW  03
023A2:  MOVWF  FF7
023A4:  CALL   0E24
....................         waitResp(); 
023A8:  CALL   0E90
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[0]); 
023AC:  MOVLW  0C
023AE:  MOVLB  1
023B0:  MOVWF  x70
023B2:  MOVLB  0
023B4:  CALL   0DB8
023B8:  CLRF   FEA
023BA:  MOVLW  6B
023BC:  MOVWF  FE9
023BE:  RCALL  1E42
....................         flag_Resp_Get_IP_CMD = 0; 
023C0:  CLRF   xBB
....................         break; 
023C2:  MOVLB  1
023C4:  BRA    251C
....................          
....................      case OPT_SHOW_STA_IP: 
....................         fprintf(ESP8266, "AT+CIFSR\r\n"); 
023C6:  MOVLW  EC
023C8:  MOVWF  FF6
023CA:  MOVLW  03
023CC:  MOVWF  FF7
023CE:  CALL   0E6E
....................         CMD_RUN = CMD_GET_IP_FROM_MENU; 
023D2:  MOVLW  05
023D4:  MOVWF  5B
....................         printf(lcd_putc, "\fCargando..."); 
023D6:  MOVLW  F8
023D8:  MOVWF  FF6
023DA:  MOVLW  03
023DC:  MOVWF  FF7
023DE:  CALL   0E24
....................         waitResp(); 
023E2:  CALL   0E90
....................         printf(lcd_putc, "\f%s",buffer_Resp_CMD[1]); 
023E6:  MOVLW  0C
023E8:  MOVLB  1
023EA:  MOVWF  x70
023EC:  MOVLB  0
023EE:  CALL   0DB8
023F2:  CLRF   FEA
023F4:  MOVLW  7B
023F6:  MOVWF  FE9
023F8:  RCALL  1E42
....................         flag_Resp_Get_IP_CMD = 0; 
023FA:  CLRF   xBB
....................         break; 
023FC:  MOVLB  1
023FE:  BRA    251C
....................          
....................      case OPT_SHOW_STA_SSID: 
....................         if(modeStar!='2'){ 
02400:  MOVF   xC1,W
02402:  SUBLW  32
02404:  BZ    243E
....................            fprintf(ESP8266, "AT+CWJAP?\r\n"); 
02406:  MOVLW  06
02408:  MOVWF  FF6
0240A:  MOVLW  04
0240C:  MOVWF  FF7
0240E:  CALL   0E6E
....................            CMD_RUN = CMD_GET_STA_INFO_FROM_MENU; 
02412:  MOVLW  07
02414:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
02416:  MOVLW  12
02418:  MOVWF  FF6
0241A:  MOVLW  04
0241C:  MOVWF  FF7
0241E:  CALL   0E24
....................            waitResp(); 
02422:  CALL   0E90
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[4]); 
02426:  MOVLW  0C
02428:  MOVLB  1
0242A:  MOVWF  x70
0242C:  MOVLB  0
0242E:  CALL   0DB8
02432:  CLRF   FEA
02434:  MOVLW  AB
02436:  MOVWF  FE9
02438:  RCALL  1E42
....................            flag_Resp_Get_STA_Info_CMD=0; 
0243A:  CLRF   xBF
....................         }else{ 
0243C:  BRA    244A
....................            printf(lcd_putc, "\fDeshabilitado"); 
0243E:  MOVLW  20
02440:  MOVWF  FF6
02442:  MOVLW  04
02444:  MOVWF  FF7
02446:  CALL   0E24
....................         } 
....................         break; 
0244A:  MOVLB  1
0244C:  BRA    251C
....................          
....................      case OPT_SHOW_AP_SSID: 
....................         if(modeStar!='1'){ 
0244E:  MOVF   xC1,W
02450:  SUBLW  31
02452:  BZ    248C
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
02454:  MOVLW  30
02456:  MOVWF  FF6
02458:  MOVLW  04
0245A:  MOVWF  FF7
0245C:  CALL   0E6E
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
02460:  MOVLW  06
02462:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
02464:  MOVLW  3C
02466:  MOVWF  FF6
02468:  MOVLW  04
0246A:  MOVWF  FF7
0246C:  CALL   0E24
....................            waitResp(); 
02470:  CALL   0E90
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[2]); 
02474:  MOVLW  0C
02476:  MOVLB  1
02478:  MOVWF  x70
0247A:  MOVLB  0
0247C:  CALL   0DB8
02480:  CLRF   FEA
02482:  MOVLW  8B
02484:  MOVWF  FE9
02486:  RCALL  1E42
....................            flag_Resp_Get_AP_Info_CMD=0; 
02488:  CLRF   xBD
....................         }else{ 
0248A:  BRA    2498
....................            printf(lcd_putc, "\fDeshabilitado"); 
0248C:  MOVLW  4A
0248E:  MOVWF  FF6
02490:  MOVLW  04
02492:  MOVWF  FF7
02494:  CALL   0E24
....................         } 
....................         break; 
02498:  MOVLB  1
0249A:  BRA    251C
....................          
....................      case OPT_SHOW_AP_KEY: 
....................         if(modeStar!='1'){ 
0249C:  MOVF   xC1,W
0249E:  SUBLW  31
024A0:  BZ    24DA
....................            fprintf(ESP8266, "AT+CWSAP?\r\n"); 
024A2:  MOVLW  5A
024A4:  MOVWF  FF6
024A6:  MOVLW  04
024A8:  MOVWF  FF7
024AA:  CALL   0E6E
....................            CMD_RUN = CMD_GET_AP_INFO_FROM_MENU; 
024AE:  MOVLW  06
024B0:  MOVWF  5B
....................            printf(lcd_putc, "\fCargando..."); 
024B2:  MOVLW  66
024B4:  MOVWF  FF6
024B6:  MOVLW  04
024B8:  MOVWF  FF7
024BA:  CALL   0E24
....................            waitResp(); 
024BE:  CALL   0E90
....................            printf(lcd_putc, "\f%s",buffer_Resp_CMD[3]); 
024C2:  MOVLW  0C
024C4:  MOVLB  1
024C6:  MOVWF  x70
024C8:  MOVLB  0
024CA:  CALL   0DB8
024CE:  CLRF   FEA
024D0:  MOVLW  9B
024D2:  MOVWF  FE9
024D4:  RCALL  1E42
....................            flag_Resp_Get_AP_Info_CMD=0; 
024D6:  CLRF   xBD
....................         }else{ 
024D8:  BRA    24E6
....................            printf(lcd_putc, "\fDeshabilitado"); 
024DA:  MOVLW  74
024DC:  MOVWF  FF6
024DE:  MOVLW  04
024E0:  MOVWF  FF7
024E2:  CALL   0E24
....................         } 
....................         break; 
024E6:  MOVLB  1
024E8:  BRA    251C
....................          
....................      case OPT_MODE_AP: 
....................         setMenuModo(); 
024EA:  BRA    2152
....................         break; 
024EC:  MOVLB  1
024EE:  BRA    251C
....................          
....................      case OPT_BACKLIGH: 
....................         output_toggle(LCD_LIGHT_PIN); 
024F0:  BCF    F95.3
024F2:  BTG    F8C.3
....................         if(input_state(LCD_LIGHT_PIN)==1){ 
024F4:  BTFSS  F83.3
024F6:  BRA    2506
....................            printf(lcd_putc, "\fBacklight On"); 
024F8:  MOVLW  84
024FA:  MOVWF  FF6
024FC:  MOVLW  04
024FE:  MOVWF  FF7
02500:  CALL   0E24
....................         }else{ 
02504:  BRA    2512
....................            printf(lcd_putc, "\fBacklight Off"); 
02506:  MOVLW  92
02508:  MOVWF  FF6
0250A:  MOVLW  04
0250C:  MOVWF  FF7
0250E:  CALL   0E24
....................         } 
....................         break; 
02512:  MOVLB  1
02514:  BRA    251C
....................          
....................      case OPT_EXIT: 
....................         break; 
02516:  MOVLB  1
02518:  BRA    251C
0251A:  MOVLB  1
....................          
....................   } 
....................    
....................   if(optSelect!=OPT_EXIT){ 
0251C:  MOVF   x6A,W
0251E:  SUBLW  07
02520:  BZ    2528
....................    pressExit(); 
02522:  MOVLB  0
02524:  RCALL  210A
02526:  MOVLB  1
....................   } 
02528:  MOVLB  0
0252A:  GOTO   2652 (RETURN)
.................... } 
....................    
.................... /*************************************************** 
.................... Despliega el menu MODE 
.................... ***************************************************/ 
....................  
.................... void setMenuModo(void){ 
*
02152:  MOVLB  1
02154:  CLRF   x6B
02156:  CLRF   x6C
....................   int optSelected = 0; 
....................   int exit = 0; 
....................  
....................   // Muestra la primera opcion del menu 
....................   printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
02158:  MOVF   x6B,W
0215A:  MULLW  0E
0215C:  MOVF   FF3,W
0215E:  CLRF   03
02160:  MOVWF  x6D
02162:  MOVLW  0C
02164:  MOVWF  x70
02166:  MOVLB  0
02168:  CALL   0DB8
0216C:  MOVLW  4C
0216E:  MOVWF  FF6
02170:  MOVLW  03
02172:  MOVWF  FF7
02174:  MOVLB  1
02176:  MOVF   x6D,W
02178:  ADDWF  FF6,F
0217A:  MOVLW  00
0217C:  ADDWFC FF7,F
0217E:  MOVLB  0
02180:  CALL   0E24
....................   showBottonMenu(); 
02184:  CALL   11A0
....................    
....................   while(!exit){ 
02188:  MOVLB  1
0218A:  MOVF   x6C,F
0218C:  BTFSS  FD8.2
0218E:  BRA    2374
....................    
....................       /******************************************** 
....................       *  INVOCA LA FUNCION RUN_COMMAND_WIFI       * 
....................       *********************************************/ 
....................       run_command_wifi(); 
02190:  MOVLB  0
02192:  CALL   12A6
....................       /********************************************/ 
....................        
....................      // TECLA SIGUIENTE: hace la navegacion entre las opciones del menu 
....................      if(input(KEY_NEXT)==0) 
02196:  BSF    F93.4
02198:  BTFSC  F81.4
0219A:  BRA    2200
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
0219C:  MOVLW  02
0219E:  MOVLB  1
021A0:  MOVWF  x6D
021A2:  MOVLW  FA
021A4:  MOVWF  xB0
021A6:  MOVLB  0
021A8:  CALL   0AF8
021AC:  MOVLB  1
021AE:  DECFSZ x6D,F
021B0:  BRA    21A2
....................         BEEP; 
021B2:  MOVLW  04
021B4:  MOVWF  x6E
021B6:  MOVLW  B9
021B8:  MOVWF  x6D
021BA:  CLRF   x70
021BC:  MOVLW  14
021BE:  MOVWF  x6F
021C0:  MOVLB  0
021C2:  RCALL  1BDE
....................         // incrementa la opcion seleccionada para mover el menu 
....................         optSelected++; 
021C4:  MOVLB  1
021C6:  INCF   x6B,F
....................         // Si la opcion seleccionada esta en el limite de las opciones  
....................         // entonces regresa a la primera posicion del menu 
....................         if(optSelected > countOptMenuModo){ 
021C8:  MOVF   x6B,W
021CA:  SUBWF  x66,W
021CC:  BC    21D0
....................            optSelected = 0; 
021CE:  CLRF   x6B
....................         } 
....................         // Muestra la opcion seleccionada 
....................         printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
021D0:  MOVF   x6B,W
021D2:  MULLW  0E
021D4:  MOVF   FF3,W
021D6:  CLRF   03
021D8:  MOVWF  x6D
021DA:  MOVLW  0C
021DC:  MOVWF  x70
021DE:  MOVLB  0
021E0:  CALL   0DB8
021E4:  MOVLW  4C
021E6:  MOVWF  FF6
021E8:  MOVLW  03
021EA:  MOVWF  FF7
021EC:  MOVLB  1
021EE:  MOVF   x6D,W
021F0:  ADDWF  FF6,F
021F2:  MOVLW  00
021F4:  ADDWFC FF7,F
021F6:  MOVLB  0
021F8:  CALL   0E24
....................         showBottonMenu(); 
021FC:  CALL   11A0
....................      } // Fin KEY_NEXT 
....................       
....................      // Finaliza la funcion y retorna la opcion del menu seleccionada 
....................      if(input(KEY_OK)==0) 
02200:  BSF    F93.5
02202:  BTFSC  F81.5
02204:  BRA    2370
....................      {  
....................         // Elimina el rebote 
....................         delay_ms(500); 
02206:  MOVLW  02
02208:  MOVLB  1
0220A:  MOVWF  x6D
0220C:  MOVLW  FA
0220E:  MOVWF  xB0
02210:  MOVLB  0
02212:  CALL   0AF8
02216:  MOVLB  1
02218:  DECFSZ x6D,F
0221A:  BRA    220C
....................         BEEP; 
0221C:  MOVLW  04
0221E:  MOVWF  x6E
02220:  MOVLW  B9
02222:  MOVWF  x6D
02224:  CLRF   x70
02226:  MOVLW  14
02228:  MOVWF  x6F
0222A:  MOVLB  0
0222C:  RCALL  1BDE
....................          
....................         // Si optSelected = countOptMenuModo entonces esta en la pos SALIR 
....................         if(optSelected == countOptMenuModo){ 
0222E:  MOVLB  1
02230:  MOVF   x66,W
02232:  SUBWF  x6B,W
02234:  BNZ   223C
....................            exit = 1; 
02236:  MOVLW  01
02238:  MOVWF  x6C
....................         }else{ 
0223A:  BRA    2372
....................            switch(optSelected){ 
0223C:  MOVF   x6B,W
0223E:  XORLW  00
02240:  MOVLB  0
02242:  BZ    224E
02244:  XORLW  01
02246:  BZ    229E
02248:  XORLW  03
0224A:  BZ    22EE
0224C:  BRA    233C
....................               case MODE_CLIENT: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=1\r\n"); 
0224E:  MOVLW  A2
02250:  MOVWF  FF6
02252:  MOVLW  04
02254:  MOVWF  FF7
02256:  CALL   0E6E
....................                  write_eeprom(0,'1'); 
0225A:  MOVF   FF2,W
0225C:  MOVWF  00
0225E:  BCF    FF2.7
02260:  CLRF   FAA
02262:  CLRF   FA9
02264:  MOVLW  31
02266:  MOVWF  FA8
02268:  BCF    FA6.6
0226A:  BCF    FA6.7
0226C:  BSF    FA6.2
0226E:  MOVLB  F
02270:  MOVLW  55
02272:  MOVWF  FA7
02274:  MOVLW  AA
02276:  MOVWF  FA7
02278:  BSF    FA6.1
0227A:  BTFSC  FA6.1
0227C:  BRA    227A
0227E:  BCF    FA6.2
02280:  MOVF   00,W
02282:  IORWF  FF2,F
....................                  delay_ms(10); 
02284:  MOVLW  0A
02286:  MOVLB  1
02288:  MOVWF  xB0
0228A:  MOVLB  0
0228C:  CALL   0AF8
....................                  printf(lcd_putc, "\fConfig Cliente"); 
02290:  MOVLW  B4
02292:  MOVWF  FF6
02294:  MOVLW  04
02296:  MOVWF  FF7
02298:  CALL   0E24
....................                  break; 
0229C:  BRA    233C
....................               case MODE_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=2\r\n"); 
0229E:  MOVLW  C4
022A0:  MOVWF  FF6
022A2:  MOVLW  04
022A4:  MOVWF  FF7
022A6:  CALL   0E6E
....................                  write_eeprom(0,'2'); 
022AA:  MOVF   FF2,W
022AC:  MOVWF  00
022AE:  BCF    FF2.7
022B0:  CLRF   FAA
022B2:  CLRF   FA9
022B4:  MOVLW  32
022B6:  MOVWF  FA8
022B8:  BCF    FA6.6
022BA:  BCF    FA6.7
022BC:  BSF    FA6.2
022BE:  MOVLB  F
022C0:  MOVLW  55
022C2:  MOVWF  FA7
022C4:  MOVLW  AA
022C6:  MOVWF  FA7
022C8:  BSF    FA6.1
022CA:  BTFSC  FA6.1
022CC:  BRA    22CA
022CE:  BCF    FA6.2
022D0:  MOVF   00,W
022D2:  IORWF  FF2,F
....................                  delay_ms(10); 
022D4:  MOVLW  0A
022D6:  MOVLB  1
022D8:  MOVWF  xB0
022DA:  MOVLB  0
022DC:  CALL   0AF8
....................                  printf(lcd_putc, "\fConfig AP"); 
022E0:  MOVLW  D6
022E2:  MOVWF  FF6
022E4:  MOVLW  04
022E6:  MOVWF  FF7
022E8:  CALL   0E24
....................                  break; 
022EC:  BRA    233C
....................               case MODE_CLIENT_AP: 
....................                  fprintf(ESP8266,"AT+CWMODE_DEF=3\r\n"); 
022EE:  MOVLW  E2
022F0:  MOVWF  FF6
022F2:  MOVLW  04
022F4:  MOVWF  FF7
022F6:  CALL   0E6E
....................                  write_eeprom(0,'3'); 
022FA:  MOVF   FF2,W
022FC:  MOVWF  00
022FE:  BCF    FF2.7
02300:  CLRF   FAA
02302:  CLRF   FA9
02304:  MOVLW  33
02306:  MOVWF  FA8
02308:  BCF    FA6.6
0230A:  BCF    FA6.7
0230C:  BSF    FA6.2
0230E:  MOVLB  F
02310:  MOVLW  55
02312:  MOVWF  FA7
02314:  MOVLW  AA
02316:  MOVWF  FA7
02318:  BSF    FA6.1
0231A:  BTFSC  FA6.1
0231C:  BRA    231A
0231E:  BCF    FA6.2
02320:  MOVF   00,W
02322:  IORWF  FF2,F
....................                  delay_ms(10); 
02324:  MOVLW  0A
02326:  MOVLB  1
02328:  MOVWF  xB0
0232A:  MOVLB  0
0232C:  CALL   0AF8
....................                  printf(lcd_putc, "\fConfig ClienteAP"); 
02330:  MOVLW  F4
02332:  MOVWF  FF6
02334:  MOVLW  04
02336:  MOVWF  FF7
02338:  CALL   0E24
....................                  break; 
....................            } 
....................            pressExit(); 
0233C:  RCALL  210A
....................            // Muestra la ultima opcion del menu seleccionada 
....................            printf(lcd_putc, "\f%s",optMenuModo[optSelected]); 
0233E:  MOVLB  1
02340:  MOVF   x6B,W
02342:  MULLW  0E
02344:  MOVF   FF3,W
02346:  CLRF   03
02348:  MOVWF  x6D
0234A:  MOVLW  0C
0234C:  MOVWF  x70
0234E:  MOVLB  0
02350:  CALL   0DB8
02354:  MOVLW  4C
02356:  MOVWF  FF6
02358:  MOVLW  03
0235A:  MOVWF  FF7
0235C:  MOVLB  1
0235E:  MOVF   x6D,W
02360:  ADDWF  FF6,F
02362:  MOVLW  00
02364:  ADDWFC FF7,F
02366:  MOVLB  0
02368:  CALL   0E24
....................            showBottonMenu(); 
0236C:  CALL   11A0
02370:  MOVLB  1
....................         } 
....................      } // Fin KEY_OK 
02372:  BRA    218A
....................   } // FIN While Infinito 
02374:  MOVLB  0
02376:  GOTO   24EC (RETURN)
.................... } // Fin funcion setMenuModo 
....................  
....................  
.................... /******************************************** 
.................... ***         VARIABLES GLOBALS             *** 
.................... /*******************************************/ 
....................  
.................... // Menu seleccionado, Inicia en el menuStart(0) 
.................... int menuActive = 0; 
....................  
.................... /******************************************** 
.................... *****          INTERRUPCIONES            **** 
.................... se dispara cuando se detectan datos de 
.................... llegada al puerto serie portWF 
.................... ********************************************/ 
.................... #INT_RDA 
.................... void  RDA_isr(void)  
*
00ACE:  BTFSS  F9E.5
00AD0:  BRA    0ACE
00AD2:  MOVFF  FAE,1B7
00AD6:  MOVLB  1
.................... { 
....................    int buffer = getc(); 
....................    ESP8266_PROCCESS_RESPONSE(buffer); 
00AD8:  MOVFF  1B7,1B8
00ADC:  MOVLB  0
00ADE:  BRA    09E6
00AE0:  BCF    F9E.5
00AE2:  GOTO   0054
.................... } 
.................... /******************************************** 
.................... ***                INIT                   *** 
.................... *********************************************/ 
....................  
....................    void main() 
*
02692:  CLRF   FF8
02694:  BCF    FD0.7
02696:  BSF    07.7
02698:  BSF    FB8.3
0269A:  MOVLW  08
0269C:  MOVWF  FAF
0269E:  MOVLW  02
026A0:  MOVWF  FB0
026A2:  MOVLW  A6
026A4:  MOVWF  FAC
026A6:  MOVLW  90
026A8:  MOVWF  FAB
026AA:  BCF    F93.0
026AC:  BSF    F8A.0
026AE:  CLRF   53
026B0:  CLRF   52
026B2:  CLRF   54
026B4:  CLRF   55
026B6:  CLRF   56
026B8:  CLRF   57
026BA:  CLRF   58
026BC:  CLRF   59
026BE:  CLRF   5A
026C0:  CLRF   5B
026C2:  MOVLW  01
026C4:  MOVWF  5C
026C6:  CLRF   5D
026C8:  MOVLW  05
026CA:  MOVWF  5E
026CC:  CLRF   xBB
026CE:  CLRF   xBC
026D0:  CLRF   xBD
026D2:  CLRF   xBE
026D4:  CLRF   xBF
026D6:  CLRF   xC0
026D8:  MOVLW  02
026DA:  MOVLB  1
026DC:  MOVWF  x62
026DE:  MOVLW  08
026E0:  MOVWF  x63
026E2:  MOVWF  x64
026E4:  MOVLW  07
026E6:  MOVWF  x65
026E8:  MOVLW  03
026EA:  MOVWF  x66
026EC:  CLRF   x67
026EE:  MOVF   FC1,W
026F0:  ANDLW  C0
026F2:  IORLW  0F
026F4:  MOVWF  FC1
026F6:  MOVLW  07
026F8:  MOVWF  FB4
026FA:  BRA    272E
026FC:  DATA 02,00
026FE:  DATA 16,00
02700:  DATA 00,0C
02702:  DATA 40,5F
02704:  DATA 00,07
02706:  DATA 80,30
02708:  DATA 2E,30
0270A:  DATA 2E,30
0270C:  DATA 2E,30
0270E:  DATA 09,C0
02710:  DATA 00,07
02712:  DATA 80,30
02714:  DATA 2E,30
02716:  DATA 2E,30
02718:  DATA 2E,30
0271A:  DATA 19,C0
0271C:  DATA 00,03
0271E:  DATA 80,4B
02720:  DATA 45,59
02722:  DATA 0D,C0
02724:  DATA 00,05
02726:  DATA 80,53
02728:  DATA 53,49
0272A:  DATA 44,00
0272C:  DATA 00,00
0272E:  MOVLW  00
02730:  MOVWF  FF8
02732:  MOVLW  26
02734:  MOVWF  FF7
02736:  MOVLW  FC
02738:  MOVWF  FF6
0273A:  TBLRD*+
0273C:  MOVF   FF5,W
0273E:  MOVWF  00
02740:  XORLW  00
02742:  BZ    276A
02744:  TBLRD*+
02746:  MOVF   FF5,W
02748:  MOVWF  01
0274A:  BTFSC  FE8.7
0274C:  BRA    2758
0274E:  ANDLW  0F
02750:  MOVWF  FEA
02752:  TBLRD*+
02754:  MOVFF  FF5,FE9
02758:  BTFSC  01.6
0275A:  TBLRD*+
0275C:  BTFSS  01.6
0275E:  TBLRD*+
02760:  MOVFF  FF5,FEE
02764:  DCFSNZ 00,F
02766:  BRA    273A
02768:  BRA    275C
0276A:  CLRF   FF8
....................    {       
....................       /*for(int idxNC=0;idxNC<=255;idxNC++){ 
....................          write_eeprom(idxNC,0xFF); 
....................          delay_ms(10); 
....................       }*/ 
....................           
....................       // Estabiliza el inicio del programa para evitar_ 
....................       // posibles errores al energizar el equipo 
....................       delay_ms(500); 
0276C:  MOVLW  02
0276E:  MOVWF  x68
02770:  MOVLW  FA
02772:  MOVWF  xB0
02774:  MOVLB  0
02776:  CALL   0AF8
0277A:  MOVLB  1
0277C:  DECFSZ x68,F
0277E:  BRA    2770
....................       getNameMenusOutput(); 
02780:  MOVLB  0
02782:  GOTO   0B20
....................       // Activa las resistencias de Pull-Up y configura el puerto 
....................       port_b_pullups(0b00110000); 
02786:  BCF    FF1.7
....................       set_tris_b(0b00110010); 
02788:  MOVLW  32
0278A:  MOVWF  F93
....................       enable_interrupts(INT_RDA);  
0278C:  BSF    F9D.5
....................       enable_interrupts(GLOBAL);  
0278E:  MOVLW  C0
02790:  IORWF  FF2,F
....................        
....................       // Inicializa la LCD 
....................       lcd_init(); 
02792:  GOTO   0CF6
....................       printf(lcd_putc, "\fConfigurando..."); 
02796:  MOVLW  E6
02798:  MOVWF  FF6
0279A:  MOVLW  0A
0279C:  MOVWF  FF7
0279E:  CALL   0E24
....................  
....................       // Enciende el backligh del display 
....................       output_high(LCD_LIGHT_PIN); 
027A2:  BCF    F95.3
027A4:  BSF    F8C.3
....................  
....................       // Inicializa el esp8266 y lo deja en modo lectura de comandos 
....................       esp8266_init(); 
027A6:  GOTO   0FA6
....................                  
....................       // Ciclo infinito para mantener el programa activo 
....................       while(1) 
....................       { 
....................          switch(menuActive){ 
027AA:  MOVLB  1
027AC:  MOVF   x67,W
027AE:  ADDLW  FC
027B0:  BC    27EA
027B2:  ADDLW  04
027B4:  MOVLB  0
027B6:  GOTO   27EE
....................             // Menu principal 
....................             case MENU_START: 
....................                menuActive = getMenuStart(); 
027BA:  GOTO   1D26
027BE:  MOVFF  01,167
....................                break; 
027C2:  MOVLB  1
027C4:  BRA    27EA
....................   
....................             case MENU_ON: 
....................                menuActive = getMenuOn(); 
027C6:  GOTO   1E68
027CA:  MOVFF  01,167
....................                break; 
027CE:  MOVLB  1
027D0:  BRA    27EA
....................   
....................             case MENU_OFF: 
....................                menuActive = getMenuOff(); 
027D2:  GOTO   1FBA
027D6:  MOVFF  01,167
....................                break; 
027DA:  MOVLB  1
027DC:  BRA    27EA
....................  
....................             case MENU_SETUP: 
....................                menuActive = getMenuSetup(); 
027DE:  BRA    2562
027E0:  MOVFF  01,167
....................                break; 
027E4:  MOVLB  1
027E6:  BRA    27EA
027E8:  MOVLB  1
....................          } // Fin del Switch(menuActive) 
027EA:  BRA    27AC
....................       } // End loop while -> true*/ 
....................    } // Fin del main 
....................  
027EC:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
